# meca 

I create 3 SLR LUR models for meca with differing levels of livestock exposure
In order to find the best model I firstly run at least 10 models with one more predictor added  
I then  use the (modified) selection code (see below) which was originally developed for the ESCAPE project

# Packages
```{r}
library(car)
library(writexl)
library(olsrr)
```

# Define the variables for LUR1, LUR2 and LUR3
```{r}
# Define the input variables
Measurements_livestockpreds_LUR1 <- read.csv("Input_files//Measurements_livestockpreds_LUR1.csv")
Measurements_livestockpreds_LUR2 <- read.csv("Input_files//Measurements_livestockpreds_LUR2.csv")
Measurements_livestockpreds_LUR3 <- read.csv("Input_files//Measurements_livestockpreds_LUR3.csv")

# Define the outcome variable
meca <- Measurements_livestockpreds_LUR1$meca_copiespm3.ln.diffmeth.mean

#  Now set the values of some variables that will be needed
# LUR1
nfirstvar_LUR1 <- 6 
nlastvar_LUR1 <- 13
# LUR2
nfirstvar_LUR2 <- 6
nlastvar_LUR2 <- 74
# LUR3 
nfirstvar_LUR3 <- 6  
nlastvar_LUR3 <- 138
```
# meca LUR1 - training model
```{r}
#  Function building to run the models 
models<-list()
# 
modeln<-1
models[[modeln]]<-list()


R2<-1
betaaddedvar<-1
addedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR1:nlastvar_LUR1){
  if (is.numeric(Measurements_livestockpreds_LUR1[,i])==TRUE){
    modeltry<-lm(meca~Measurements_livestockpreds_LUR1[,i])                            
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    # find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # Measurements_livestockpreds_LUR1[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR1)[i]
    addedvar<-rbind(addedvar,names(Measurements_livestockpreds_LUR1)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)
models[[modeln]]$results

#  this are the candidates models with the highest R2, not a negative beta for the new, nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)
models[[modeln]]$resultspos

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))
models[[modeln]]$resultspos

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j
models[[modeln]]$indexbestmodel

subset(models[[modeln]]$resultspos, rank==1)
subset(models[[modeln]]$resultspos)

#  this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]
models[[modeln]]$summarybestmodel

# here are the names
models[[modeln]]$namesbestmodel<-c(names(Measurements_livestockpreds_LUR1)[models[[1]]$indexbestmodel])
models[[modeln]]$namesbestmodel

# this is the r2 of that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2
models[[modeln]]$R2bestmodel

# this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(meca~Measurements_livestockpreds_LUR1[,models[[1]]$indexbestmodel]) 
models[[modeln]]$bestmodel

summary(models[[modeln]]$bestmodel)


#  2 # 

#  Add 2nd variable (the only difference of the above part is that now modeln=2 the modelstatement has 2 variables)
#  and the cAll for the list of variable names in the model changed slightly

modeln<-2

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR1:nlastvar_LUR1){
  if (is.numeric(Measurements_livestockpreds_LUR1[,i])==TRUE){
    modeltry<-lm(meca~Measurements_livestockpreds_LUR1[,models[[1]]$indexbestmodel]+ Measurements_livestockpreds_LUR1[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    # find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # Measurements_livestockpreds_LUR1[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR1)[i]
    addedvar<-rbind(addedvar,names(Measurements_livestockpreds_LUR1)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  these are the candidate models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)
models[[modeln]]$resultspos

#  rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))
models[[modeln]]$resultspos

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j
models[[modeln]]$indexbestmodel

subset(models[[modeln]]$resultspos, rank==1)

# this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]
models[[modeln]]$summarybestmodel

# here are the names
models[[modeln]]$namesbestmodel<-c(names(Measurements_livestockpreds_LUR1)[models[[1]]$indexbestmodel], names(Measurements_livestockpreds_LUR1)[models[[2]]$indexbestmodel] )
models[[modeln]]$namesbestmodel

# this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2
models[[modeln]]$R2bestmodel

# this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(meca~Measurements_livestockpreds_LUR1[,models[[1]]$indexbestmodel]+Measurements_livestockpreds_LUR1[,models[[2]]$indexbestmodel]) 
models[[modeln]]$bestmodel

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel

models[[1]]$namesbestmodel
models[[2]]$namesbestmodel

models[[1]]$R2bestmodel
models[[2]]$R2bestmodel

#  at this point I always check whether the next model (with 2 variables) is more than 1% better than the one before and if not I end here
#  R2 of the second model increases from model 1 to 2 
#  Also check vif and cook's distance 
vif(models[[2]]$bestmodel) #  no VIF values are > 1
ols_plot_cooksd_bar(models[[2]]$bestmodel, print_plot = TRUE) #  no cook's distances are >1 

#  3 # 

#  add third variable (the only difference of the above part is that now modeln=3 the model statement has 3 variables)
#  and the cAll for the list of variable names in the model changed slightly

modeln<-3

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR1:nlastvar_LUR1){
  if (is.numeric(Measurements_livestockpreds_LUR1[,i])==TRUE){  
    modeltry<-lm(meca~Measurements_livestockpreds_LUR1[,models[[1]]$indexbestmodel]+Measurements_livestockpreds_LUR1[,models[[2]]$indexbestmodel]+ Measurements_livestockpreds_LUR1[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    # find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # All[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR1)[i]
    addedvar<-rbind(addedvar,names(Measurements_livestockpreds_LUR1)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))


#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

# this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

# here are the names
models[[modeln]]$namesbestmodel<-c(names(Measurements_livestockpreds_LUR1)[models[[1]]$indexbestmodel], names(Measurements_livestockpreds_LUR1)[models[[2]]$indexbestmodel] , names(Measurements_livestockpreds_LUR1)[models[[3]]$indexbestmodel])

# this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

# this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(meca~Measurements_livestockpreds_LUR1[,models[[1]]$indexbestmodel]+Measurements_livestockpreds_LUR1[,models[[2]]$indexbestmodel]+Measurements_livestockpreds_LUR1[,models[[3]]$indexbestmodel]) 

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel

models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel

models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel

#  No R^2 now decreases

#  CODE FOR PICKING OUT THE BEST MODEL #  
temp <- 0
besti <- 0
for (i in 1:10){ #  think this runs the loop 10 times - not fully sure thought - but not to do with the number of models I don't think - as when I change to 3, I still get the model with 4 variables as best model
  print(models[[i]]$R2bestmodel)
  #       print(models[[i]]$summarybestmodel$coefficients=-1,4])
  #       if((models[[i]]$R2bestmodel-temp > 0.0) && (all(models[[i]]$summarybestmodel$coefficients[-1,4]<0.1))){
  #         temp <- models[[i]]$R2bestmodel
  #         besti <- i
  #         }
  if((models[[i]]$R2bestmodel-temp > 0.0) && (all(models[[i]]$summarybestmodel$coefficients[-1,4]<0.1))){
    temp <- models[[i]]$R2bestmodel
    besti <- i
  }else{
    finalBestModel <- models[[besti]]$bestmodel
    finalBestModelNames <- models[[besti]]$namesbestmodel
    Sites <- 1:dim(Measurements_livestockpreds_LUR1)[1] # full original model
    #  CVaR2<-escCV(Sites)[2] # Cross Validation
    maxCD<-max(cooks.distance(finalBestModel))
    if(length(finalBestModelNames)<2){ # vif fn doesnot work when only 1 variable...       # 
      maxVIF<-"NA"
    }else{
      maxVIF<-max(vif(finalBestModel))
    }
    print(paste("This is the best meca model 1: ",besti,
                "(AdjR2: ",format(models[[besti]]$R2bestmodel,digits=3), "; MaxCD: ",format(maxCD,digits=3),"; MaxVIF: ",
                format(maxVIF,digits=3),")", sep=''))
    print(finalBestModelNames)
    break
  }
}

#  Best model is with 1 predictor: AllFarm.3000m.95Win.10to90scaled
#  Same as that previously identified
meca_LUR1_algorithmmethod <- lm(meca_copiespm3.ln.diffmeth.mean~ AllFarm.3000m.95Win.10to90scaled, data = Measurements_livestockpreds_LUR1)
summary(meca_LUR1_algorithmmethod)

# Calculate RMSE
predicted_meca_LUR1 <- predict(meca_LUR1_algorithmmethod, Measurements_livestockpreds_LUR1)
RMSE_meca_LUR1 <- sqrt(mean((Measurements_livestockpreds_LUR1$meca_copiespm3.ln.diffmeth.mean - predicted_meca_LUR1)^2))
predicted_meca_LUR1

#  Save these predicted concentrations along with the measured concentrations as an excel file 
#  Create a dataframe 
meca_LUR1_preds_observed <- data.frame(Measurements_livestockpreds_LUR1$Loc_ID,Measurements_livestockpreds_LUR1$meca_copiespm3.ln.diffmeth.mean, predicted_meca_LUR1)
print(meca_LUR1_preds_observed)

#  Save as xls file 
write_xlsx(meca_LUR1_preds_observed,"Output_files//meca_LUR1_preds_observed.xlsx")

#  MODEL CHECKING:
#  1)Check normality of residuals 
#  2)Check residuals for linearity, independence and homoscedasticity
#  3)Check multicollinearity (VIF)
#  4)Check influential points (Cook's Distance)

#  1) Normality of residuals
boxplot(residuals(meca_LUR1_algorithmmethod),main="boxplot of residuals - meca LUR model 1",xlab="LUR model 1 residuals")
qqnorm(residuals(meca_LUR1_algorithmmethod),main="QQ-plot of residuals - meca LUR model 1",xlab="LUR model 1 residuals")

#  2)Check residuals for linearity, independence and homoscedasticity
plot(fitted(meca_LUR1_algorithmmethod),residuals(meca_LUR1_algorithmmethod))

#  3)Check multicollinearity (VIF)
#  NA as only 1 predictor

#  4)Check influential points (Cook's Distance)
ols_plot_cooksd_bar(meca_LUR1_algorithmmethod, print_plot = TRUE)
maxCD_meca_LUR1 <- max(cooks.distance(meca_LUR1_algorithmmethod))
maxCD_meca_LUR1
#  won't remove any outliers - none with cook's d > 1
```

# meca LUR1 model - LOOCV
```{r}
#  LOOCV - LUR model 1 for meca
#  Leave one out cross validation - the goal of cross validation is to get a generalized score of the model. The reason for this generalization is to, hopefully, improve the model’s effectiveness in predicting on future data inputs.
#  It is a type of 'internal' cross validation
Measurements_livestockpreds_LUR1_LOOCV <- Measurements_livestockpreds_LUR1
set.seed(123)
Measurements_livestockpreds_LUR1_LOOCV$meca_LUR1_LOOCV_PRED <- unlist(lapply(1:nrow(Measurements_livestockpreds_LUR1_LOOCV),function(inx){
  train <- Measurements_livestockpreds_LUR1_LOOCV[-inx,,drop=FALSE]
  test <- Measurements_livestockpreds_LUR1_LOOCV[inx,,drop=FALSE]
  cvm <- lm(meca_copiespm3.ln.diffmeth.mean ~ AllFarm.3000m.95Win.10to90scaled , data=train)
  pred <- predict(cvm,newdata=test)
  return(pred)
}))

predicted_meca_LUR1_LOOCV <- Measurements_livestockpreds_LUR1_LOOCV$meca_LUR1_LOOCV_PRED

#  Save these predicted concentrations along with the measured concentrations as an excel file 
#  Create a dataframe 
meca_LUR1_LOOCV_preds_observed <- data.frame(Measurements_livestockpreds_LUR1_LOOCV$Loc_ID,Measurements_livestockpreds_LUR1_LOOCV$meca_copiespm3.ln.diffmeth.mean, Measurements_livestockpreds_LUR1_LOOCV$meca_LUR1_LOOCV_PRED)
print(meca_LUR1_LOOCV_preds_observed)

#  Save as xls file 
write_xlsx(meca_LUR1_LOOCV_preds_observed,"Output_files//meca_LUR1_LOOCV_preds_observed.xlsx")

# Compute the LOOCV model R2
meca_LUR1_LOOCV_lm <- lm(meca_copiespm3.ln.diffmeth.mean ~ meca_LUR1_LOOCV_PRED, data=Measurements_livestockpreds_LUR1_LOOCV)
summary(meca_LUR1_LOOCV_lm)
#  meca LUR1 model LOOCV multiple R^2 = 0.214

# Calculate RMSE
preds_meca_LUR1_LOOCV <- predict(meca_LUR1_LOOCV_lm, Measurements_livestockpreds_LUR1_LOOCV)
RMSE_meca_LUR1_LOOCV <- sqrt(mean((Measurements_livestockpreds_LUR1_LOOCV$meca_copiespm3.ln.diffmeth.mean - preds_meca_LUR1_LOOCV)^2))
RMSE_meca_LUR1_LOOCV

#  Plot LOOCV estimations vs. observed concentrations
plot(Measurements_livestockpreds_LUR1_LOOCV$meca_LUR1_LOOCV_PRED, Measurements_livestockpreds_LUR1_LOOCV$meca_copiespm3.ln.diffmeth.mean)
abline(lm(Measurements_livestockpreds_LUR1_LOOCV$meca_copiespm3.ln.diffmeth.mean ~ Measurements_livestockpreds_LUR1_LOOCV$meca_LUR1_LOOCV_PRED))
```
#  meca LUR1 - 10-fold CV 
```{r}
options(stringsAsFactors = FALSE) # so that dataframes are not opened in new tabs

# This is the required dataset
Measurements_livestockpreds_LUR1 

#  10-fold hold-out validation is done to assess model robustness. This is done using a random selection of 90% of the measurement sites. 
#  Part 1. Each measurement site gets randomly allocated number out of range 1-10
#  Completely randomly pulling sites
meca_HV_LUR1_df <- Measurements_livestockpreds_LUR1[c(1,5,6:13)] #  new df created with only meca values 
#  Create valID variable 
meca_HV_LUR1_df$valID <- 0
#  Draw 10 samples, thus on average 6 sites per test set (i.e 6 sites are removed from each model and then the model is tested on these 6 sites )
set.seed(123)
VGOB1_FINAL_meca_LUR1 <- c()
for (s in 1:1){
  if (s==1) set <- meca_HV_LUR1_df
  draws <- c(1:nrow(set))
  chosen <- c()
  tempdraws <- draws
  for (d in 1:10){
    list <- sample(tempdraws, length(tempdraws)/(11-d), FALSE)
    set[list,]$valID <- d
    chosen <- c(chosen, list)
    tempdraws <- draws[-chosen]
  }

#  Combine datasets to 1
VGOB1_FINAL_meca_LUR1 <- set
}

summary(set)
rm(set)

#  View the df created
str(VGOB1_FINAL_meca_LUR1, list.len=ncol(VGOB1_FINAL_meca_LUR1))
names(VGOB1_FINAL_meca_LUR1)
summary(VGOB1_FINAL_meca_LUR1)

#  Part 2: Make 10 subsets of dataset based on randomly allocated number (so these are the training datasets) 
#  Then create 10 subsets, each excluding 1 set of 10 sites
VGOB1_subsetA_meca_LUR1 <- subset(VGOB1_FINAL_meca_LUR1, valID != 1)
VGOB1_subsetB_meca_LUR1 <- subset(VGOB1_FINAL_meca_LUR1, valID != 2)  
VGOB1_subsetC_meca_LUR1 <- subset(VGOB1_FINAL_meca_LUR1, valID != 3)
VGOB1_subsetD_meca_LUR1 <- subset(VGOB1_FINAL_meca_LUR1, valID != 4)
VGOB1_subsetE_meca_LUR1 <- subset(VGOB1_FINAL_meca_LUR1, valID != 5)
VGOB1_subsetF_meca_LUR1 <- subset(VGOB1_FINAL_meca_LUR1, valID != 6)
VGOB1_subsetG_meca_LUR1 <- subset(VGOB1_FINAL_meca_LUR1, valID != 7)
VGOB1_subsetH_meca_LUR1 <- subset(VGOB1_FINAL_meca_LUR1, valID != 8)
VGOB1_subsetI_meca_LUR1 <- subset(VGOB1_FINAL_meca_LUR1, valID != 9)
VGOB1_subsetJ_meca_LUR1 <- subset(VGOB1_FINAL_meca_LUR1, valID != 10)

#  Part 3: Build for each subset a LUR model (i.e. go through the whole LUR model script for each subset (so each training set). Start with subset A, until final LUR model. Then subset B, until final LUR model etc.) 

#### A ####
# LUR model building process for subset A
#  This is the dataframe with the relevant predictor vars for LUR1 models for subset A (55 sites)
VGOB1_subsetA_meca_LUR1 # n.b. this dataframe only includes microbial marker concentrations for meca unlike the dataframe Measurements_livestockpreds_LUR1 as previously used for the model building. 

#  Now set the values of some variables that will be needed
nfirstvar_LUR_1 <- 3  
nlastvar_LUR_1 <- 10

# Function building to run the models 
# 1 #  

models<-list()
modeln<-1
models[[modeln]]<-list()

R2<-1
betaaddedvar<-1
addedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_1:nlastvar_LUR_1){
  if (is.numeric(VGOB1_subsetA_meca_LUR1[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetA_meca_LUR1$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetA_meca_LUR1[,i])                            
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    #  Measurements_livestockpreds_LUR1[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR1)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetA_meca_LUR1)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)
models[[modeln]]$results

#  this are the candidates models with the highest R2, not a negative beta for the new, nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)
models[[modeln]]$resultspos

#  rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))
models[[modeln]]$resultspos

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j
models[[modeln]]$indexbestmodel

subset(models[[modeln]]$resultspos, rank==1)
subset(models[[modeln]]$resultspos)

#  this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]
models[[modeln]]$summarybestmodel

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetA_meca_LUR1)[models[[1]]$indexbestmodel])
models[[modeln]]$namesbestmodel

#  this is the r2 of that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2
models[[modeln]]$R2bestmodel

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetA_meca_LUR1$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetA_meca_LUR1[,models[[1]]$indexbestmodel]) 
models[[modeln]]$bestmodel

summary(models[[modeln]]$bestmodel)

#  The first model includes the predictor: nPigMultipFarmWghtDist.3000m.sum.Tr.1P9 - meaning the number of multiplier pig farms weighted to distance in a 3000m buffer

# 2 #  
# Add 2nd variable (the only difference of the above part is that now modeln=2 the model statement has 2 variables)
# and the call for the list of variable names in the model changed slightly

modeln<-2

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_1:nlastvar_LUR_1){
  if (is.numeric(VGOB1_subsetA_meca_LUR1[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetA_meca_LUR1$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetA_meca_LUR1[,models[[1]]$indexbestmodel]+ VGOB1_subsetA_meca_LUR1[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # Measurements_livestockpreds_LUR1[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR1)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetA_meca_LUR1)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  these are the candidate models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)
models[[modeln]]$resultspos

#  rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))
models[[modeln]]$resultspos

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j
models[[modeln]]$indexbestmodel

subset(models[[modeln]]$resultspos, rank==1)

# this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]
models[[modeln]]$summarybestmodel

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetA_meca_LUR1)[models[[1]]$indexbestmodel], names(VGOB1_subsetA_meca_LUR1)[models[[2]]$indexbestmodel] )
models[[modeln]]$namesbestmodel

# this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2
models[[modeln]]$R2bestmodel

# this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetA_meca_LUR1$meca_copiespm3.ln.diffmeth.mean~                               VGOB1_subsetA_meca_LUR1[,models[[1]]$indexbestmodel]+                           VGOB1_subsetA_meca_LUR1[,models[[2]]$indexbestmodel]) 

models[[modeln]]$bestmodel

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel


# 3 #  
# add third variable (the only difference of the above part is that now modeln=3 the model statement has 3 variables)
# and the call for the list of variable names in the model changed slightly

modeln<-3

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_1:nlastvar_LUR_1){
  if (is.numeric(VGOB1_subsetA_meca_LUR1[,i])==TRUE){  
    modeltry<-lm(VGOB1_subsetA_meca_LUR1$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetA_meca_LUR1[,models[[1]]$indexbestmodel]+VGOB1_subsetA_meca_LUR1[,models[[2]]$indexbestmodel]+ VGOB1_subsetA_meca_LUR1[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # All[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR1)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetA_meca_LUR1)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

#  rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

#  this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

#  here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetA_meca_LUR1)[models[[1]]$indexbestmodel], names(VGOB1_subsetA_meca_LUR1)[models[[2]]$indexbestmodel], names(VGOB1_subsetA_meca_LUR1)[models[[3]]$indexbestmodel])

#  this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetA_meca_LUR1$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetA_meca_LUR1[,models[[1]]$indexbestmodel]+ VGOB1_subsetA_meca_LUR1[,models[[2]]$indexbestmodel]+ VGOB1_subsetA_meca_LUR1[,models[[3]]$indexbestmodel]) 

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel


# 4 #
#  add forth variable (the only difference of the above part is that now model n=4 the model statement more variables)
#  and the call for the list of variable names in the model changed slightly
modeln<-4

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1


for (i in nfirstvar_LUR_1:nlastvar_LUR_1){
  if (is.numeric(VGOB1_subsetA_meca_LUR1[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetA_meca_LUR1$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetA_meca_LUR1[,models[[1]]$indexbestmodel]+VGOB1_subsetA_meca_LUR1[,models[[2]]$indexbestmodel]+VGOB1_subsetA_meca_LUR1[,models[[3]]$indexbestmodel]+VGOB1_subsetA_meca_LUR1[,i])
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    #  the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    #  All[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR1)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetA_meca_LUR1)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

#  this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

#  here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetA_meca_LUR1)[models[[1]]$indexbestmodel], names(VGOB1_subsetA_meca_LUR1)[models[[2]]$indexbestmodel], names(VGOB1_subsetA_meca_LUR1)[models[[3]]$indexbestmodel], names(VGOB1_subsetA_meca_LUR1)[models[[4]]$indexbestmodel])

#  this is the r2 of that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetA_meca_LUR1$meca_copiespm3.ln.diffmeth.mean~ VGOB1_subsetA_meca_LUR1[,models[[1]]$indexbestmodel]+ VGOB1_subsetA_meca_LUR1[,models[[2]]$indexbestmodel]+VGOB1_subsetA_meca_LUR1[,models[[3]]$indexbestmodel]+ VGOB1_subsetA_meca_LUR1[,models[[4]]$indexbestmodel])


models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel


# 5 #
# add fifth variable (the only difference of the above part is that now modeln=5 the model statement more variables)
# and the call for the list of variable names in the model changed slightly
modeln<-5

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_1:nlastvar_LUR_1){
  if (is.numeric(VGOB1_subsetA_meca_LUR1[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetA_meca_LUR1$meca_copiespm3.ln.diffmeth.mean~ VGOB1_subsetA_meca_LUR1[,models[[1]]$indexbestmodel]+ VGOB1_subsetA_meca_LUR1[,models[[2]]$indexbestmodel]+ VGOB1_subsetA_meca_LUR1[,models[[3]]$indexbestmodel]+ VGOB1_subsetA_meca_LUR1[,models[[4]]$indexbestmodel]+ VGOB1_subsetA_meca_LUR1[,i])

R2<-rbind(R2,summary(modeltry)$adj.r.squared)
# the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])#
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # All[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR1)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetA_meca_LUR1)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

#  this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetA_meca_LUR1)[models[[1]]$indexbestmodel], names(VGOB1_subsetA_meca_LUR1)[models[[2]]$indexbestmodel], names(VGOB1_subsetA_meca_LUR1)[models[[3]]$indexbestmodel], names(VGOB1_subsetA_meca_LUR1)[models[[4]]$indexbestmodel], names(VGOB1_subsetA_meca_LUR1)[models[[5]]$indexbestmodel])

#  this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetA_meca_LUR1$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetA_meca_LUR1[,models[[1]]$indexbestmodel]+VGOB1_subsetA_meca_LUR1[,models[[2]]$indexbestmodel]+VGOB1_subsetA_meca_LUR1[,models[[3]]$indexbestmodel]+ VGOB1_subsetA_meca_LUR1[,models[[4]]$indexbestmodel]+ VGOB1_subsetA_meca_LUR1[,models[[5]]$indexbestmodel])
models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[5]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[5]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel
models[[5]]$R2bestmodel


# The next part of the code (n=6-8) does not work
# This is because one of the coefficients included in the model with 6 variables is negative, the code does not allow for this. I can stop here.

# # 6 #
# # add sixth variable (the only difference of the above part is that now model n=6 the model statement more variables)
# #  and the call for the list of variable names in the model changed slightly
# 
# modeln<-6
# 
# models[[modeln]]<-list()
# 
# R2<-1
# addedvar<-1
# betaaddedvar<-1
# minbetas<-1
# j<-1
# 
# for (i in nfirstvar_LUR_1 :nlastvar_LUR_1){
#   if (is.numeric(VGOB1_subsetA_meca_LUR1[,i])==TRUE){
#     modeltry<-lm(VGOB1_subsetA_meca_LUR1$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetA_meca_LUR1[,models[[1]]$indexbestmodel]+VGOB1_subsetA_meca_LUR1[,models[[2]]$indexbestmodel]+VGOB1_subsetA_meca_LUR1[,models[[3]]$indexbestmodel]+VGOB1_subsetA_meca_LUR1[,models[[4]]$indexbestmodel]+VGOB1_subsetA_meca_LUR1[,models[[5]]$indexbestmodel]+ VGOB1_subsetA_meca_LUR1[,i])
#     R2<-rbind(R2,summary(modeltry)$adj.r.squared)
#     # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
#     betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])#
#     #  find out if there is a negative beta at All. The intercept does not count [-1]!
#     minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
#     # All[,i] is the row that's being tried out now. the name of that row can be found in  names(All)[i]
#     addedvar<-rbind(addedvar,names(VGOB1_subsetA_meca_LUR1)[i])
#     j<-rbind(j, i)
#     models[[modeln]][[i]]<-summary(modeltry)
#   }
# }
# 
# models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)
# 
# #  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
# models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)
# 
# # rank the R2's of these models
# models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))
# 
# #  this is the index of the row with the highest R2 and  no negative betas in this subset
# models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j
# 
# subset(models[[modeln]]$resultspos, rank==1)
# 
# # this is the model
# models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]
# 
# # here are the names
# models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetA_meca_LUR1)[models[[1]]$indexbestmodel], names(VGOB1_subsetA_meca_LUR1)[models[[2]]$indexbestmodel] , names(VGOB1_subsetA_meca_LUR1)[models[[3]]$indexbestmodel], names(VGOB1_subsetA_meca_LUR1)[models[[4]]$indexbestmodel], names(VGOB1_subsetA_meca_LUR1)[models[[5]]$indexbestmodel], names(VGOB1_subsetA_meca_LUR1)[models[[6]]$indexbestmodel])
# 
# #  this is the r2 or that model
# models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2
# 
# #  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
# models[[modeln]]$bestmodel <- lm(VGOB1_subsetA_meca_LUR1$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetA_meca_LUR1[,models[[1]]$indexbestmodel]+VGOB1_subsetA_meca_LUR1[,models[[2]]$indexbestmodel]+VGOB1_subsetA_meca_LUR1[,models[[3]]$indexbestmodel]+ VGOB1_subsetA_meca_LUR1[,models[[4]]$indexbestmodel]+ VGOB1_subsetA_meca_LUR1[,models[[5]]$indexbestmodel]+ VGOB1_subsetA_meca_LUR1[,models[[6]]$indexbestmodel])
# 
# models[[1]]$summarybestmodel
# models[[2]]$summarybestmodel
# models[[3]]$summarybestmodel
# models[[4]]$summarybestmodel
# models[[5]]$summarybestmodel
# models[[6]]$summarybestmodel
# models[[1]]$namesbestmodel
# models[[2]]$namesbestmodel
# models[[3]]$namesbestmodel
# models[[4]]$namesbestmodel
# models[[5]]$namesbestmodel
# models[[6]]$namesbestmodel
# models[[1]]$R2bestmodel
# models[[2]]$R2bestmodel
# models[[3]]$R2bestmodel
# models[[4]]$R2bestmodel
# models[[5]]$R2bestmodel
# models[[6]]$R2bestmodel
# 
# 
# # 7 #
# # add seventh variable (the only difference of the above part is that now model n=7 the model statement more variables)
# #  and the call for the list of variable names in the model changed slightly
# 
# modeln<-7
# 
# models[[modeln]]<-list()
# 
# R2<-1
# addedvar<-1
# betaaddedvar<-1
# minbetas<-1
# j<-1
# 
# for (i in nfirstvar_LUR_1 :nlastvar_LUR_1){
#   if (is.numeric(VGOB1_subsetA_meca_LUR1[,i])==TRUE){
#     modeltry<-lm(VGOB1_subsetA_meca_LUR1$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetA_meca_LUR1[,models[[1]]$indexbestmodel]+VGOB1_subsetA_meca_LUR1[,models[[2]]$indexbestmodel]+VGOB1_subsetA_meca_LUR1[,models[[3]]$indexbestmodel]+VGOB1_subsetA_meca_LUR1[,models[[4]]$indexbestmodel]+VGOB1_subsetA_meca_LUR1[,models[[5]]$indexbestmodel]+VGOB1_subsetA_meca_LUR1[,models[[6]]$indexbestmodel]+ VGOB1_subsetA_meca_LUR1[,i])
#     R2<-rbind(R2,summary(modeltry)$adj.r.squared)
#     # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
#     betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])#
#     #  find out if there is a negative beta at All. The intercept does not count [-1]!
#     minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
#     # Measurements_livestockpreds_LUR1[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR1)[i]
#     addedvar<-rbind(addedvar,names(VGOB1_subsetA_meca_LUR1)[i])
#     j<-rbind(j, i)
#     models[[modeln]][[i]]<-summary(modeltry)
#   }
# }
# 
# models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)
# 
# #  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
# models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)
# 
# # rank the R2's of these models
# models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))
# 
# #  this is the index of the row with the highest R2 and  no negative betas in this subset
# models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j
# 
# subset(models[[modeln]]$resultspos, rank==1)
# 
# # this is the model
# models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]
# 
# # here are the names
# models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetA_meca_LUR1)[models[[1]]$indexbestmodel], names(VGOB1_subsetA_meca_LUR1)[models[[2]]$indexbestmodel] , names(VGOB1_subsetA_meca_LUR1)[models[[3]]$indexbestmodel], names(VGOB1_subsetA_meca_LUR1)[models[[4]]$indexbestmodel], names(VGOB1_subsetA_meca_LUR1)[models[[5]]$indexbestmodel], names(VGOB1_subsetA_meca_LUR1)[models[[6]]$indexbestmodel], names(VGOB1_subsetA_meca_LUR1)[models[[7]]$indexbestmodel])
# 
# #  this is the r2 or that model
# models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2
# 
# #  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
# models[[modeln]]$bestmodel <- lm(VGOB1_subsetA_meca_LUR1$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetA_meca_LUR1[,models[[1]]$indexbestmodel]+VGOB1_subsetA_meca_LUR1[,models[[2]]$indexbestmodel]+VGOB1_subsetA_meca_LUR1[,models[[3]]$indexbestmodel]+ VGOB1_subsetA_meca_LUR1[,models[[4]]$indexbestmodel]+ VGOB1_subsetA_meca_LUR1[,models[[5]]$indexbestmodel]+ VGOB1_subsetA_meca_LUR1[,models[[6]]$indexbestmodel]+ VGOB1_subsetA_meca_LUR1[,models[[7]]$indexbestmodel])
# 
# models[[1]]$summarybestmodel
# models[[2]]$summarybestmodel
# models[[3]]$summarybestmodel
# models[[4]]$summarybestmodel
# models[[5]]$summarybestmodel
# models[[6]]$summarybestmodel
# models[[7]]$summarybestmodel
# models[[1]]$namesbestmodel
# models[[2]]$namesbestmodel
# models[[3]]$namesbestmodel
# models[[4]]$namesbestmodel
# models[[5]]$namesbestmodel
# models[[6]]$namesbestmodel
# models[[7]]$namesbestmodel
# models[[1]]$R2bestmodel
# models[[2]]$R2bestmodel
# models[[3]]$R2bestmodel
# models[[4]]$R2bestmodel
# models[[5]]$R2bestmodel
# models[[6]]$R2bestmodel
# models[[7]]$R2bestmodel
# 
# # 8 #
# # add eighth variable (the only difference of the above part is that now modeln=7 the model statement more variables)
# # and the call for the list of variable names in the model changed slightly
# 
# modeln<-8
# 
# models[[modeln]]<-list()
# 
# R2<-1
# addedvar<-1
# betaaddedvar<-1
# minbetas<-1
# j<-1
# 
# for (i in nfirstvar_LUR_1 :nlastvar_LUR_1){
#   if (is.numeric(VGOB1_subsetA_meca_LUR1[,i])==TRUE){
#     modeltry<-lm(VGOB1_subsetA_meca_LUR1$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetA_meca_LUR1[,models[[1]]$indexbestmodel]+VGOB1_subsetA_meca_LUR1[,models[[2]]$indexbestmodel]+VGOB1_subsetA_meca_LUR1[,models[[3]]$indexbestmodel]+VGOB1_subsetA_meca_LUR1[,models[[4]]$indexbestmodel]+VGOB1_subsetA_meca_LUR1[,models[[5]]$indexbestmodel]+VGOB1_subsetA_meca_LUR1[,models[[6]]$indexbestmodel]+ VGOB1_subsetA_meca_LUR1[,models[[7]]$indexbestmodel]+ VGOB1_subsetA_meca_LUR1[,i])
#     R2<-rbind(R2,summary(modeltry)$adj.r.squared)
#     # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
#     betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])#
#     #  find out if there is a negative beta at All. The intercept does not count [-1]!
#     minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
#     # Measurements_livestockpreds_LUR1[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR1)[i]
#     addedvar<-rbind(addedvar,names(VGOB1_subsetA_meca_LUR1)[i])
#     j<-rbind(j, i)
#     models[[modeln]][[i]]<-summary(modeltry)
#   }
# }
# 
# models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)
# 
# #  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
# models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)
# 
# # rank the R2's of these models
# models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))
# 
# #  this is the index of the row with the highest R2 and  no negative betas in this subset
# models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j
# 
# subset(models[[modeln]]$resultspos, rank==1)
# 
# # this is the model
# models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]
# 
# # here are the names
# models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetA_meca_LUR1)[models[[1]]$indexbestmodel], names(VGOB1_subsetA_meca_LUR1)[models[[2]]$indexbestmodel] , names(VGOB1_subsetA_meca_LUR1)[models[[3]]$indexbestmodel], names(VGOB1_subsetA_meca_LUR1)[models[[4]]$indexbestmodel], names(VGOB1_subsetA_meca_LUR1)[models[[5]]$indexbestmodel], names(VGOB1_subsetA_meca_LUR1)[models[[6]]$indexbestmodel], names(VGOB1_subsetA_meca_LUR1)[models[[7]]$indexbestmodel], names(VGOB1_subsetA_meca_LUR1)[models[[8]]$indexbestmodel])
# 
# #  this is the r2 or that model
# models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2
# 
# #  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
# models[[modeln]]$bestmodel <- lm(VGOB1_subsetA_meca_LUR1$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetA_meca_LUR1[,models[[1]]$indexbestmodel]+VGOB1_subsetA_meca_LUR1[,models[[2]]$indexbestmodel]+VGOB1_subsetA_meca_LUR1[,models[[3]]$indexbestmodel]+ VGOB1_subsetA_meca_LUR1[,models[[4]]$indexbestmodel]+ VGOB1_subsetA_meca_LUR1[,models[[5]]$indexbestmodel]+ VGOB1_subsetA_meca_LUR1[,models[[6]]$indexbestmodel]+ VGOB1_subsetA_meca_LUR1[,models[[7]]$indexbestmodel]+ VGOB1_subsetA_meca_LUR1[,models[[8]]$indexbestmodel])
# 
# models[[1]]$summarybestmodel
# models[[2]]$summarybestmodel
# models[[3]]$summarybestmodel
# models[[4]]$summarybestmodel
# models[[5]]$summarybestmodel
# models[[6]]$summarybestmodel
# models[[7]]$summarybestmodel
# models[[8]]$summarybestmodel
# models[[1]]$namesbestmodel
# models[[2]]$namesbestmodel
# models[[3]]$namesbestmodel
# models[[4]]$namesbestmodel
# models[[5]]$namesbestmodel
# models[[6]]$namesbestmodel
# models[[7]]$namesbestmodel
# models[[8]]$namesbestmodel
# models[[1]]$R2bestmodel
# models[[2]]$R2bestmodel
# models[[3]]$R2bestmodel
# models[[4]]$R2bestmodel
# models[[5]]$R2bestmodel
# models[[6]]$R2bestmodel
# models[[7]]$R2bestmodel
# models[[8]]$R2bestmodel

#   CODE FOR PICKING OUT THE BEST MODEL #   
temp <- 0
besti <- 0
for (i in 1:10){ #  think this runs the loop 10 times - not fully sure thought - but not to do with the number of models I don't think - as when I change to 3, I still get the model with 4 variables as best model
  print(models[[i]]$R2bestmodel)
  #       print(models[[i]]$summarybestmodel$coefficients=-1,4])
  #       if((models[[i]]$R2bestmodel-temp > 0.0) && (all(models[[i]]$summarybestmodel$coefficients[-1,4]<0.1))){
  #         temp <- models[[i]]$R2bestmodel
  #         besti <- i
  #         }
  if((models[[i]]$R2bestmodel-temp > 0.0) && (all(models[[i]]$summarybestmodel$coefficients[-1,4]<0.1))){
    temp <- models[[i]]$R2bestmodel
    besti <- i
  }else{
    finalBestModel_meca_LUR1_subsetA <- models[[besti]]$bestmodel
    finalBestModelNames_meca_subsetA <- models[[besti]]$namesbestmodel
    Sites <- 1:dim(VGOB1_subsetA_meca_LUR1)[1] # full original model
    #  CVaR2<-escCV_meca_LUR1(Sites)[2] # Cross Validation
    maxCD<-max(cooks.distance(finalBestModel_meca_LUR1_subsetA))
    if(length(finalBestModelNames_meca_subsetA)<2){ # vif fn doesnot work when only 1 variable...       # 
      maxVIF<-"NA"
    }else{
      maxVIF<-max(vif(finalBestModel_meca_LUR1_subsetA))
    }
    print(paste("This is the best meca model for subset A: ",besti,
                "(AdjR2: ",format(models[[besti]]$R2bestmodel,digits=3), "; MaxCD: ",format(maxCD,digits=3),"; MaxVIF: ",
                format(maxVIF,digits=3),")", sep=''))
    print(finalBestModelNames_meca_subsetA)
    break
  }
}

#  Overview of the final best model using the algorithm selection process (taking into account VIF, R^2, and p-values)
finalBestModel_meca_LUR1_subsetA 
finalBestModelNames_meca_subsetA
models[[besti]]$summarybestmodel
models[[besti]]$R2bestmodel

#### B ####
# LUR model building process for subset B
# This is the dataframe with the relevant predictor vars for LUR1 models for subset B (55 sites)
VGOB1_subsetB_meca_LUR1 # n.b. this dataframe only includes microbial marker concentrations for meca unlike the dataframe Measurements_livestockpreds_LUR1 as previously used for the model building. 

#  Now set the values of some variables that will be needed
nfirstvar_LUR_1 <- 3  
nlastvar_LUR_1 <- 10

# Function building to run the models 
# 1 #  

models<-list()
modeln<-1
models[[modeln]]<-list()

R2<-1
betaaddedvar<-1
addedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_1:nlastvar_LUR_1){
  if (is.numeric(VGOB1_subsetB_meca_LUR1[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetB_meca_LUR1$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetB_meca_LUR1[,i])                            
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    #  Measurements_livestockpreds_LUR1[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR1)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetB_meca_LUR1)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)
models[[modeln]]$results

#  this are the candidates models with the highest R2, not a negative beta for the new, nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)
models[[modeln]]$resultspos

#  rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))
models[[modeln]]$resultspos

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j
models[[modeln]]$indexbestmodel

subset(models[[modeln]]$resultspos, rank==1)
subset(models[[modeln]]$resultspos)

#  this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]
models[[modeln]]$summarybestmodel

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetB_meca_LUR1)[models[[1]]$indexbestmodel])
models[[modeln]]$namesbestmodel

#  this is the r2 of that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2
models[[modeln]]$R2bestmodel

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetB_meca_LUR1$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetB_meca_LUR1[,models[[1]]$indexbestmodel]) 
models[[modeln]]$bestmodel

summary(models[[modeln]]$bestmodel)

#  The first model includes the predictor: nPigMultipFarmWghtDist.3000m.sum.Tr.1P9 - meaning the number of multiplier pig farms weighted to distance in a 3000m buffer

# 2 #  
# Add 2nd variable (the only difference of the above part is that now modeln=2 the model statement has 2 variables)
# and the call for the list of variable names in the model changed slightly

modeln<-2

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_1:nlastvar_LUR_1){
  if (is.numeric(VGOB1_subsetB_meca_LUR1[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetB_meca_LUR1$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetB_meca_LUR1[,models[[1]]$indexbestmodel]+ VGOB1_subsetB_meca_LUR1[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # Measurements_livestockpreds_LUR1[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR1)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetB_meca_LUR1)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  these are the candidate models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)
models[[modeln]]$resultspos

#  rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))
models[[modeln]]$resultspos

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j
models[[modeln]]$indexbestmodel

subset(models[[modeln]]$resultspos, rank==1)

# this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]
models[[modeln]]$summarybestmodel

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetB_meca_LUR1)[models[[1]]$indexbestmodel], names(VGOB1_subsetB_meca_LUR1)[models[[2]]$indexbestmodel] )
models[[modeln]]$namesbestmodel

# this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2
models[[modeln]]$R2bestmodel

# this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetB_meca_LUR1$meca_copiespm3.ln.diffmeth.mean~                               VGOB1_subsetB_meca_LUR1[,models[[1]]$indexbestmodel]+                           VGOB1_subsetB_meca_LUR1[,models[[2]]$indexbestmodel]) 

models[[modeln]]$bestmodel

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel

# 3 #
# add third variable (the only difference of the above part is that now modeln=3 the model statement has 3 variables)
# and the call for the list of variable names in the model changed slightly

modeln<-3

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_1:nlastvar_LUR_1){
  if (is.numeric(VGOB1_subsetB_meca_LUR1[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetB_meca_LUR1$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetB_meca_LUR1[,models[[1]]$indexbestmodel]+VGOB1_subsetB_meca_LUR1[,models[[2]]$indexbestmodel]+ VGOB1_subsetB_meca_LUR1[,i])
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])#
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # All[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR1)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetB_meca_LUR1)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

#  rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

#  this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

#  here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetB_meca_LUR1)[models[[1]]$indexbestmodel], names(VGOB1_subsetB_meca_LUR1)[models[[2]]$indexbestmodel], names(VGOB1_subsetB_meca_LUR1)[models[[3]]$indexbestmodel])

#  this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetB_meca_LUR1$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetB_meca_LUR1[,models[[1]]$indexbestmodel]+ VGOB1_subsetB_meca_LUR1[,models[[2]]$indexbestmodel]+ VGOB1_subsetB_meca_LUR1[,models[[3]]$indexbestmodel])

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel


# 4 #
#  add forth variable (the only difference of the above part is that now model n=4 the model statement more variables)
#  and the call for the list of variable names in the model changed slightly
modeln<-4

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1


for (i in nfirstvar_LUR_1:nlastvar_LUR_1){
  if (is.numeric(VGOB1_subsetB_meca_LUR1[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetB_meca_LUR1$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetB_meca_LUR1[,models[[1]]$indexbestmodel]+VGOB1_subsetB_meca_LUR1[,models[[2]]$indexbestmodel]+VGOB1_subsetB_meca_LUR1[,models[[3]]$indexbestmodel]+VGOB1_subsetB_meca_LUR1[,i])
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    #  the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    #  All[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR1)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetB_meca_LUR1)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

#  this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

#  here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetB_meca_LUR1)[models[[1]]$indexbestmodel], names(VGOB1_subsetB_meca_LUR1)[models[[2]]$indexbestmodel], names(VGOB1_subsetB_meca_LUR1)[models[[3]]$indexbestmodel], names(VGOB1_subsetB_meca_LUR1)[models[[4]]$indexbestmodel])

#  this is the r2 of that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetB_meca_LUR1$meca_copiespm3.ln.diffmeth.mean~ VGOB1_subsetB_meca_LUR1[,models[[1]]$indexbestmodel]+ VGOB1_subsetB_meca_LUR1[,models[[2]]$indexbestmodel]+ VGOB1_subsetB_meca_LUR1[,models[[3]]$indexbestmodel]+ VGOB1_subsetB_meca_LUR1[,models[[4]]$indexbestmodel])


models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel


# # 5 #
# # add fifth variable (the only difference of the above part is that now modeln=5 the model statement more variables)
# # and the call for the list of variable names in the model changed slightly
# modeln<-5
# 
# models[[modeln]]<-list()
# 
# R2<-1
# addedvar<-1
# betaaddedvar<-1
# minbetas<-1
# j<-1
# 
# for (i in nfirstvar_LUR_1:nlastvar_LUR_1){
#   if (is.numeric(VGOB1_subsetB_meca_LUR1[,i])==TRUE){
#     modeltry<-lm(VGOB1_subsetB_meca_LUR1$meca_copiespm3.ln.diffmeth.mean~ VGOB1_subsetB_meca_LUR1[,models[[1]]$indexbestmodel]+ VGOB1_subsetB_meca_LUR1[,models[[2]]$indexbestmodel]+ VGOB1_subsetB_meca_LUR1[,models[[3]]$indexbestmodel]+ VGOB1_subsetB_meca_LUR1[,models[[4]]$indexbestmodel]+ VGOB1_subsetB_meca_LUR1[,i])
# 
# R2<-rbind(R2,summary(modeltry)$adj.r.squared)
# # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
#     betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])#
#     #  find out if there is a negative beta at All. The intercept does not count [-1]!
#     minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
#     # All[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR1)[i]
#     addedvar<-rbind(addedvar,names(VGOB1_subsetB_meca_LUR1)[i])
#     j<-rbind(j, i)
#     models[[modeln]][[i]]<-summary(modeltry)
#   }
# }
# 
# models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)
# 
# #  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
# models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)
# 
# # rank the R2's of these models
# models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))
# 
# #  this is the index of the row with the highest R2 and  no negative betas in this subset
# models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j
# 
# subset(models[[modeln]]$resultspos, rank==1)
# 
# #  this is the model
# models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]
# 
# # here are the names
# models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetB_meca_LUR1)[models[[1]]$indexbestmodel], names(VGOB1_subsetB_meca_LUR1)[models[[2]]$indexbestmodel], names(VGOB1_subsetB_meca_LUR1)[models[[3]]$indexbestmodel], names(VGOB1_subsetB_meca_LUR1)[models[[4]]$indexbestmodel], names(VGOB1_subsetB_meca_LUR1)[models[[5]]$indexbestmodel])
# 
# #  this is the r2 or that model
# models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2
# 
# #  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
# models[[modeln]]$bestmodel <- lm(VGOB1_subsetB_meca_LUR1$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetB_meca_LUR1[,models[[1]]$indexbestmodel]+VGOB1_subsetB_meca_LUR1[,models[[2]]$indexbestmodel]+VGOB1_subsetB_meca_LUR1[,models[[3]]$indexbestmodel]+ VGOB1_subsetB_meca_LUR1[,models[[4]]$indexbestmodel]+ VGOB1_subsetB_meca_LUR1[,models[[5]]$indexbestmodel])
# models[[1]]$summarybestmodel
# models[[2]]$summarybestmodel
# models[[3]]$summarybestmodel
# models[[4]]$summarybestmodel
# models[[5]]$summarybestmodel
# models[[1]]$namesbestmodel
# models[[2]]$namesbestmodel
# models[[3]]$namesbestmodel
# models[[4]]$namesbestmodel
# models[[5]]$namesbestmodel
# models[[1]]$R2bestmodel
# models[[2]]$R2bestmodel
# models[[3]]$R2bestmodel
# models[[4]]$R2bestmodel
# models[[5]]$R2bestmodel

# # 6 #  
# # add sixth variable (the only difference of the above part is that now model n=6 the model statement more variables)
# #  and the call for the list of variable names in the model changed slightly
# 
# modeln<-6
# 
# models[[modeln]]<-list()
# 
# R2<-1
# addedvar<-1
# betaaddedvar<-1
# minbetas<-1
# j<-1
# 
# for (i in nfirstvar_LUR_1 :nlastvar_LUR_1){
#   if (is.numeric(VGOB1_subsetB_meca_LUR1[,i])==TRUE){
#     modeltry<-lm(VGOB1_subsetB_meca_LUR1$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetB_meca_LUR1[,models[[1]]$indexbestmodel]+VGOB1_subsetB_meca_LUR1[,models[[2]]$indexbestmodel]+VGOB1_subsetB_meca_LUR1[,models[[3]]$indexbestmodel]+VGOB1_subsetB_meca_LUR1[,models[[4]]$indexbestmodel]+VGOB1_subsetB_meca_LUR1[,models[[5]]$indexbestmodel]+ VGOB1_subsetB_meca_LUR1[,i]) 
#     R2<-rbind(R2,summary(modeltry)$adj.r.squared)
#     # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
#     betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
#     #  find out if there is a negative beta at All. The intercept does not count [-1]!
#     minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
#     # All[,i] is the row that's being tried out now. the name of that row can be found in  names(All)[i]
#     addedvar<-rbind(addedvar,names(VGOB1_subsetB_meca_LUR1)[i])
#     j<-rbind(j, i)
#     models[[modeln]][[i]]<-summary(modeltry)
#   }
# }
# 
# models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)
# 
# #  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
# models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)
# 
# # rank the R2's of these models
# models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))
# 
# #  this is the index of the row with the highest R2 and  no negative betas in this subset
# models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j
# 
# subset(models[[modeln]]$resultspos, rank==1)
# 
# # this is the model
# models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]
# 
# # here are the names
# models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetB_meca_LUR1)[models[[1]]$indexbestmodel], names(VGOB1_subsetB_meca_LUR1)[models[[2]]$indexbestmodel] , names(VGOB1_subsetB_meca_LUR1)[models[[3]]$indexbestmodel], names(VGOB1_subsetB_meca_LUR1)[models[[4]]$indexbestmodel], names(VGOB1_subsetB_meca_LUR1)[models[[5]]$indexbestmodel], names(VGOB1_subsetB_meca_LUR1)[models[[6]]$indexbestmodel])
# 
# #  this is the r2 or that model
# models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2
# 
# #  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
# models[[modeln]]$bestmodel <- lm(VGOB1_subsetB_meca_LUR1$meca_copiespm3.ln.diffmeth.mean~ VGOB1_subsetB_meca_LUR1[,models[[1]]$indexbestmodel]+ VGOB1_subsetB_meca_LUR1[,models[[2]]$indexbestmodel]+ VGOB1_subsetB_meca_LUR1[,models[[3]]$indexbestmodel]+ VGOB1_subsetB_meca_LUR1[,models[[4]]$indexbestmodel]+ VGOB1_subsetB_meca_LUR1[,models[[5]]$indexbestmodel]+ VGOB1_subsetB_meca_LUR1[,models[[6]]$indexbestmodel]) 
# 
# models[[1]]$summarybestmodel
# models[[2]]$summarybestmodel
# models[[3]]$summarybestmodel
# models[[4]]$summarybestmodel
# models[[5]]$summarybestmodel
# models[[6]]$summarybestmodel
# models[[1]]$namesbestmodel
# models[[2]]$namesbestmodel
# models[[3]]$namesbestmodel
# models[[4]]$namesbestmodel
# models[[5]]$namesbestmodel
# models[[6]]$namesbestmodel
# models[[1]]$R2bestmodel
# models[[2]]$R2bestmodel
# models[[3]]$R2bestmodel
# models[[4]]$R2bestmodel
# models[[5]]$R2bestmodel
# models[[6]]$R2bestmodel
# 
# 
# # 7 #  
# # add seventh variable (the only difference of the above part is that now model n=7 the model statement more variables)
# #  and the call for the list of variable names in the model changed slightly
# 
# modeln<-7
# 
# models[[modeln]]<-list()
# 
# R2<-1
# addedvar<-1
# betaaddedvar<-1
# minbetas<-1
# j<-1
# 
# for (i in nfirstvar_LUR_1 :nlastvar_LUR_1){
#   if (is.numeric(VGOB1_subsetB_meca_LUR1[,i])==TRUE){
#     modeltry<- lm(VGOB1_subsetB_meca_LUR1$meca_copiespm3.ln.diffmeth.mean~ VGOB1_subsetB_meca_LUR1[,models[[1]]$indexbestmodel]+ VGOB1_subsetB_meca_LUR1[,models[[2]]$indexbestmodel]+ VGOB1_subsetB_meca_LUR1[,models[[3]]$indexbestmodel]+ VGOB1_subsetB_meca_LUR1[,models[[4]]$indexbestmodel]+ VGOB1_subsetB_meca_LUR1[,models[[5]]$indexbestmodel]+ VGOB1_subsetB_meca_LUR1[,models[[6]]$indexbestmodel]+ VGOB1_subsetB_meca_LUR1[,i]) 
#     R2<-rbind(R2,summary(modeltry)$adj.r.squared)
#     # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
#     betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
#     #  find out if there is a negative beta at All. The intercept does not count [-1]!
#     minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
#     # Measurements_livestockpreds_LUR1[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR1)[i]
#     addedvar<-rbind(addedvar,names(VGOB1_subsetB_meca_LUR1)[i])
#     j<-rbind(j, i)
#     models[[modeln]][[i]]<-summary(modeltry)
#   }
# }
# 
# models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)
# 
# #  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
# models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)
# 
# # rank the R2's of these models
# models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))
# 
# #  this is the index of the row with the highest R2 and  no negative betas in this subset
# models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j
# 
# subset(models[[modeln]]$resultspos, rank==1)
# 
# # this is the model
# models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]
# 
# # here are the names
# models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetB_meca_LUR1)[models[[1]]$indexbestmodel], names(VGOB1_subsetB_meca_LUR1)[models[[2]]$indexbestmodel] , names(VGOB1_subsetB_meca_LUR1)[models[[3]]$indexbestmodel], names(VGOB1_subsetB_meca_LUR1)[models[[4]]$indexbestmodel], names(VGOB1_subsetB_meca_LUR1)[models[[5]]$indexbestmodel], names(VGOB1_subsetB_meca_LUR1)[models[[6]]$indexbestmodel], names(VGOB1_subsetB_meca_LUR1)[models[[7]]$indexbestmodel])
# 
# #  this is the r2 or that model
# models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2
# 
# #  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
# models[[modeln]]$bestmodel <- lm(VGOB1_subsetB_meca_LUR1$meca_copiespm3.ln.diffmeth.mean~ VGOB1_subsetB_meca_LUR1[,models[[1]]$indexbestmodel]+ VGOB1_subsetB_meca_LUR1[,models[[2]]$indexbestmodel]+ VGOB1_subsetB_meca_LUR1[,models[[3]]$indexbestmodel]+ VGOB1_subsetB_meca_LUR1[,models[[4]]$indexbestmodel]+ VGOB1_subsetB_meca_LUR1[,models[[5]]$indexbestmodel]+ VGOB1_subsetB_meca_LUR1[,models[[6]]$indexbestmodel]+ VGOB1_subsetB_meca_LUR1[,models[[7]]$indexbestmodel]) 
# 
# models[[1]]$summarybestmodel
# models[[2]]$summarybestmodel
# models[[3]]$summarybestmodel
# models[[4]]$summarybestmodel
# models[[5]]$summarybestmodel
# models[[6]]$summarybestmodel
# models[[7]]$summarybestmodel
# models[[1]]$namesbestmodel
# models[[2]]$namesbestmodel
# models[[3]]$namesbestmodel
# models[[4]]$namesbestmodel
# models[[5]]$namesbestmodel
# models[[6]]$namesbestmodel
# models[[7]]$namesbestmodel
# models[[1]]$R2bestmodel
# models[[2]]$R2bestmodel
# models[[3]]$R2bestmodel
# models[[4]]$R2bestmodel
# models[[5]]$R2bestmodel
# models[[6]]$R2bestmodel
# models[[7]]$R2bestmodel
# 
# # 8 #  
# # add eighth variable (the only difference of the above part is that now modeln=7 the model statement more variables)
# # and the call for the list of variable names in the model changed slightly
# 
# modeln<-8
# 
# models[[modeln]]<-list()
# 
# R2<-1
# addedvar<-1
# betaaddedvar<-1
# minbetas<-1
# j<-1
# 
# for (i in nfirstvar_LUR_1 :nlastvar_LUR_1){
#   if (is.numeric(VGOB1_subsetB_meca_LUR1[,i])==TRUE){
#     modeltry<- lm(VGOB1_subsetB_meca_LUR1$meca_copiespm3.ln.diffmeth.mean~ VGOB1_subsetB_meca_LUR1[,models[[1]]$indexbestmodel]+ VGOB1_subsetB_meca_LUR1[,models[[2]]$indexbestmodel]+ VGOB1_subsetB_meca_LUR1[,models[[3]]$indexbestmodel]+ VGOB1_subsetB_meca_LUR1[,models[[4]]$indexbestmodel]+ VGOB1_subsetB_meca_LUR1[,models[[5]]$indexbestmodel]+ VGOB1_subsetB_meca_LUR1[,models[[6]]$indexbestmodel]+ VGOB1_subsetB_meca_LUR1[,models[[7]]$indexbestmodel]+ VGOB1_subsetB_meca_LUR1[,i]) 
#     R2<-rbind(R2,summary(modeltry)$adj.r.squared)
#     # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
#     betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
#     #  find out if there is a negative beta at All. The intercept does not count [-1]!
#     minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
#     # Measurements_livestockpreds_LUR1[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR1)[i]
#     addedvar<-rbind(addedvar,names(VGOB1_subsetB_meca_LUR1)[i])
#     j<-rbind(j, i)
#     models[[modeln]][[i]]<-summary(modeltry)
#   }
# }
# 
# models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)
# 
# #  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
# models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)
# 
# # rank the R2's of these models
# models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))
# 
# #  this is the index of the row with the highest R2 and  no negative betas in this subset
# models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j
# 
# subset(models[[modeln]]$resultspos, rank==1)
# 
# # this is the model
# models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]
# 
# # here are the names
# models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetB_meca_LUR1)[models[[1]]$indexbestmodel], names(VGOB1_subsetB_meca_LUR1)[models[[2]]$indexbestmodel] , names(VGOB1_subsetB_meca_LUR1)[models[[3]]$indexbestmodel], names(VGOB1_subsetB_meca_LUR1)[models[[4]]$indexbestmodel], names(VGOB1_subsetB_meca_LUR1)[models[[5]]$indexbestmodel], names(VGOB1_subsetB_meca_LUR1)[models[[6]]$indexbestmodel], names(VGOB1_subsetB_meca_LUR1)[models[[7]]$indexbestmodel], names(VGOB1_subsetB_meca_LUR1)[models[[8]]$indexbestmodel])
# 
# #  this is the r2 or that model
# models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2
# 
# #  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
# models[[modeln]]$bestmodel <- lm(VGOB1_subsetB_meca_LUR1$meca_copiespm3.ln.diffmeth.mean~ VGOB1_subsetB_meca_LUR1[,models[[1]]$indexbestmodel]+ VGOB1_subsetB_meca_LUR1[,models[[2]]$indexbestmodel]+ VGOB1_subsetB_meca_LUR1[,models[[3]]$indexbestmodel]+ VGOB1_subsetB_meca_LUR1[,models[[4]]$indexbestmodel]+ VGOB1_subsetB_meca_LUR1[,models[[5]]$indexbestmodel]+ VGOB1_subsetB_meca_LUR1[,models[[6]]$indexbestmodel]+ VGOB1_subsetB_meca_LUR1[,models[[7]]$indexbestmodel]+ VGOB1_subsetB_meca_LUR1[,models[[8]]$indexbestmodel]) 
# 
# models[[1]]$summarybestmodel
# models[[2]]$summarybestmodel
# models[[3]]$summarybestmodel
# models[[4]]$summarybestmodel
# models[[5]]$summarybestmodel
# models[[6]]$summarybestmodel
# models[[7]]$summarybestmodel
# models[[8]]$summarybestmodel
# models[[1]]$namesbestmodel
# models[[2]]$namesbestmodel
# models[[3]]$namesbestmodel
# models[[4]]$namesbestmodel
# models[[5]]$namesbestmodel
# models[[6]]$namesbestmodel
# models[[7]]$namesbestmodel
# models[[8]]$namesbestmodel
# models[[1]]$R2bestmodel
# models[[2]]$R2bestmodel
# models[[3]]$R2bestmodel
# models[[4]]$R2bestmodel
# models[[5]]$R2bestmodel
# models[[6]]$R2bestmodel
# models[[7]]$R2bestmodel
# models[[8]]$R2bestmodel

#   CODE FOR PICKING OUT THE BEST MODEL #   
temp <- 0
besti <- 0
for (i in 1:10){ #  think this runs the loop 10 times - not fully sure thought - but not to do with the number of models I don't think - as when I change to 3, I still get the model with 4 variables as best model
  print(models[[i]]$R2bestmodel)
  #       print(models[[i]]$summarybestmodel$coefficients=-1,4])
  #       if((models[[i]]$R2bestmodel-temp > 0.0) && (all(models[[i]]$summarybestmodel$coefficients[-1,4]<0.1))){
  #         temp <- models[[i]]$R2bestmodel
  #         besti <- i
  #         }
  if((models[[i]]$R2bestmodel-temp > 0.0) && (all(models[[i]]$summarybestmodel$coefficients[-1,4]<0.1))){
    temp <- models[[i]]$R2bestmodel
    besti <- i
  }else{
    finalBestModel_meca_LUR1_subsetB <- models[[besti]]$bestmodel
    finalBestModelNames_meca_subsetB <- models[[besti]]$namesbestmodel
    Sites <- 1:dim(VGOB1_subsetB_meca_LUR1)[1] # full original model
    #  CVaR2<-escCV_meca_LUR1(Sites)[2] # Cross Validation
    maxCD<-max(cooks.distance(finalBestModel_meca_LUR1_subsetB))
    if(length(finalBestModelNames_meca_subsetB)<2){ # vif fn doesnot work when only 1 variable...       # 
      maxVIF<-"NA"
    }else{
      maxVIF<-max(vif(finalBestModel_meca_LUR1_subsetB))
    }
    print(paste("This is the best meca model for subset B of 10-fold CV: ",besti,
                "(AdjR2: ",format(models[[besti]]$R2bestmodel,digits=3), "; MaxCD: ",format(maxCD,digits=3),"; MaxVIF: ",
                format(maxVIF,digits=3),")", sep=''))
    print(finalBestModelNames_meca_subsetB)
    break
  }
}

#  Overview of the final best model using the algorithm selection process (taking into account VIF, R^2, and p-values)
finalBestModel_meca_LUR1_subsetB 
finalBestModelNames_meca_subsetB 
models[[besti]]$summarybestmodel
models[[besti]]$R2bestmodel

#### C ####
# LUR model building process for subset C
#  This is the dataframe with the relevant predictor vars for LUR1 models for subset C (55 sites)
VGOB1_subsetC_meca_LUR1 # n.b. this dataframe only includes microbial marker concentrations for meca unlike the dataframe Measurements_livestockpreds_LUR1 as previously used for the model building. 

#  Now set the values of some variables that will be needed
nfirstvar_LUR_1 <- 3  
nlastvar_LUR_1 <- 10

# Function building to run the models 
# 1 #  

models<-list()
modeln<-1
models[[modeln]]<-list()

R2<-1
betaaddedvar<-1
addedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_1:nlastvar_LUR_1){
  if (is.numeric(VGOB1_subsetC_meca_LUR1[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetC_meca_LUR1$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetC_meca_LUR1[,i])                            
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    #  Measurements_livestockpreds_LUR1[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR1)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetC_meca_LUR1)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)
models[[modeln]]$results

#  this are the candidates models with the highest R2, not a negative beta for the new, nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)
models[[modeln]]$resultspos

#  rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))
models[[modeln]]$resultspos

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j
models[[modeln]]$indexbestmodel

subset(models[[modeln]]$resultspos, rank==1)
subset(models[[modeln]]$resultspos)

#  this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]
models[[modeln]]$summarybestmodel

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetC_meca_LUR1)[models[[1]]$indexbestmodel])
models[[modeln]]$namesbestmodel

#  this is the r2 of that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2
models[[modeln]]$R2bestmodel

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetC_meca_LUR1$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetC_meca_LUR1[,models[[1]]$indexbestmodel]) 
models[[modeln]]$bestmodel

summary(models[[modeln]]$bestmodel)

#  The first model includes the predictor: nPigMultipFarmWghtDist.3000m.sum.Tr.1P9 - meaning the number of multiplier pig farms weighted to distance in a 3000m buffer

# 2 #  
# Add 2nd variable (the only difference of the above part is that now modeln=2 the model statement has 2 variables)
# and the call for the list of variable names in the model changed slightly

modeln<-2

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_1:nlastvar_LUR_1){
  if (is.numeric(VGOB1_subsetC_meca_LUR1[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetC_meca_LUR1$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetC_meca_LUR1[,models[[1]]$indexbestmodel]+ VGOB1_subsetC_meca_LUR1[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # Measurements_livestockpreds_LUR1[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR1)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetC_meca_LUR1)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  these are the candidate models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)
models[[modeln]]$resultspos

#  rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))
models[[modeln]]$resultspos

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j
models[[modeln]]$indexbestmodel

subset(models[[modeln]]$resultspos, rank==1)

# this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]
models[[modeln]]$summarybestmodel

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetC_meca_LUR1)[models[[1]]$indexbestmodel], names(VGOB1_subsetC_meca_LUR1)[models[[2]]$indexbestmodel] )
models[[modeln]]$namesbestmodel

# this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2
models[[modeln]]$R2bestmodel

# this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetC_meca_LUR1$meca_copiespm3.ln.diffmeth.mean~                               VGOB1_subsetC_meca_LUR1[,models[[1]]$indexbestmodel]+                           VGOB1_subsetC_meca_LUR1[,models[[2]]$indexbestmodel]) 

models[[modeln]]$bestmodel

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel


# 3 #  
# add third variable (the only difference of the above part is that now modeln=3 the model statement has 3 variables)
# and the call for the list of variable names in the model changed slightly

modeln<-3

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_1:nlastvar_LUR_1){
  if (is.numeric(VGOB1_subsetC_meca_LUR1[,i])==TRUE){  
    modeltry<-lm(VGOB1_subsetC_meca_LUR1$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetC_meca_LUR1[,models[[1]]$indexbestmodel]+VGOB1_subsetC_meca_LUR1[,models[[2]]$indexbestmodel]+ VGOB1_subsetC_meca_LUR1[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # All[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR1)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetC_meca_LUR1)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

#  rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

#  this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

#  here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetC_meca_LUR1)[models[[1]]$indexbestmodel], names(VGOB1_subsetC_meca_LUR1)[models[[2]]$indexbestmodel], names(VGOB1_subsetC_meca_LUR1)[models[[3]]$indexbestmodel])

#  this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetC_meca_LUR1$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetC_meca_LUR1[,models[[1]]$indexbestmodel]+ VGOB1_subsetC_meca_LUR1[,models[[2]]$indexbestmodel]+ VGOB1_subsetC_meca_LUR1[,models[[3]]$indexbestmodel]) 

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel

# # 4 #
# #  add forth variable (the only difference of the above part is that now model n=4 the model statement more variables)
# #  and the call for the list of variable names in the model changed slightly
# modeln<-4
# 
# models[[modeln]]<-list()
# 
# R2<-1
# addedvar<-1
# betaaddedvar<-1
# minbetas<-1
# j<-1
# 
# 
# for (i in nfirstvar_LUR_1:nlastvar_LUR_1){
#   if (is.numeric(VGOB1_subsetC_meca_LUR1[,i])==TRUE){
#     modeltry<-lm(VGOB1_subsetC_meca_LUR1$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetC_meca_LUR1[,models[[1]]$indexbestmodel]+VGOB1_subsetC_meca_LUR1[,models[[2]]$indexbestmodel]+VGOB1_subsetC_meca_LUR1[,models[[3]]$indexbestmodel]+VGOB1_subsetC_meca_LUR1[,i])
#     R2<-rbind(R2,summary(modeltry)$adj.r.squared)
#     #  the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
#     betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])
#     #  find out if there is a negative beta at All. The intercept does not count [-1]!
#     minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
#     #  All[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR1)[i]
#     addedvar<-rbind(addedvar,names(VGOB1_subsetC_meca_LUR1)[i])
#     j<-rbind(j, i)
#     models[[modeln]][[i]]<-summary(modeltry)
#   }
# }
# 
# models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)
# 
# #  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
# models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)
# 
# # rank the R2's of these models
# models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))
# 
# #  this is the index of the row with the highest R2 and  no negative betas in this subset
# models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j
# 
# subset(models[[modeln]]$resultspos, rank==1)
# 
# #  this is the model
# models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]
# 
# #  here are the names
# models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetC_meca_LUR1)[models[[1]]$indexbestmodel], names(VGOB1_subsetC_meca_LUR1)[models[[2]]$indexbestmodel], names(VGOB1_subsetC_meca_LUR1)[models[[3]]$indexbestmodel], names(VGOB1_subsetC_meca_LUR1)[models[[4]]$indexbestmodel])
# 
# #  this is the r2 of that model
# models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2
# 
# #  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
# models[[modeln]]$bestmodel <- lm(VGOB1_subsetC_meca_LUR1$meca_copiespm3.ln.diffmeth.mean~ VGOB1_subsetC_meca_LUR1[,models[[1]]$indexbestmodel]+ VGOB1_subsetC_meca_LUR1[,models[[2]]$indexbestmodel]+VGOB1_subsetC_meca_LUR1[,models[[3]]$indexbestmodel]+ VGOB1_subsetC_meca_LUR1[,models[[4]]$indexbestmodel])
# 
# 
# models[[1]]$summarybestmodel
# models[[2]]$summarybestmodel
# models[[3]]$summarybestmodel
# models[[4]]$summarybestmodel
# models[[1]]$namesbestmodel
# models[[2]]$namesbestmodel
# models[[3]]$namesbestmodel
# models[[4]]$namesbestmodel
# models[[1]]$R2bestmodel
# models[[2]]$R2bestmodel
# models[[3]]$R2bestmodel
# models[[4]]$R2bestmodel

# 
# # 5 #  
# # add fifth variable (the only difference of the above part is that now modeln=5 the model statement more variables)
# # and the call for the list of variable names in the model changed slightly
# modeln<-5
# 
# models[[modeln]]<-list()
# 
# R2<-1
# addedvar<-1
# betaaddedvar<-1
# minbetas<-1
# j<-1
# 
# for (i in nfirstvar_LUR_1:nlastvar_LUR_1){
#   if (is.numeric(VGOB1_subsetC_meca_LUR1[,i])==TRUE){
#     modeltry<-lm(VGOB1_subsetC_meca_LUR1$meca_copiespm3.ln.diffmeth.mean~ VGOB1_subsetC_meca_LUR1[,models[[1]]$indexbestmodel]+ VGOB1_subsetC_meca_LUR1[,models[[2]]$indexbestmodel]+ VGOB1_subsetC_meca_LUR1[,models[[3]]$indexbestmodel]+ VGOB1_subsetC_meca_LUR1[,models[[4]]$indexbestmodel]+ VGOB1_subsetC_meca_LUR1[,i]) 
#   
# R2<-rbind(R2,summary(modeltry)$adj.r.squared)
# # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
#     betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
#     #  find out if there is a negative beta at All. The intercept does not count [-1]!
#     minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
#     # All[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR1)[i]
#     addedvar<-rbind(addedvar,names(VGOB1_subsetC_meca_LUR1)[i])
#     j<-rbind(j, i)
#     models[[modeln]][[i]]<-summary(modeltry)
#   }
# }
# 
# models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)
# 
# #  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
# models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)
# 
# # rank the R2's of these models
# models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))
# 
# #  this is the index of the row with the highest R2 and  no negative betas in this subset
# models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j
# 
# subset(models[[modeln]]$resultspos, rank==1)
# 
# #  this is the model
# models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]
# 
# # here are the names
# models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetC_meca_LUR1)[models[[1]]$indexbestmodel], names(VGOB1_subsetC_meca_LUR1)[models[[2]]$indexbestmodel], names(VGOB1_subsetC_meca_LUR1)[models[[3]]$indexbestmodel], names(VGOB1_subsetC_meca_LUR1)[models[[4]]$indexbestmodel], names(VGOB1_subsetC_meca_LUR1)[models[[5]]$indexbestmodel])
# 
# #  this is the r2 or that model
# models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2
# 
# #  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
# models[[modeln]]$bestmodel <- lm(VGOB1_subsetC_meca_LUR1$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetC_meca_LUR1[,models[[1]]$indexbestmodel]+VGOB1_subsetC_meca_LUR1[,models[[2]]$indexbestmodel]+VGOB1_subsetC_meca_LUR1[,models[[3]]$indexbestmodel]+ VGOB1_subsetC_meca_LUR1[,models[[4]]$indexbestmodel]+ VGOB1_subsetC_meca_LUR1[,models[[5]]$indexbestmodel]) 
# models[[1]]$summarybestmodel
# models[[2]]$summarybestmodel
# models[[3]]$summarybestmodel
# models[[4]]$summarybestmodel
# models[[5]]$summarybestmodel
# models[[1]]$namesbestmodel
# models[[2]]$namesbestmodel
# models[[3]]$namesbestmodel
# models[[4]]$namesbestmodel
# models[[5]]$namesbestmodel
# models[[1]]$R2bestmodel
# models[[2]]$R2bestmodel
# models[[3]]$R2bestmodel
# models[[4]]$R2bestmodel
# models[[5]]$R2bestmodel
# 
# # 6 #  
# # add sixth variable (the only difference of the above part is that now model n=6 the model statement more variables)
# #  and the call for the list of variable names in the model changed slightly
# 
# modeln<-6
# 
# models[[modeln]]<-list()
# 
# R2<-1
# addedvar<-1
# betaaddedvar<-1
# minbetas<-1
# j<-1
# 
# for (i in nfirstvar_LUR_1 :nlastvar_LUR_1){
#   if (is.numeric(VGOB1_subsetC_meca_LUR1[,i])==TRUE){
#     modeltry<-lm(VGOB1_subsetC_meca_LUR1$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetC_meca_LUR1[,models[[1]]$indexbestmodel]+VGOB1_subsetC_meca_LUR1[,models[[2]]$indexbestmodel]+VGOB1_subsetC_meca_LUR1[,models[[3]]$indexbestmodel]+VGOB1_subsetC_meca_LUR1[,models[[4]]$indexbestmodel]+VGOB1_subsetC_meca_LUR1[,models[[5]]$indexbestmodel]+ VGOB1_subsetC_meca_LUR1[,i]) 
#     R2<-rbind(R2,summary(modeltry)$adj.r.squared)
#     # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
#     betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
#     #  find out if there is a negative beta at All. The intercept does not count [-1]!
#     minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
#     # All[,i] is the row that's being tried out now. the name of that row can be found in  names(All)[i]
#     addedvar<-rbind(addedvar,names(VGOB1_subsetC_meca_LUR1)[i])
#     j<-rbind(j, i)
#     models[[modeln]][[i]]<-summary(modeltry)
#   }
# }
# 
# models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)
# 
# #  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
# models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)
# 
# # rank the R2's of these models
# models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))
# 
# #  this is the index of the row with the highest R2 and  no negative betas in this subset
# models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j
# 
# subset(models[[modeln]]$resultspos, rank==1)
# 
# # this is the model
# models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]
# 
# # here are the names
# models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetC_meca_LUR1)[models[[1]]$indexbestmodel], names(VGOB1_subsetC_meca_LUR1)[models[[2]]$indexbestmodel] , names(VGOB1_subsetC_meca_LUR1)[models[[3]]$indexbestmodel], names(VGOB1_subsetC_meca_LUR1)[models[[4]]$indexbestmodel], names(VGOB1_subsetC_meca_LUR1)[models[[5]]$indexbestmodel], names(VGOB1_subsetC_meca_LUR1)[models[[6]]$indexbestmodel])
# 
# #  this is the r2 or that model
# models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2
# 
# #  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
# models[[modeln]]$bestmodel <- lm(VGOB1_subsetC_meca_LUR1$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetC_meca_LUR1[,models[[1]]$indexbestmodel]+VGOB1_subsetC_meca_LUR1[,models[[2]]$indexbestmodel]+VGOB1_subsetC_meca_LUR1[,models[[3]]$indexbestmodel]+ VGOB1_subsetC_meca_LUR1[,models[[4]]$indexbestmodel]+ VGOB1_subsetC_meca_LUR1[,models[[5]]$indexbestmodel]+ VGOB1_subsetC_meca_LUR1[,models[[6]]$indexbestmodel]) 
# 
# models[[1]]$summarybestmodel
# models[[2]]$summarybestmodel
# models[[3]]$summarybestmodel
# models[[4]]$summarybestmodel
# models[[5]]$summarybestmodel
# models[[6]]$summarybestmodel
# models[[1]]$namesbestmodel
# models[[2]]$namesbestmodel
# models[[3]]$namesbestmodel
# models[[4]]$namesbestmodel
# models[[5]]$namesbestmodel
# models[[6]]$namesbestmodel
# models[[1]]$R2bestmodel
# models[[2]]$R2bestmodel
# models[[3]]$R2bestmodel
# models[[4]]$R2bestmodel
# models[[5]]$R2bestmodel
# models[[6]]$R2bestmodel
# 
# 
# # 7 #  
# # add seventh variable (the only difference of the above part is that now model n=7 the model statement more variables)
# #  and the call for the list of variable names in the model changed slightly
# 
# modeln<-7
# 
# models[[modeln]]<-list()
# 
# R2<-1
# addedvar<-1
# betaaddedvar<-1
# minbetas<-1
# j<-1
# 
# for (i in nfirstvar_LUR_1 :nlastvar_LUR_1){
#   if (is.numeric(VGOB1_subsetC_meca_LUR1[,i])==TRUE){
#     modeltry<-lm(VGOB1_subsetC_meca_LUR1$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetC_meca_LUR1[,models[[1]]$indexbestmodel]+VGOB1_subsetC_meca_LUR1[,models[[2]]$indexbestmodel]+VGOB1_subsetC_meca_LUR1[,models[[3]]$indexbestmodel]+VGOB1_subsetC_meca_LUR1[,models[[4]]$indexbestmodel]+VGOB1_subsetC_meca_LUR1[,models[[5]]$indexbestmodel]+VGOB1_subsetC_meca_LUR1[,models[[6]]$indexbestmodel]+ VGOB1_subsetC_meca_LUR1[,i]) 
#     R2<-rbind(R2,summary(modeltry)$adj.r.squared)
#     # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
#     betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
#     #  find out if there is a negative beta at All. The intercept does not count [-1]!
#     minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
#     # Measurements_livestockpreds_LUR1[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR1)[i]
#     addedvar<-rbind(addedvar,names(VGOB1_subsetC_meca_LUR1)[i])
#     j<-rbind(j, i)
#     models[[modeln]][[i]]<-summary(modeltry)
#   }
# }
# 
# models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)
# 
# #  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
# models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)
# 
# # rank the R2's of these models
# models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))
# 
# #  this is the index of the row with the highest R2 and  no negative betas in this subset
# models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j
# 
# subset(models[[modeln]]$resultspos, rank==1)
# 
# # this is the model
# models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]
# 
# # here are the names
# models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetC_meca_LUR1)[models[[1]]$indexbestmodel], names(VGOB1_subsetC_meca_LUR1)[models[[2]]$indexbestmodel] , names(VGOB1_subsetC_meca_LUR1)[models[[3]]$indexbestmodel], names(VGOB1_subsetC_meca_LUR1)[models[[4]]$indexbestmodel], names(VGOB1_subsetC_meca_LUR1)[models[[5]]$indexbestmodel], names(VGOB1_subsetC_meca_LUR1)[models[[6]]$indexbestmodel], names(VGOB1_subsetC_meca_LUR1)[models[[7]]$indexbestmodel])
# 
# #  this is the r2 or that model
# models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2
# 
# #  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
# models[[modeln]]$bestmodel <- lm(VGOB1_subsetC_meca_LUR1$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetC_meca_LUR1[,models[[1]]$indexbestmodel]+VGOB1_subsetC_meca_LUR1[,models[[2]]$indexbestmodel]+VGOB1_subsetC_meca_LUR1[,models[[3]]$indexbestmodel]+ VGOB1_subsetC_meca_LUR1[,models[[4]]$indexbestmodel]+ VGOB1_subsetC_meca_LUR1[,models[[5]]$indexbestmodel]+ VGOB1_subsetC_meca_LUR1[,models[[6]]$indexbestmodel]+ VGOB1_subsetC_meca_LUR1[,models[[7]]$indexbestmodel]) 
# 
# models[[1]]$summarybestmodel
# models[[2]]$summarybestmodel
# models[[3]]$summarybestmodel
# models[[4]]$summarybestmodel
# models[[5]]$summarybestmodel
# models[[6]]$summarybestmodel
# models[[7]]$summarybestmodel
# models[[1]]$namesbestmodel
# models[[2]]$namesbestmodel
# models[[3]]$namesbestmodel
# models[[4]]$namesbestmodel
# models[[5]]$namesbestmodel
# models[[6]]$namesbestmodel
# models[[7]]$namesbestmodel
# models[[1]]$R2bestmodel
# models[[2]]$R2bestmodel
# models[[3]]$R2bestmodel
# models[[4]]$R2bestmodel
# models[[5]]$R2bestmodel
# models[[6]]$R2bestmodel
# models[[7]]$R2bestmodel
# 
# # 8 #  
# # add eighth variable (the only difference of the above part is that now modeln=7 the model statement more variables)
# # and the call for the list of variable names in the model changed slightly
# 
# modeln<-8
# 
# models[[modeln]]<-list()
# 
# R2<-1
# addedvar<-1
# betaaddedvar<-1
# minbetas<-1
# j<-1
# 
# for (i in nfirstvar_LUR_1 :nlastvar_LUR_1){
#   if (is.numeric(VGOB1_subsetC_meca_LUR1[,i])==TRUE){
#     modeltry<-lm(VGOB1_subsetC_meca_LUR1$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetC_meca_LUR1[,models[[1]]$indexbestmodel]+VGOB1_subsetC_meca_LUR1[,models[[2]]$indexbestmodel]+VGOB1_subsetC_meca_LUR1[,models[[3]]$indexbestmodel]+VGOB1_subsetC_meca_LUR1[,models[[4]]$indexbestmodel]+VGOB1_subsetC_meca_LUR1[,models[[5]]$indexbestmodel]+VGOB1_subsetC_meca_LUR1[,models[[6]]$indexbestmodel]+ VGOB1_subsetC_meca_LUR1[,models[[7]]$indexbestmodel]+ VGOB1_subsetC_meca_LUR1[,i]) 
#     R2<-rbind(R2,summary(modeltry)$adj.r.squared)
#     # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
#     betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
#     #  find out if there is a negative beta at All. The intercept does not count [-1]!
#     minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
#     # Measurements_livestockpreds_LUR1[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR1)[i]
#     addedvar<-rbind(addedvar,names(VGOB1_subsetC_meca_LUR1)[i])
#     j<-rbind(j, i)
#     models[[modeln]][[i]]<-summary(modeltry)
#   }
# }
# 
# models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)
# 
# #  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
# models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)
# 
# # rank the R2's of these models
# models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))
# 
# #  this is the index of the row with the highest R2 and  no negative betas in this subset
# models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j
# 
# subset(models[[modeln]]$resultspos, rank==1)
# 
# # this is the model
# models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]
# 
# # here are the names
# models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetC_meca_LUR1)[models[[1]]$indexbestmodel], names(VGOB1_subsetC_meca_LUR1)[models[[2]]$indexbestmodel] , names(VGOB1_subsetC_meca_LUR1)[models[[3]]$indexbestmodel], names(VGOB1_subsetC_meca_LUR1)[models[[4]]$indexbestmodel], names(VGOB1_subsetC_meca_LUR1)[models[[5]]$indexbestmodel], names(VGOB1_subsetC_meca_LUR1)[models[[6]]$indexbestmodel], names(VGOB1_subsetC_meca_LUR1)[models[[7]]$indexbestmodel], names(VGOB1_subsetC_meca_LUR1)[models[[8]]$indexbestmodel])
# 
# #  this is the r2 or that model
# models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2
# 
# #  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
# models[[modeln]]$bestmodel <- lm(VGOB1_subsetC_meca_LUR1$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetC_meca_LUR1[,models[[1]]$indexbestmodel]+VGOB1_subsetC_meca_LUR1[,models[[2]]$indexbestmodel]+VGOB1_subsetC_meca_LUR1[,models[[3]]$indexbestmodel]+ VGOB1_subsetC_meca_LUR1[,models[[4]]$indexbestmodel]+ VGOB1_subsetC_meca_LUR1[,models[[5]]$indexbestmodel]+ VGOB1_subsetC_meca_LUR1[,models[[6]]$indexbestmodel]+ VGOB1_subsetC_meca_LUR1[,models[[7]]$indexbestmodel]+ VGOB1_subsetC_meca_LUR1[,models[[8]]$indexbestmodel]) 
# 
# models[[1]]$summarybestmodel
# models[[2]]$summarybestmodel
# models[[3]]$summarybestmodel
# models[[4]]$summarybestmodel
# models[[5]]$summarybestmodel
# models[[6]]$summarybestmodel
# models[[7]]$summarybestmodel
# models[[8]]$summarybestmodel
# models[[1]]$namesbestmodel
# models[[2]]$namesbestmodel
# models[[3]]$namesbestmodel
# models[[4]]$namesbestmodel
# models[[5]]$namesbestmodel
# models[[6]]$namesbestmodel
# models[[7]]$namesbestmodel
# models[[8]]$namesbestmodel
# models[[1]]$R2bestmodel
# models[[2]]$R2bestmodel
# models[[3]]$R2bestmodel
# models[[4]]$R2bestmodel
# models[[5]]$R2bestmodel
# models[[6]]$R2bestmodel
# models[[7]]$R2bestmodel
# models[[8]]$R2bestmodel

#   CODE FOR PICKING OUT THE BEST MODEL #   
temp <- 0
besti <- 0
for (i in 1:10){ #  think this runs the loop 10 times - not fully sure thought - but not to do with the number of models I don't think - as when I change to 3, I still get the model with 4 variables as best model
  print(models[[i]]$R2bestmodel)
  #       print(models[[i]]$summarybestmodel$coefficients=-1,4])
  #       if((models[[i]]$R2bestmodel-temp > 0.0) && (all(models[[i]]$summarybestmodel$coefficients[-1,4]<0.1))){
  #         temp <- models[[i]]$R2bestmodel
  #         besti <- i
  #         }
  if((models[[i]]$R2bestmodel-temp > 0.0) && (all(models[[i]]$summarybestmodel$coefficients[-1,4]<0.1))){
    temp <- models[[i]]$R2bestmodel
    besti <- i
  }else{
    finalBestModel_meca_LUR1_subsetC <- models[[besti]]$bestmodel
    finalBestModelNames_meca_subsetC <- models[[besti]]$namesbestmodel
    Sites <- 1:dim(VGOB1_subsetC_meca_LUR1)[1] # full original model
    #  CVaR2<-escCV_meca_LUR1(Sites)[2] # Cross Validation
    maxCD<-max(cooks.distance(finalBestModel_meca_LUR1_subsetC))
    if(length(finalBestModelNames_meca_subsetC)<2){ # vif fn doesnot work when only 1 variable...       # 
      maxVIF<-"NA"
    }else{
      maxVIF<-max(vif(finalBestModel_meca_LUR1_subsetC))
    }
    print(paste("This is the best meca model for subset C: ",besti,
                "(AdjR2: ",format(models[[besti]]$R2bestmodel,digits=3), "; MaxCD: ",format(maxCD,digits=3),"; MaxVIF: ",
                format(maxVIF,digits=3),")", sep=''))
    print(finalBestModelNames_meca_subsetC)
    break
  }
}

#  Overview of the final best model using the algorithm selection process (taking into account VIF, R^2, and p-values)
finalBestModel_meca_LUR1_subsetC
finalBestModelNames_meca_subsetC
models[[besti]]$summarybestmodel
models[[besti]]$R2bestmodel

#### D ####
# LUR model building process for subset D
#  This is the dataframe with the relevant predictor vars for LUR1 models for subset D (55 sites)
VGOB1_subsetD_meca_LUR1 # n.b. this dataframe only includes microbial marker concentrations for meca unlike the dataframe Measurements_livestockpreds_LUR1 as previously used for the model building. 

#  Now set the values of some variables that will be needed
nfirstvar_LUR_1 <- 3  
nlastvar_LUR_1 <- 10

# Function building to run the models 
# 1 #  

models<-list()
modeln<-1
models[[modeln]]<-list()

R2<-1
betaaddedvar<-1
addedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_1:nlastvar_LUR_1){
  if (is.numeric(VGOB1_subsetD_meca_LUR1[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetD_meca_LUR1$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetD_meca_LUR1[,i])                            
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    #  Measurements_livestockpreds_LUR1[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR1)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetD_meca_LUR1)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)
models[[modeln]]$results

#  this are the candidates models with the highest R2, not a negative beta for the new, nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)
models[[modeln]]$resultspos

#  rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))
models[[modeln]]$resultspos

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j
models[[modeln]]$indexbestmodel

subset(models[[modeln]]$resultspos, rank==1)
subset(models[[modeln]]$resultspos)

#  this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]
models[[modeln]]$summarybestmodel

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetD_meca_LUR1)[models[[1]]$indexbestmodel])
models[[modeln]]$namesbestmodel

#  this is the r2 of that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2
models[[modeln]]$R2bestmodel

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetD_meca_LUR1$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetD_meca_LUR1[,models[[1]]$indexbestmodel]) 
models[[modeln]]$bestmodel

summary(models[[modeln]]$bestmodel)

#  The first model includes the predictor: nPigMultipFarmWghtDist.3000m.sum.Tr.1P9 - meaning the number of multiplier pig farms weighted to distance in a 3000m buffer

# 2 #  
# Add 2nd variable (the only difference of the above part is that now modeln=2 the model statement has 2 variables)
# and the call for the list of variable names in the model changed slightly

modeln<-2

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_1:nlastvar_LUR_1){
  if (is.numeric(VGOB1_subsetD_meca_LUR1[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetD_meca_LUR1$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetD_meca_LUR1[,models[[1]]$indexbestmodel]+ VGOB1_subsetD_meca_LUR1[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # Measurements_livestockpreds_LUR1[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR1)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetD_meca_LUR1)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  these are the candidate models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)
models[[modeln]]$resultspos

#  rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))
models[[modeln]]$resultspos

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j
models[[modeln]]$indexbestmodel

subset(models[[modeln]]$resultspos, rank==1)

# this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]
models[[modeln]]$summarybestmodel

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetD_meca_LUR1)[models[[1]]$indexbestmodel], names(VGOB1_subsetD_meca_LUR1)[models[[2]]$indexbestmodel] )
models[[modeln]]$namesbestmodel

# this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2
models[[modeln]]$R2bestmodel

# this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetD_meca_LUR1$meca_copiespm3.ln.diffmeth.mean~                               VGOB1_subsetD_meca_LUR1[,models[[1]]$indexbestmodel]+                           VGOB1_subsetD_meca_LUR1[,models[[2]]$indexbestmodel]) 

models[[modeln]]$bestmodel

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel

# 3 #
# add third variable (the only difference of the above part is that now modeln=3 the model statement has 3 variables)
# and the call for the list of variable names in the model changed slightly

modeln<-3

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_1:nlastvar_LUR_1){
  if (is.numeric(VGOB1_subsetD_meca_LUR1[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetD_meca_LUR1$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetD_meca_LUR1[,models[[1]]$indexbestmodel]+VGOB1_subsetD_meca_LUR1[,models[[2]]$indexbestmodel]+ VGOB1_subsetD_meca_LUR1[,i])
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])#
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # All[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR1)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetD_meca_LUR1)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

#  rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

#  this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

#  here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetD_meca_LUR1)[models[[1]]$indexbestmodel], names(VGOB1_subsetD_meca_LUR1)[models[[2]]$indexbestmodel], names(VGOB1_subsetD_meca_LUR1)[models[[3]]$indexbestmodel])

#  this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetD_meca_LUR1$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetD_meca_LUR1[,models[[1]]$indexbestmodel]+ VGOB1_subsetD_meca_LUR1[,models[[2]]$indexbestmodel]+ VGOB1_subsetD_meca_LUR1[,models[[3]]$indexbestmodel])

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel

# 
# # 4 #
# #  add forth variable (the only difference of the above part is that now model n=4 the model statement more variables)
# #  and the call for the list of variable names in the model changed slightly
# modeln<-4
# 
# models[[modeln]]<-list()
# 
# R2<-1
# addedvar<-1
# betaaddedvar<-1
# minbetas<-1
# j<-1
# 
# 
# for (i in nfirstvar_LUR_1:nlastvar_LUR_1){
#   if (is.numeric(VGOB1_subsetD_meca_LUR1[,i])==TRUE){
#     modeltry<-lm(VGOB1_subsetD_meca_LUR1$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetD_meca_LUR1[,models[[1]]$indexbestmodel]+VGOB1_subsetD_meca_LUR1[,models[[2]]$indexbestmodel]+VGOB1_subsetD_meca_LUR1[,models[[3]]$indexbestmodel]+VGOB1_subsetD_meca_LUR1[,i])
#     R2<-rbind(R2,summary(modeltry)$adj.r.squared)
#     #  the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
#     betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])
#     #  find out if there is a negative beta at All. The intercept does not count [-1]!
#     minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
#     #  All[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR1)[i]
#     addedvar<-rbind(addedvar,names(VGOB1_subsetD_meca_LUR1)[i])
#     j<-rbind(j, i)
#     models[[modeln]][[i]]<-summary(modeltry)
#   }
# }
# 
# models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)
# 
# #  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
# models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)
# 
# # rank the R2's of these models
# models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))
# 
# #  this is the index of the row with the highest R2 and  no negative betas in this subset
# models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j
# 
# subset(models[[modeln]]$resultspos, rank==1)
# 
# #  this is the model
# models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]
# 
# #  here are the names
# models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetD_meca_LUR1)[models[[1]]$indexbestmodel], names(VGOB1_subsetD_meca_LUR1)[models[[2]]$indexbestmodel], names(VGOB1_subsetD_meca_LUR1)[models[[3]]$indexbestmodel], names(VGOB1_subsetD_meca_LUR1)[models[[4]]$indexbestmodel])
# 
# #  this is the r2 of that model
# models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2
# 
# #  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
# models[[modeln]]$bestmodel <- lm(VGOB1_subsetD_meca_LUR1$meca_copiespm3.ln.diffmeth.mean~ VGOB1_subsetD_meca_LUR1[,models[[1]]$indexbestmodel]+ VGOB1_subsetD_meca_LUR1[,models[[2]]$indexbestmodel]+VGOB1_subsetD_meca_LUR1[,models[[3]]$indexbestmodel]+ VGOB1_subsetD_meca_LUR1[,models[[4]]$indexbestmodel])
# 
# 
# models[[1]]$summarybestmodel
# models[[2]]$summarybestmodel
# models[[3]]$summarybestmodel
# models[[4]]$summarybestmodel
# models[[1]]$namesbestmodel
# models[[2]]$namesbestmodel
# models[[3]]$namesbestmodel
# models[[4]]$namesbestmodel
# models[[1]]$R2bestmodel
# models[[2]]$R2bestmodel
# models[[3]]$R2bestmodel
# models[[4]]$R2bestmodel
# 
# # 5 #  
# # add fifth variable (the only difference of the above part is that now modeln=5 the model statement more variables)
# # and the call for the list of variable names in the model changed slightly
# modeln<-5
# 
# models[[modeln]]<-list()
# 
# R2<-1
# addedvar<-1
# betaaddedvar<-1
# minbetas<-1
# j<-1
# 
# for (i in nfirstvar_LUR_1:nlastvar_LUR_1){
#   if (is.numeric(VGOB1_subsetD_meca_LUR1[,i])==TRUE){
#     modeltry<-lm(VGOB1_subsetD_meca_LUR1$meca_copiespm3.ln.diffmeth.mean~ VGOB1_subsetD_meca_LUR1[,models[[1]]$indexbestmodel]+ VGOB1_subsetD_meca_LUR1[,models[[2]]$indexbestmodel]+ VGOB1_subsetD_meca_LUR1[,models[[3]]$indexbestmodel]+ VGOB1_subsetD_meca_LUR1[,models[[4]]$indexbestmodel]+ VGOB1_subsetD_meca_LUR1[,i]) 
#   
# R2<-rbind(R2,summary(modeltry)$adj.r.squared)
# # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
#     betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
#     #  find out if there is a negative beta at All. The intercept does not count [-1]!
#     minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
#     # All[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR1)[i]
#     addedvar<-rbind(addedvar,names(VGOB1_subsetD_meca_LUR1)[i])
#     j<-rbind(j, i)
#     models[[modeln]][[i]]<-summary(modeltry)
#   }
# }
# 
# models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)
# 
# #  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
# models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)
# 
# # rank the R2's of these models
# models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))
# 
# #  this is the index of the row with the highest R2 and  no negative betas in this subset
# models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j
# 
# subset(models[[modeln]]$resultspos, rank==1)
# 
# #  this is the model
# models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]
# 
# # here are the names
# models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetD_meca_LUR1)[models[[1]]$indexbestmodel], names(VGOB1_subsetD_meca_LUR1)[models[[2]]$indexbestmodel], names(VGOB1_subsetD_meca_LUR1)[models[[3]]$indexbestmodel], names(VGOB1_subsetD_meca_LUR1)[models[[4]]$indexbestmodel], names(VGOB1_subsetD_meca_LUR1)[models[[5]]$indexbestmodel])
# 
# #  this is the r2 or that model
# models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2
# 
# #  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
# models[[modeln]]$bestmodel <- lm(VGOB1_subsetD_meca_LUR1$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetD_meca_LUR1[,models[[1]]$indexbestmodel]+VGOB1_subsetD_meca_LUR1[,models[[2]]$indexbestmodel]+VGOB1_subsetD_meca_LUR1[,models[[3]]$indexbestmodel]+ VGOB1_subsetD_meca_LUR1[,models[[4]]$indexbestmodel]+ VGOB1_subsetD_meca_LUR1[,models[[5]]$indexbestmodel]) 
# models[[1]]$summarybestmodel
# models[[2]]$summarybestmodel
# models[[3]]$summarybestmodel
# models[[4]]$summarybestmodel
# models[[5]]$summarybestmodel
# models[[1]]$namesbestmodel
# models[[2]]$namesbestmodel
# models[[3]]$namesbestmodel
# models[[4]]$namesbestmodel
# models[[5]]$namesbestmodel
# models[[1]]$R2bestmodel
# models[[2]]$R2bestmodel
# models[[3]]$R2bestmodel
# models[[4]]$R2bestmodel
# models[[5]]$R2bestmodel
# 
# # 6 #  
# # add sixth variable (the only difference of the above part is that now model n=6 the model statement more variables)
# #  and the call for the list of variable names in the model changed slightly
# 
# modeln<-6
# 
# models[[modeln]]<-list()
# 
# R2<-1
# addedvar<-1
# betaaddedvar<-1
# minbetas<-1
# j<-1
# 
# for (i in nfirstvar_LUR_1 :nlastvar_LUR_1){
#   if (is.numeric(VGOB1_subsetD_meca_LUR1[,i])==TRUE){
#     modeltry<-lm(VGOB1_subsetD_meca_LUR1$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetD_meca_LUR1[,models[[1]]$indexbestmodel]+VGOB1_subsetD_meca_LUR1[,models[[2]]$indexbestmodel]+VGOB1_subsetD_meca_LUR1[,models[[3]]$indexbestmodel]+VGOB1_subsetD_meca_LUR1[,models[[4]]$indexbestmodel]+VGOB1_subsetD_meca_LUR1[,models[[5]]$indexbestmodel]+ VGOB1_subsetD_meca_LUR1[,i]) 
#     R2<-rbind(R2,summary(modeltry)$adj.r.squared)
#     # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
#     betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
#     #  find out if there is a negative beta at All. The intercept does not count [-1]!
#     minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
#     # All[,i] is the row that's being tried out now. the name of that row can be found in  names(All)[i]
#     addedvar<-rbind(addedvar,names(VGOB1_subsetD_meca_LUR1)[i])
#     j<-rbind(j, i)
#     models[[modeln]][[i]]<-summary(modeltry)
#   }
# }
# 
# models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)
# 
# #  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
# models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)
# 
# # rank the R2's of these models
# models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))
# 
# #  this is the index of the row with the highest R2 and  no negative betas in this subset
# models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j
# 
# subset(models[[modeln]]$resultspos, rank==1)
# 
# # this is the model
# models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]
# 
# # here are the names
# models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetD_meca_LUR1)[models[[1]]$indexbestmodel], names(VGOB1_subsetD_meca_LUR1)[models[[2]]$indexbestmodel] , names(VGOB1_subsetD_meca_LUR1)[models[[3]]$indexbestmodel], names(VGOB1_subsetD_meca_LUR1)[models[[4]]$indexbestmodel], names(VGOB1_subsetD_meca_LUR1)[models[[5]]$indexbestmodel], names(VGOB1_subsetD_meca_LUR1)[models[[6]]$indexbestmodel])
# 
# #  this is the r2 or that model
# models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2
# 
# #  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
# models[[modeln]]$bestmodel <- lm(VGOB1_subsetD_meca_LUR1$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetD_meca_LUR1[,models[[1]]$indexbestmodel]+VGOB1_subsetD_meca_LUR1[,models[[2]]$indexbestmodel]+VGOB1_subsetD_meca_LUR1[,models[[3]]$indexbestmodel]+ VGOB1_subsetD_meca_LUR1[,models[[4]]$indexbestmodel]+ VGOB1_subsetD_meca_LUR1[,models[[5]]$indexbestmodel]+ VGOB1_subsetD_meca_LUR1[,models[[6]]$indexbestmodel]) 
# 
# models[[1]]$summarybestmodel
# models[[2]]$summarybestmodel
# models[[3]]$summarybestmodel
# models[[4]]$summarybestmodel
# models[[5]]$summarybestmodel
# models[[6]]$summarybestmodel
# models[[1]]$namesbestmodel
# models[[2]]$namesbestmodel
# models[[3]]$namesbestmodel
# models[[4]]$namesbestmodel
# models[[5]]$namesbestmodel
# models[[6]]$namesbestmodel
# models[[1]]$R2bestmodel
# models[[2]]$R2bestmodel
# models[[3]]$R2bestmodel
# models[[4]]$R2bestmodel
# models[[5]]$R2bestmodel
# models[[6]]$R2bestmodel
# 
# 
# # 7 #  
# # add seventh variable (the only difference of the above part is that now model n=7 the model statement more variables)
# #  and the call for the list of variable names in the model changed slightly
# 
# modeln<-7
# 
# models[[modeln]]<-list()
# 
# R2<-1
# addedvar<-1
# betaaddedvar<-1
# minbetas<-1
# j<-1
# 
# for (i in nfirstvar_LUR_1 :nlastvar_LUR_1){
#   if (is.numeric(VGOB1_subsetD_meca_LUR1[,i])==TRUE){
#     modeltry<-lm(VGOB1_subsetD_meca_LUR1$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetD_meca_LUR1[,models[[1]]$indexbestmodel]+VGOB1_subsetD_meca_LUR1[,models[[2]]$indexbestmodel]+VGOB1_subsetD_meca_LUR1[,models[[3]]$indexbestmodel]+VGOB1_subsetD_meca_LUR1[,models[[4]]$indexbestmodel]+VGOB1_subsetD_meca_LUR1[,models[[5]]$indexbestmodel]+VGOB1_subsetD_meca_LUR1[,models[[6]]$indexbestmodel]+ VGOB1_subsetD_meca_LUR1[,i]) 
#     R2<-rbind(R2,summary(modeltry)$adj.r.squared)
#     # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
#     betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
#     #  find out if there is a negative beta at All. The intercept does not count [-1]!
#     minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
#     # Measurements_livestockpreds_LUR1[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR1)[i]
#     addedvar<-rbind(addedvar,names(VGOB1_subsetD_meca_LUR1)[i])
#     j<-rbind(j, i)
#     models[[modeln]][[i]]<-summary(modeltry)
#   }
# }
# 
# models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)
# 
# #  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
# models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)
# 
# # rank the R2's of these models
# models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))
# 
# #  this is the index of the row with the highest R2 and  no negative betas in this subset
# models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j
# 
# subset(models[[modeln]]$resultspos, rank==1)
# 
# # this is the model
# models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]
# 
# # here are the names
# models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetD_meca_LUR1)[models[[1]]$indexbestmodel], names(VGOB1_subsetD_meca_LUR1)[models[[2]]$indexbestmodel] , names(VGOB1_subsetD_meca_LUR1)[models[[3]]$indexbestmodel], names(VGOB1_subsetD_meca_LUR1)[models[[4]]$indexbestmodel], names(VGOB1_subsetD_meca_LUR1)[models[[5]]$indexbestmodel], names(VGOB1_subsetD_meca_LUR1)[models[[6]]$indexbestmodel], names(VGOB1_subsetD_meca_LUR1)[models[[7]]$indexbestmodel])
# 
# #  this is the r2 or that model
# models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2
# 
# #  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
# models[[modeln]]$bestmodel <- lm(VGOB1_subsetD_meca_LUR1$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetD_meca_LUR1[,models[[1]]$indexbestmodel]+VGOB1_subsetD_meca_LUR1[,models[[2]]$indexbestmodel]+VGOB1_subsetD_meca_LUR1[,models[[3]]$indexbestmodel]+ VGOB1_subsetD_meca_LUR1[,models[[4]]$indexbestmodel]+ VGOB1_subsetD_meca_LUR1[,models[[5]]$indexbestmodel]+ VGOB1_subsetD_meca_LUR1[,models[[6]]$indexbestmodel]+ VGOB1_subsetD_meca_LUR1[,models[[7]]$indexbestmodel]) 
# 
# models[[1]]$summarybestmodel
# models[[2]]$summarybestmodel
# models[[3]]$summarybestmodel
# models[[4]]$summarybestmodel
# models[[5]]$summarybestmodel
# models[[6]]$summarybestmodel
# models[[7]]$summarybestmodel
# models[[1]]$namesbestmodel
# models[[2]]$namesbestmodel
# models[[3]]$namesbestmodel
# models[[4]]$namesbestmodel
# models[[5]]$namesbestmodel
# models[[6]]$namesbestmodel
# models[[7]]$namesbestmodel
# models[[1]]$R2bestmodel
# models[[2]]$R2bestmodel
# models[[3]]$R2bestmodel
# models[[4]]$R2bestmodel
# models[[5]]$R2bestmodel
# models[[6]]$R2bestmodel
# models[[7]]$R2bestmodel
# 
# # 8 #  
# # add eighth variable (the only difference of the above part is that now modeln=7 the model statement more variables)
# # and the call for the list of variable names in the model changed slightly
# 
# modeln<-8
# 
# models[[modeln]]<-list()
# 
# R2<-1
# addedvar<-1
# betaaddedvar<-1
# minbetas<-1
# j<-1
# 
# for (i in nfirstvar_LUR_1 :nlastvar_LUR_1){
#   if (is.numeric(VGOB1_subsetD_meca_LUR1[,i])==TRUE){
#     modeltry<-lm(VGOB1_subsetD_meca_LUR1$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetD_meca_LUR1[,models[[1]]$indexbestmodel]+VGOB1_subsetD_meca_LUR1[,models[[2]]$indexbestmodel]+VGOB1_subsetD_meca_LUR1[,models[[3]]$indexbestmodel]+VGOB1_subsetD_meca_LUR1[,models[[4]]$indexbestmodel]+VGOB1_subsetD_meca_LUR1[,models[[5]]$indexbestmodel]+VGOB1_subsetD_meca_LUR1[,models[[6]]$indexbestmodel]+ VGOB1_subsetD_meca_LUR1[,models[[7]]$indexbestmodel]+ VGOB1_subsetD_meca_LUR1[,i]) 
#     R2<-rbind(R2,summary(modeltry)$adj.r.squared)
#     # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
#     betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
#     #  find out if there is a negative beta at All. The intercept does not count [-1]!
#     minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
#     # Measurements_livestockpreds_LUR1[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR1)[i]
#     addedvar<-rbind(addedvar,names(VGOB1_subsetD_meca_LUR1)[i])
#     j<-rbind(j, i)
#     models[[modeln]][[i]]<-summary(modeltry)
#   }
# }
# 
# models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)
# 
# #  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
# models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)
# 
# # rank the R2's of these models
# models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))
# 
# #  this is the index of the row with the highest R2 and  no negative betas in this subset
# models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j
# 
# subset(models[[modeln]]$resultspos, rank==1)
# 
# # this is the model
# models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]
# 
# # here are the names
# models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetD_meca_LUR1)[models[[1]]$indexbestmodel], names(VGOB1_subsetD_meca_LUR1)[models[[2]]$indexbestmodel] , names(VGOB1_subsetD_meca_LUR1)[models[[3]]$indexbestmodel], names(VGOB1_subsetD_meca_LUR1)[models[[4]]$indexbestmodel], names(VGOB1_subsetD_meca_LUR1)[models[[5]]$indexbestmodel], names(VGOB1_subsetD_meca_LUR1)[models[[6]]$indexbestmodel], names(VGOB1_subsetD_meca_LUR1)[models[[7]]$indexbestmodel], names(VGOB1_subsetD_meca_LUR1)[models[[8]]$indexbestmodel])
# 
# #  this is the r2 or that model
# models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2
# 
# #  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
# models[[modeln]]$bestmodel <- lm(VGOB1_subsetD_meca_LUR1$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetD_meca_LUR1[,models[[1]]$indexbestmodel]+VGOB1_subsetD_meca_LUR1[,models[[2]]$indexbestmodel]+VGOB1_subsetD_meca_LUR1[,models[[3]]$indexbestmodel]+ VGOB1_subsetD_meca_LUR1[,models[[4]]$indexbestmodel]+ VGOB1_subsetD_meca_LUR1[,models[[5]]$indexbestmodel]+ VGOB1_subsetD_meca_LUR1[,models[[6]]$indexbestmodel]+ VGOB1_subsetD_meca_LUR1[,models[[7]]$indexbestmodel]+ VGOB1_subsetD_meca_LUR1[,models[[8]]$indexbestmodel]) 
# 
# models[[1]]$summarybestmodel
# models[[2]]$summarybestmodel
# models[[3]]$summarybestmodel
# models[[4]]$summarybestmodel
# models[[5]]$summarybestmodel
# models[[6]]$summarybestmodel
# models[[7]]$summarybestmodel
# models[[8]]$summarybestmodel
# models[[1]]$namesbestmodel
# models[[2]]$namesbestmodel
# models[[3]]$namesbestmodel
# models[[4]]$namesbestmodel
# models[[5]]$namesbestmodel
# models[[6]]$namesbestmodel
# models[[7]]$namesbestmodel
# models[[8]]$namesbestmodel
# models[[1]]$R2bestmodel
# models[[2]]$R2bestmodel
# models[[3]]$R2bestmodel
# models[[4]]$R2bestmodel
# models[[5]]$R2bestmodel
# models[[6]]$R2bestmodel
# models[[7]]$R2bestmodel
# models[[8]]$R2bestmodel

#   CODE FOR PICKING OUT THE BEST MODEL #   
temp <- 0
besti <- 0
for (i in 1:10){ #  think this runs the loop 10 times - not fully sure thought - but not to do with the number of models I don't think - as when I change to 3, I still get the model with 4 variables as best model
  print(models[[i]]$R2bestmodel)
  #       print(models[[i]]$summarybestmodel$coefficients=-1,4])
  #       if((models[[i]]$R2bestmodel-temp > 0.0) && (all(models[[i]]$summarybestmodel$coefficients[-1,4]<0.1))){
  #         temp <- models[[i]]$R2bestmodel
  #         besti <- i
  #         }
  if((models[[i]]$R2bestmodel-temp > 0.0) && (all(models[[i]]$summarybestmodel$coefficients[-1,4]<0.1))){
    temp <- models[[i]]$R2bestmodel
    besti <- i
  }else{
    finalBestModel_meca_LUR1_subsetD <- models[[besti]]$bestmodel
    finalBestModelNames_meca_subsetD <- models[[besti]]$namesbestmodel
    Sites <- 1:dim(VGOB1_subsetD_meca_LUR1)[1] # full original model
    #  CVaR2<-escCV_meca_LUR1(Sites)[2] # Cross Validation
    maxCD<-max(cooks.distance(finalBestModel_meca_LUR1_subsetD))
    if(length(finalBestModelNames_meca_subsetD)<2){ # vif fn doesnot work when only 1 variable...       # 
      maxVIF<-"NA"
    }else{
      maxVIF<-max(vif(finalBestModel_meca_LUR1_subsetD))
    }
    print(paste("This is the best meca model for subset D: ",besti,
                "(AdjR2: ",format(models[[besti]]$R2bestmodel,digits=3), "; MaxCD: ",format(maxCD,digits=3),"; MaxVIF: ",
                format(maxVIF,digits=3),")", sep=''))
    print(finalBestModelNames_meca_subsetD)
    break
  }
}

#  Overview of the final best model using the algorithm selection process (taking into account VIF, R^2, and p-values)
finalBestModel_meca_LUR1_subsetD
finalBestModelNames_meca_subsetD
models[[besti]]$summarybestmodel
models[[besti]]$R2bestmodel


#### E ####
# LUR model building process for subset E
#  This is the dataframe with the relevant predictor vars for LUR1 models for subset E (55 sites)
VGOB1_subsetE_meca_LUR1 # n.b. this dataframe only includes microbial marker concentrations for meca unlike the dataframe Measurements_livestockpreds_LUR1 as previously used for the model building. 

#  Now set the values of some variables that will be needed
nfirstvar_LUR_1 <- 3  
nlastvar_LUR_1 <- 10

# Function building to run the models 
# 1 #  

models<-list()
modeln<-1
models[[modeln]]<-list()

R2<-1
betaaddedvar<-1
addedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_1:nlastvar_LUR_1){
  if (is.numeric(VGOB1_subsetE_meca_LUR1[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetE_meca_LUR1$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetE_meca_LUR1[,i])                            
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    #  Measurements_livestockpreds_LUR1[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR1)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetE_meca_LUR1)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)
models[[modeln]]$results

#  this are the candidates models with the highest R2, not a negative beta for the new, nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)
models[[modeln]]$resultspos

#  rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))
models[[modeln]]$resultspos

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j
models[[modeln]]$indexbestmodel

subset(models[[modeln]]$resultspos, rank==1)
subset(models[[modeln]]$resultspos)

#  this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]
models[[modeln]]$summarybestmodel

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetE_meca_LUR1)[models[[1]]$indexbestmodel])
models[[modeln]]$namesbestmodel

#  this is the r2 of that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2
models[[modeln]]$R2bestmodel

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetE_meca_LUR1$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetE_meca_LUR1[,models[[1]]$indexbestmodel]) 
models[[modeln]]$bestmodel

summary(models[[modeln]]$bestmodel)

#  The first model includes the predictor: nPigMultipFarmWghtDist.3000m.sum.Tr.1P9 - meaning the number of multiplier pig farms weighted to distance in a 3000m buffer

# 2 #  
# Add 2nd variable (the only difference of the above part is that now modeln=2 the model statement has 2 variables)
# and the call for the list of variable names in the model changed slightly

modeln<-2

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_1:nlastvar_LUR_1){
  if (is.numeric(VGOB1_subsetE_meca_LUR1[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetE_meca_LUR1$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetE_meca_LUR1[,models[[1]]$indexbestmodel]+ VGOB1_subsetE_meca_LUR1[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # Measurements_livestockpreds_LUR1[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR1)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetE_meca_LUR1)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  these are the candidate models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)
models[[modeln]]$resultspos

#  rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))
models[[modeln]]$resultspos

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j
models[[modeln]]$indexbestmodel

subset(models[[modeln]]$resultspos, rank==1)

# this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]
models[[modeln]]$summarybestmodel

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetE_meca_LUR1)[models[[1]]$indexbestmodel], names(VGOB1_subsetE_meca_LUR1)[models[[2]]$indexbestmodel] )
models[[modeln]]$namesbestmodel

# this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2
models[[modeln]]$R2bestmodel

# this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetE_meca_LUR1$meca_copiespm3.ln.diffmeth.mean~                               VGOB1_subsetE_meca_LUR1[,models[[1]]$indexbestmodel]+                           VGOB1_subsetE_meca_LUR1[,models[[2]]$indexbestmodel]) 

models[[modeln]]$bestmodel

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel

# 3 #
# add third variable (the only difference of the above part is that now modeln=3 the model statement has 3 variables)
# and the call for the list of variable names in the model changed slightly

modeln<-3

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_1:nlastvar_LUR_1){
  if (is.numeric(VGOB1_subsetE_meca_LUR1[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetE_meca_LUR1$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetE_meca_LUR1[,models[[1]]$indexbestmodel]+VGOB1_subsetE_meca_LUR1[,models[[2]]$indexbestmodel]+ VGOB1_subsetE_meca_LUR1[,i])
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])#
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # All[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR1)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetE_meca_LUR1)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

#  rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

#  this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

#  here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetE_meca_LUR1)[models[[1]]$indexbestmodel], names(VGOB1_subsetE_meca_LUR1)[models[[2]]$indexbestmodel], names(VGOB1_subsetE_meca_LUR1)[models[[3]]$indexbestmodel])

#  this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetE_meca_LUR1$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetE_meca_LUR1[,models[[1]]$indexbestmodel]+ VGOB1_subsetE_meca_LUR1[,models[[2]]$indexbestmodel]+ VGOB1_subsetE_meca_LUR1[,models[[3]]$indexbestmodel])

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel

# The next part of the code (n=4-8) does not work
# This is because one of the coefficients included in the model with 6 variables is negative, the code does not allow for this. I can stop here.

# # 4 #
# #  add forth variable (the only difference of the above part is that now model n=4 the model statement more variables)
# #  and the call for the list of variable names in the model changed slightly
# modeln<-4
# 
# models[[modeln]]<-list()
# 
# R2<-1
# addedvar<-1
# betaaddedvar<-1
# minbetas<-1
# j<-1
# 
# 
# for (i in nfirstvar_LUR_1:nlastvar_LUR_1){
#   if (is.numeric(VGOB1_subsetE_meca_LUR1[,i])==TRUE){
#     modeltry<-lm(VGOB1_subsetE_meca_LUR1$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetE_meca_LUR1[,models[[1]]$indexbestmodel]+VGOB1_subsetE_meca_LUR1[,models[[2]]$indexbestmodel]+VGOB1_subsetE_meca_LUR1[,models[[3]]$indexbestmodel]+VGOB1_subsetE_meca_LUR1[,i])
#     R2<-rbind(R2,summary(modeltry)$adj.r.squared)
#     #  the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
#     betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])
#     #  find out if there is a negative beta at All. The intercept does not count [-1]!
#     minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
#     #  All[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR1)[i]
#     addedvar<-rbind(addedvar,names(VGOB1_subsetE_meca_LUR1)[i])
#     j<-rbind(j, i)
#     models[[modeln]][[i]]<-summary(modeltry)
#   }
# }
# 
# models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)
# 
# #  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
# models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)
# 
# # rank the R2's of these models
# models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))
# 
# #  this is the index of the row with the highest R2 and  no negative betas in this subset
# models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j
# 
# subset(models[[modeln]]$resultspos, rank==1)
# 
# #  this is the model
# models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]
# 
# #  here are the names
# models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetE_meca_LUR1)[models[[1]]$indexbestmodel], names(VGOB1_subsetE_meca_LUR1)[models[[2]]$indexbestmodel], names(VGOB1_subsetE_meca_LUR1)[models[[3]]$indexbestmodel], names(VGOB1_subsetE_meca_LUR1)[models[[4]]$indexbestmodel])
# 
# #  this is the r2 of that model
# models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2
# 
# #  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
# models[[modeln]]$bestmodel <- lm(VGOB1_subsetE_meca_LUR1$meca_copiespm3.ln.diffmeth.mean~ VGOB1_subsetE_meca_LUR1[,models[[1]]$indexbestmodel]+ VGOB1_subsetE_meca_LUR1[,models[[2]]$indexbestmodel]+VGOB1_subsetE_meca_LUR1[,models[[3]]$indexbestmodel]+ VGOB1_subsetE_meca_LUR1[,models[[4]]$indexbestmodel])
# 
# 
# models[[1]]$summarybestmodel
# models[[2]]$summarybestmodel
# models[[3]]$summarybestmodel
# models[[4]]$summarybestmodel
# models[[1]]$namesbestmodel
# models[[2]]$namesbestmodel
# models[[3]]$namesbestmodel
# models[[4]]$namesbestmodel
# models[[1]]$R2bestmodel
# models[[2]]$R2bestmodel
# models[[3]]$R2bestmodel
# models[[4]]$R2bestmodel

# 
# # 5 #  
# # add fifth variable (the only difference of the above part is that now modeln=5 the model statement more variables)
# # and the call for the list of variable names in the model changed slightly
# modeln<-5
# 
# models[[modeln]]<-list()
# 
# R2<-1
# addedvar<-1
# betaaddedvar<-1
# minbetas<-1
# j<-1
# 
# for (i in nfirstvar_LUR_1:nlastvar_LUR_1){
#   if (is.numeric(VGOB1_subsetE_meca_LUR1[,i])==TRUE){
#     modeltry<-lm(VGOB1_subsetE_meca_LUR1$meca_copiespm3.ln.diffmeth.mean~ VGOB1_subsetE_meca_LUR1[,models[[1]]$indexbestmodel]+ VGOB1_subsetE_meca_LUR1[,models[[2]]$indexbestmodel]+ VGOB1_subsetE_meca_LUR1[,models[[3]]$indexbestmodel]+ VGOB1_subsetE_meca_LUR1[,models[[4]]$indexbestmodel]+ VGOB1_subsetE_meca_LUR1[,i]) 
#   
# R2<-rbind(R2,summary(modeltry)$adj.r.squared)
# # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
#     betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
#     #  find out if there is a negative beta at All. The intercept does not count [-1]!
#     minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
#     # All[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR1)[i]
#     addedvar<-rbind(addedvar,names(VGOB1_subsetE_meca_LUR1)[i])
#     j<-rbind(j, i)
#     models[[modeln]][[i]]<-summary(modeltry)
#   }
# }
# 
# models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)
# 
# #  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
# models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)
# 
# # rank the R2's of these models
# models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))
# 
# #  this is the index of the row with the highest R2 and  no negative betas in this subset
# models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j
# 
# subset(models[[modeln]]$resultspos, rank==1)
# 
# #  this is the model
# models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]
# 
# # here are the names
# models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetE_meca_LUR1)[models[[1]]$indexbestmodel], names(VGOB1_subsetE_meca_LUR1)[models[[2]]$indexbestmodel], names(VGOB1_subsetE_meca_LUR1)[models[[3]]$indexbestmodel], names(VGOB1_subsetE_meca_LUR1)[models[[4]]$indexbestmodel], names(VGOB1_subsetE_meca_LUR1)[models[[5]]$indexbestmodel])
# 
# #  this is the r2 or that model
# models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2
# 
# #  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
# models[[modeln]]$bestmodel <- lm(VGOB1_subsetE_meca_LUR1$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetE_meca_LUR1[,models[[1]]$indexbestmodel]+VGOB1_subsetE_meca_LUR1[,models[[2]]$indexbestmodel]+VGOB1_subsetE_meca_LUR1[,models[[3]]$indexbestmodel]+ VGOB1_subsetE_meca_LUR1[,models[[4]]$indexbestmodel]+ VGOB1_subsetE_meca_LUR1[,models[[5]]$indexbestmodel]) 
# models[[1]]$summarybestmodel
# models[[2]]$summarybestmodel
# models[[3]]$summarybestmodel
# models[[4]]$summarybestmodel
# models[[5]]$summarybestmodel
# models[[1]]$namesbestmodel
# models[[2]]$namesbestmodel
# models[[3]]$namesbestmodel
# models[[4]]$namesbestmodel
# models[[5]]$namesbestmodel
# models[[1]]$R2bestmodel
# models[[2]]$R2bestmodel
# models[[3]]$R2bestmodel
# models[[4]]$R2bestmodel
# models[[5]]$R2bestmodel
# 
# # 6 #  
# # add sixth variable (the only difference of the above part is that now model n=6 the model statement more variables)
# #  and the call for the list of variable names in the model changed slightly
# 
# modeln<-6
# 
# models[[modeln]]<-list()
# 
# R2<-1
# addedvar<-1
# betaaddedvar<-1
# minbetas<-1
# j<-1
# 
# for (i in nfirstvar_LUR_1 :nlastvar_LUR_1){
#   if (is.numeric(VGOB1_subsetE_meca_LUR1[,i])==TRUE){
#     modeltry<-lm(VGOB1_subsetE_meca_LUR1$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetE_meca_LUR1[,models[[1]]$indexbestmodel]+VGOB1_subsetE_meca_LUR1[,models[[2]]$indexbestmodel]+VGOB1_subsetE_meca_LUR1[,models[[3]]$indexbestmodel]+VGOB1_subsetE_meca_LUR1[,models[[4]]$indexbestmodel]+VGOB1_subsetE_meca_LUR1[,models[[5]]$indexbestmodel]+ VGOB1_subsetE_meca_LUR1[,i]) 
#     R2<-rbind(R2,summary(modeltry)$adj.r.squared)
#     # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
#     betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
#     #  find out if there is a negative beta at All. The intercept does not count [-1]!
#     minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
#     # All[,i] is the row that's being tried out now. the name of that row can be found in  names(All)[i]
#     addedvar<-rbind(addedvar,names(VGOB1_subsetE_meca_LUR1)[i])
#     j<-rbind(j, i)
#     models[[modeln]][[i]]<-summary(modeltry)
#   }
# }
# 
# models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)
# 
# #  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
# models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)
# 
# # rank the R2's of these models
# models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))
# 
# #  this is the index of the row with the highest R2 and  no negative betas in this subset
# models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j
# 
# subset(models[[modeln]]$resultspos, rank==1)
# 
# # this is the model
# models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]
# 
# # here are the names
# models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetE_meca_LUR1)[models[[1]]$indexbestmodel], names(VGOB1_subsetE_meca_LUR1)[models[[2]]$indexbestmodel] , names(VGOB1_subsetE_meca_LUR1)[models[[3]]$indexbestmodel], names(VGOB1_subsetE_meca_LUR1)[models[[4]]$indexbestmodel], names(VGOB1_subsetE_meca_LUR1)[models[[5]]$indexbestmodel], names(VGOB1_subsetE_meca_LUR1)[models[[6]]$indexbestmodel])
# 
# #  this is the r2 or that model
# models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2
# 
# #  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
# models[[modeln]]$bestmodel <- lm(VGOB1_subsetE_meca_LUR1$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetE_meca_LUR1[,models[[1]]$indexbestmodel]+VGOB1_subsetE_meca_LUR1[,models[[2]]$indexbestmodel]+VGOB1_subsetE_meca_LUR1[,models[[3]]$indexbestmodel]+ VGOB1_subsetE_meca_LUR1[,models[[4]]$indexbestmodel]+ VGOB1_subsetE_meca_LUR1[,models[[5]]$indexbestmodel]+ VGOB1_subsetE_meca_LUR1[,models[[6]]$indexbestmodel]) 
# 
# models[[1]]$summarybestmodel
# models[[2]]$summarybestmodel
# models[[3]]$summarybestmodel
# models[[4]]$summarybestmodel
# models[[5]]$summarybestmodel
# models[[6]]$summarybestmodel
# models[[1]]$namesbestmodel
# models[[2]]$namesbestmodel
# models[[3]]$namesbestmodel
# models[[4]]$namesbestmodel
# models[[5]]$namesbestmodel
# models[[6]]$namesbestmodel
# models[[1]]$R2bestmodel
# models[[2]]$R2bestmodel
# models[[3]]$R2bestmodel
# models[[4]]$R2bestmodel
# models[[5]]$R2bestmodel
# models[[6]]$R2bestmodel
# 
# 
# # 7 #  
# # add seventh variable (the only difference of the above part is that now model n=7 the model statement more variables)
# #  and the call for the list of variable names in the model changed slightly
# 
# modeln<-7
# 
# models[[modeln]]<-list()
# 
# R2<-1
# addedvar<-1
# betaaddedvar<-1
# minbetas<-1
# j<-1
# 
# for (i in nfirstvar_LUR_1 :nlastvar_LUR_1){
#   if (is.numeric(VGOB1_subsetE_meca_LUR1[,i])==TRUE){
#     modeltry<-lm(VGOB1_subsetE_meca_LUR1$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetE_meca_LUR1[,models[[1]]$indexbestmodel]+VGOB1_subsetE_meca_LUR1[,models[[2]]$indexbestmodel]+VGOB1_subsetE_meca_LUR1[,models[[3]]$indexbestmodel]+VGOB1_subsetE_meca_LUR1[,models[[4]]$indexbestmodel]+VGOB1_subsetE_meca_LUR1[,models[[5]]$indexbestmodel]+VGOB1_subsetE_meca_LUR1[,models[[6]]$indexbestmodel]+ VGOB1_subsetE_meca_LUR1[,i]) 
#     R2<-rbind(R2,summary(modeltry)$adj.r.squared)
#     # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
#     betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
#     #  find out if there is a negative beta at All. The intercept does not count [-1]!
#     minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
#     # Measurements_livestockpreds_LUR1[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR1)[i]
#     addedvar<-rbind(addedvar,names(VGOB1_subsetE_meca_LUR1)[i])
#     j<-rbind(j, i)
#     models[[modeln]][[i]]<-summary(modeltry)
#   }
# }
# 
# models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)
# 
# #  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
# models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)
# 
# # rank the R2's of these models
# models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))
# 
# #  this is the index of the row with the highest R2 and  no negative betas in this subset
# models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j
# 
# subset(models[[modeln]]$resultspos, rank==1)
# 
# # this is the model
# models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]
# 
# # here are the names
# models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetE_meca_LUR1)[models[[1]]$indexbestmodel], names(VGOB1_subsetE_meca_LUR1)[models[[2]]$indexbestmodel] , names(VGOB1_subsetE_meca_LUR1)[models[[3]]$indexbestmodel], names(VGOB1_subsetE_meca_LUR1)[models[[4]]$indexbestmodel], names(VGOB1_subsetE_meca_LUR1)[models[[5]]$indexbestmodel], names(VGOB1_subsetE_meca_LUR1)[models[[6]]$indexbestmodel], names(VGOB1_subsetE_meca_LUR1)[models[[7]]$indexbestmodel])
# 
# #  this is the r2 or that model
# models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2
# 
# #  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
# models[[modeln]]$bestmodel <- lm(VGOB1_subsetE_meca_LUR1$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetE_meca_LUR1[,models[[1]]$indexbestmodel]+VGOB1_subsetE_meca_LUR1[,models[[2]]$indexbestmodel]+VGOB1_subsetE_meca_LUR1[,models[[3]]$indexbestmodel]+ VGOB1_subsetE_meca_LUR1[,models[[4]]$indexbestmodel]+ VGOB1_subsetE_meca_LUR1[,models[[5]]$indexbestmodel]+ VGOB1_subsetE_meca_LUR1[,models[[6]]$indexbestmodel]+ VGOB1_subsetE_meca_LUR1[,models[[7]]$indexbestmodel]) 
# 
# models[[1]]$summarybestmodel
# models[[2]]$summarybestmodel
# models[[3]]$summarybestmodel
# models[[4]]$summarybestmodel
# models[[5]]$summarybestmodel
# models[[6]]$summarybestmodel
# models[[7]]$summarybestmodel
# models[[1]]$namesbestmodel
# models[[2]]$namesbestmodel
# models[[3]]$namesbestmodel
# models[[4]]$namesbestmodel
# models[[5]]$namesbestmodel
# models[[6]]$namesbestmodel
# models[[7]]$namesbestmodel
# models[[1]]$R2bestmodel
# models[[2]]$R2bestmodel
# models[[3]]$R2bestmodel
# models[[4]]$R2bestmodel
# models[[5]]$R2bestmodel
# models[[6]]$R2bestmodel
# models[[7]]$R2bestmodel
# 
# # 8 #  
# # add eighth variable (the only difference of the above part is that now modeln=7 the model statement more variables)
# # and the call for the list of variable names in the model changed slightly
# 
# modeln<-8
# 
# models[[modeln]]<-list()
# 
# R2<-1
# addedvar<-1
# betaaddedvar<-1
# minbetas<-1
# j<-1
# 
# for (i in nfirstvar_LUR_1 :nlastvar_LUR_1){
#   if (is.numeric(VGOB1_subsetE_meca_LUR1[,i])==TRUE){
#     modeltry<-lm(VGOB1_subsetE_meca_LUR1$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetE_meca_LUR1[,models[[1]]$indexbestmodel]+VGOB1_subsetE_meca_LUR1[,models[[2]]$indexbestmodel]+VGOB1_subsetE_meca_LUR1[,models[[3]]$indexbestmodel]+VGOB1_subsetE_meca_LUR1[,models[[4]]$indexbestmodel]+VGOB1_subsetE_meca_LUR1[,models[[5]]$indexbestmodel]+VGOB1_subsetE_meca_LUR1[,models[[6]]$indexbestmodel]+ VGOB1_subsetE_meca_LUR1[,models[[7]]$indexbestmodel]+ VGOB1_subsetE_meca_LUR1[,i]) 
#     R2<-rbind(R2,summary(modeltry)$adj.r.squared)
#     # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
#     betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
#     #  find out if there is a negative beta at All. The intercept does not count [-1]!
#     minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
#     # Measurements_livestockpreds_LUR1[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR1)[i]
#     addedvar<-rbind(addedvar,names(VGOB1_subsetE_meca_LUR1)[i])
#     j<-rbind(j, i)
#     models[[modeln]][[i]]<-summary(modeltry)
#   }
# }
# 
# models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)
# 
# #  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
# models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)
# 
# # rank the R2's of these models
# models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))
# 
# #  this is the index of the row with the highest R2 and  no negative betas in this subset
# models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j
# 
# subset(models[[modeln]]$resultspos, rank==1)
# 
# # this is the model
# models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]
# 
# # here are the names
# models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetE_meca_LUR1)[models[[1]]$indexbestmodel], names(VGOB1_subsetE_meca_LUR1)[models[[2]]$indexbestmodel] , names(VGOB1_subsetE_meca_LUR1)[models[[3]]$indexbestmodel], names(VGOB1_subsetE_meca_LUR1)[models[[4]]$indexbestmodel], names(VGOB1_subsetE_meca_LUR1)[models[[5]]$indexbestmodel], names(VGOB1_subsetE_meca_LUR1)[models[[6]]$indexbestmodel], names(VGOB1_subsetE_meca_LUR1)[models[[7]]$indexbestmodel], names(VGOB1_subsetE_meca_LUR1)[models[[8]]$indexbestmodel])
# 
# #  this is the r2 or that model
# models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2
# 
# #  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
# models[[modeln]]$bestmodel <- lm(VGOB1_subsetE_meca_LUR1$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetE_meca_LUR1[,models[[1]]$indexbestmodel]+VGOB1_subsetE_meca_LUR1[,models[[2]]$indexbestmodel]+VGOB1_subsetE_meca_LUR1[,models[[3]]$indexbestmodel]+ VGOB1_subsetE_meca_LUR1[,models[[4]]$indexbestmodel]+ VGOB1_subsetE_meca_LUR1[,models[[5]]$indexbestmodel]+ VGOB1_subsetE_meca_LUR1[,models[[6]]$indexbestmodel]+ VGOB1_subsetE_meca_LUR1[,models[[7]]$indexbestmodel]+ VGOB1_subsetE_meca_LUR1[,models[[8]]$indexbestmodel]) 
# 
# models[[1]]$summarybestmodel
# models[[2]]$summarybestmodel
# models[[3]]$summarybestmodel
# models[[4]]$summarybestmodel
# models[[5]]$summarybestmodel
# models[[6]]$summarybestmodel
# models[[7]]$summarybestmodel
# models[[8]]$summarybestmodel
# models[[1]]$namesbestmodel
# models[[2]]$namesbestmodel
# models[[3]]$namesbestmodel
# models[[4]]$namesbestmodel
# models[[5]]$namesbestmodel
# models[[6]]$namesbestmodel
# models[[7]]$namesbestmodel
# models[[8]]$namesbestmodel
# models[[1]]$R2bestmodel
# models[[2]]$R2bestmodel
# models[[3]]$R2bestmodel
# models[[4]]$R2bestmodel
# models[[5]]$R2bestmodel
# models[[6]]$R2bestmodel
# models[[7]]$R2bestmodel
# models[[8]]$R2bestmodel


#   CODE FOR PICKING OUT THE BEST MODEL #   
temp <- 0
besti <- 0
for (i in 1:10){ #  think this runs the loop 10 times - not fully sure thought - but not to do with the number of models I don't think - as when I change to 3, I still get the model with 4 variables as best model
  print(models[[i]]$R2bestmodel)
  #       print(models[[i]]$summarybestmodel$coefficients=-1,4])
  #       if((models[[i]]$R2bestmodel-temp > 0.0) && (all(models[[i]]$summarybestmodel$coefficients[-1,4]<0.1))){
  #         temp <- models[[i]]$R2bestmodel
  #         besti <- i
  #         }
  if((models[[i]]$R2bestmodel-temp > 0.0) && (all(models[[i]]$summarybestmodel$coefficients[-1,4]<0.1))){
    temp <- models[[i]]$R2bestmodel
    besti <- i
  }else{
    finalBestModel_meca_LUR1_subsetE <- models[[besti]]$bestmodel
    finalBestModelNames_meca_subsetE <- models[[besti]]$namesbestmodel
    Sites <- 1:dim(VGOB1_subsetE_meca_LUR1)[1] # full original model
    #  CVaR2<-escCV_meca_LUR1(Sites)[2] # Cross Validation
    maxCD<-max(cooks.distance(finalBestModel_meca_LUR1_subsetE))
    if(length(finalBestModelNames_meca_subsetE)<2){ # vif fn doesnot work when only 1 variable...       # 
      maxVIF<-"NA"
    }else{
      maxVIF<-max(vif(finalBestModel_meca_LUR1_subsetE))
    }
    print(paste("This is the best meca model for subset E: ",besti,
                "(AdjR2: ",format(models[[besti]]$R2bestmodel,digits=3), "; MaxCD: ",format(maxCD,digits=3),"; MaxVIF: ",
                format(maxVIF,digits=3),")", sep=''))
    print(finalBestModelNames_meca_subsetE)
    break
  }
}

#  Overview of the final best model using the algorithm selection process (taking into account VIF, R^2, and p-values)
finalBestModel_meca_LUR1_subsetE
finalBestModelNames_meca_subsetE
models[[besti]]$summarybestmodel
models[[besti]]$R2bestmodel

#### F ####
# LUR model building process for subset F
#  This is the dataframe with the relevant predictor vars for LUR1 models for subset F (55 sites)
VGOB1_subsetF_meca_LUR1 # n.b. this dataframe only includes microbial marker concentrations for meca unlike the dataframe Measurements_livestockpreds_LUR1 as previously used for the model building. 

#  Now set the values of some variables that will be needed
nfirstvar_LUR_1 <- 3  
nlastvar_LUR_1 <- 10

# Function building to run the models 
# 1 #  

models<-list()
modeln<-1
models[[modeln]]<-list()

R2<-1
betaaddedvar<-1
addedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_1:nlastvar_LUR_1){
  if (is.numeric(VGOB1_subsetF_meca_LUR1[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetF_meca_LUR1$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetF_meca_LUR1[,i])                            
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    #  Measurements_livestockpreds_LUR1[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR1)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetF_meca_LUR1)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)
models[[modeln]]$results

#  this are the candidates models with the highest R2, not a negative beta for the new, nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)
models[[modeln]]$resultspos

#  rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))
models[[modeln]]$resultspos

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j
models[[modeln]]$indexbestmodel

subset(models[[modeln]]$resultspos, rank==1)
subset(models[[modeln]]$resultspos)

#  this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]
models[[modeln]]$summarybestmodel

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetF_meca_LUR1)[models[[1]]$indexbestmodel])
models[[modeln]]$namesbestmodel

#  this is the r2 of that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2
models[[modeln]]$R2bestmodel

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetF_meca_LUR1$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetF_meca_LUR1[,models[[1]]$indexbestmodel]) 
models[[modeln]]$bestmodel

summary(models[[modeln]]$bestmodel)

#  The first model includes the predictor: nPigMultipFarmWghtDist.3000m.sum.Tr.1P9 - meaning the number of multiplier pig farms weighted to distance in a 3000m buffer

# 2 #  
# Add 2nd variable (the only difference of the above part is that now modeln=2 the model statement has 2 variables)
# and the call for the list of variable names in the model changed slightly

modeln<-2

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_1:nlastvar_LUR_1){
  if (is.numeric(VGOB1_subsetF_meca_LUR1[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetF_meca_LUR1$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetF_meca_LUR1[,models[[1]]$indexbestmodel]+ VGOB1_subsetF_meca_LUR1[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # Measurements_livestockpreds_LUR1[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR1)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetF_meca_LUR1)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  these are the candidate models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)
models[[modeln]]$resultspos

#  rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))
models[[modeln]]$resultspos

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j
models[[modeln]]$indexbestmodel

subset(models[[modeln]]$resultspos, rank==1)

# this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]
models[[modeln]]$summarybestmodel

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetF_meca_LUR1)[models[[1]]$indexbestmodel], names(VGOB1_subsetF_meca_LUR1)[models[[2]]$indexbestmodel] )
models[[modeln]]$namesbestmodel

# this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2
models[[modeln]]$R2bestmodel

# this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetF_meca_LUR1$meca_copiespm3.ln.diffmeth.mean~                               VGOB1_subsetF_meca_LUR1[,models[[1]]$indexbestmodel]+                           VGOB1_subsetF_meca_LUR1[,models[[2]]$indexbestmodel]) 

models[[modeln]]$bestmodel

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel


# 3 #  
# add third variable (the only difference of the above part is that now modeln=3 the model statement has 3 variables)
# and the call for the list of variable names in the model changed slightly

modeln<-3

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_1:nlastvar_LUR_1){
  if (is.numeric(VGOB1_subsetF_meca_LUR1[,i])==TRUE){  
    modeltry<-lm(VGOB1_subsetF_meca_LUR1$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetF_meca_LUR1[,models[[1]]$indexbestmodel]+VGOB1_subsetF_meca_LUR1[,models[[2]]$indexbestmodel]+ VGOB1_subsetF_meca_LUR1[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # All[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR1)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetF_meca_LUR1)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

#  rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

#  this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

#  here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetF_meca_LUR1)[models[[1]]$indexbestmodel], names(VGOB1_subsetF_meca_LUR1)[models[[2]]$indexbestmodel], names(VGOB1_subsetF_meca_LUR1)[models[[3]]$indexbestmodel])

#  this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetF_meca_LUR1$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetF_meca_LUR1[,models[[1]]$indexbestmodel]+ VGOB1_subsetF_meca_LUR1[,models[[2]]$indexbestmodel]+ VGOB1_subsetF_meca_LUR1[,models[[3]]$indexbestmodel]) 

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel


# 4 #  
#  add forth variable (the only difference of the above part is that now model n=4 the model statement more variables)
#  and the call for the list of variable names in the model changed slightly
modeln<-4

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1


for (i in nfirstvar_LUR_1:nlastvar_LUR_1){
  if (is.numeric(VGOB1_subsetF_meca_LUR1[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetF_meca_LUR1$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetF_meca_LUR1[,models[[1]]$indexbestmodel]+VGOB1_subsetF_meca_LUR1[,models[[2]]$indexbestmodel]+VGOB1_subsetF_meca_LUR1[,models[[3]]$indexbestmodel]+VGOB1_subsetF_meca_LUR1[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    #  the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    #  All[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR1)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetF_meca_LUR1)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

#  this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

#  here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetF_meca_LUR1)[models[[1]]$indexbestmodel], names(VGOB1_subsetF_meca_LUR1)[models[[2]]$indexbestmodel], names(VGOB1_subsetF_meca_LUR1)[models[[3]]$indexbestmodel], names(VGOB1_subsetF_meca_LUR1)[models[[4]]$indexbestmodel])

#  this is the r2 of that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetF_meca_LUR1$meca_copiespm3.ln.diffmeth.mean~ VGOB1_subsetF_meca_LUR1[,models[[1]]$indexbestmodel]+ VGOB1_subsetF_meca_LUR1[,models[[2]]$indexbestmodel]+VGOB1_subsetF_meca_LUR1[,models[[3]]$indexbestmodel]+ VGOB1_subsetF_meca_LUR1[,models[[4]]$indexbestmodel]) 


models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel

# The next part of the code (n=5-8) does not work
# This is because one of the coefficients included in the model with 6 variables is negative, the code does not allow for this. I can stop here.

# # 5 #
# # add fifth variable (the only difference of the above part is that now modeln=5 the model statement more variables)
# # and the call for the list of variable names in the model changed slightly
# modeln<-5
# 
# models[[modeln]]<-list()
# 
# R2<-1
# addedvar<-1
# betaaddedvar<-1
# minbetas<-1
# j<-1
# 
# for (i in nfirstvar_LUR_1:nlastvar_LUR_1){
#   if (is.numeric(VGOB1_subsetF_meca_LUR1[,i])==TRUE){
#     modeltry<-lm(VGOB1_subsetF_meca_LUR1$meca_copiespm3.ln.diffmeth.mean~ VGOB1_subsetF_meca_LUR1[,models[[1]]$indexbestmodel]+ VGOB1_subsetF_meca_LUR1[,models[[2]]$indexbestmodel]+ VGOB1_subsetF_meca_LUR1[,models[[3]]$indexbestmodel]+ VGOB1_subsetF_meca_LUR1[,models[[4]]$indexbestmodel]+ VGOB1_subsetF_meca_LUR1[,i])
# 
# R2<-rbind(R2,summary(modeltry)$adj.r.squared)
# # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
#     betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])#
#     #  find out if there is a negative beta at All. The intercept does not count [-1]!
#     minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
#     # All[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR1)[i]
#     addedvar<-rbind(addedvar,names(VGOB1_subsetF_meca_LUR1)[i])
#     j<-rbind(j, i)
#     models[[modeln]][[i]]<-summary(modeltry)
#   }
# }
# 
# models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)
# 
# #  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
# models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)
# 
# # rank the R2's of these models
# models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))
# 
# #  this is the index of the row with the highest R2 and  no negative betas in this subset
# models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j
# 
# subset(models[[modeln]]$resultspos, rank==1)
# 
# #  this is the model
# models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]
# 
# # here are the names
# models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetF_meca_LUR1)[models[[1]]$indexbestmodel], names(VGOB1_subsetF_meca_LUR1)[models[[2]]$indexbestmodel], names(VGOB1_subsetF_meca_LUR1)[models[[3]]$indexbestmodel], names(VGOB1_subsetF_meca_LUR1)[models[[4]]$indexbestmodel], names(VGOB1_subsetF_meca_LUR1)[models[[5]]$indexbestmodel])
# 
# #  this is the r2 or that model
# models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2
# 
# #  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
# models[[modeln]]$bestmodel <- lm(VGOB1_subsetF_meca_LUR1$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetF_meca_LUR1[,models[[1]]$indexbestmodel]+VGOB1_subsetF_meca_LUR1[,models[[2]]$indexbestmodel]+VGOB1_subsetF_meca_LUR1[,models[[3]]$indexbestmodel]+ VGOB1_subsetF_meca_LUR1[,models[[4]]$indexbestmodel]+ VGOB1_subsetF_meca_LUR1[,models[[5]]$indexbestmodel])
# models[[1]]$summarybestmodel
# models[[2]]$summarybestmodel
# models[[3]]$summarybestmodel
# models[[4]]$summarybestmodel
# models[[5]]$summarybestmodel
# models[[1]]$namesbestmodel
# models[[2]]$namesbestmodel
# models[[3]]$namesbestmodel
# models[[4]]$namesbestmodel
# models[[5]]$namesbestmodel
# models[[1]]$R2bestmodel
# models[[2]]$R2bestmodel
# models[[3]]$R2bestmodel
# models[[4]]$R2bestmodel
# models[[5]]$R2bestmodel

# # 6 #  
# # add sixth variable (the only difference of the above part is that now model n=6 the model statement more variables)
# #  and the call for the list of variable names in the model changed slightly
# 
# modeln<-6
# 
# models[[modeln]]<-list()
# 
# R2<-1
# addedvar<-1
# betaaddedvar<-1
# minbetas<-1
# j<-1
# 
# for (i in nfirstvar_LUR_1 :nlastvar_LUR_1){
#   if (is.numeric(VGOB1_subsetF_meca_LUR1[,i])==TRUE){
#     modeltry<-lm(VGOB1_subsetF_meca_LUR1$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetF_meca_LUR1[,models[[1]]$indexbestmodel]+VGOB1_subsetF_meca_LUR1[,models[[2]]$indexbestmodel]+VGOB1_subsetF_meca_LUR1[,models[[3]]$indexbestmodel]+VGOB1_subsetF_meca_LUR1[,models[[4]]$indexbestmodel]+VGOB1_subsetF_meca_LUR1[,models[[5]]$indexbestmodel]+ VGOB1_subsetF_meca_LUR1[,i]) 
#     R2<-rbind(R2,summary(modeltry)$adj.r.squared)
#     # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
#     betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
#     #  find out if there is a negative beta at All. The intercept does not count [-1]!
#     minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
#     # All[,i] is the row that's being tried out now. the name of that row can be found in  names(All)[i]
#     addedvar<-rbind(addedvar,names(VGOB1_subsetF_meca_LUR1)[i])
#     j<-rbind(j, i)
#     models[[modeln]][[i]]<-summary(modeltry)
#   }
# }
# 
# models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)
# 
# #  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
# models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)
# 
# # rank the R2's of these models
# models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))
# 
# #  this is the index of the row with the highest R2 and  no negative betas in this subset
# models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j
# 
# subset(models[[modeln]]$resultspos, rank==1)
# 
# # this is the model
# models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]
# 
# # here are the names
# models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetF_meca_LUR1)[models[[1]]$indexbestmodel], names(VGOB1_subsetF_meca_LUR1)[models[[2]]$indexbestmodel] , names(VGOB1_subsetF_meca_LUR1)[models[[3]]$indexbestmodel], names(VGOB1_subsetF_meca_LUR1)[models[[4]]$indexbestmodel], names(VGOB1_subsetF_meca_LUR1)[models[[5]]$indexbestmodel], names(VGOB1_subsetF_meca_LUR1)[models[[6]]$indexbestmodel])
# 
# #  this is the r2 or that model
# models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2
# 
# #  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
# models[[modeln]]$bestmodel <- lm(VGOB1_subsetF_meca_LUR1$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetF_meca_LUR1[,models[[1]]$indexbestmodel]+VGOB1_subsetF_meca_LUR1[,models[[2]]$indexbestmodel]+VGOB1_subsetF_meca_LUR1[,models[[3]]$indexbestmodel]+ VGOB1_subsetF_meca_LUR1[,models[[4]]$indexbestmodel]+ VGOB1_subsetF_meca_LUR1[,models[[5]]$indexbestmodel]+ VGOB1_subsetF_meca_LUR1[,models[[6]]$indexbestmodel]) 
# 
# models[[1]]$summarybestmodel
# models[[2]]$summarybestmodel
# models[[3]]$summarybestmodel
# models[[4]]$summarybestmodel
# models[[5]]$summarybestmodel
# models[[6]]$summarybestmodel
# models[[1]]$namesbestmodel
# models[[2]]$namesbestmodel
# models[[3]]$namesbestmodel
# models[[4]]$namesbestmodel
# models[[5]]$namesbestmodel
# models[[6]]$namesbestmodel
# models[[1]]$R2bestmodel
# models[[2]]$R2bestmodel
# models[[3]]$R2bestmodel
# models[[4]]$R2bestmodel
# models[[5]]$R2bestmodel
# models[[6]]$R2bestmodel
# 
# 
# # 7 #  
# # add seventh variable (the only difference of the above part is that now model n=7 the model statement more variables)
# #  and the call for the list of variable names in the model changed slightly
# 
# modeln<-7
# 
# models[[modeln]]<-list()
# 
# R2<-1
# addedvar<-1
# betaaddedvar<-1
# minbetas<-1
# j<-1
# 
# for (i in nfirstvar_LUR_1 :nlastvar_LUR_1){
#   if (is.numeric(VGOB1_subsetF_meca_LUR1[,i])==TRUE){
#     modeltry<-lm(VGOB1_subsetF_meca_LUR1$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetF_meca_LUR1[,models[[1]]$indexbestmodel]+VGOB1_subsetF_meca_LUR1[,models[[2]]$indexbestmodel]+VGOB1_subsetF_meca_LUR1[,models[[3]]$indexbestmodel]+VGOB1_subsetF_meca_LUR1[,models[[4]]$indexbestmodel]+VGOB1_subsetF_meca_LUR1[,models[[5]]$indexbestmodel]+VGOB1_subsetF_meca_LUR1[,models[[6]]$indexbestmodel]+ VGOB1_subsetF_meca_LUR1[,i]) 
#     R2<-rbind(R2,summary(modeltry)$adj.r.squared)
#     # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
#     betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
#     #  find out if there is a negative beta at All. The intercept does not count [-1]!
#     minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
#     # Measurements_livestockpreds_LUR1[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR1)[i]
#     addedvar<-rbind(addedvar,names(VGOB1_subsetF_meca_LUR1)[i])
#     j<-rbind(j, i)
#     models[[modeln]][[i]]<-summary(modeltry)
#   }
# }
# 
# models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)
# 
# #  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
# models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)
# 
# # rank the R2's of these models
# models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))
# 
# #  this is the index of the row with the highest R2 and  no negative betas in this subset
# models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j
# 
# subset(models[[modeln]]$resultspos, rank==1)
# 
# # this is the model
# models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]
# 
# # here are the names
# models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetF_meca_LUR1)[models[[1]]$indexbestmodel], names(VGOB1_subsetF_meca_LUR1)[models[[2]]$indexbestmodel] , names(VGOB1_subsetF_meca_LUR1)[models[[3]]$indexbestmodel], names(VGOB1_subsetF_meca_LUR1)[models[[4]]$indexbestmodel], names(VGOB1_subsetF_meca_LUR1)[models[[5]]$indexbestmodel], names(VGOB1_subsetF_meca_LUR1)[models[[6]]$indexbestmodel], names(VGOB1_subsetF_meca_LUR1)[models[[7]]$indexbestmodel])
# 
# #  this is the r2 or that model
# models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2
# 
# #  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
# models[[modeln]]$bestmodel <- lm(VGOB1_subsetF_meca_LUR1$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetF_meca_LUR1[,models[[1]]$indexbestmodel]+VGOB1_subsetF_meca_LUR1[,models[[2]]$indexbestmodel]+VGOB1_subsetF_meca_LUR1[,models[[3]]$indexbestmodel]+ VGOB1_subsetF_meca_LUR1[,models[[4]]$indexbestmodel]+ VGOB1_subsetF_meca_LUR1[,models[[5]]$indexbestmodel]+ VGOB1_subsetF_meca_LUR1[,models[[6]]$indexbestmodel]+ VGOB1_subsetF_meca_LUR1[,models[[7]]$indexbestmodel]) 
# 
# models[[1]]$summarybestmodel
# models[[2]]$summarybestmodel
# models[[3]]$summarybestmodel
# models[[4]]$summarybestmodel
# models[[5]]$summarybestmodel
# models[[6]]$summarybestmodel
# models[[7]]$summarybestmodel
# models[[1]]$namesbestmodel
# models[[2]]$namesbestmodel
# models[[3]]$namesbestmodel
# models[[4]]$namesbestmodel
# models[[5]]$namesbestmodel
# models[[6]]$namesbestmodel
# models[[7]]$namesbestmodel
# models[[1]]$R2bestmodel
# models[[2]]$R2bestmodel
# models[[3]]$R2bestmodel
# models[[4]]$R2bestmodel
# models[[5]]$R2bestmodel
# models[[6]]$R2bestmodel
# models[[7]]$R2bestmodel
# 
# # 8 #  
# # add eighth variable (the only difference of the above part is that now modeln=7 the model statement more variables)
# # and the call for the list of variable names in the model changed slightly
# 
# modeln<-8
# 
# models[[modeln]]<-list()
# 
# R2<-1
# addedvar<-1
# betaaddedvar<-1
# minbetas<-1
# j<-1
# 
# for (i in nfirstvar_LUR_1 :nlastvar_LUR_1){
#   if (is.numeric(VGOB1_subsetF_meca_LUR1[,i])==TRUE){
#     modeltry<-lm(VGOB1_subsetF_meca_LUR1$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetF_meca_LUR1[,models[[1]]$indexbestmodel]+VGOB1_subsetF_meca_LUR1[,models[[2]]$indexbestmodel]+VGOB1_subsetF_meca_LUR1[,models[[3]]$indexbestmodel]+VGOB1_subsetF_meca_LUR1[,models[[4]]$indexbestmodel]+VGOB1_subsetF_meca_LUR1[,models[[5]]$indexbestmodel]+VGOB1_subsetF_meca_LUR1[,models[[6]]$indexbestmodel]+ VGOB1_subsetF_meca_LUR1[,models[[7]]$indexbestmodel]+ VGOB1_subsetF_meca_LUR1[,i]) 
#     R2<-rbind(R2,summary(modeltry)$adj.r.squared)
#     # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
#     betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
#     #  find out if there is a negative beta at All. The intercept does not count [-1]!
#     minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
#     # Measurements_livestockpreds_LUR1[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR1)[i]
#     addedvar<-rbind(addedvar,names(VGOB1_subsetF_meca_LUR1)[i])
#     j<-rbind(j, i)
#     models[[modeln]][[i]]<-summary(modeltry)
#   }
# }
# 
# models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)
# 
# #  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
# models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)
# 
# # rank the R2's of these models
# models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))
# 
# #  this is the index of the row with the highest R2 and  no negative betas in this subset
# models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j
# 
# subset(models[[modeln]]$resultspos, rank==1)
# 
# # this is the model
# models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]
# 
# # here are the names
# models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetF_meca_LUR1)[models[[1]]$indexbestmodel], names(VGOB1_subsetF_meca_LUR1)[models[[2]]$indexbestmodel] , names(VGOB1_subsetF_meca_LUR1)[models[[3]]$indexbestmodel], names(VGOB1_subsetF_meca_LUR1)[models[[4]]$indexbestmodel], names(VGOB1_subsetF_meca_LUR1)[models[[5]]$indexbestmodel], names(VGOB1_subsetF_meca_LUR1)[models[[6]]$indexbestmodel], names(VGOB1_subsetF_meca_LUR1)[models[[7]]$indexbestmodel], names(VGOB1_subsetF_meca_LUR1)[models[[8]]$indexbestmodel])
# 
# #  this is the r2 or that model
# models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2
# 
# #  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
# models[[modeln]]$bestmodel <- lm(VGOB1_subsetF_meca_LUR1$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetF_meca_LUR1[,models[[1]]$indexbestmodel]+VGOB1_subsetF_meca_LUR1[,models[[2]]$indexbestmodel]+VGOB1_subsetF_meca_LUR1[,models[[3]]$indexbestmodel]+ VGOB1_subsetF_meca_LUR1[,models[[4]]$indexbestmodel]+ VGOB1_subsetF_meca_LUR1[,models[[5]]$indexbestmodel]+ VGOB1_subsetF_meca_LUR1[,models[[6]]$indexbestmodel]+ VGOB1_subsetF_meca_LUR1[,models[[7]]$indexbestmodel]+ VGOB1_subsetF_meca_LUR1[,models[[8]]$indexbestmodel]) 
# 
# models[[1]]$summarybestmodel
# models[[2]]$summarybestmodel
# models[[3]]$summarybestmodel
# models[[4]]$summarybestmodel
# models[[5]]$summarybestmodel
# models[[6]]$summarybestmodel
# models[[7]]$summarybestmodel
# models[[8]]$summarybestmodel
# models[[1]]$namesbestmodel
# models[[2]]$namesbestmodel
# models[[3]]$namesbestmodel
# models[[4]]$namesbestmodel
# models[[5]]$namesbestmodel
# models[[6]]$namesbestmodel
# models[[7]]$namesbestmodel
# models[[8]]$namesbestmodel
# models[[1]]$R2bestmodel
# models[[2]]$R2bestmodel
# models[[3]]$R2bestmodel
# models[[4]]$R2bestmodel
# models[[5]]$R2bestmodel
# models[[6]]$R2bestmodel
# models[[7]]$R2bestmodel
# models[[8]]$R2bestmodel

#   CODE FOR PICKING OUT THE BEST MODEL #   
temp <- 0
besti <- 0
for (i in 1:10){ #  think this runs the loop 10 times - not fully sure thought - but not to do with the number of models I don't think - as when I change to 3, I still get the model with 4 variables as best model
  print(models[[i]]$R2bestmodel)
  #       print(models[[i]]$summarybestmodel$coefficients=-1,4])
  #       if((models[[i]]$R2bestmodel-temp > 0.0) && (all(models[[i]]$summarybestmodel$coefficients[-1,4]<0.1))){
  #         temp <- models[[i]]$R2bestmodel
  #         besti <- i
  #         }
  if((models[[i]]$R2bestmodel-temp > 0.0) && (all(models[[i]]$summarybestmodel$coefficients[-1,4]<0.1))){
    temp <- models[[i]]$R2bestmodel
    besti <- i
  }else{
    finalBestModel_meca_LUR1_subsetF <- models[[besti]]$bestmodel
    finalBestModelNames_meca_subsetF <- models[[besti]]$namesbestmodel
    Sites <- 1:dim(VGOB1_subsetF_meca_LUR1)[1] # full original model
    #  CVaR2<-escCV_meca_LUR1(Sites)[2] # Cross Validation
    maxCD<-max(cooks.distance(finalBestModel_meca_LUR1_subsetF))
    if(length(finalBestModelNames_meca_subsetF)<2){ # vif fn doesnot work when only 1 variable...       # 
      maxVIF<-"NA"
    }else{
      maxVIF<-max(vif(finalBestModel_meca_LUR1_subsetF))
    }
    print(paste("This is the best meca model for subset F: ",besti,
                "(AdjR2: ",format(models[[besti]]$R2bestmodel,digits=3), "; MaxCD: ",format(maxCD,digits=3),"; MaxVIF: ",
                format(maxVIF,digits=3),")", sep=''))
    print(finalBestModelNames_meca_subsetF)
    break
  }
}

#  Overview of the final best model using the algorithm selection process (taking into account VIF, R^2, and p-values)
finalBestModel_meca_LUR1_subsetF
finalBestModelNames_meca_subsetF
models[[besti]]$summarybestmodel
models[[besti]]$R2bestmodel

#### G ####
# LUR model building process for subset G
#  This is the dataframe with the relevant predictor vars for LUR1 models for subset G (55 sites)
VGOB1_subsetG_meca_LUR1 # n.b. this dataframe only includes microbial marker concentrations for meca unlike the dataframe Measurements_livestockpreds_LUR1 as previously used for the model building. 

#  Now set the values of some variables that will be needed
nfirstvar_LUR_1 <- 3  
nlastvar_LUR_1 <- 10

# Function building to run the models 
# 1 #  

models<-list()
modeln<-1
models[[modeln]]<-list()

R2<-1
betaaddedvar<-1
addedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_1:nlastvar_LUR_1){
  if (is.numeric(VGOB1_subsetG_meca_LUR1[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetG_meca_LUR1$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetG_meca_LUR1[,i])                            
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    #  Measurements_livestockpreds_LUR1[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR1)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetG_meca_LUR1)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)
models[[modeln]]$results

#  this are the candidates models with the highest R2, not a negative beta for the new, nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)
models[[modeln]]$resultspos

#  rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))
models[[modeln]]$resultspos

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j
models[[modeln]]$indexbestmodel

subset(models[[modeln]]$resultspos, rank==1)
subset(models[[modeln]]$resultspos)

#  this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]
models[[modeln]]$summarybestmodel

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetG_meca_LUR1)[models[[1]]$indexbestmodel])
models[[modeln]]$namesbestmodel

#  this is the r2 of that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2
models[[modeln]]$R2bestmodel

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetG_meca_LUR1$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetG_meca_LUR1[,models[[1]]$indexbestmodel]) 
models[[modeln]]$bestmodel

summary(models[[modeln]]$bestmodel)

#  The first model includes the predictor: nPigMultipFarmWghtDist.3000m.sum.Tr.1P9 - meaning the number of multiplier pig farms weighted to distance in a 3000m buffer

# 2 #  
# Add 2nd variable (the only difference of the above part is that now modeln=2 the model statement has 2 variables)
# and the call for the list of variable names in the model changed slightly

modeln<-2

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_1:nlastvar_LUR_1){
  if (is.numeric(VGOB1_subsetG_meca_LUR1[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetG_meca_LUR1$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetG_meca_LUR1[,models[[1]]$indexbestmodel]+ VGOB1_subsetG_meca_LUR1[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # Measurements_livestockpreds_LUR1[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR1)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetG_meca_LUR1)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  these are the candidate models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)
models[[modeln]]$resultspos

#  rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))
models[[modeln]]$resultspos

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j
models[[modeln]]$indexbestmodel

subset(models[[modeln]]$resultspos, rank==1)

# this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]
models[[modeln]]$summarybestmodel

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetG_meca_LUR1)[models[[1]]$indexbestmodel], names(VGOB1_subsetG_meca_LUR1)[models[[2]]$indexbestmodel] )
models[[modeln]]$namesbestmodel

# this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2
models[[modeln]]$R2bestmodel

# this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetG_meca_LUR1$meca_copiespm3.ln.diffmeth.mean~                               VGOB1_subsetG_meca_LUR1[,models[[1]]$indexbestmodel]+                           VGOB1_subsetG_meca_LUR1[,models[[2]]$indexbestmodel]) 

models[[modeln]]$bestmodel

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel


# 3 #  
# add third variable (the only difference of the above part is that now modeln=3 the model statement has 3 variables)
# and the call for the list of variable names in the model changed slightly

modeln<-3

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_1:nlastvar_LUR_1){
  if (is.numeric(VGOB1_subsetG_meca_LUR1[,i])==TRUE){  
    modeltry<-lm(VGOB1_subsetG_meca_LUR1$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetG_meca_LUR1[,models[[1]]$indexbestmodel]+VGOB1_subsetG_meca_LUR1[,models[[2]]$indexbestmodel]+ VGOB1_subsetG_meca_LUR1[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # All[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR1)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetG_meca_LUR1)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

#  rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

#  this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

#  here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetG_meca_LUR1)[models[[1]]$indexbestmodel], names(VGOB1_subsetG_meca_LUR1)[models[[2]]$indexbestmodel], names(VGOB1_subsetG_meca_LUR1)[models[[3]]$indexbestmodel])

#  this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetG_meca_LUR1$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetG_meca_LUR1[,models[[1]]$indexbestmodel]+ VGOB1_subsetG_meca_LUR1[,models[[2]]$indexbestmodel]+ VGOB1_subsetG_meca_LUR1[,models[[3]]$indexbestmodel]) 

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel

# 4 #
#  add forth variable (the only difference of the above part is that now model n=4 the model statement more variables)
#  and the call for the list of variable names in the model changed slightly
modeln<-4

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1


for (i in nfirstvar_LUR_1:nlastvar_LUR_1){
  if (is.numeric(VGOB1_subsetG_meca_LUR1[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetG_meca_LUR1$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetG_meca_LUR1[,models[[1]]$indexbestmodel]+VGOB1_subsetG_meca_LUR1[,models[[2]]$indexbestmodel]+VGOB1_subsetG_meca_LUR1[,models[[3]]$indexbestmodel]+VGOB1_subsetG_meca_LUR1[,i])
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    #  the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    #  All[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR1)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetG_meca_LUR1)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

#  this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

#  here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetG_meca_LUR1)[models[[1]]$indexbestmodel], names(VGOB1_subsetG_meca_LUR1)[models[[2]]$indexbestmodel], names(VGOB1_subsetG_meca_LUR1)[models[[3]]$indexbestmodel], names(VGOB1_subsetG_meca_LUR1)[models[[4]]$indexbestmodel])

#  this is the r2 of that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetG_meca_LUR1$meca_copiespm3.ln.diffmeth.mean~ VGOB1_subsetG_meca_LUR1[,models[[1]]$indexbestmodel]+ VGOB1_subsetG_meca_LUR1[,models[[2]]$indexbestmodel]+VGOB1_subsetG_meca_LUR1[,models[[3]]$indexbestmodel]+ VGOB1_subsetG_meca_LUR1[,models[[4]]$indexbestmodel])


models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel

# The next part of the code (n=5-8) does not work
# This is because one of the coefficients included in the model with 6 variables is negative, the code does not allow for this. I can stop here.

# # 5 #
# # add fifth variable (the only difference of the above part is that now modeln=5 the model statement more variables)
# # and the call for the list of variable names in the model changed slightly
# modeln<-5
# 
# models[[modeln]]<-list()
# 
# R2<-1
# addedvar<-1
# betaaddedvar<-1
# minbetas<-1
# j<-1
# 
# for (i in nfirstvar_LUR_1:nlastvar_LUR_1){
#   if (is.numeric(VGOB1_subsetG_meca_LUR1[,i])==TRUE){
#     modeltry<-lm(VGOB1_subsetG_meca_LUR1$meca_copiespm3.ln.diffmeth.mean~ VGOB1_subsetG_meca_LUR1[,models[[1]]$indexbestmodel]+ VGOB1_subsetG_meca_LUR1[,models[[2]]$indexbestmodel]+ VGOB1_subsetG_meca_LUR1[,models[[3]]$indexbestmodel]+ VGOB1_subsetG_meca_LUR1[,models[[4]]$indexbestmodel]+ VGOB1_subsetG_meca_LUR1[,i])
# 
# R2<-rbind(R2,summary(modeltry)$adj.r.squared)
# # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
#     betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])#
#     #  find out if there is a negative beta at All. The intercept does not count [-1]!
#     minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
#     # All[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR1)[i]
#     addedvar<-rbind(addedvar,names(VGOB1_subsetG_meca_LUR1)[i])
#     j<-rbind(j, i)
#     models[[modeln]][[i]]<-summary(modeltry)
#   }
# }
# 
# models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)
# 
# #  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
# models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)
# 
# # rank the R2's of these models
# models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))
# 
# #  this is the index of the row with the highest R2 and  no negative betas in this subset
# models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j
# 
# subset(models[[modeln]]$resultspos, rank==1)
# 
# #  this is the model
# models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]
# 
# # here are the names
# models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetG_meca_LUR1)[models[[1]]$indexbestmodel], names(VGOB1_subsetG_meca_LUR1)[models[[2]]$indexbestmodel], names(VGOB1_subsetG_meca_LUR1)[models[[3]]$indexbestmodel], names(VGOB1_subsetG_meca_LUR1)[models[[4]]$indexbestmodel], names(VGOB1_subsetG_meca_LUR1)[models[[5]]$indexbestmodel])
# 
# #  this is the r2 or that model
# models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2
# 
# #  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
# models[[modeln]]$bestmodel <- lm(VGOB1_subsetG_meca_LUR1$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetG_meca_LUR1[,models[[1]]$indexbestmodel]+VGOB1_subsetG_meca_LUR1[,models[[2]]$indexbestmodel]+VGOB1_subsetG_meca_LUR1[,models[[3]]$indexbestmodel]+ VGOB1_subsetG_meca_LUR1[,models[[4]]$indexbestmodel]+ VGOB1_subsetG_meca_LUR1[,models[[5]]$indexbestmodel])
# models[[1]]$summarybestmodel
# models[[2]]$summarybestmodel
# models[[3]]$summarybestmodel
# models[[4]]$summarybestmodel
# models[[5]]$summarybestmodel
# models[[1]]$namesbestmodel
# models[[2]]$namesbestmodel
# models[[3]]$namesbestmodel
# models[[4]]$namesbestmodel
# models[[5]]$namesbestmodel
# models[[1]]$R2bestmodel
# models[[2]]$R2bestmodel
# models[[3]]$R2bestmodel
# models[[4]]$R2bestmodel
# models[[5]]$R2bestmodel

# # 6 #  
# # add sixth variable (the only difference of the above part is that now model n=6 the model statement more variables)
# #  and the call for the list of variable names in the model changed slightly
# 
# modeln<-6
# 
# models[[modeln]]<-list()
# 
# R2<-1
# addedvar<-1
# betaaddedvar<-1
# minbetas<-1
# j<-1
# 
# for (i in nfirstvar_LUR_1 :nlastvar_LUR_1){
#   if (is.numeric(VGOB1_subsetG_meca_LUR1[,i])==TRUE){
#     modeltry<-lm(VGOB1_subsetG_meca_LUR1$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetG_meca_LUR1[,models[[1]]$indexbestmodel]+VGOB1_subsetG_meca_LUR1[,models[[2]]$indexbestmodel]+VGOB1_subsetG_meca_LUR1[,models[[3]]$indexbestmodel]+VGOB1_subsetG_meca_LUR1[,models[[4]]$indexbestmodel]+VGOB1_subsetG_meca_LUR1[,models[[5]]$indexbestmodel]+ VGOB1_subsetG_meca_LUR1[,i]) 
#     R2<-rbind(R2,summary(modeltry)$adj.r.squared)
#     # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
#     betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
#     #  find out if there is a negative beta at All. The intercept does not count [-1]!
#     minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
#     # All[,i] is the row that's being tried out now. the name of that row can be found in  names(All)[i]
#     addedvar<-rbind(addedvar,names(VGOB1_subsetG_meca_LUR1)[i])
#     j<-rbind(j, i)
#     models[[modeln]][[i]]<-summary(modeltry)
#   }
# }
# 
# models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)
# 
# #  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
# models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)
# 
# # rank the R2's of these models
# models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))
# 
# #  this is the index of the row with the highest R2 and  no negative betas in this subset
# models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j
# 
# subset(models[[modeln]]$resultspos, rank==1)
# 
# # this is the model
# models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]
# 
# # here are the names
# models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetG_meca_LUR1)[models[[1]]$indexbestmodel], names(VGOB1_subsetG_meca_LUR1)[models[[2]]$indexbestmodel] , names(VGOB1_subsetG_meca_LUR1)[models[[3]]$indexbestmodel], names(VGOB1_subsetG_meca_LUR1)[models[[4]]$indexbestmodel], names(VGOB1_subsetG_meca_LUR1)[models[[5]]$indexbestmodel], names(VGOB1_subsetG_meca_LUR1)[models[[6]]$indexbestmodel])
# 
# #  this is the r2 or that model
# models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2
# 
# #  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
# models[[modeln]]$bestmodel <- lm(VGOB1_subsetG_meca_LUR1$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetG_meca_LUR1[,models[[1]]$indexbestmodel]+VGOB1_subsetG_meca_LUR1[,models[[2]]$indexbestmodel]+VGOB1_subsetG_meca_LUR1[,models[[3]]$indexbestmodel]+ VGOB1_subsetG_meca_LUR1[,models[[4]]$indexbestmodel]+ VGOB1_subsetG_meca_LUR1[,models[[5]]$indexbestmodel]+ VGOB1_subsetG_meca_LUR1[,models[[6]]$indexbestmodel]) 
# 
# models[[1]]$summarybestmodel
# models[[2]]$summarybestmodel
# models[[3]]$summarybestmodel
# models[[4]]$summarybestmodel
# models[[5]]$summarybestmodel
# models[[6]]$summarybestmodel
# models[[1]]$namesbestmodel
# models[[2]]$namesbestmodel
# models[[3]]$namesbestmodel
# models[[4]]$namesbestmodel
# models[[5]]$namesbestmodel
# models[[6]]$namesbestmodel
# models[[1]]$R2bestmodel
# models[[2]]$R2bestmodel
# models[[3]]$R2bestmodel
# models[[4]]$R2bestmodel
# models[[5]]$R2bestmodel
# models[[6]]$R2bestmodel
# 
# 
# # 7 #  
# # add seventh variable (the only difference of the above part is that now model n=7 the model statement more variables)
# #  and the call for the list of variable names in the model changed slightly
# 
# modeln<-7
# 
# models[[modeln]]<-list()
# 
# R2<-1
# addedvar<-1
# betaaddedvar<-1
# minbetas<-1
# j<-1
# 
# for (i in nfirstvar_LUR_1 :nlastvar_LUR_1){
#   if (is.numeric(VGOB1_subsetG_meca_LUR1[,i])==TRUE){
#     modeltry<-lm(VGOB1_subsetG_meca_LUR1$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetG_meca_LUR1[,models[[1]]$indexbestmodel]+VGOB1_subsetG_meca_LUR1[,models[[2]]$indexbestmodel]+VGOB1_subsetG_meca_LUR1[,models[[3]]$indexbestmodel]+VGOB1_subsetG_meca_LUR1[,models[[4]]$indexbestmodel]+VGOB1_subsetG_meca_LUR1[,models[[5]]$indexbestmodel]+VGOB1_subsetG_meca_LUR1[,models[[6]]$indexbestmodel]+ VGOB1_subsetG_meca_LUR1[,i]) 
#     R2<-rbind(R2,summary(modeltry)$adj.r.squared)
#     # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
#     betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
#     #  find out if there is a negative beta at All. The intercept does not count [-1]!
#     minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
#     # Measurements_livestockpreds_LUR1[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR1)[i]
#     addedvar<-rbind(addedvar,names(VGOB1_subsetG_meca_LUR1)[i])
#     j<-rbind(j, i)
#     models[[modeln]][[i]]<-summary(modeltry)
#   }
# }
# 
# models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)
# 
# #  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
# models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)
# 
# # rank the R2's of these models
# models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))
# 
# #  this is the index of the row with the highest R2 and  no negative betas in this subset
# models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j
# 
# subset(models[[modeln]]$resultspos, rank==1)
# 
# # this is the model
# models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]
# 
# # here are the names
# models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetG_meca_LUR1)[models[[1]]$indexbestmodel], names(VGOB1_subsetG_meca_LUR1)[models[[2]]$indexbestmodel] , names(VGOB1_subsetG_meca_LUR1)[models[[3]]$indexbestmodel], names(VGOB1_subsetG_meca_LUR1)[models[[4]]$indexbestmodel], names(VGOB1_subsetG_meca_LUR1)[models[[5]]$indexbestmodel], names(VGOB1_subsetG_meca_LUR1)[models[[6]]$indexbestmodel], names(VGOB1_subsetG_meca_LUR1)[models[[7]]$indexbestmodel])
# 
# #  this is the r2 or that model
# models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2
# 
# #  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
# models[[modeln]]$bestmodel <- lm(VGOB1_subsetG_meca_LUR1$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetG_meca_LUR1[,models[[1]]$indexbestmodel]+VGOB1_subsetG_meca_LUR1[,models[[2]]$indexbestmodel]+VGOB1_subsetG_meca_LUR1[,models[[3]]$indexbestmodel]+ VGOB1_subsetG_meca_LUR1[,models[[4]]$indexbestmodel]+ VGOB1_subsetG_meca_LUR1[,models[[5]]$indexbestmodel]+ VGOB1_subsetG_meca_LUR1[,models[[6]]$indexbestmodel]+ VGOB1_subsetG_meca_LUR1[,models[[7]]$indexbestmodel]) 
# 
# models[[1]]$summarybestmodel
# models[[2]]$summarybestmodel
# models[[3]]$summarybestmodel
# models[[4]]$summarybestmodel
# models[[5]]$summarybestmodel
# models[[6]]$summarybestmodel
# models[[7]]$summarybestmodel
# models[[1]]$namesbestmodel
# models[[2]]$namesbestmodel
# models[[3]]$namesbestmodel
# models[[4]]$namesbestmodel
# models[[5]]$namesbestmodel
# models[[6]]$namesbestmodel
# models[[7]]$namesbestmodel
# models[[1]]$R2bestmodel
# models[[2]]$R2bestmodel
# models[[3]]$R2bestmodel
# models[[4]]$R2bestmodel
# models[[5]]$R2bestmodel
# models[[6]]$R2bestmodel
# models[[7]]$R2bestmodel
# 
# # 8 #  
# # add eighth variable (the only difference of the above part is that now modeln=7 the model statement more variables)
# # and the call for the list of variable names in the model changed slightly
# 
# modeln<-8
# 
# models[[modeln]]<-list()
# 
# R2<-1
# addedvar<-1
# betaaddedvar<-1
# minbetas<-1
# j<-1
# 
# for (i in nfirstvar_LUR_1 :nlastvar_LUR_1){
#   if (is.numeric(VGOB1_subsetG_meca_LUR1[,i])==TRUE){
#     modeltry<-lm(VGOB1_subsetG_meca_LUR1$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetG_meca_LUR1[,models[[1]]$indexbestmodel]+VGOB1_subsetG_meca_LUR1[,models[[2]]$indexbestmodel]+VGOB1_subsetG_meca_LUR1[,models[[3]]$indexbestmodel]+VGOB1_subsetG_meca_LUR1[,models[[4]]$indexbestmodel]+VGOB1_subsetG_meca_LUR1[,models[[5]]$indexbestmodel]+VGOB1_subsetG_meca_LUR1[,models[[6]]$indexbestmodel]+ VGOB1_subsetG_meca_LUR1[,models[[7]]$indexbestmodel]+ VGOB1_subsetG_meca_LUR1[,i]) 
#     R2<-rbind(R2,summary(modeltry)$adj.r.squared)
#     # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
#     betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
#     #  find out if there is a negative beta at All. The intercept does not count [-1]!
#     minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
#     # Measurements_livestockpreds_LUR1[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR1)[i]
#     addedvar<-rbind(addedvar,names(VGOB1_subsetG_meca_LUR1)[i])
#     j<-rbind(j, i)
#     models[[modeln]][[i]]<-summary(modeltry)
#   }
# }
# 
# models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)
# 
# #  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
# models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)
# 
# # rank the R2's of these models
# models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))
# 
# #  this is the index of the row with the highest R2 and  no negative betas in this subset
# models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j
# 
# subset(models[[modeln]]$resultspos, rank==1)
# 
# # this is the model
# models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]
# 
# # here are the names
# models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetG_meca_LUR1)[models[[1]]$indexbestmodel], names(VGOB1_subsetG_meca_LUR1)[models[[2]]$indexbestmodel] , names(VGOB1_subsetG_meca_LUR1)[models[[3]]$indexbestmodel], names(VGOB1_subsetG_meca_LUR1)[models[[4]]$indexbestmodel], names(VGOB1_subsetG_meca_LUR1)[models[[5]]$indexbestmodel], names(VGOB1_subsetG_meca_LUR1)[models[[6]]$indexbestmodel], names(VGOB1_subsetG_meca_LUR1)[models[[7]]$indexbestmodel], names(VGOB1_subsetG_meca_LUR1)[models[[8]]$indexbestmodel])
# 
# #  this is the r2 or that model
# models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2
# 
# #  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
# models[[modeln]]$bestmodel <- lm(VGOB1_subsetG_meca_LUR1$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetG_meca_LUR1[,models[[1]]$indexbestmodel]+VGOB1_subsetG_meca_LUR1[,models[[2]]$indexbestmodel]+VGOB1_subsetG_meca_LUR1[,models[[3]]$indexbestmodel]+ VGOB1_subsetG_meca_LUR1[,models[[4]]$indexbestmodel]+ VGOB1_subsetG_meca_LUR1[,models[[5]]$indexbestmodel]+ VGOB1_subsetG_meca_LUR1[,models[[6]]$indexbestmodel]+ VGOB1_subsetG_meca_LUR1[,models[[7]]$indexbestmodel]+ VGOB1_subsetG_meca_LUR1[,models[[8]]$indexbestmodel]) 
# 
# models[[1]]$summarybestmodel
# models[[2]]$summarybestmodel
# models[[3]]$summarybestmodel
# models[[4]]$summarybestmodel
# models[[5]]$summarybestmodel
# models[[6]]$summarybestmodel
# models[[7]]$summarybestmodel
# models[[8]]$summarybestmodel
# models[[1]]$namesbestmodel
# models[[2]]$namesbestmodel
# models[[3]]$namesbestmodel
# models[[4]]$namesbestmodel
# models[[5]]$namesbestmodel
# models[[6]]$namesbestmodel
# models[[7]]$namesbestmodel
# models[[8]]$namesbestmodel
# models[[1]]$R2bestmodel
# models[[2]]$R2bestmodel
# models[[3]]$R2bestmodel
# models[[4]]$R2bestmodel
# models[[5]]$R2bestmodel
# models[[6]]$R2bestmodel
# models[[7]]$R2bestmodel
# models[[8]]$R2bestmodel

#   CODE FOR PICKING OUT THE BEST MODEL #   
temp <- 0
besti <- 0
for (i in 1:10){ #  think this runs the loop 10 times - not fully sure thought - but not to do with the number of models I don't think - as when I change to 3, I still get the model with 4 variables as best model
  print(models[[i]]$R2bestmodel)
  #       print(models[[i]]$summarybestmodel$coefficients=-1,4])
  #       if((models[[i]]$R2bestmodel-temp > 0.0) && (all(models[[i]]$summarybestmodel$coefficients[-1,4]<0.1))){
  #         temp <- models[[i]]$R2bestmodel
  #         besti <- i
  #         }
  if((models[[i]]$R2bestmodel-temp > 0.0) && (all(models[[i]]$summarybestmodel$coefficients[-1,4]<0.1))){
    temp <- models[[i]]$R2bestmodel
    besti <- i
  }else{
    finalBestModel_meca_LUR1_subsetG <- models[[besti]]$bestmodel
    finalBestModelNames_meca_subsetG <- models[[besti]]$namesbestmodel
    Sites <- 1:dim(VGOB1_subsetG_meca_LUR1)[1] # full original model
    #  CVaR2<-escCV_meca_LUR1(Sites)[2] # Cross Validation
    maxCD<-max(cooks.distance(finalBestModel_meca_LUR1_subsetG))
    if(length(finalBestModelNames_meca_subsetG)<2){ # vif fn doesnot work when only 1 variable...       # 
      maxVIF<-"NA"
    }else{
      maxVIF<-max(vif(finalBestModel_meca_LUR1_subsetG))
    }
    print(paste("This is the best meca model for subset G: ",besti,
                "(AdjR2: ",format(models[[besti]]$R2bestmodel,digits=3), "; MaxCD: ",format(maxCD,digits=3),"; MaxVIF: ",
                format(maxVIF,digits=3),")", sep=''))
    print(finalBestModelNames_meca_subsetG)
    break
  }
}

#  Overview of the final best model using the algorithm selection process (taking into account VIF, R^2, and p-values)
finalBestModel_meca_LUR1_subsetG
finalBestModelNames_meca_subsetG
models[[besti]]$summarybestmodel
models[[besti]]$R2bestmodel

#### H ####
# LUR model building process for subset H
#  This is the dataframe with the relevant predictor vars for LUR1 models for subset H (55 sites)
VGOB1_subsetH_meca_LUR1 # n.b. this dataframe only includes microbial marker concentrations for meca unlike the dataframe Measurements_livestockpreds_LUR1 as previously used for the model building. 

#  Now set the values of some variables that will be needed
nfirstvar_LUR_1 <- 3  
nlastvar_LUR_1 <- 10

# Function building to run the models 
# 1 #  

models<-list()
modeln<-1
models[[modeln]]<-list()

R2<-1
betaaddedvar<-1
addedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_1:nlastvar_LUR_1){
  if (is.numeric(VGOB1_subsetH_meca_LUR1[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetH_meca_LUR1$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetH_meca_LUR1[,i])                            
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    #  Measurements_livestockpreds_LUR1[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR1)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetH_meca_LUR1)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)
models[[modeln]]$results

#  this are the candidates models with the highest R2, not a negative beta for the new, nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)
models[[modeln]]$resultspos

#  rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))
models[[modeln]]$resultspos

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j
models[[modeln]]$indexbestmodel

subset(models[[modeln]]$resultspos, rank==1)
subset(models[[modeln]]$resultspos)

#  this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]
models[[modeln]]$summarybestmodel

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetH_meca_LUR1)[models[[1]]$indexbestmodel])
models[[modeln]]$namesbestmodel

#  this is the r2 of that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2
models[[modeln]]$R2bestmodel

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetH_meca_LUR1$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetH_meca_LUR1[,models[[1]]$indexbestmodel]) 
models[[modeln]]$bestmodel

summary(models[[modeln]]$bestmodel)

#  The first model includes the predictor: nPigMultipFarmWghtDist.3000m.sum.Tr.1P9 - meaning the number of multiplier pig farms weighted to distance in a 3000m buffer

# 2 #  
# Add 2nd variable (the only difference of the above part is that now modeln=2 the model statement has 2 variables)
# and the call for the list of variable names in the model changed slightly

modeln<-2

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_1:nlastvar_LUR_1){
  if (is.numeric(VGOB1_subsetH_meca_LUR1[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetH_meca_LUR1$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetH_meca_LUR1[,models[[1]]$indexbestmodel]+ VGOB1_subsetH_meca_LUR1[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # Measurements_livestockpreds_LUR1[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR1)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetH_meca_LUR1)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  these are the candidate models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)
models[[modeln]]$resultspos

#  rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))
models[[modeln]]$resultspos

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j
models[[modeln]]$indexbestmodel

subset(models[[modeln]]$resultspos, rank==1)

# this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]
models[[modeln]]$summarybestmodel

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetH_meca_LUR1)[models[[1]]$indexbestmodel], names(VGOB1_subsetH_meca_LUR1)[models[[2]]$indexbestmodel] )
models[[modeln]]$namesbestmodel

# this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2
models[[modeln]]$R2bestmodel

# this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetH_meca_LUR1$meca_copiespm3.ln.diffmeth.mean~                               VGOB1_subsetH_meca_LUR1[,models[[1]]$indexbestmodel]+                           VGOB1_subsetH_meca_LUR1[,models[[2]]$indexbestmodel]) 

models[[modeln]]$bestmodel

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel


# 3 #  
# add third variable (the only difference of the above part is that now modeln=3 the model statement has 3 variables)
# and the call for the list of variable names in the model changed slightly

modeln<-3

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_1:nlastvar_LUR_1){
  if (is.numeric(VGOB1_subsetH_meca_LUR1[,i])==TRUE){  
    modeltry<-lm(VGOB1_subsetH_meca_LUR1$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetH_meca_LUR1[,models[[1]]$indexbestmodel]+VGOB1_subsetH_meca_LUR1[,models[[2]]$indexbestmodel]+ VGOB1_subsetH_meca_LUR1[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # All[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR1)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetH_meca_LUR1)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

#  rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

#  this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

#  here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetH_meca_LUR1)[models[[1]]$indexbestmodel], names(VGOB1_subsetH_meca_LUR1)[models[[2]]$indexbestmodel], names(VGOB1_subsetH_meca_LUR1)[models[[3]]$indexbestmodel])

#  this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetH_meca_LUR1$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetH_meca_LUR1[,models[[1]]$indexbestmodel]+ VGOB1_subsetH_meca_LUR1[,models[[2]]$indexbestmodel]+ VGOB1_subsetH_meca_LUR1[,models[[3]]$indexbestmodel]) 

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel

# The next part of the code (n=4-8) does not work
# This is because one of the coefficients included in the model with 6 variables is negative, the code does not allow for this. I can stop here.

# # 4 #
# #  add forth variable (the only difference of the above part is that now model n=4 the model statement more variables)
# #  and the call for the list of variable names in the model changed slightly
# modeln<-4
# 
# models[[modeln]]<-list()
# 
# R2<-1
# addedvar<-1
# betaaddedvar<-1
# minbetas<-1
# j<-1
# 
# 
# for (i in nfirstvar_LUR_1:nlastvar_LUR_1){
#   if (is.numeric(VGOB1_subsetH_meca_LUR1[,i])==TRUE){
#     modeltry<-lm(VGOB1_subsetH_meca_LUR1$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetH_meca_LUR1[,models[[1]]$indexbestmodel]+VGOB1_subsetH_meca_LUR1[,models[[2]]$indexbestmodel]+VGOB1_subsetH_meca_LUR1[,models[[3]]$indexbestmodel]+VGOB1_subsetH_meca_LUR1[,i])
#     R2<-rbind(R2,summary(modeltry)$adj.r.squared)
#     #  the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
#     betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])
#     #  find out if there is a negative beta at All. The intercept does not count [-1]!
#     minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
#     #  All[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR1)[i]
#     addedvar<-rbind(addedvar,names(VGOB1_subsetH_meca_LUR1)[i])
#     j<-rbind(j, i)
#     models[[modeln]][[i]]<-summary(modeltry)
#   }
# }
# 
# models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)
# 
# #  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
# models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)
# 
# # rank the R2's of these models
# models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))
# 
# #  this is the index of the row with the highest R2 and  no negative betas in this subset
# models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j
# 
# subset(models[[modeln]]$resultspos, rank==1)
# 
# #  this is the model
# models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]
# 
# #  here are the names
# models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetH_meca_LUR1)[models[[1]]$indexbestmodel], names(VGOB1_subsetH_meca_LUR1)[models[[2]]$indexbestmodel], names(VGOB1_subsetH_meca_LUR1)[models[[3]]$indexbestmodel], names(VGOB1_subsetH_meca_LUR1)[models[[4]]$indexbestmodel])
# 
# #  this is the r2 of that model
# models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2
# 
# #  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
# models[[modeln]]$bestmodel <- lm(VGOB1_subsetH_meca_LUR1$meca_copiespm3.ln.diffmeth.mean~ VGOB1_subsetH_meca_LUR1[,models[[1]]$indexbestmodel]+ VGOB1_subsetH_meca_LUR1[,models[[2]]$indexbestmodel]+VGOB1_subsetH_meca_LUR1[,models[[3]]$indexbestmodel]+ VGOB1_subsetH_meca_LUR1[,models[[4]]$indexbestmodel])
# 
# 
# models[[1]]$summarybestmodel
# models[[2]]$summarybestmodel
# models[[3]]$summarybestmodel
# models[[4]]$summarybestmodel
# models[[1]]$namesbestmodel
# models[[2]]$namesbestmodel
# models[[3]]$namesbestmodel
# models[[4]]$namesbestmodel
# models[[1]]$R2bestmodel
# models[[2]]$R2bestmodel
# models[[3]]$R2bestmodel
# models[[4]]$R2bestmodel

# 
# # 5 #  
# # add fifth variable (the only difference of the above part is that now modeln=5 the model statement more variables)
# # and the call for the list of variable names in the model changed slightly
# modeln<-5
# 
# models[[modeln]]<-list()
# 
# R2<-1
# addedvar<-1
# betaaddedvar<-1
# minbetas<-1
# j<-1
# 
# for (i in nfirstvar_LUR_1:nlastvar_LUR_1){
#   if (is.numeric(VGOB1_subsetH_meca_LUR1[,i])==TRUE){
#     modeltry<-lm(VGOB1_subsetH_meca_LUR1$meca_copiespm3.ln.diffmeth.mean~ VGOB1_subsetH_meca_LUR1[,models[[1]]$indexbestmodel]+ VGOB1_subsetH_meca_LUR1[,models[[2]]$indexbestmodel]+ VGOB1_subsetH_meca_LUR1[,models[[3]]$indexbestmodel]+ VGOB1_subsetH_meca_LUR1[,models[[4]]$indexbestmodel]+ VGOB1_subsetH_meca_LUR1[,i]) 
#   
# R2<-rbind(R2,summary(modeltry)$adj.r.squared)
# # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
#     betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
#     #  find out if there is a negative beta at All. The intercept does not count [-1]!
#     minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
#     # All[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR1)[i]
#     addedvar<-rbind(addedvar,names(VGOB1_subsetH_meca_LUR1)[i])
#     j<-rbind(j, i)
#     models[[modeln]][[i]]<-summary(modeltry)
#   }
# }
# 
# models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)
# 
# #  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
# models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)
# 
# # rank the R2's of these models
# models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))
# 
# #  this is the index of the row with the highest R2 and  no negative betas in this subset
# models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j
# 
# subset(models[[modeln]]$resultspos, rank==1)
# 
# #  this is the model
# models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]
# 
# # here are the names
# models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetH_meca_LUR1)[models[[1]]$indexbestmodel], names(VGOB1_subsetH_meca_LUR1)[models[[2]]$indexbestmodel], names(VGOB1_subsetH_meca_LUR1)[models[[3]]$indexbestmodel], names(VGOB1_subsetH_meca_LUR1)[models[[4]]$indexbestmodel], names(VGOB1_subsetH_meca_LUR1)[models[[5]]$indexbestmodel])
# 
# #  this is the r2 or that model
# models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2
# 
# #  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
# models[[modeln]]$bestmodel <- lm(VGOB1_subsetH_meca_LUR1$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetH_meca_LUR1[,models[[1]]$indexbestmodel]+VGOB1_subsetH_meca_LUR1[,models[[2]]$indexbestmodel]+VGOB1_subsetH_meca_LUR1[,models[[3]]$indexbestmodel]+ VGOB1_subsetH_meca_LUR1[,models[[4]]$indexbestmodel]+ VGOB1_subsetH_meca_LUR1[,models[[5]]$indexbestmodel]) 
# models[[1]]$summarybestmodel
# models[[2]]$summarybestmodel
# models[[3]]$summarybestmodel
# models[[4]]$summarybestmodel
# models[[5]]$summarybestmodel
# models[[1]]$namesbestmodel
# models[[2]]$namesbestmodel
# models[[3]]$namesbestmodel
# models[[4]]$namesbestmodel
# models[[5]]$namesbestmodel
# models[[1]]$R2bestmodel
# models[[2]]$R2bestmodel
# models[[3]]$R2bestmodel
# models[[4]]$R2bestmodel
# models[[5]]$R2bestmodel
# 
# # 6 #  
# # add sixth variable (the only difference of the above part is that now model n=6 the model statement more variables)
# #  and the call for the list of variable names in the model changed slightly
# 
# modeln<-6
# 
# models[[modeln]]<-list()
# 
# R2<-1
# addedvar<-1
# betaaddedvar<-1
# minbetas<-1
# j<-1
# 
# for (i in nfirstvar_LUR_1 :nlastvar_LUR_1){
#   if (is.numeric(VGOB1_subsetH_meca_LUR1[,i])==TRUE){
#     modeltry<-lm(VGOB1_subsetH_meca_LUR1$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetH_meca_LUR1[,models[[1]]$indexbestmodel]+VGOB1_subsetH_meca_LUR1[,models[[2]]$indexbestmodel]+VGOB1_subsetH_meca_LUR1[,models[[3]]$indexbestmodel]+VGOB1_subsetH_meca_LUR1[,models[[4]]$indexbestmodel]+VGOB1_subsetH_meca_LUR1[,models[[5]]$indexbestmodel]+ VGOB1_subsetH_meca_LUR1[,i]) 
#     R2<-rbind(R2,summary(modeltry)$adj.r.squared)
#     # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
#     betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
#     #  find out if there is a negative beta at All. The intercept does not count [-1]!
#     minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
#     # All[,i] is the row that's being tried out now. the name of that row can be found in  names(All)[i]
#     addedvar<-rbind(addedvar,names(VGOB1_subsetH_meca_LUR1)[i])
#     j<-rbind(j, i)
#     models[[modeln]][[i]]<-summary(modeltry)
#   }
# }
# 
# models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)
# 
# #  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
# models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)
# 
# # rank the R2's of these models
# models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))
# 
# #  this is the index of the row with the highest R2 and  no negative betas in this subset
# models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j
# 
# subset(models[[modeln]]$resultspos, rank==1)
# 
# # this is the model
# models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]
# 
# # here are the names
# models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetH_meca_LUR1)[models[[1]]$indexbestmodel], names(VGOB1_subsetH_meca_LUR1)[models[[2]]$indexbestmodel] , names(VGOB1_subsetH_meca_LUR1)[models[[3]]$indexbestmodel], names(VGOB1_subsetH_meca_LUR1)[models[[4]]$indexbestmodel], names(VGOB1_subsetH_meca_LUR1)[models[[5]]$indexbestmodel], names(VGOB1_subsetH_meca_LUR1)[models[[6]]$indexbestmodel])
# 
# #  this is the r2 or that model
# models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2
# 
# #  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
# models[[modeln]]$bestmodel <- lm(VGOB1_subsetH_meca_LUR1$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetH_meca_LUR1[,models[[1]]$indexbestmodel]+VGOB1_subsetH_meca_LUR1[,models[[2]]$indexbestmodel]+VGOB1_subsetH_meca_LUR1[,models[[3]]$indexbestmodel]+ VGOB1_subsetH_meca_LUR1[,models[[4]]$indexbestmodel]+ VGOB1_subsetH_meca_LUR1[,models[[5]]$indexbestmodel]+ VGOB1_subsetH_meca_LUR1[,models[[6]]$indexbestmodel]) 
# 
# models[[1]]$summarybestmodel
# models[[2]]$summarybestmodel
# models[[3]]$summarybestmodel
# models[[4]]$summarybestmodel
# models[[5]]$summarybestmodel
# models[[6]]$summarybestmodel
# models[[1]]$namesbestmodel
# models[[2]]$namesbestmodel
# models[[3]]$namesbestmodel
# models[[4]]$namesbestmodel
# models[[5]]$namesbestmodel
# models[[6]]$namesbestmodel
# models[[1]]$R2bestmodel
# models[[2]]$R2bestmodel
# models[[3]]$R2bestmodel
# models[[4]]$R2bestmodel
# models[[5]]$R2bestmodel
# models[[6]]$R2bestmodel
# 
# 
# # 7 #  
# # add seventh variable (the only difference of the above part is that now model n=7 the model statement more variables)
# #  and the call for the list of variable names in the model changed slightly
# 
# modeln<-7
# 
# models[[modeln]]<-list()
# 
# R2<-1
# addedvar<-1
# betaaddedvar<-1
# minbetas<-1
# j<-1
# 
# for (i in nfirstvar_LUR_1 :nlastvar_LUR_1){
#   if (is.numeric(VGOB1_subsetH_meca_LUR1[,i])==TRUE){
#     modeltry<-lm(VGOB1_subsetH_meca_LUR1$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetH_meca_LUR1[,models[[1]]$indexbestmodel]+VGOB1_subsetH_meca_LUR1[,models[[2]]$indexbestmodel]+VGOB1_subsetH_meca_LUR1[,models[[3]]$indexbestmodel]+VGOB1_subsetH_meca_LUR1[,models[[4]]$indexbestmodel]+VGOB1_subsetH_meca_LUR1[,models[[5]]$indexbestmodel]+VGOB1_subsetH_meca_LUR1[,models[[6]]$indexbestmodel]+ VGOB1_subsetH_meca_LUR1[,i]) 
#     R2<-rbind(R2,summary(modeltry)$adj.r.squared)
#     # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
#     betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
#     #  find out if there is a negative beta at All. The intercept does not count [-1]!
#     minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
#     # Measurements_livestockpreds_LUR1[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR1)[i]
#     addedvar<-rbind(addedvar,names(VGOB1_subsetH_meca_LUR1)[i])
#     j<-rbind(j, i)
#     models[[modeln]][[i]]<-summary(modeltry)
#   }
# }
# 
# models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)
# 
# #  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
# models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)
# 
# # rank the R2's of these models
# models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))
# 
# #  this is the index of the row with the highest R2 and  no negative betas in this subset
# models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j
# 
# subset(models[[modeln]]$resultspos, rank==1)
# 
# # this is the model
# models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]
# 
# # here are the names
# models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetH_meca_LUR1)[models[[1]]$indexbestmodel], names(VGOB1_subsetH_meca_LUR1)[models[[2]]$indexbestmodel] , names(VGOB1_subsetH_meca_LUR1)[models[[3]]$indexbestmodel], names(VGOB1_subsetH_meca_LUR1)[models[[4]]$indexbestmodel], names(VGOB1_subsetH_meca_LUR1)[models[[5]]$indexbestmodel], names(VGOB1_subsetH_meca_LUR1)[models[[6]]$indexbestmodel], names(VGOB1_subsetH_meca_LUR1)[models[[7]]$indexbestmodel])
# 
# #  this is the r2 or that model
# models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2
# 
# #  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
# models[[modeln]]$bestmodel <- lm(VGOB1_subsetH_meca_LUR1$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetH_meca_LUR1[,models[[1]]$indexbestmodel]+VGOB1_subsetH_meca_LUR1[,models[[2]]$indexbestmodel]+VGOB1_subsetH_meca_LUR1[,models[[3]]$indexbestmodel]+ VGOB1_subsetH_meca_LUR1[,models[[4]]$indexbestmodel]+ VGOB1_subsetH_meca_LUR1[,models[[5]]$indexbestmodel]+ VGOB1_subsetH_meca_LUR1[,models[[6]]$indexbestmodel]+ VGOB1_subsetH_meca_LUR1[,models[[7]]$indexbestmodel]) 
# 
# models[[1]]$summarybestmodel
# models[[2]]$summarybestmodel
# models[[3]]$summarybestmodel
# models[[4]]$summarybestmodel
# models[[5]]$summarybestmodel
# models[[6]]$summarybestmodel
# models[[7]]$summarybestmodel
# models[[1]]$namesbestmodel
# models[[2]]$namesbestmodel
# models[[3]]$namesbestmodel
# models[[4]]$namesbestmodel
# models[[5]]$namesbestmodel
# models[[6]]$namesbestmodel
# models[[7]]$namesbestmodel
# models[[1]]$R2bestmodel
# models[[2]]$R2bestmodel
# models[[3]]$R2bestmodel
# models[[4]]$R2bestmodel
# models[[5]]$R2bestmodel
# models[[6]]$R2bestmodel
# models[[7]]$R2bestmodel
# 
# # 8 #  
# # add eighth variable (the only difference of the above part is that now modeln=7 the model statement more variables)
# # and the call for the list of variable names in the model changed slightly
# 
# modeln<-8
# 
# models[[modeln]]<-list()
# 
# R2<-1
# addedvar<-1
# betaaddedvar<-1
# minbetas<-1
# j<-1
# 
# for (i in nfirstvar_LUR_1 :nlastvar_LUR_1){
#   if (is.numeric(VGOB1_subsetH_meca_LUR1[,i])==TRUE){
#     modeltry<-lm(VGOB1_subsetH_meca_LUR1$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetH_meca_LUR1[,models[[1]]$indexbestmodel]+VGOB1_subsetH_meca_LUR1[,models[[2]]$indexbestmodel]+VGOB1_subsetH_meca_LUR1[,models[[3]]$indexbestmodel]+VGOB1_subsetH_meca_LUR1[,models[[4]]$indexbestmodel]+VGOB1_subsetH_meca_LUR1[,models[[5]]$indexbestmodel]+VGOB1_subsetH_meca_LUR1[,models[[6]]$indexbestmodel]+ VGOB1_subsetH_meca_LUR1[,models[[7]]$indexbestmodel]+ VGOB1_subsetH_meca_LUR1[,i]) 
#     R2<-rbind(R2,summary(modeltry)$adj.r.squared)
#     # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
#     betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
#     #  find out if there is a negative beta at All. The intercept does not count [-1]!
#     minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
#     # Measurements_livestockpreds_LUR1[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR1)[i]
#     addedvar<-rbind(addedvar,names(VGOB1_subsetH_meca_LUR1)[i])
#     j<-rbind(j, i)
#     models[[modeln]][[i]]<-summary(modeltry)
#   }
# }
# 
# models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)
# 
# #  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
# models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)
# 
# # rank the R2's of these models
# models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))
# 
# #  this is the index of the row with the highest R2 and  no negative betas in this subset
# models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j
# 
# subset(models[[modeln]]$resultspos, rank==1)
# 
# # this is the model
# models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]
# 
# # here are the names
# models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetH_meca_LUR1)[models[[1]]$indexbestmodel], names(VGOB1_subsetH_meca_LUR1)[models[[2]]$indexbestmodel] , names(VGOB1_subsetH_meca_LUR1)[models[[3]]$indexbestmodel], names(VGOB1_subsetH_meca_LUR1)[models[[4]]$indexbestmodel], names(VGOB1_subsetH_meca_LUR1)[models[[5]]$indexbestmodel], names(VGOB1_subsetH_meca_LUR1)[models[[6]]$indexbestmodel], names(VGOB1_subsetH_meca_LUR1)[models[[7]]$indexbestmodel], names(VGOB1_subsetH_meca_LUR1)[models[[8]]$indexbestmodel])
# 
# #  this is the r2 or that model
# models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2
# 
# #  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
# models[[modeln]]$bestmodel <- lm(VGOB1_subsetH_meca_LUR1$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetH_meca_LUR1[,models[[1]]$indexbestmodel]+VGOB1_subsetH_meca_LUR1[,models[[2]]$indexbestmodel]+VGOB1_subsetH_meca_LUR1[,models[[3]]$indexbestmodel]+ VGOB1_subsetH_meca_LUR1[,models[[4]]$indexbestmodel]+ VGOB1_subsetH_meca_LUR1[,models[[5]]$indexbestmodel]+ VGOB1_subsetH_meca_LUR1[,models[[6]]$indexbestmodel]+ VGOB1_subsetH_meca_LUR1[,models[[7]]$indexbestmodel]+ VGOB1_subsetH_meca_LUR1[,models[[8]]$indexbestmodel]) 
# 
# models[[1]]$summarybestmodel
# models[[2]]$summarybestmodel
# models[[3]]$summarybestmodel
# models[[4]]$summarybestmodel
# models[[5]]$summarybestmodel
# models[[6]]$summarybestmodel
# models[[7]]$summarybestmodel
# models[[8]]$summarybestmodel
# models[[1]]$namesbestmodel
# models[[2]]$namesbestmodel
# models[[3]]$namesbestmodel
# models[[4]]$namesbestmodel
# models[[5]]$namesbestmodel
# models[[6]]$namesbestmodel
# models[[7]]$namesbestmodel
# models[[8]]$namesbestmodel
# models[[1]]$R2bestmodel
# models[[2]]$R2bestmodel
# models[[3]]$R2bestmodel
# models[[4]]$R2bestmodel
# models[[5]]$R2bestmodel
# models[[6]]$R2bestmodel
# models[[7]]$R2bestmodel
# models[[8]]$R2bestmodel


#   CODE FOR PICKING OUT THE BEST MODEL #   
temp <- 0
besti <- 0
for (i in 1:10){ #  think this runs the loop 10 times - not fully sure thought - but not to do with the number of models I don't think - as when I change to 3, I still get the model with 4 variables as best model
  print(models[[i]]$R2bestmodel)
  #       print(models[[i]]$summarybestmodel$coefficients=-1,4])
  #       if((models[[i]]$R2bestmodel-temp > 0.0) && (all(models[[i]]$summarybestmodel$coefficients[-1,4]<0.1))){
  #         temp <- models[[i]]$R2bestmodel
  #         besti <- i
  #         }
  if((models[[i]]$R2bestmodel-temp > 0.0) && (all(models[[i]]$summarybestmodel$coefficients[-1,4]<0.1))){
    temp <- models[[i]]$R2bestmodel
    besti <- i
  }else{
    finalBestModel_meca_LUR1_subsetH <- models[[besti]]$bestmodel
    finalBestModelNames_meca_subsetH <- models[[besti]]$namesbestmodel
    Sites <- 1:dim(VGOB1_subsetH_meca_LUR1)[1] # full original model
    #  CVaR2<-escCV_meca_LUR1(Sites)[2] # Cross Validation
    maxCD<-max(cooks.distance(finalBestModel_meca_LUR1_subsetH))
    if(length(finalBestModelNames_meca_subsetH)<2){ # vif fn doesnot work when only 1 variable...       # 
      maxVIF<-"NA"
    }else{
      maxVIF<-max(vif(finalBestModel_meca_LUR1_subsetH))
    }
    print(paste("This is the best meca model for subset H: ",besti,
                "(AdjR2: ",format(models[[besti]]$R2bestmodel,digits=3), "; MaxCD: ",format(maxCD,digits=3),"; MaxVIF: ",
                format(maxVIF,digits=3),")", sep=''))
    print(finalBestModelNames_meca_subsetH)
    break
  }
}

#  Overview of the final best model using the algorithm selection process (taking into account VIF, R^2, and p-values)
finalBestModel_meca_LUR1_subsetH
finalBestModelNames_meca_subsetH
models[[besti]]$summarybestmodel
models[[besti]]$R2bestmodel

#### I ####
# LUR model building process for subset I
#  This is the dataframe with the relevant predictor vars for LUR1 models for subset I (55 sites)
VGOB1_subsetI_meca_LUR1 # n.b. this dataframe only includes microbial marker concentrations for meca unlike the dataframe Measurements_livestockpreds_LUR1 as previously used for the model building. 

#  Now set the values of some variables that will be needed
nfirstvar_LUR_1 <- 3  
nlastvar_LUR_1 <- 10

# Function building to run the models 
# 1 #  

models<-list()
modeln<-1
models[[modeln]]<-list()

R2<-1
betaaddedvar<-1
addedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_1:nlastvar_LUR_1){
  if (is.numeric(VGOB1_subsetI_meca_LUR1[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetI_meca_LUR1$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetI_meca_LUR1[,i])                            
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    #  Measurements_livestockpreds_LUR1[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR1)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetI_meca_LUR1)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)
models[[modeln]]$results

#  this are the candidates models with the highest R2, not a negative beta for the new, nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)
models[[modeln]]$resultspos

#  rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))
models[[modeln]]$resultspos

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j
models[[modeln]]$indexbestmodel

subset(models[[modeln]]$resultspos, rank==1)
subset(models[[modeln]]$resultspos)

#  this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]
models[[modeln]]$summarybestmodel

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetI_meca_LUR1)[models[[1]]$indexbestmodel])
models[[modeln]]$namesbestmodel

#  this is the r2 of that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2
models[[modeln]]$R2bestmodel

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetI_meca_LUR1$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetI_meca_LUR1[,models[[1]]$indexbestmodel]) 
models[[modeln]]$bestmodel

summary(models[[modeln]]$bestmodel)

#  The first model includes the predictor: nPigMultipFarmWghtDist.3000m.sum.Tr.1P9 - meaning the number of multiplier pig farms weighted to distance in a 3000m buffer

# 2 #  
# Add 2nd variable (the only difference of the above part is that now modeln=2 the model statement has 2 variables)
# and the call for the list of variable names in the model changed slightly

modeln<-2

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_1:nlastvar_LUR_1){
  if (is.numeric(VGOB1_subsetI_meca_LUR1[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetI_meca_LUR1$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetI_meca_LUR1[,models[[1]]$indexbestmodel]+ VGOB1_subsetI_meca_LUR1[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # Measurements_livestockpreds_LUR1[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR1)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetI_meca_LUR1)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  these are the candidate models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)
models[[modeln]]$resultspos

#  rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))
models[[modeln]]$resultspos

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j
models[[modeln]]$indexbestmodel

subset(models[[modeln]]$resultspos, rank==1)

# this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]
models[[modeln]]$summarybestmodel

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetI_meca_LUR1)[models[[1]]$indexbestmodel], names(VGOB1_subsetI_meca_LUR1)[models[[2]]$indexbestmodel] )
models[[modeln]]$namesbestmodel

# this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2
models[[modeln]]$R2bestmodel

# this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetI_meca_LUR1$meca_copiespm3.ln.diffmeth.mean~                               VGOB1_subsetI_meca_LUR1[,models[[1]]$indexbestmodel]+                           VGOB1_subsetI_meca_LUR1[,models[[2]]$indexbestmodel]) 

models[[modeln]]$bestmodel

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel

# 3 #
# add third variable (the only difference of the above part is that now modeln=3 the model statement has 3 variables)
# and the call for the list of variable names in the model changed slightly

modeln<-3

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_1:nlastvar_LUR_1){
  if (is.numeric(VGOB1_subsetI_meca_LUR1[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetI_meca_LUR1$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetI_meca_LUR1[,models[[1]]$indexbestmodel]+VGOB1_subsetI_meca_LUR1[,models[[2]]$indexbestmodel]+ VGOB1_subsetI_meca_LUR1[,i])
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])#
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # All[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR1)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetI_meca_LUR1)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

#  rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

#  this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

#  here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetI_meca_LUR1)[models[[1]]$indexbestmodel], names(VGOB1_subsetI_meca_LUR1)[models[[2]]$indexbestmodel], names(VGOB1_subsetI_meca_LUR1)[models[[3]]$indexbestmodel])

#  this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetI_meca_LUR1$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetI_meca_LUR1[,models[[1]]$indexbestmodel]+ VGOB1_subsetI_meca_LUR1[,models[[2]]$indexbestmodel]+ VGOB1_subsetI_meca_LUR1[,models[[3]]$indexbestmodel])

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
# 
# 
# # 4 #
# #  add forth variable (the only difference of the above part is that now model n=4 the model statement more variables)
# #  and the call for the list of variable names in the model changed slightly
# modeln<-4
# 
# models[[modeln]]<-list()
# 
# R2<-1
# addedvar<-1
# betaaddedvar<-1
# minbetas<-1
# j<-1
# 
# 
# for (i in nfirstvar_LUR_1:nlastvar_LUR_1){
#   if (is.numeric(VGOB1_subsetI_meca_LUR1[,i])==TRUE){
#     modeltry<-lm(VGOB1_subsetI_meca_LUR1$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetI_meca_LUR1[,models[[1]]$indexbestmodel]+VGOB1_subsetI_meca_LUR1[,models[[2]]$indexbestmodel]+VGOB1_subsetI_meca_LUR1[,models[[3]]$indexbestmodel]+VGOB1_subsetI_meca_LUR1[,i])
#     R2<-rbind(R2,summary(modeltry)$adj.r.squared)
#     #  the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
#     betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])
#     #  find out if there is a negative beta at All. The intercept does not count [-1]!
#     minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
#     #  All[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR1)[i]
#     addedvar<-rbind(addedvar,names(VGOB1_subsetI_meca_LUR1)[i])
#     j<-rbind(j, i)
#     models[[modeln]][[i]]<-summary(modeltry)
#   }
# }
# 
# models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)
# 
# #  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
# models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)
# 
# # rank the R2's of these models
# models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))
# 
# #  this is the index of the row with the highest R2 and  no negative betas in this subset
# models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j
# 
# subset(models[[modeln]]$resultspos, rank==1)
# 
# #  this is the model
# models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]
# 
# #  here are the names
# models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetI_meca_LUR1)[models[[1]]$indexbestmodel], names(VGOB1_subsetI_meca_LUR1)[models[[2]]$indexbestmodel], names(VGOB1_subsetI_meca_LUR1)[models[[3]]$indexbestmodel], names(VGOB1_subsetI_meca_LUR1)[models[[4]]$indexbestmodel])
# 
# #  this is the r2 of that model
# models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2
# 
# #  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
# models[[modeln]]$bestmodel <- lm(VGOB1_subsetI_meca_LUR1$meca_copiespm3.ln.diffmeth.mean~ VGOB1_subsetI_meca_LUR1[,models[[1]]$indexbestmodel]+ VGOB1_subsetI_meca_LUR1[,models[[2]]$indexbestmodel]+VGOB1_subsetI_meca_LUR1[,models[[3]]$indexbestmodel]+ VGOB1_subsetI_meca_LUR1[,models[[4]]$indexbestmodel])
# 
# 
# models[[1]]$summarybestmodel
# models[[2]]$summarybestmodel
# models[[3]]$summarybestmodel
# models[[4]]$summarybestmodel
# models[[1]]$namesbestmodel
# models[[2]]$namesbestmodel
# models[[3]]$namesbestmodel
# models[[4]]$namesbestmodel
# models[[1]]$R2bestmodel
# models[[2]]$R2bestmodel
# models[[3]]$R2bestmodel
# models[[4]]$R2bestmodel
# 
# 
# # 5 #  
# # add fifth variable (the only difference of the above part is that now modeln=5 the model statement more variables)
# # and the call for the list of variable names in the model changed slightly
# modeln<-5
# 
# models[[modeln]]<-list()
# 
# R2<-1
# addedvar<-1
# betaaddedvar<-1
# minbetas<-1
# j<-1
# 
# for (i in nfirstvar_LUR_1:nlastvar_LUR_1){
#   if (is.numeric(VGOB1_subsetI_meca_LUR1[,i])==TRUE){
#     modeltry<-lm(VGOB1_subsetI_meca_LUR1$meca_copiespm3.ln.diffmeth.mean~ VGOB1_subsetI_meca_LUR1[,models[[1]]$indexbestmodel]+ VGOB1_subsetI_meca_LUR1[,models[[2]]$indexbestmodel]+ VGOB1_subsetI_meca_LUR1[,models[[3]]$indexbestmodel]+ VGOB1_subsetI_meca_LUR1[,models[[4]]$indexbestmodel]+ VGOB1_subsetI_meca_LUR1[,i]) 
#   
# R2<-rbind(R2,summary(modeltry)$adj.r.squared)
# # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
#     betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
#     #  find out if there is a negative beta at All. The intercept does not count [-1]!
#     minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
#     # All[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR1)[i]
#     addedvar<-rbind(addedvar,names(VGOB1_subsetI_meca_LUR1)[i])
#     j<-rbind(j, i)
#     models[[modeln]][[i]]<-summary(modeltry)
#   }
# }
# 
# models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)
# 
# #  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
# models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)
# 
# # rank the R2's of these models
# models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))
# 
# #  this is the index of the row with the highest R2 and  no negative betas in this subset
# models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j
# 
# subset(models[[modeln]]$resultspos, rank==1)
# 
# #  this is the model
# models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]
# 
# # here are the names
# models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetI_meca_LUR1)[models[[1]]$indexbestmodel], names(VGOB1_subsetI_meca_LUR1)[models[[2]]$indexbestmodel], names(VGOB1_subsetI_meca_LUR1)[models[[3]]$indexbestmodel], names(VGOB1_subsetI_meca_LUR1)[models[[4]]$indexbestmodel], names(VGOB1_subsetI_meca_LUR1)[models[[5]]$indexbestmodel])
# 
# #  this is the r2 or that model
# models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2
# 
# #  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
# models[[modeln]]$bestmodel <- lm(VGOB1_subsetI_meca_LUR1$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetI_meca_LUR1[,models[[1]]$indexbestmodel]+VGOB1_subsetI_meca_LUR1[,models[[2]]$indexbestmodel]+VGOB1_subsetI_meca_LUR1[,models[[3]]$indexbestmodel]+ VGOB1_subsetI_meca_LUR1[,models[[4]]$indexbestmodel]+ VGOB1_subsetI_meca_LUR1[,models[[5]]$indexbestmodel]) 
# models[[1]]$summarybestmodel
# models[[2]]$summarybestmodel
# models[[3]]$summarybestmodel
# models[[4]]$summarybestmodel
# models[[5]]$summarybestmodel
# models[[1]]$namesbestmodel
# models[[2]]$namesbestmodel
# models[[3]]$namesbestmodel
# models[[4]]$namesbestmodel
# models[[5]]$namesbestmodel
# models[[1]]$R2bestmodel
# models[[2]]$R2bestmodel
# models[[3]]$R2bestmodel
# models[[4]]$R2bestmodel
# models[[5]]$R2bestmodel
# 
# # 6 #  
# # add sixth variable (the only difference of the above part is that now model n=6 the model statement more variables)
# #  and the call for the list of variable names in the model changed slightly
# 
# modeln<-6
# 
# models[[modeln]]<-list()
# 
# R2<-1
# addedvar<-1
# betaaddedvar<-1
# minbetas<-1
# j<-1
# 
# for (i in nfirstvar_LUR_1 :nlastvar_LUR_1){
#   if (is.numeric(VGOB1_subsetI_meca_LUR1[,i])==TRUE){
#     modeltry<-lm(VGOB1_subsetI_meca_LUR1$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetI_meca_LUR1[,models[[1]]$indexbestmodel]+VGOB1_subsetI_meca_LUR1[,models[[2]]$indexbestmodel]+VGOB1_subsetI_meca_LUR1[,models[[3]]$indexbestmodel]+VGOB1_subsetI_meca_LUR1[,models[[4]]$indexbestmodel]+VGOB1_subsetI_meca_LUR1[,models[[5]]$indexbestmodel]+ VGOB1_subsetI_meca_LUR1[,i]) 
#     R2<-rbind(R2,summary(modeltry)$adj.r.squared)
#     # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
#     betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
#     #  find out if there is a negative beta at All. The intercept does not count [-1]!
#     minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
#     # All[,i] is the row that's being tried out now. the name of that row can be found in  names(All)[i]
#     addedvar<-rbind(addedvar,names(VGOB1_subsetI_meca_LUR1)[i])
#     j<-rbind(j, i)
#     models[[modeln]][[i]]<-summary(modeltry)
#   }
# }
# 
# models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)
# 
# #  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
# models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)
# 
# # rank the R2's of these models
# models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))
# 
# #  this is the index of the row with the highest R2 and  no negative betas in this subset
# models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j
# 
# subset(models[[modeln]]$resultspos, rank==1)
# 
# # this is the model
# models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]
# 
# # here are the names
# models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetI_meca_LUR1)[models[[1]]$indexbestmodel], names(VGOB1_subsetI_meca_LUR1)[models[[2]]$indexbestmodel] , names(VGOB1_subsetI_meca_LUR1)[models[[3]]$indexbestmodel], names(VGOB1_subsetI_meca_LUR1)[models[[4]]$indexbestmodel], names(VGOB1_subsetI_meca_LUR1)[models[[5]]$indexbestmodel], names(VGOB1_subsetI_meca_LUR1)[models[[6]]$indexbestmodel])
# 
# #  this is the r2 or that model
# models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2
# 
# #  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
# models[[modeln]]$bestmodel <- lm(VGOB1_subsetI_meca_LUR1$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetI_meca_LUR1[,models[[1]]$indexbestmodel]+VGOB1_subsetI_meca_LUR1[,models[[2]]$indexbestmodel]+VGOB1_subsetI_meca_LUR1[,models[[3]]$indexbestmodel]+ VGOB1_subsetI_meca_LUR1[,models[[4]]$indexbestmodel]+ VGOB1_subsetI_meca_LUR1[,models[[5]]$indexbestmodel]+ VGOB1_subsetI_meca_LUR1[,models[[6]]$indexbestmodel]) 
# 
# models[[1]]$summarybestmodel
# models[[2]]$summarybestmodel
# models[[3]]$summarybestmodel
# models[[4]]$summarybestmodel
# models[[5]]$summarybestmodel
# models[[6]]$summarybestmodel
# models[[1]]$namesbestmodel
# models[[2]]$namesbestmodel
# models[[3]]$namesbestmodel
# models[[4]]$namesbestmodel
# models[[5]]$namesbestmodel
# models[[6]]$namesbestmodel
# models[[1]]$R2bestmodel
# models[[2]]$R2bestmodel
# models[[3]]$R2bestmodel
# models[[4]]$R2bestmodel
# models[[5]]$R2bestmodel
# models[[6]]$R2bestmodel
# 
# 
# # 7 #  
# # add seventh variable (the only difference of the above part is that now model n=7 the model statement more variables)
# #  and the call for the list of variable names in the model changed slightly
# 
# modeln<-7
# 
# models[[modeln]]<-list()
# 
# R2<-1
# addedvar<-1
# betaaddedvar<-1
# minbetas<-1
# j<-1
# 
# for (i in nfirstvar_LUR_1 :nlastvar_LUR_1){
#   if (is.numeric(VGOB1_subsetI_meca_LUR1[,i])==TRUE){
#     modeltry<-lm(VGOB1_subsetI_meca_LUR1$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetI_meca_LUR1[,models[[1]]$indexbestmodel]+VGOB1_subsetI_meca_LUR1[,models[[2]]$indexbestmodel]+VGOB1_subsetI_meca_LUR1[,models[[3]]$indexbestmodel]+VGOB1_subsetI_meca_LUR1[,models[[4]]$indexbestmodel]+VGOB1_subsetI_meca_LUR1[,models[[5]]$indexbestmodel]+VGOB1_subsetI_meca_LUR1[,models[[6]]$indexbestmodel]+ VGOB1_subsetI_meca_LUR1[,i]) 
#     R2<-rbind(R2,summary(modeltry)$adj.r.squared)
#     # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
#     betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
#     #  find out if there is a negative beta at All. The intercept does not count [-1]!
#     minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
#     # Measurements_livestockpreds_LUR1[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR1)[i]
#     addedvar<-rbind(addedvar,names(VGOB1_subsetI_meca_LUR1)[i])
#     j<-rbind(j, i)
#     models[[modeln]][[i]]<-summary(modeltry)
#   }
# }
# 
# models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)
# 
# #  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
# models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)
# 
# # rank the R2's of these models
# models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))
# 
# #  this is the index of the row with the highest R2 and  no negative betas in this subset
# models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j
# 
# subset(models[[modeln]]$resultspos, rank==1)
# 
# # this is the model
# models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]
# 
# # here are the names
# models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetI_meca_LUR1)[models[[1]]$indexbestmodel], names(VGOB1_subsetI_meca_LUR1)[models[[2]]$indexbestmodel] , names(VGOB1_subsetI_meca_LUR1)[models[[3]]$indexbestmodel], names(VGOB1_subsetI_meca_LUR1)[models[[4]]$indexbestmodel], names(VGOB1_subsetI_meca_LUR1)[models[[5]]$indexbestmodel], names(VGOB1_subsetI_meca_LUR1)[models[[6]]$indexbestmodel], names(VGOB1_subsetI_meca_LUR1)[models[[7]]$indexbestmodel])
# 
# #  this is the r2 or that model
# models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2
# 
# #  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
# models[[modeln]]$bestmodel <- lm(VGOB1_subsetI_meca_LUR1$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetI_meca_LUR1[,models[[1]]$indexbestmodel]+VGOB1_subsetI_meca_LUR1[,models[[2]]$indexbestmodel]+VGOB1_subsetI_meca_LUR1[,models[[3]]$indexbestmodel]+ VGOB1_subsetI_meca_LUR1[,models[[4]]$indexbestmodel]+ VGOB1_subsetI_meca_LUR1[,models[[5]]$indexbestmodel]+ VGOB1_subsetI_meca_LUR1[,models[[6]]$indexbestmodel]+ VGOB1_subsetI_meca_LUR1[,models[[7]]$indexbestmodel]) 
# 
# models[[1]]$summarybestmodel
# models[[2]]$summarybestmodel
# models[[3]]$summarybestmodel
# models[[4]]$summarybestmodel
# models[[5]]$summarybestmodel
# models[[6]]$summarybestmodel
# models[[7]]$summarybestmodel
# models[[1]]$namesbestmodel
# models[[2]]$namesbestmodel
# models[[3]]$namesbestmodel
# models[[4]]$namesbestmodel
# models[[5]]$namesbestmodel
# models[[6]]$namesbestmodel
# models[[7]]$namesbestmodel
# models[[1]]$R2bestmodel
# models[[2]]$R2bestmodel
# models[[3]]$R2bestmodel
# models[[4]]$R2bestmodel
# models[[5]]$R2bestmodel
# models[[6]]$R2bestmodel
# models[[7]]$R2bestmodel
# 
# # 8 #  
# # add eighth variable (the only difference of the above part is that now modeln=7 the model statement more variables)
# # and the call for the list of variable names in the model changed slightly
# 
# modeln<-8
# 
# models[[modeln]]<-list()
# 
# R2<-1
# addedvar<-1
# betaaddedvar<-1
# minbetas<-1
# j<-1
# 
# for (i in nfirstvar_LUR_1 :nlastvar_LUR_1){
#   if (is.numeric(VGOB1_subsetI_meca_LUR1[,i])==TRUE){
#     modeltry<-lm(VGOB1_subsetI_meca_LUR1$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetI_meca_LUR1[,models[[1]]$indexbestmodel]+VGOB1_subsetI_meca_LUR1[,models[[2]]$indexbestmodel]+VGOB1_subsetI_meca_LUR1[,models[[3]]$indexbestmodel]+VGOB1_subsetI_meca_LUR1[,models[[4]]$indexbestmodel]+VGOB1_subsetI_meca_LUR1[,models[[5]]$indexbestmodel]+VGOB1_subsetI_meca_LUR1[,models[[6]]$indexbestmodel]+ VGOB1_subsetI_meca_LUR1[,models[[7]]$indexbestmodel]+ VGOB1_subsetI_meca_LUR1[,i]) 
#     R2<-rbind(R2,summary(modeltry)$adj.r.squared)
#     # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
#     betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
#     #  find out if there is a negative beta at All. The intercept does not count [-1]!
#     minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
#     # Measurements_livestockpreds_LUR1[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR1)[i]
#     addedvar<-rbind(addedvar,names(VGOB1_subsetI_meca_LUR1)[i])
#     j<-rbind(j, i)
#     models[[modeln]][[i]]<-summary(modeltry)
#   }
# }
# 
# models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)
# 
# #  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
# models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)
# 
# # rank the R2's of these models
# models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))
# 
# #  this is the index of the row with the highest R2 and  no negative betas in this subset
# models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j
# 
# subset(models[[modeln]]$resultspos, rank==1)
# 
# # this is the model
# models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]
# 
# # here are the names
# models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetI_meca_LUR1)[models[[1]]$indexbestmodel], names(VGOB1_subsetI_meca_LUR1)[models[[2]]$indexbestmodel] , names(VGOB1_subsetI_meca_LUR1)[models[[3]]$indexbestmodel], names(VGOB1_subsetI_meca_LUR1)[models[[4]]$indexbestmodel], names(VGOB1_subsetI_meca_LUR1)[models[[5]]$indexbestmodel], names(VGOB1_subsetI_meca_LUR1)[models[[6]]$indexbestmodel], names(VGOB1_subsetI_meca_LUR1)[models[[7]]$indexbestmodel], names(VGOB1_subsetI_meca_LUR1)[models[[8]]$indexbestmodel])
# 
# #  this is the r2 or that model
# models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2
# 
# #  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
# models[[modeln]]$bestmodel <- lm(VGOB1_subsetI_meca_LUR1$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetI_meca_LUR1[,models[[1]]$indexbestmodel]+VGOB1_subsetI_meca_LUR1[,models[[2]]$indexbestmodel]+VGOB1_subsetI_meca_LUR1[,models[[3]]$indexbestmodel]+ VGOB1_subsetI_meca_LUR1[,models[[4]]$indexbestmodel]+ VGOB1_subsetI_meca_LUR1[,models[[5]]$indexbestmodel]+ VGOB1_subsetI_meca_LUR1[,models[[6]]$indexbestmodel]+ VGOB1_subsetI_meca_LUR1[,models[[7]]$indexbestmodel]+ VGOB1_subsetI_meca_LUR1[,models[[8]]$indexbestmodel]) 
# 
# models[[1]]$summarybestmodel
# models[[2]]$summarybestmodel
# models[[3]]$summarybestmodel
# models[[4]]$summarybestmodel
# models[[5]]$summarybestmodel
# models[[6]]$summarybestmodel
# models[[7]]$summarybestmodel
# models[[8]]$summarybestmodel
# models[[1]]$namesbestmodel
# models[[2]]$namesbestmodel
# models[[3]]$namesbestmodel
# models[[4]]$namesbestmodel
# models[[5]]$namesbestmodel
# models[[6]]$namesbestmodel
# models[[7]]$namesbestmodel
# models[[8]]$namesbestmodel
# models[[1]]$R2bestmodel
# models[[2]]$R2bestmodel
# models[[3]]$R2bestmodel
# models[[4]]$R2bestmodel
# models[[5]]$R2bestmodel
# models[[6]]$R2bestmodel
# models[[7]]$R2bestmodel
# models[[8]]$R2bestmodel

#   CODE FOR PICKING OUT THE BEST MODEL #   
temp <- 0
besti <- 0
for (i in 1:10){ #  think this runs the loop 10 times - not fully sure thought - but not to do with the number of models I don't think - as when I change to 3, I still get the model with 4 variables as best model
  print(models[[i]]$R2bestmodel)
  #       print(models[[i]]$summarybestmodel$coefficients=-1,4])
  #       if((models[[i]]$R2bestmodel-temp > 0.0) && (all(models[[i]]$summarybestmodel$coefficients[-1,4]<0.1))){
  #         temp <- models[[i]]$R2bestmodel
  #         besti <- i
  #         }
  if((models[[i]]$R2bestmodel-temp > 0.0) && (all(models[[i]]$summarybestmodel$coefficients[-1,4]<0.1))){
    temp <- models[[i]]$R2bestmodel
    besti <- i
  }else{
    finalBestModel_meca_LUR1_subsetI <- models[[besti]]$bestmodel
    finalBestModelNames_meca_subsetI <- models[[besti]]$namesbestmodel
    Sites <- 1:dim(VGOB1_subsetI_meca_LUR1)[1] # full original model
    #  CVaR2<-escCV_meca_LUR1(Sites)[2] # Cross Validation
    maxCD<-max(cooks.distance(finalBestModel_meca_LUR1_subsetI))
    if(length(finalBestModelNames_meca_subsetI)<2){ # vif fn doesnot work when only 1 variable...       # 
      maxVIF<-"NA"
    }else{
      maxVIF<-max(vif(finalBestModel_meca_LUR1_subsetI))
    }
    print(paste("This is the best meca model for subset I: ",besti,
                "(AdjR2: ",format(models[[besti]]$R2bestmodel,digits=3), "; MaxCD: ",format(maxCD,digits=3),"; MaxVIF: ",
                format(maxVIF,digits=3),")", sep=''))
    print(finalBestModelNames_meca_subsetI)
    break
  }
}

#  Overview of the final best model using the algorithm selection process (taking into account VIF, R^2, and p-values)
finalBestModel_meca_LUR1_subsetI
finalBestModelNames_meca_subsetI
models[[besti]]$summarybestmodel
models[[besti]]$R2bestmodel

#### J ####
# LUR model building process for subset J
#  This is the dataframe with the relevant predictor vars for LUR1 models for subset J (55 sites)
VGOB1_subsetJ_meca_LUR1 # n.b. this dataframe only includes microbial marker concentrations for meca unlike the dataframe Measurements_livestockpreds_LUR1 as previously used for the model building. 

#  Now set the values of some variables that will be needed
nfirstvar_LUR_1 <- 3  
nlastvar_LUR_1 <- 10

# Function building to run the models 
# 1 #  

models<-list()
modeln<-1
models[[modeln]]<-list()

R2<-1
betaaddedvar<-1
addedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_1:nlastvar_LUR_1){
  if (is.numeric(VGOB1_subsetJ_meca_LUR1[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetJ_meca_LUR1$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetJ_meca_LUR1[,i])                            
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    #  Measurements_livestockpreds_LUR1[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR1)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetJ_meca_LUR1)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)
models[[modeln]]$results

#  this are the candidates models with the highest R2, not a negative beta for the new, nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)
models[[modeln]]$resultspos

#  rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))
models[[modeln]]$resultspos

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j
models[[modeln]]$indexbestmodel

subset(models[[modeln]]$resultspos, rank==1)
subset(models[[modeln]]$resultspos)

#  this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]
models[[modeln]]$summarybestmodel

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetJ_meca_LUR1)[models[[1]]$indexbestmodel])
models[[modeln]]$namesbestmodel

#  this is the r2 of that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2
models[[modeln]]$R2bestmodel

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetJ_meca_LUR1$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetJ_meca_LUR1[,models[[1]]$indexbestmodel]) 
models[[modeln]]$bestmodel

summary(models[[modeln]]$bestmodel)

#  The first model includes the predictor: nPigMultipFarmWghtDist.3000m.sum.Tr.1P9 - meaning the number of multiplier pig farms weighted to distance in a 3000m buffer

# 2 #  
# Add 2nd variable (the only difference of the above part is that now modeln=2 the model statement has 2 variables)
# and the call for the list of variable names in the model changed slightly

modeln<-2

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_1:nlastvar_LUR_1){
  if (is.numeric(VGOB1_subsetJ_meca_LUR1[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetJ_meca_LUR1$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetJ_meca_LUR1[,models[[1]]$indexbestmodel]+ VGOB1_subsetJ_meca_LUR1[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # Measurements_livestockpreds_LUR1[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR1)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetJ_meca_LUR1)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  these are the candidate models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)
models[[modeln]]$resultspos

#  rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))
models[[modeln]]$resultspos

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j
models[[modeln]]$indexbestmodel

subset(models[[modeln]]$resultspos, rank==1)

# this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]
models[[modeln]]$summarybestmodel

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetJ_meca_LUR1)[models[[1]]$indexbestmodel], names(VGOB1_subsetJ_meca_LUR1)[models[[2]]$indexbestmodel] )
models[[modeln]]$namesbestmodel

# this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2
models[[modeln]]$R2bestmodel

# this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetJ_meca_LUR1$meca_copiespm3.ln.diffmeth.mean~                               VGOB1_subsetJ_meca_LUR1[,models[[1]]$indexbestmodel]+                           VGOB1_subsetJ_meca_LUR1[,models[[2]]$indexbestmodel]) 

models[[modeln]]$bestmodel

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel

# The next part of the code (n=3-8) does not work
# This is because one of the coefficients included in the model with 6 variables is negative, the code does not allow for this. I can stop here.

# # 3 #  
# # add third variable (the only difference of the above part is that now modeln=3 the model statement has 3 variables)
# # and the call for the list of variable names in the model changed slightly
# 
# modeln<-3
# 
# models[[modeln]]<-list()
# 
# R2<-1
# addedvar<-1
# betaaddedvar<-1
# minbetas<-1
# j<-1
# 
# for (i in nfirstvar_LUR_1:nlastvar_LUR_1){
#   if (is.numeric(VGOB1_subsetJ_meca_LUR1[,i])==TRUE){  
#     modeltry<-lm(VGOB1_subsetJ_meca_LUR1$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetJ_meca_LUR1[,models[[1]]$indexbestmodel]+VGOB1_subsetJ_meca_LUR1[,models[[2]]$indexbestmodel]+ VGOB1_subsetJ_meca_LUR1[,i]) 
#     R2<-rbind(R2,summary(modeltry)$adj.r.squared)
#     # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
#     betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
#     #  find out if there is a negative beta at All. The intercept does not count [-1]!
#     minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
#     # All[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR1)[i]
#     addedvar<-rbind(addedvar,names(VGOB1_subsetJ_meca_LUR1)[i])
#     j<-rbind(j, i)
#     models[[modeln]][[i]]<-summary(modeltry)
#   }
# }
# 
# models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)
# 
# #  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
# models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)
# 
# #  rank the R2's of these models
# models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))
# 
# #  this is the index of the row with the highest R2 and  no negative betas in this subset
# models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j
# 
# subset(models[[modeln]]$resultspos, rank==1)
# 
# #  this is the model
# models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]
# 
# #  here are the names
# models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetJ_meca_LUR1)[models[[1]]$indexbestmodel], names(VGOB1_subsetJ_meca_LUR1)[models[[2]]$indexbestmodel], names(VGOB1_subsetJ_meca_LUR1)[models[[3]]$indexbestmodel])
# 
# #  this is the r2 or that model
# models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2
# 
# #  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
# models[[modeln]]$bestmodel <- lm(VGOB1_subsetJ_meca_LUR1$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetJ_meca_LUR1[,models[[1]]$indexbestmodel]+ VGOB1_subsetJ_meca_LUR1[,models[[2]]$indexbestmodel]+ VGOB1_subsetJ_meca_LUR1[,models[[3]]$indexbestmodel]) 
# 
# models[[1]]$summarybestmodel
# models[[2]]$summarybestmodel
# models[[3]]$summarybestmodel
# models[[1]]$namesbestmodel
# models[[2]]$namesbestmodel
# models[[3]]$namesbestmodel
# models[[1]]$R2bestmodel
# models[[2]]$R2bestmodel
# models[[3]]$R2bestmodel

# # 4 #  
# #  add forth variable (the only difference of the above part is that now model n=4 the model statement more variables)
# #  and the call for the list of variable names in the model changed slightly
# modeln<-4
# 
# models[[modeln]]<-list()
# 
# R2<-1
# addedvar<-1
# betaaddedvar<-1
# minbetas<-1
# j<-1
# 
# 
# for (i in nfirstvar_LUR_1:nlastvar_LUR_1){
#   if (is.numeric(VGOB1_subsetJ_meca_LUR1[,i])==TRUE){
#     modeltry<-lm(VGOB1_subsetJ_meca_LUR1$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetJ_meca_LUR1[,models[[1]]$indexbestmodel]+VGOB1_subsetJ_meca_LUR1[,models[[2]]$indexbestmodel]+VGOB1_subsetJ_meca_LUR1[,models[[3]]$indexbestmodel]+VGOB1_subsetJ_meca_LUR1[,i]) 
#     R2<-rbind(R2,summary(modeltry)$adj.r.squared)
#     #  the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
#     betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])
#     #  find out if there is a negative beta at All. The intercept does not count [-1]!
#     minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
#     #  All[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR1)[i]
#     addedvar<-rbind(addedvar,names(VGOB1_subsetJ_meca_LUR1)[i])
#     j<-rbind(j, i)
#     models[[modeln]][[i]]<-summary(modeltry)
#   }
# }
# 
# models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)
# 
# #  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
# models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)
# 
# # rank the R2's of these models
# models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))
# 
# #  this is the index of the row with the highest R2 and  no negative betas in this subset
# models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j
# 
# subset(models[[modeln]]$resultspos, rank==1)
# 
# #  this is the model
# models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]
# 
# #  here are the names
# models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetJ_meca_LUR1)[models[[1]]$indexbestmodel], names(VGOB1_subsetJ_meca_LUR1)[models[[2]]$indexbestmodel], names(VGOB1_subsetJ_meca_LUR1)[models[[3]]$indexbestmodel], names(VGOB1_subsetJ_meca_LUR1)[models[[4]]$indexbestmodel])
# 
# #  this is the r2 of that model
# models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2
# 
# #  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
# models[[modeln]]$bestmodel <- lm(VGOB1_subsetJ_meca_LUR1$meca_copiespm3.ln.diffmeth.mean~ VGOB1_subsetJ_meca_LUR1[,models[[1]]$indexbestmodel]+ VGOB1_subsetJ_meca_LUR1[,models[[2]]$indexbestmodel]+VGOB1_subsetJ_meca_LUR1[,models[[3]]$indexbestmodel]+ VGOB1_subsetJ_meca_LUR1[,models[[4]]$indexbestmodel]) 
# 
# 
# models[[1]]$summarybestmodel
# models[[2]]$summarybestmodel
# models[[3]]$summarybestmodel
# models[[4]]$summarybestmodel
# models[[1]]$namesbestmodel
# models[[2]]$namesbestmodel
# models[[3]]$namesbestmodel
# models[[4]]$namesbestmodel
# models[[1]]$R2bestmodel
# models[[2]]$R2bestmodel
# models[[3]]$R2bestmodel
# models[[4]]$R2bestmodel
# 
# 
# # 5 #  
# # add fifth variable (the only difference of the above part is that now modeln=5 the model statement more variables)
# # and the call for the list of variable names in the model changed slightly
# modeln<-5
# 
# models[[modeln]]<-list()
# 
# R2<-1
# addedvar<-1
# betaaddedvar<-1
# minbetas<-1
# j<-1
# 
# for (i in nfirstvar_LUR_1:nlastvar_LUR_1){
#   if (is.numeric(VGOB1_subsetJ_meca_LUR1[,i])==TRUE){
#     modeltry<-lm(VGOB1_subsetJ_meca_LUR1$meca_copiespm3.ln.diffmeth.mean~ VGOB1_subsetJ_meca_LUR1[,models[[1]]$indexbestmodel]+ VGOB1_subsetJ_meca_LUR1[,models[[2]]$indexbestmodel]+ VGOB1_subsetJ_meca_LUR1[,models[[3]]$indexbestmodel]+ VGOB1_subsetJ_meca_LUR1[,models[[4]]$indexbestmodel]+ VGOB1_subsetJ_meca_LUR1[,i]) 
#   
# R2<-rbind(R2,summary(modeltry)$adj.r.squared)
# # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
#     betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
#     #  find out if there is a negative beta at All. The intercept does not count [-1]!
#     minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
#     # All[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR1)[i]
#     addedvar<-rbind(addedvar,names(VGOB1_subsetJ_meca_LUR1)[i])
#     j<-rbind(j, i)
#     models[[modeln]][[i]]<-summary(modeltry)
#   }
# }
# 
# models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)
# 
# #  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
# models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)
# 
# # rank the R2's of these models
# models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))
# 
# #  this is the index of the row with the highest R2 and  no negative betas in this subset
# models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j
# 
# subset(models[[modeln]]$resultspos, rank==1)
# 
# #  this is the model
# models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]
# 
# # here are the names
# models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetJ_meca_LUR1)[models[[1]]$indexbestmodel], names(VGOB1_subsetJ_meca_LUR1)[models[[2]]$indexbestmodel], names(VGOB1_subsetJ_meca_LUR1)[models[[3]]$indexbestmodel], names(VGOB1_subsetJ_meca_LUR1)[models[[4]]$indexbestmodel], names(VGOB1_subsetJ_meca_LUR1)[models[[5]]$indexbestmodel])
# 
# #  this is the r2 or that model
# models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2
# 
# #  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
# models[[modeln]]$bestmodel <- lm(VGOB1_subsetJ_meca_LUR1$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetJ_meca_LUR1[,models[[1]]$indexbestmodel]+VGOB1_subsetJ_meca_LUR1[,models[[2]]$indexbestmodel]+VGOB1_subsetJ_meca_LUR1[,models[[3]]$indexbestmodel]+ VGOB1_subsetJ_meca_LUR1[,models[[4]]$indexbestmodel]+ VGOB1_subsetJ_meca_LUR1[,models[[5]]$indexbestmodel]) 
# models[[1]]$summarybestmodel
# models[[2]]$summarybestmodel
# models[[3]]$summarybestmodel
# models[[4]]$summarybestmodel
# models[[5]]$summarybestmodel
# models[[1]]$namesbestmodel
# models[[2]]$namesbestmodel
# models[[3]]$namesbestmodel
# models[[4]]$namesbestmodel
# models[[5]]$namesbestmodel
# models[[1]]$R2bestmodel
# models[[2]]$R2bestmodel
# models[[3]]$R2bestmodel
# models[[4]]$R2bestmodel
# models[[5]]$R2bestmodel
# 
# # 6 #  
# # add sixth variable (the only difference of the above part is that now model n=6 the model statement more variables)
# #  and the call for the list of variable names in the model changed slightly
# 
# modeln<-6
# 
# models[[modeln]]<-list()
# 
# R2<-1
# addedvar<-1
# betaaddedvar<-1
# minbetas<-1
# j<-1
# 
# for (i in nfirstvar_LUR_1 :nlastvar_LUR_1){
#   if (is.numeric(VGOB1_subsetJ_meca_LUR1[,i])==TRUE){
#     modeltry<-lm(VGOB1_subsetJ_meca_LUR1$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetJ_meca_LUR1[,models[[1]]$indexbestmodel]+VGOB1_subsetJ_meca_LUR1[,models[[2]]$indexbestmodel]+VGOB1_subsetJ_meca_LUR1[,models[[3]]$indexbestmodel]+VGOB1_subsetJ_meca_LUR1[,models[[4]]$indexbestmodel]+VGOB1_subsetJ_meca_LUR1[,models[[5]]$indexbestmodel]+ VGOB1_subsetJ_meca_LUR1[,i]) 
#     R2<-rbind(R2,summary(modeltry)$adj.r.squared)
#     # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
#     betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
#     #  find out if there is a negative beta at All. The intercept does not count [-1]!
#     minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
#     # All[,i] is the row that's being tried out now. the name of that row can be found in  names(All)[i]
#     addedvar<-rbind(addedvar,names(VGOB1_subsetJ_meca_LUR1)[i])
#     j<-rbind(j, i)
#     models[[modeln]][[i]]<-summary(modeltry)
#   }
# }
# 
# models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)
# 
# #  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
# models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)
# 
# # rank the R2's of these models
# models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))
# 
# #  this is the index of the row with the highest R2 and  no negative betas in this subset
# models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j
# 
# subset(models[[modeln]]$resultspos, rank==1)
# 
# # this is the model
# models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]
# 
# # here are the names
# models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetJ_meca_LUR1)[models[[1]]$indexbestmodel], names(VGOB1_subsetJ_meca_LUR1)[models[[2]]$indexbestmodel] , names(VGOB1_subsetJ_meca_LUR1)[models[[3]]$indexbestmodel], names(VGOB1_subsetJ_meca_LUR1)[models[[4]]$indexbestmodel], names(VGOB1_subsetJ_meca_LUR1)[models[[5]]$indexbestmodel], names(VGOB1_subsetJ_meca_LUR1)[models[[6]]$indexbestmodel])
# 
# #  this is the r2 or that model
# models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2
# 
# #  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
# models[[modeln]]$bestmodel <- lm(VGOB1_subsetJ_meca_LUR1$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetJ_meca_LUR1[,models[[1]]$indexbestmodel]+VGOB1_subsetJ_meca_LUR1[,models[[2]]$indexbestmodel]+VGOB1_subsetJ_meca_LUR1[,models[[3]]$indexbestmodel]+ VGOB1_subsetJ_meca_LUR1[,models[[4]]$indexbestmodel]+ VGOB1_subsetJ_meca_LUR1[,models[[5]]$indexbestmodel]+ VGOB1_subsetJ_meca_LUR1[,models[[6]]$indexbestmodel]) 
# 
# models[[1]]$summarybestmodel
# models[[2]]$summarybestmodel
# models[[3]]$summarybestmodel
# models[[4]]$summarybestmodel
# models[[5]]$summarybestmodel
# models[[6]]$summarybestmodel
# models[[1]]$namesbestmodel
# models[[2]]$namesbestmodel
# models[[3]]$namesbestmodel
# models[[4]]$namesbestmodel
# models[[5]]$namesbestmodel
# models[[6]]$namesbestmodel
# models[[1]]$R2bestmodel
# models[[2]]$R2bestmodel
# models[[3]]$R2bestmodel
# models[[4]]$R2bestmodel
# models[[5]]$R2bestmodel
# models[[6]]$R2bestmodel
# 
# 
# # 7 #  
# # add seventh variable (the only difference of the above part is that now model n=7 the model statement more variables)
# #  and the call for the list of variable names in the model changed slightly
# 
# modeln<-7
# 
# models[[modeln]]<-list()
# 
# R2<-1
# addedvar<-1
# betaaddedvar<-1
# minbetas<-1
# j<-1
# 
# for (i in nfirstvar_LUR_1 :nlastvar_LUR_1){
#   if (is.numeric(VGOB1_subsetJ_meca_LUR1[,i])==TRUE){
#     modeltry<-lm(VGOB1_subsetJ_meca_LUR1$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetJ_meca_LUR1[,models[[1]]$indexbestmodel]+VGOB1_subsetJ_meca_LUR1[,models[[2]]$indexbestmodel]+VGOB1_subsetJ_meca_LUR1[,models[[3]]$indexbestmodel]+VGOB1_subsetJ_meca_LUR1[,models[[4]]$indexbestmodel]+VGOB1_subsetJ_meca_LUR1[,models[[5]]$indexbestmodel]+VGOB1_subsetJ_meca_LUR1[,models[[6]]$indexbestmodel]+ VGOB1_subsetJ_meca_LUR1[,i]) 
#     R2<-rbind(R2,summary(modeltry)$adj.r.squared)
#     # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
#     betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
#     #  find out if there is a negative beta at All. The intercept does not count [-1]!
#     minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
#     # Measurements_livestockpreds_LUR1[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR1)[i]
#     addedvar<-rbind(addedvar,names(VGOB1_subsetJ_meca_LUR1)[i])
#     j<-rbind(j, i)
#     models[[modeln]][[i]]<-summary(modeltry)
#   }
# }
# 
# models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)
# 
# #  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
# models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)
# 
# # rank the R2's of these models
# models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))
# 
# #  this is the index of the row with the highest R2 and  no negative betas in this subset
# models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j
# 
# subset(models[[modeln]]$resultspos, rank==1)
# 
# # this is the model
# models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]
# 
# # here are the names
# models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetJ_meca_LUR1)[models[[1]]$indexbestmodel], names(VGOB1_subsetJ_meca_LUR1)[models[[2]]$indexbestmodel] , names(VGOB1_subsetJ_meca_LUR1)[models[[3]]$indexbestmodel], names(VGOB1_subsetJ_meca_LUR1)[models[[4]]$indexbestmodel], names(VGOB1_subsetJ_meca_LUR1)[models[[5]]$indexbestmodel], names(VGOB1_subsetJ_meca_LUR1)[models[[6]]$indexbestmodel], names(VGOB1_subsetJ_meca_LUR1)[models[[7]]$indexbestmodel])
# 
# #  this is the r2 or that model
# models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2
# 
# #  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
# models[[modeln]]$bestmodel <- lm(VGOB1_subsetJ_meca_LUR1$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetJ_meca_LUR1[,models[[1]]$indexbestmodel]+VGOB1_subsetJ_meca_LUR1[,models[[2]]$indexbestmodel]+VGOB1_subsetJ_meca_LUR1[,models[[3]]$indexbestmodel]+ VGOB1_subsetJ_meca_LUR1[,models[[4]]$indexbestmodel]+ VGOB1_subsetJ_meca_LUR1[,models[[5]]$indexbestmodel]+ VGOB1_subsetJ_meca_LUR1[,models[[6]]$indexbestmodel]+ VGOB1_subsetJ_meca_LUR1[,models[[7]]$indexbestmodel]) 
# 
# models[[1]]$summarybestmodel
# models[[2]]$summarybestmodel
# models[[3]]$summarybestmodel
# models[[4]]$summarybestmodel
# models[[5]]$summarybestmodel
# models[[6]]$summarybestmodel
# models[[7]]$summarybestmodel
# models[[1]]$namesbestmodel
# models[[2]]$namesbestmodel
# models[[3]]$namesbestmodel
# models[[4]]$namesbestmodel
# models[[5]]$namesbestmodel
# models[[6]]$namesbestmodel
# models[[7]]$namesbestmodel
# models[[1]]$R2bestmodel
# models[[2]]$R2bestmodel
# models[[3]]$R2bestmodel
# models[[4]]$R2bestmodel
# models[[5]]$R2bestmodel
# models[[6]]$R2bestmodel
# models[[7]]$R2bestmodel
# 
# # 8 #  
# # add eighth variable (the only difference of the above part is that now modeln=7 the model statement more variables)
# # and the call for the list of variable names in the model changed slightly
# 
# modeln<-8
# 
# models[[modeln]]<-list()
# 
# R2<-1
# addedvar<-1
# betaaddedvar<-1
# minbetas<-1
# j<-1
# 
# for (i in nfirstvar_LUR_1 :nlastvar_LUR_1){
#   if (is.numeric(VGOB1_subsetJ_meca_LUR1[,i])==TRUE){
#     modeltry<-lm(VGOB1_subsetJ_meca_LUR1$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetJ_meca_LUR1[,models[[1]]$indexbestmodel]+VGOB1_subsetJ_meca_LUR1[,models[[2]]$indexbestmodel]+VGOB1_subsetJ_meca_LUR1[,models[[3]]$indexbestmodel]+VGOB1_subsetJ_meca_LUR1[,models[[4]]$indexbestmodel]+VGOB1_subsetJ_meca_LUR1[,models[[5]]$indexbestmodel]+VGOB1_subsetJ_meca_LUR1[,models[[6]]$indexbestmodel]+ VGOB1_subsetJ_meca_LUR1[,models[[7]]$indexbestmodel]+ VGOB1_subsetJ_meca_LUR1[,i]) 
#     R2<-rbind(R2,summary(modeltry)$adj.r.squared)
#     # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
#     betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
#     #  find out if there is a negative beta at All. The intercept does not count [-1]!
#     minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
#     # Measurements_livestockpreds_LUR1[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR1)[i]
#     addedvar<-rbind(addedvar,names(VGOB1_subsetJ_meca_LUR1)[i])
#     j<-rbind(j, i)
#     models[[modeln]][[i]]<-summary(modeltry)
#   }
# }
# 
# models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)
# 
# #  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
# models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)
# 
# # rank the R2's of these models
# models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))
# 
# #  this is the index of the row with the highest R2 and  no negative betas in this subset
# models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j
# 
# subset(models[[modeln]]$resultspos, rank==1)
# 
# # this is the model
# models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]
# 
# # here are the names
# models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetJ_meca_LUR1)[models[[1]]$indexbestmodel], names(VGOB1_subsetJ_meca_LUR1)[models[[2]]$indexbestmodel] , names(VGOB1_subsetJ_meca_LUR1)[models[[3]]$indexbestmodel], names(VGOB1_subsetJ_meca_LUR1)[models[[4]]$indexbestmodel], names(VGOB1_subsetJ_meca_LUR1)[models[[5]]$indexbestmodel], names(VGOB1_subsetJ_meca_LUR1)[models[[6]]$indexbestmodel], names(VGOB1_subsetJ_meca_LUR1)[models[[7]]$indexbestmodel], names(VGOB1_subsetJ_meca_LUR1)[models[[8]]$indexbestmodel])
# 
# #  this is the r2 or that model
# models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2
# 
# #  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
# models[[modeln]]$bestmodel <- lm(VGOB1_subsetJ_meca_LUR1$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetJ_meca_LUR1[,models[[1]]$indexbestmodel]+VGOB1_subsetJ_meca_LUR1[,models[[2]]$indexbestmodel]+VGOB1_subsetJ_meca_LUR1[,models[[3]]$indexbestmodel]+ VGOB1_subsetJ_meca_LUR1[,models[[4]]$indexbestmodel]+ VGOB1_subsetJ_meca_LUR1[,models[[5]]$indexbestmodel]+ VGOB1_subsetJ_meca_LUR1[,models[[6]]$indexbestmodel]+ VGOB1_subsetJ_meca_LUR1[,models[[7]]$indexbestmodel]+ VGOB1_subsetJ_meca_LUR1[,models[[8]]$indexbestmodel]) 
# 
# models[[1]]$summarybestmodel
# models[[2]]$summarybestmodel
# models[[3]]$summarybestmodel
# models[[4]]$summarybestmodel
# models[[5]]$summarybestmodel
# models[[6]]$summarybestmodel
# models[[7]]$summarybestmodel
# models[[8]]$summarybestmodel
# models[[1]]$namesbestmodel
# models[[2]]$namesbestmodel
# models[[3]]$namesbestmodel
# models[[4]]$namesbestmodel
# models[[5]]$namesbestmodel
# models[[6]]$namesbestmodel
# models[[7]]$namesbestmodel
# models[[8]]$namesbestmodel
# models[[1]]$R2bestmodel
# models[[2]]$R2bestmodel
# models[[3]]$R2bestmodel
# models[[4]]$R2bestmodel
# models[[5]]$R2bestmodel
# models[[6]]$R2bestmodel
# models[[7]]$R2bestmodel
# models[[8]]$R2bestmodel


#   CODE FOR PICKING OUT THE BEST MODEL #   
temp <- 0
besti <- 0
for (i in 1:10){ #  think this runs the loop 10 times - not fully sure thought - but not to do with the number of models I don't think - as when I change to 3, I still get the model with 4 variables as best model
  print(models[[i]]$R2bestmodel)
  #       print(models[[i]]$summarybestmodel$coefficients=-1,4])
  #       if((models[[i]]$R2bestmodel-temp > 0.0) && (all(models[[i]]$summarybestmodel$coefficients[-1,4]<0.1))){
  #         temp <- models[[i]]$R2bestmodel
  #         besti <- i
  #         }
  if((models[[i]]$R2bestmodel-temp > 0.0) && (all(models[[i]]$summarybestmodel$coefficients[-1,4]<0.1))){
    temp <- models[[i]]$R2bestmodel
    besti <- i
  }else{
    finalBestModel_meca_LUR1_subsetJ <- models[[besti]]$bestmodel
    finalBestModelNames_meca_subsetJ <- models[[besti]]$namesbestmodel
    Sites <- 1:dim(VGOB1_subsetJ_meca_LUR1)[1] # full original model
    #  CVaR2<-escCV_meca_LUR1(Sites)[2] # Cross Validation
    maxCD<-max(cooks.distance(finalBestModel_meca_LUR1_subsetJ))
    if(length(finalBestModelNames_meca_subsetJ)<2){ # vif fn doesnot work when only 1 variable...       # 
      maxVIF<-"NA"
    }else{
      maxVIF<-max(vif(finalBestModel_meca_LUR1_subsetJ))
    }
    print(paste("This is the best meca model for subset J: ",besti,
                "(AdjR2: ",format(models[[besti]]$R2bestmodel,digits=3), "; MaxCD: ",format(maxCD,digits=3),"; MaxVIF: ",
                format(maxVIF,digits=3),")", sep=''))
    print(finalBestModelNames_meca_subsetJ)
    break
  }
}

#  Overview of the final best model using the algorithm selection process (taking into account VIF, R^2, and p-values)
finalBestModel_meca_LUR1_subsetJ
finalBestModelNames_meca_subsetJ
models[[besti]]$summarybestmodel
models[[besti]]$R2bestmodel

#### Predicting hold out sites ####
# These are the models from the 10 subsets: 
finalBestModel_meca_LUR1_subsetA
finalBestModel_meca_LUR1_subsetB
finalBestModel_meca_LUR1_subsetC
finalBestModel_meca_LUR1_subsetD
finalBestModel_meca_LUR1_subsetE
finalBestModel_meca_LUR1_subsetF
finalBestModel_meca_LUR1_subsetG
finalBestModel_meca_LUR1_subsetH
finalBestModel_meca_LUR1_subsetI
finalBestModel_meca_LUR1_subsetJ

#  Selecting of test sets
#  valID 1 to 10
VGOB1_subsetvalID1_meca_LUR1 <- subset(VGOB1_FINAL_meca_LUR1, valID == 1)
VGOB1_subsetvalID2_meca_LUR1 <- subset(VGOB1_FINAL_meca_LUR1, valID == 2)
VGOB1_subsetvalID3_meca_LUR1 <- subset(VGOB1_FINAL_meca_LUR1, valID == 3)
VGOB1_subsetvalID4_meca_LUR1 <- subset(VGOB1_FINAL_meca_LUR1, valID == 4)
VGOB1_subsetvalID5_meca_LUR1 <- subset(VGOB1_FINAL_meca_LUR1, valID == 5)
VGOB1_subsetvalID6_meca_LUR1 <- subset(VGOB1_FINAL_meca_LUR1, valID == 6)
VGOB1_subsetvalID7_meca_LUR1 <- subset(VGOB1_FINAL_meca_LUR1, valID == 7)
VGOB1_subsetvalID8_meca_LUR1 <- subset(VGOB1_FINAL_meca_LUR1, valID == 8)
VGOB1_subsetvalID9_meca_LUR1 <- subset(VGOB1_FINAL_meca_LUR1, valID == 9)
VGOB1_subsetvalID10_meca_LUR1 <- subset(VGOB1_FINAL_meca_LUR1, valID == 10)

#  For every subset predict (based on LUR model for that subset, so the training sites) the concentrations at the sites left out (test sites) to enable comparisons observed vs predicted 

#  Set 1
finalBestModel_meca_LUR1_subsetA
finalBestModelNames_meca_subsetA
summary(finalBestModel_meca_LUR1_subsetA)
# write the model out
finalBestModel_meca_LUR1_subsetA_lm <- lm(meca_copiespm3.ln.diffmeth.mean~  nAnyFarmWghtDist.3000m.sum.95Win.10to90scaled, data = VGOB1_subsetA_meca_LUR1)
VGOB1_subsetvalID1_meca_LUR1$meca_PRED_HV <- predict(finalBestModel_meca_LUR1_subsetA_lm,VGOB1_subsetvalID1_meca_LUR1)
summary(VGOB1_subsetvalID1_meca_LUR1$meca_PRED_HV)
plot(VGOB1_subsetvalID1_meca_LUR1$meca_PRED_HV, VGOB1_subsetvalID1_meca_LUR1$meca_copiespm3.ln.diffmeth.mean, xlab="meca predicted (HV)", ylab="meca concentration observed")
VGOB1_subsetvalID1_meca_LUR1_lm <- lm(meca_copiespm3.ln.diffmeth.mean~meca_PRED_HV, data=VGOB1_subsetvalID1_meca_LUR1 )
summary(VGOB1_subsetvalID1_meca_LUR1_lm)

#  Set 2
finalBestModel_meca_LUR1_subsetB
finalBestModelNames_meca_subsetB
summary(finalBestModel_meca_LUR1_subsetB)
# write the model out
finalBestModel_meca_LUR1_subsetB_lm <- lm(meca_copiespm3.ln.diffmeth.mean~ AllFarm.3000m.95Win.10to90scaled , data = VGOB1_subsetB_meca_LUR1)
VGOB1_subsetvalID2_meca_LUR1$meca_PRED_HV <- predict(finalBestModel_meca_LUR1_subsetB_lm,VGOB1_subsetvalID2_meca_LUR1)
summary(VGOB1_subsetvalID2_meca_LUR1$meca_PRED_HV)
plot(VGOB1_subsetvalID2_meca_LUR1$meca_PRED_HV, VGOB1_subsetvalID2_meca_LUR1$meca_copiespm3.ln.diffmeth.mean, xlab="meca predicted (HV)", ylab="meca concentration observed")
VGOB1_subsetvalID2_meca_LUR1_lm <- lm(meca_copiespm3.ln.diffmeth.mean~meca_PRED_HV, data=VGOB1_subsetvalID2_meca_LUR1)
summary(VGOB1_subsetvalID2_meca_LUR1_lm)

#  Set 3
finalBestModel_meca_LUR1_subsetC
finalBestModelNames_meca_subsetC
summary(finalBestModel_meca_LUR1_subsetC)
# write the model out
finalBestModel_meca_LUR1_subsetC_lm <- lm(meca_copiespm3.ln.diffmeth.mean~ AllFarm.3000m.95Win.10to90scaled , data = VGOB1_subsetC_meca_LUR1)
VGOB1_subsetvalID3_meca_LUR1$meca_PRED_HV <- predict(finalBestModel_meca_LUR1_subsetC_lm,VGOB1_subsetvalID3_meca_LUR1)
summary(VGOB1_subsetvalID3_meca_LUR1$meca_PRED_HV)
plot(VGOB1_subsetvalID3_meca_LUR1$meca_PRED_HV, VGOB1_subsetvalID3_meca_LUR1$meca_copiespm3.ln.diffmeth.mean, xlab="meca predicted (HV)", ylab="meca concentration observed")
VGOB1_subsetvalID3_meca_LUR1_lm <- lm(meca_copiespm3.ln.diffmeth.mean~meca_PRED_HV, data=VGOB1_subsetvalID3_meca_LUR1 )
summary(VGOB1_subsetvalID3_meca_LUR1_lm)

#  Set 4
finalBestModel_meca_LUR1_subsetD
finalBestModelNames_meca_subsetD
summary(finalBestModel_meca_LUR1_subsetD)
# write the model out
finalBestModel_meca_LUR1_subsetD_lm <- lm(meca_copiespm3.ln.diffmeth.mean~ AllFarm.3000m.95Win.10to90scaled, data = VGOB1_subsetD_meca_LUR1)
VGOB1_subsetvalID4_meca_LUR1$meca_PRED_HV <- predict(finalBestModel_meca_LUR1_subsetD_lm,VGOB1_subsetvalID4_meca_LUR1)
summary(VGOB1_subsetvalID4_meca_LUR1$meca_PRED_HV)
plot(VGOB1_subsetvalID4_meca_LUR1$meca_PRED_HV, VGOB1_subsetvalID4_meca_LUR1$meca_copiespm3.ln.diffmeth.mean, xlab="meca predicted (HV)", ylab="meca concentration observed")
VGOB1_subsetvalID4_meca_LUR1_lm <- lm(meca_copiespm3.ln.diffmeth.mean~meca_PRED_HV, data=VGOB1_subsetvalID4_meca_LUR1 )
summary(VGOB1_subsetvalID4_meca_LUR1_lm)

#  Set 5
finalBestModel_meca_LUR1_subsetE
finalBestModelNames_meca_subsetE
summary(finalBestModel_meca_LUR1_subsetE)
# write the model out
finalBestModel_meca_LUR1_subsetE_lm <- lm(meca_copiespm3.ln.diffmeth.mean~ AllFarm.3000m.95Win.10to90scaled, data = VGOB1_subsetE_meca_LUR1)
VGOB1_subsetvalID5_meca_LUR1$meca_PRED_HV <- predict(finalBestModel_meca_LUR1_subsetE_lm,VGOB1_subsetvalID5_meca_LUR1)
summary(VGOB1_subsetvalID5_meca_LUR1$meca_PRED_HV)
plot(VGOB1_subsetvalID5_meca_LUR1$meca_PRED_HV, VGOB1_subsetvalID5_meca_LUR1$meca_copiespm3.ln.diffmeth.mean, xlab="meca predicted (HV)", ylab="meca concentration observed")
VGOB1_subsetvalID5_meca_LUR1_lm <- lm(meca_copiespm3.ln.diffmeth.mean~meca_PRED_HV, data=VGOB1_subsetvalID5_meca_LUR1)
summary(VGOB1_subsetvalID5_meca_LUR1_lm)

#  Set 6
finalBestModel_meca_LUR1_subsetF
finalBestModelNames_meca_subsetF
summary(finalBestModel_meca_LUR1_subsetF)
# write the model out
finalBestModel_meca_LUR1_subsetF_lm <- lm(meca_copiespm3.ln.diffmeth.mean~ nAnyFarmWghtDist.3000m.sum.95Win.10to90scaled, data = VGOB1_subsetF_meca_LUR1)
VGOB1_subsetvalID6_meca_LUR1$meca_PRED_HV <- predict(finalBestModel_meca_LUR1_subsetF_lm,VGOB1_subsetvalID1_meca_LUR1)
summary(VGOB1_subsetvalID6_meca_LUR1$meca_PRED_HV)
plot(VGOB1_subsetvalID6_meca_LUR1$meca_PRED_HV, VGOB1_subsetvalID6_meca_LUR1$meca_copiespm3.ln.diffmeth.mean, xlab="meca predicted (HV)", ylab="meca concentration observed")
VGOB1_subsetvalID6_meca_LUR1_lm <- lm(meca_copiespm3.ln.diffmeth.mean~meca_PRED_HV, data=VGOB1_subsetvalID6_meca_LUR1 )
summary(VGOB1_subsetvalID6_meca_LUR1_lm)

#  Set 7
finalBestModel_meca_LUR1_subsetG
finalBestModelNames_meca_subsetG
summary(finalBestModel_meca_LUR1_subsetG)
# write the model out
finalBestModel_meca_LUR1_subsetG_lm <- lm(meca_copiespm3.ln.diffmeth.mean~ nAnyFarmWghtDist.3000m.sum.95Win.10to90scaled, data = VGOB1_subsetG_meca_LUR1)
VGOB1_subsetvalID7_meca_LUR1$meca_PRED_HV <- predict(finalBestModel_meca_LUR1_subsetG_lm,VGOB1_subsetvalID7_meca_LUR1)
summary(VGOB1_subsetvalID7_meca_LUR1$meca_PRED_HV)
plot(VGOB1_subsetvalID7_meca_LUR1$meca_PRED_HV, VGOB1_subsetvalID7_meca_LUR1$meca_copiespm3.ln.diffmeth.mean, xlab="meca predicted (HV)", ylab="meca concentration observed")
VGOB1_subsetvalID7_meca_LUR1_lm <- lm(meca_copiespm3.ln.diffmeth.mean~meca_PRED_HV, data=VGOB1_subsetvalID7_meca_LUR1)
summary(VGOB1_subsetvalID7_meca_LUR1_lm)

#  Set 8
finalBestModel_meca_LUR1_subsetH
finalBestModelNames_meca_subsetH
summary(finalBestModel_meca_LUR1_subsetH)
# write the model out
finalBestModel_meca_LUR1_subsetH_lm <- lm(meca_copiespm3.ln.diffmeth.mean~ AllFarm.3000m.95Win.10to90scaled, data = VGOB1_subsetH_meca_LUR1)
VGOB1_subsetvalID8_meca_LUR1$meca_PRED_HV <- predict(finalBestModel_meca_LUR1_subsetH_lm,VGOB1_subsetvalID8_meca_LUR1)
summary(VGOB1_subsetvalID8_meca_LUR1$meca_PRED_HV)
plot(VGOB1_subsetvalID8_meca_LUR1$meca_PRED_HV, VGOB1_subsetvalID8_meca_LUR1$meca_copiespm3.ln.diffmeth.mean, xlab="meca predicted (HV)", ylab="meca concentration observed")
VGOB1_subsetvalID8_meca_LUR1_lm <- lm(meca_copiespm3.ln.diffmeth.mean~meca_PRED_HV, data=VGOB1_subsetvalID8_meca_LUR1)
summary(VGOB1_subsetvalID8_meca_LUR1_lm)

#  Set 9
finalBestModel_meca_LUR1_subsetI
finalBestModelNames_meca_subsetI
summary(finalBestModel_meca_LUR1_subsetI)
# write the model out
finalBestModel_meca_LUR1_subsetI_lm <- lm(meca_copiespm3.ln.diffmeth.mean~ AllFarm.3000m.95Win.10to90scaled, data = VGOB1_subsetI_meca_LUR1)
VGOB1_subsetvalID9_meca_LUR1$meca_PRED_HV <- predict(finalBestModel_meca_LUR1_subsetI_lm,VGOB1_subsetvalID9_meca_LUR1)
summary(VGOB1_subsetvalID9_meca_LUR1$meca_PRED_HV)
plot(VGOB1_subsetvalID9_meca_LUR1$meca_PRED_HV, VGOB1_subsetvalID9_meca_LUR1$meca_copiespm3.ln.diffmeth.mean, xlab="meca predicted (HV)", ylab="meca concentration observed")
VGOB1_subsetvalID9_meca_LUR1_lm <- lm(meca_copiespm3.ln.diffmeth.mean~meca_PRED_HV, data=VGOB1_subsetvalID9_meca_LUR1 )
summary(VGOB1_subsetvalID9_meca_LUR1_lm)

#  Set 10
finalBestModel_meca_LUR1_subsetJ
finalBestModelNames_meca_subsetJ
summary(finalBestModel_meca_LUR1_subsetJ)
# write the model out
finalBestModel_meca_LUR1_subsetJ_lm <- lm(meca_copiespm3.ln.diffmeth.mean~AllFarm.3000m.95Win.10to90scaled, data = VGOB1_subsetJ_meca_LUR1)
VGOB1_subsetvalID10_meca_LUR1$meca_PRED_HV <- predict(finalBestModel_meca_LUR1_subsetJ_lm,VGOB1_subsetvalID10_meca_LUR1)
summary(VGOB1_subsetvalID10_meca_LUR1$meca_PRED_HV)
plot(VGOB1_subsetvalID10_meca_LUR1$meca_PRED_HV, VGOB1_subsetvalID10_meca_LUR1$meca_copiespm3.ln.diffmeth.mean, xlab="meca predicted (HV)", ylab="meca concentration observed")
VGOB1_subsetvalID10_meca_LUR1_lm <- lm(meca_copiespm3.ln.diffmeth.mean~meca_PRED_HV, data=VGOB1_subsetvalID10_meca_LUR1)
summary(VGOB1_subsetvalID10_meca_LUR1_lm)

# Calculate max VIF and cook's distnace of each subset (each fold of the 10-fold CV)
# Since all models only include 1 variable, VIF is not possible to calculate
maxCD_meca_LUR1_subsetA <- max(cooks.distance(finalBestModel_meca_LUR1_subsetA))
maxCD_meca_LUR1_subsetB <- max(cooks.distance(finalBestModel_meca_LUR1_subsetB))
maxCD_meca_LUR1_subsetC <- max(cooks.distance(finalBestModel_meca_LUR1_subsetC))
maxCD_meca_LUR1_subsetD <- max(cooks.distance(finalBestModel_meca_LUR1_subsetD))
maxCD_meca_LUR1_subsetE <- max(cooks.distance(finalBestModel_meca_LUR1_subsetE))
maxCD_meca_LUR1_subsetF <- max(cooks.distance(finalBestModel_meca_LUR1_subsetF))
maxCD_meca_LUR1_subsetG <- max(cooks.distance(finalBestModel_meca_LUR1_subsetG))
maxCD_meca_LUR1_subsetH <- max(cooks.distance(finalBestModel_meca_LUR1_subsetH))
maxCD_meca_LUR1_subsetI <- max(cooks.distance(finalBestModel_meca_LUR1_subsetI))
maxCD_meca_LUR1_subsetJ <- max(cooks.distance(finalBestModel_meca_LUR1_subsetJ))

meca_LUR1_maxCD_subsetvalID1to10 <- c(maxCD_meca_LUR1_subsetA, maxCD_meca_LUR1_subsetB, maxCD_meca_LUR1_subsetC, maxCD_meca_LUR1_subsetD, maxCD_meca_LUR1_subsetE, maxCD_meca_LUR1_subsetF, maxCD_meca_LUR1_subsetG, maxCD_meca_LUR1_subsetH, maxCD_meca_LUR1_subsetI, maxCD_meca_LUR1_subsetJ)

meca_LUR1_maxCD_df <- as.data.frame(meca_LUR1_maxCD_subsetvalID1to10)

row.names(meca_LUR1_maxCD_df) <- c("SubsetA", "SubsetB", "SubsetC", "SubsetD", "SubsetE", "SubsetF", "SubsetG", "SubsetH", "SubsetI", "SubsetJ")

write_xlsx(meca_LUR1_maxCD_df,"Output_files\\meca_LUR1_maxCD_df.xlsx")

#  Merging of all test sets to make overall comparisons of predicted vs observed
VGOB1_subsetvalID1to10_meca_LUR1_10foldCV <- rbind(VGOB1_subsetvalID1_meca_LUR1, VGOB1_subsetvalID2_meca_LUR1, VGOB1_subsetvalID3_meca_LUR1, VGOB1_subsetvalID4_meca_LUR1, VGOB1_subsetvalID5_meca_LUR1, VGOB1_subsetvalID6_meca_LUR1, VGOB1_subsetvalID7_meca_LUR1, VGOB1_subsetvalID8_meca_LUR1, VGOB1_subsetvalID9_meca_LUR1, VGOB1_subsetvalID10_meca_LUR1)

#  Overall comparison of predicted vs observed
plot(VGOB1_subsetvalID1to10_meca_LUR1_10foldCV$meca_PRED_HV, VGOB1_subsetvalID1to10_meca_LUR1_10foldCV$meca_copiespm3.ln.diffmeth.mean, xlab="LUR1-predicted meca DNA concentration (ln copies/m^3)", ylab="Observed meca DNA concentration (ln copies/m^3)", cex.lab=0.85)
abline(lm(VGOB1_subsetvalID1to10_meca_LUR1_10foldCV$meca_copiespm3.ln.diffmeth.mean ~ VGOB1_subsetvalID1to10_meca_LUR1_10foldCV$meca_PRED_HV))

VGOB1_subsetvalID1to10_meca_LUR1_10foldCV_lm <- lm(meca_copiespm3.ln.diffmeth.mean ~ meca_PRED_HV, data=VGOB1_subsetvalID1to10_meca_LUR1_10foldCV)
summary(VGOB1_subsetvalID1to10_meca_LUR1_10foldCV_lm)

# 10-fold CV multiple R2 for meca LUR1 = 0.1203

#  Calculate RMSE
RMSE_meca_LUR1_10foldCV <- sqrt(mean((VGOB1_subsetvalID1to10_meca_LUR1_10foldCV$meca_copiespm3.ln.diffmeth.mean - VGOB1_subsetvalID1to10_meca_LUR1_10foldCV$meca_PRED_HV)^2))
RMSE_meca_LUR1_10foldCV

# 10-fold RMSE for meca LUR1 = 0.8975063 

#  Save these predicted concentrations as an excel file along with the actual measured concentrations of meca at each of the measurement sites 
#  These are the predicted concentrations for the sites that were left out of the model training procedure in 10-fold cross validation 
meca_LUR1_10foldCV_preds <- VGOB1_subsetvalID1to10_meca_LUR1_10foldCV$meca_PRED_HV 
#  These are the actual measured concentrations at the 61 measurement sites - these are in the same order as the above sites in order to match the predicted concentrations (i.e. not in order 1-61)
VGOB1_subsetvalID1to10_meca_LUR1_10foldCV$meca_copiespm3.ln.diffmeth.mean

VGOB1_subsetvalID1to10_meca_LUR1_10foldCV$Loc_ID

#  Create a dataframe 
meca_SLR_10foldCVpreds_observed <- data.frame(VGOB1_subsetvalID1to10_meca_LUR1_10foldCV$Loc_ID,VGOB1_subsetvalID1to10_meca_LUR1_10foldCV$meca_copiespm3.ln.diffmeth.mean, VGOB1_subsetvalID1to10_meca_LUR1_10foldCV$meca_PRED_HV)
print(meca_SLR_10foldCVpreds_observed)

#  Save as xls file 
write_xlsx(meca_SLR_10foldCVpreds_observed,"Output_files//meca_LUR1_10foldCV_observed_predicted.xlsx")
```
#  meca LUR2
```{r}
#  Function building to run the models 
#  1 # 
models<-list()

modeln<-1
models[[modeln]]<-list()


R2<-1
betaaddedvar<-1
addedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR2:nlastvar_LUR2){
  if (is.numeric(Measurements_livestockpreds_LUR2[,i])==TRUE){
    modeltry<-lm(meca~Measurements_livestockpreds_LUR2[,i])                            
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    # find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # Measurements_livestockpreds_LUR2[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR2)[i]
    addedvar<-rbind(addedvar,names(Measurements_livestockpreds_LUR2)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)
models[[modeln]]$results

#  this are the candidates models with the highest R2, not a negative beta for the new, nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)
models[[modeln]]$resultspos

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))
models[[modeln]]$resultspos

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j
models[[modeln]]$indexbestmodel

subset(models[[modeln]]$resultspos, rank==1)
subset(models[[modeln]]$resultspos)

#  this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]
models[[modeln]]$summarybestmodel

# here are the names
models[[modeln]]$namesbestmodel<-c(names(Measurements_livestockpreds_LUR2)[models[[1]]$indexbestmodel])
models[[modeln]]$namesbestmodel

# this is the r2 of that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2
models[[modeln]]$R2bestmodel

# this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(meca~Measurements_livestockpreds_LUR2[,models[[1]]$indexbestmodel]) 
models[[modeln]]$bestmodel

summary(models[[modeln]]$bestmodel)


#  2 # 

#  Add 2nd variable (the only difference of the above part is that now modeln=2 the model statement has 2 variables)
#  and the cAll for the list of variable names in the model changed slightly

modeln<-2

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR2:nlastvar_LUR2){
  if (is.numeric(Measurements_livestockpreds_LUR2[,i])==TRUE){
    modeltry<-lm(meca~Measurements_livestockpreds_LUR2[,models[[1]]$indexbestmodel]+ Measurements_livestockpreds_LUR2[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    # find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # Measurements_livestockpreds_LUR2[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR2)[i]
    addedvar<-rbind(addedvar,names(Measurements_livestockpreds_LUR2)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  these are the candidate models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)
models[[modeln]]$resultspos

#  rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))
models[[modeln]]$resultspos

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j
models[[modeln]]$indexbestmodel

subset(models[[modeln]]$resultspos, rank==1)

# this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]
models[[modeln]]$summarybestmodel

# here are the names
models[[modeln]]$namesbestmodel<-c(names(Measurements_livestockpreds_LUR2)[models[[1]]$indexbestmodel], names(Measurements_livestockpreds_LUR2)[models[[2]]$indexbestmodel] )
models[[modeln]]$namesbestmodel

# this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2
models[[modeln]]$R2bestmodel

# this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(meca~Measurements_livestockpreds_LUR2[,models[[1]]$indexbestmodel]+Measurements_livestockpreds_LUR2[,models[[2]]$indexbestmodel]) 
models[[modeln]]$bestmodel

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel

models[[1]]$namesbestmodel
models[[2]]$namesbestmodel

models[[1]]$R2bestmodel
models[[2]]$R2bestmodel

#  at this point I always check whether the next model (with 2 variables) is more than 1% better than the one before and if not I end here
#  R2 of the second model is > 1% higher
#  Also check vif and cook's distance 
vif(models[[2]]$bestmodel) #  no VIF values are > 1
ols_plot_cooksd_bar(models[[2]]$bestmodel, print_plot = TRUE) #  no cook's distances are >1 


#  3 # 

#  add third variable (the only difference of the above part is that now modeln=3 the model statement has 3 variables)
#  and the cAll for the list of variable names in the model changed slightly

modeln<-3

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR2:nlastvar_LUR2){
  if (is.numeric(Measurements_livestockpreds_LUR2[,i])==TRUE){  
    modeltry<-lm(meca~Measurements_livestockpreds_LUR2[,models[[1]]$indexbestmodel]+Measurements_livestockpreds_LUR2[,models[[2]]$indexbestmodel]+ Measurements_livestockpreds_LUR2[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    # find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # All[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR2)[i]
    addedvar<-rbind(addedvar,names(Measurements_livestockpreds_LUR2)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))


#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

# this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

# here are the names
models[[modeln]]$namesbestmodel<-c(names(Measurements_livestockpreds_LUR2)[models[[1]]$indexbestmodel], names(Measurements_livestockpreds_LUR2)[models[[2]]$indexbestmodel] , names(Measurements_livestockpreds_LUR2)[models[[3]]$indexbestmodel])

# this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

# this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(meca~Measurements_livestockpreds_LUR2[,models[[1]]$indexbestmodel]+Measurements_livestockpreds_LUR2[,models[[2]]$indexbestmodel]+Measurements_livestockpreds_LUR2[,models[[3]]$indexbestmodel]) 

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel

models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel

models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel

#  Yes R^2 increases >1% 
#  Also check vif and cook's distance 
vif(models[[3]]$bestmodel) #  no VIF values are > 1
ols_plot_cooksd_bar(models[[3]]$bestmodel, print_plot = TRUE) #  no cook's distances are >1 


#  4 # 

#  add forth variable (the only difference of the above part is that now model n=4 the model statement more variables)
#  and the cAll for the list of variable names in the model changed slightly
modeln<-4

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1


for (i in nfirstvar_LUR2:nlastvar_LUR2){
  if (is.numeric(Measurements_livestockpreds_LUR2[,i])==TRUE){
    modeltry<-lm(meca~Measurements_livestockpreds_LUR2[,models[[1]]$indexbestmodel]+Measurements_livestockpreds_LUR2[,models[[2]]$indexbestmodel]+Measurements_livestockpreds_LUR2[,models[[3]]$indexbestmodel]+Measurements_livestockpreds_LUR2[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    # find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # All[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR2)[i]
    addedvar<-rbind(addedvar,names(Measurements_livestockpreds_LUR2)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

# this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

# here are the names
models[[modeln]]$namesbestmodel<-c(names(Measurements_livestockpreds_LUR2)[models[[1]]$indexbestmodel], names(Measurements_livestockpreds_LUR2)[models[[2]]$indexbestmodel] , names(Measurements_livestockpreds_LUR2)[models[[3]]$indexbestmodel], names(Measurements_livestockpreds_LUR2)[models[[4]]$indexbestmodel])

# this is the r2 of that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

# this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(meca~Measurements_livestockpreds_LUR2[,models[[1]]$indexbestmodel]+Measurements_livestockpreds_LUR2[,models[[2]]$indexbestmodel]+Measurements_livestockpreds_LUR2[,models[[3]]$indexbestmodel]+ Measurements_livestockpreds_LUR2[,models[[4]]$indexbestmodel]) 


models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel

#  R^2 increasese by > 1% 
#  Also check vif and cook's distance 
vif(models[[4]]$bestmodel) #  no VIF values are > 1 - approaching 3 (highest is 2.43)
ols_plot_cooksd_bar(models[[4]]$bestmodel, print_plot = TRUE) #  no cook's distances are >1 

#  5 # 
#  add fifth variable (the only difference of the above part is that now modeln=5 the model statement more variables)
#  and the cAll for the list of variable names in the model changed slightly
modeln<-5

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR2:nlastvar_LUR2){
  if (is.numeric(Measurements_livestockpreds_LUR2[,i])==TRUE){
    modeltry<-lm(meca~Measurements_livestockpreds_LUR2[,models[[1]]$indexbestmodel]+Measurements_livestockpreds_LUR2[,models[[2]]$indexbestmodel]+Measurements_livestockpreds_LUR2[,models[[3]]$indexbestmodel]+Measurements_livestockpreds_LUR2[,models[[4]]$indexbestmodel]+ Measurements_livestockpreds_LUR2[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    # find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # All[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR2)[i]
    addedvar<-rbind(addedvar,names(Measurements_livestockpreds_LUR2)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

#  this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

# here are the names
models[[modeln]]$namesbestmodel<-c(names(Measurements_livestockpreds_LUR2)[models[[1]]$indexbestmodel], names(Measurements_livestockpreds_LUR2)[models[[2]]$indexbestmodel] , names(Measurements_livestockpreds_LUR2)[models[[3]]$indexbestmodel], names(Measurements_livestockpreds_LUR2)[models[[4]]$indexbestmodel], names(Measurements_livestockpreds_LUR2)[models[[5]]$indexbestmodel])


# this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

# this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(meca~Measurements_livestockpreds_LUR2[,models[[1]]$indexbestmodel]+Measurements_livestockpreds_LUR2[,models[[2]]$indexbestmodel]+Measurements_livestockpreds_LUR2[,models[[3]]$indexbestmodel]+ Measurements_livestockpreds_LUR2[,models[[4]]$indexbestmodel]+ Measurements_livestockpreds_LUR2[,models[[5]]$indexbestmodel]) 


models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[5]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[5]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel
models[[5]]$R2bestmodel

#  at this point I always check whether the next model is more than 1% better than the one before and if not I end here
#  Yes model 5 is 1.3724% better than model 4 therefore I continue
#  Also check vif and cook's distance 
vif(models[[5]]$bestmodel) #  I have some values approaching 3 but not yet 3 (highest is 2.69)
ols_plot_cooksd_bar(models[[5]]$bestmodel, print_plot = TRUE) #  no cook's distances are >1 

#  6 # 
#  add sixth variable (the only difference of the above part is that now modeln=6 the modelstatement more variables)
#  and the cAll for the list of variable names in the model changed slightly

modeln<-6

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR2 :nlastvar_LUR2){
  if (is.numeric(Measurements_livestockpreds_LUR2[,i])==TRUE){
    modeltry<-lm(meca~Measurements_livestockpreds_LUR2[,models[[1]]$indexbestmodel]+Measurements_livestockpreds_LUR2[,models[[2]]$indexbestmodel]+Measurements_livestockpreds_LUR2[,models[[3]]$indexbestmodel]+Measurements_livestockpreds_LUR2[,models[[4]]$indexbestmodel]+Measurements_livestockpreds_LUR2[,models[[5]]$indexbestmodel]+ Measurements_livestockpreds_LUR2[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    # find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # All[,i] is the row that's being tried out now. the name of that row can be found in  names(All)[i]
    addedvar<-rbind(addedvar,names(Measurements_livestockpreds_LUR2)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

# this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

# here are the names
models[[modeln]]$namesbestmodel<-c(names(Measurements_livestockpreds_LUR2)[models[[1]]$indexbestmodel], names(Measurements_livestockpreds_LUR2)[models[[2]]$indexbestmodel] , names(Measurements_livestockpreds_LUR2)[models[[3]]$indexbestmodel], names(Measurements_livestockpreds_LUR2)[models[[4]]$indexbestmodel], names(Measurements_livestockpreds_LUR2)[models[[5]]$indexbestmodel], names(Measurements_livestockpreds_LUR2)[models[[6]]$indexbestmodel])

# this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

# this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(meca~Measurements_livestockpreds_LUR2[,models[[1]]$indexbestmodel]+Measurements_livestockpreds_LUR2[,models[[2]]$indexbestmodel]+Measurements_livestockpreds_LUR2[,models[[3]]$indexbestmodel]+ Measurements_livestockpreds_LUR2[,models[[4]]$indexbestmodel]+ Measurements_livestockpreds_LUR2[,models[[5]]$indexbestmodel]+ Measurements_livestockpreds_LUR2[,models[[6]]$indexbestmodel]) 

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[5]]$summarybestmodel
models[[6]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[5]]$namesbestmodel
models[[6]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel
models[[5]]$R2bestmodel
models[[6]]$R2bestmodel

#  7 # 
modeln<-7

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR2 :nlastvar_LUR2){
  if (is.numeric(Measurements_livestockpreds_LUR2[,i])==TRUE){
    modeltry<-lm(meca~Measurements_livestockpreds_LUR2[,models[[1]]$indexbestmodel]+Measurements_livestockpreds_LUR2[,models[[2]]$indexbestmodel]+Measurements_livestockpreds_LUR2[,models[[3]]$indexbestmodel]+Measurements_livestockpreds_LUR2[,models[[4]]$indexbestmodel]+Measurements_livestockpreds_LUR2[,models[[5]]$indexbestmodel]+Measurements_livestockpreds_LUR2[,models[[6]]$indexbestmodel]+ Measurements_livestockpreds_LUR2[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    # find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # Measurements_livestockpreds_LUR2[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR2)[i]
    addedvar<-rbind(addedvar,names(Measurements_livestockpreds_LUR2)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

# this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

# here are the names
models[[modeln]]$namesbestmodel<-c(names(Measurements_livestockpreds_LUR2)[models[[1]]$indexbestmodel], names(Measurements_livestockpreds_LUR2)[models[[2]]$indexbestmodel] , names(Measurements_livestockpreds_LUR2)[models[[3]]$indexbestmodel], names(Measurements_livestockpreds_LUR2)[models[[4]]$indexbestmodel], names(Measurements_livestockpreds_LUR2)[models[[5]]$indexbestmodel], names(Measurements_livestockpreds_LUR2)[models[[6]]$indexbestmodel],
names(Measurements_livestockpreds_LUR2)[models[[7]]$indexbestmodel])

# this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

# this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(meca~Measurements_livestockpreds_LUR2[,models[[1]]$indexbestmodel]+Measurements_livestockpreds_LUR2[,models[[2]]$indexbestmodel]+Measurements_livestockpreds_LUR2[,models[[3]]$indexbestmodel]+ Measurements_livestockpreds_LUR2[,models[[4]]$indexbestmodel]+ Measurements_livestockpreds_LUR2[,models[[5]]$indexbestmodel]+ Measurements_livestockpreds_LUR2[,models[[6]]$indexbestmodel]+
Measurements_livestockpreds_LUR2[,models[[7]]$indexbestmodel]) 

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[5]]$summarybestmodel
models[[6]]$summarybestmodel
models[[7]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[5]]$namesbestmodel
models[[6]]$namesbestmodel
models[[7]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel
models[[5]]$R2bestmodel
models[[6]]$R2bestmodel
models[[7]]$R2bestmodel

#  8 # 
#  add eighth variable (the only difference of the above part is that now modeln=8 the modelstatement more variables)
#  and the cAll for the list of variable names in the model changed slightly

modeln<-8

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR2 :nlastvar_LUR2){
  if (is.numeric(Measurements_livestockpreds_LUR2[,i])==TRUE){
    modeltry<-lm(meca~Measurements_livestockpreds_LUR2[,models[[1]]$indexbestmodel]+Measurements_livestockpreds_LUR2[,models[[2]]$indexbestmodel]+Measurements_livestockpreds_LUR2[,models[[3]]$indexbestmodel]+Measurements_livestockpreds_LUR2[,models[[4]]$indexbestmodel]+Measurements_livestockpreds_LUR2[,models[[5]]$indexbestmodel]+Measurements_livestockpreds_LUR2[,models[[6]]$indexbestmodel]+ Measurements_livestockpreds_LUR2[,models[[7]]$indexbestmodel]+ Measurements_livestockpreds_LUR2[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    # find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # Measurements_livestockpreds_LUR2[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR2)[i]
    addedvar<-rbind(addedvar,names(Measurements_livestockpreds_LUR2)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

# this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

# here are the names
models[[modeln]]$namesbestmodel<-c(names(Measurements_livestockpreds_LUR2)[models[[1]]$indexbestmodel], names(Measurements_livestockpreds_LUR2)[models[[2]]$indexbestmodel] , names(Measurements_livestockpreds_LUR2)[models[[3]]$indexbestmodel], names(Measurements_livestockpreds_LUR2)[models[[4]]$indexbestmodel], names(Measurements_livestockpreds_LUR2)[models[[5]]$indexbestmodel], names(Measurements_livestockpreds_LUR2)[models[[6]]$indexbestmodel],
names(Measurements_livestockpreds_LUR2)[models[[7]]$indexbestmodel],
names(Measurements_livestockpreds_LUR2)[models[[8]]$indexbestmodel] )

# this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

# this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(meca~Measurements_livestockpreds_LUR2[,models[[1]]$indexbestmodel]+Measurements_livestockpreds_LUR2[,models[[2]]$indexbestmodel]+Measurements_livestockpreds_LUR2[,models[[3]]$indexbestmodel]+ Measurements_livestockpreds_LUR2[,models[[4]]$indexbestmodel]+ Measurements_livestockpreds_LUR2[,models[[5]]$indexbestmodel]+ Measurements_livestockpreds_LUR2[,models[[6]]$indexbestmodel]+
Measurements_livestockpreds_LUR2[,models[[7]]$indexbestmodel] +Measurements_livestockpreds_LUR2[,models[[8]]$indexbestmodel]) 

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[5]]$summarybestmodel
models[[6]]$summarybestmodel
models[[7]]$summarybestmodel
models[[8]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[5]]$namesbestmodel
models[[6]]$namesbestmodel
models[[7]]$namesbestmodel
models[[8]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel
models[[5]]$R2bestmodel
models[[6]]$R2bestmodel
models[[7]]$R2bestmodel
models[[8]]$R2bestmodel

#  9 # 

modeln<-9

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR2 :nlastvar_LUR2){
  if (is.numeric(Measurements_livestockpreds_LUR2[,i])==TRUE){
    modeltry<-lm(meca~Measurements_livestockpreds_LUR2[,models[[1]]$indexbestmodel]+Measurements_livestockpreds_LUR2[,models[[2]]$indexbestmodel]+Measurements_livestockpreds_LUR2[,models[[3]]$indexbestmodel]+Measurements_livestockpreds_LUR2[,models[[4]]$indexbestmodel]+Measurements_livestockpreds_LUR2[,models[[5]]$indexbestmodel]+ Measurements_livestockpreds_LUR2[,models[[6]]$indexbestmodel]+ Measurements_livestockpreds_LUR2[,models[[7]]$indexbestmodel]+ Measurements_livestockpreds_LUR2[,models[[8]]$indexbestmodel]+ Measurements_livestockpreds_LUR2[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    # find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # Measurements_livestockpreds_LUR2[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR2)[i]
    addedvar<-rbind(addedvar,names(Measurements_livestockpreds_LUR2)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

# this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

# here are the names
models[[modeln]]$namesbestmodel<-c(names(Measurements_livestockpreds_LUR2)[models[[1]]$indexbestmodel], names(Measurements_livestockpreds_LUR2)[models[[2]]$indexbestmodel] , names(Measurements_livestockpreds_LUR2)[models[[3]]$indexbestmodel], names(Measurements_livestockpreds_LUR2)[models[[4]]$indexbestmodel], names(Measurements_livestockpreds_LUR2)[models[[5]]$indexbestmodel], names(Measurements_livestockpreds_LUR2)[models[[6]]$indexbestmodel], names(Measurements_livestockpreds_LUR2)[models[[7]]$indexbestmodel], names(Measurements_livestockpreds_LUR2)[models[[8]]$indexbestmodel], names(Measurements_livestockpreds_LUR2)[models[[9]]$indexbestmodel])

# this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

# this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(meca~Measurements_livestockpreds_LUR2[,models[[1]]$indexbestmodel]+Measurements_livestockpreds_LUR2[,models[[2]]$indexbestmodel]+Measurements_livestockpreds_LUR2[,models[[3]]$indexbestmodel]+ Measurements_livestockpreds_LUR2[,models[[4]]$indexbestmodel]+ Measurements_livestockpreds_LUR2[,models[[5]]$indexbestmodel]+ Measurements_livestockpreds_LUR2[,models[[6]]$indexbestmodel]+ Measurements_livestockpreds_LUR2[,models[[7]]$indexbestmodel]+ Measurements_livestockpreds_LUR2[,models[[8]]$indexbestmodel]+ Measurements_livestockpreds_LUR2[,models[[9]]$indexbestmodel]) 

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[5]]$summarybestmodel
models[[6]]$summarybestmodel
models[[7]]$summarybestmodel
models[[8]]$summarybestmodel
models[[9]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[5]]$namesbestmodel
models[[6]]$namesbestmodel
models[[7]]$namesbestmodel
models[[8]]$namesbestmodel
models[[9]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel
models[[5]]$R2bestmodel
models[[6]]$R2bestmodel
models[[7]]$R2bestmodel
models[[8]]$R2bestmodel
models[[9]]$R2bestmodel


#  at this point I always check wether the nextmodel is more than 1%better than the one before and if not I end here
#  last step is to exclude All var with p>0.1 one by one with the lowest p first, until All <0.1.
#  
 # #  10 #
 # modeln<-10
 # 
 # models[[modeln]]<-list()
 # 
 # R2<-1
 # addedvar<-1
 # betaaddedvar<-1
 # minbetas<-1
 # j<-1
 # 
 # for (i in nfirstvar_LUR2 :nlastvar_LUR2){
 #   if (is.numeric(Measurements_livestockpreds_LUR2[,i])==TRUE){
 #     modeltry<-lm(meca~Measurements_livestockpreds_LUR2[,models[[1]]$indexbestmodel]+Measurements_livestockpreds_LUR2[,models[[2]]$indexbestmodel]+Measurements_livestockpreds_LUR2[,models[[3]]$indexbestmodel]+Measurements_livestockpreds_LUR2[,models[[4]]$indexbestmodel]+Measurements_livestockpreds_LUR2[,models[[5]]$indexbestmodel]+ Measurements_livestockpreds_LUR2[,models[[6]]$indexbestmodel]+ Measurements_livestockpreds_LUR2[,models[[7]]$indexbestmodel]+ Measurements_livestockpreds_LUR2[,models[[8]]$indexbestmodel]+ Measurements_livestockpreds_LUR2[,models[[9]]$indexbestmodel]+ Measurements_livestockpreds_LUR2[,i])
 #     R2<-rbind(R2,summary(modeltry)$adj.r.squared)
 #     # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
 #     betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])#
 #     # find out if there is a negative beta at All. The intercept does not count [-1]!
 #     minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
 #     # Measurements_livestockpreds_LUR2[,i] is the row that's being tried out now. the name of that row can be found in  names(All)[i]
 #     addedvar<-rbind(addedvar,names(Measurements_livestockpreds_LUR2)[i])
 #     j<-rbind(j, i)
 #     models[[modeln]][[i]]<-summary(modeltry)
 #   }
 # }
 # 
 # models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)
 # 
 # #  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
 # models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)
 # 
 # # rank the R2's of these models
 # models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))
 # 
 # #  this is the index of the row with the highest R2 and  no negative betas in this subset
 # models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j
 # 
 # subset(models[[modeln]]$resultspos, rank==1)
 # 
 # # this is the model
 # models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]
 # 
 # # here are the names
 # models[[modeln]]$namesbestmodel<-c(names(Measurements_livestockpreds_LUR2)[models[[1]]$indexbestmodel], names(Measurements_livestockpreds_LUR2)[models[[2]]$indexbestmodel] , names(Measurements_livestockpreds_LUR2)[models[[3]]$indexbestmodel], names(Measurements_livestockpreds_LUR2)[models[[4]]$indexbestmodel], names(Measurements_livestockpreds_LUR2)[models[[5]]$indexbestmodel], names(Measurements_livestockpreds_LUR2)[models[[6]]$indexbestmodel], names(Measurements_livestockpreds_LUR2)[models[[7]]$indexbestmodel], names(Measurements_livestockpreds_LUR2)[models[[8]]$indexbestmodel], names(Measurements_livestockpreds_LUR2)[models[[9]]$indexbestmodel], names(Measurements_livestockpreds_LUR2)[models[[10]]$indexbestmodel])
 # 
 # # this is the r2 or that model
 # models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2
 # 
 # # this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
 # models[[modeln]]$bestmodel <- lm(meca~Measurements_livestockpreds_LUR2[,models[[1]]$indexbestmodel]+Measurements_livestockpreds_LUR2[,models[[2]]$indexbestmodel]+Measurements_livestockpreds_LUR2[,models[[3]]$indexbestmodel]+ Measurements_livestockpreds_LUR2[,models[[4]]$indexbestmodel]+ Measurements_livestockpreds_LUR2[,models[[5]]$indexbestmodel]+ Measurements_livestockpreds_LUR2[,models[[6]]$indexbestmodel]+ Measurements_livestockpreds_LUR2[,models[[7]]$indexbestmodel]+ Measurements_livestockpreds_LUR2[,models[[8]]$indexbestmodel]+ Measurements_livestockpreds_LUR2[,models[[9]]$indexbestmodel]+ Measurements_livestockpreds_LUR2[,models[[10]]$indexbestmodel])
 # 
 # models[[1]]$summarybestmodel
 # models[[2]]$summarybestmodel
 # models[[3]]$summarybestmodel
 # models[[4]]$summarybestmodel
 # models[[5]]$summarybestmodel
 # models[[6]]$summarybestmodel
 # models[[7]]$summarybestmodel
 # models[[8]]$summarybestmodel
 # models[[9]]$summarybestmodel
 # models[[10]]$summarybestmodel
 # models[[1]]$namesbestmodel
 # models[[2]]$namesbestmodel
 # models[[3]]$namesbestmodel
 # models[[4]]$namesbestmodel
 # models[[5]]$namesbestmodel
 # models[[6]]$namesbestmodel
 # models[[7]]$namesbestmodel
 # models[[8]]$namesbestmodel
 # models[[9]]$namesbestmodel
 # models[[10]]$namesbestmodel
 # models[[1]]$R2bestmodel
 # models[[2]]$R2bestmodel
 # models[[3]]$R2bestmodel
 # models[[4]]$R2bestmodel
 # models[[5]]$R2bestmodel
 # models[[6]]$R2bestmodel
 # models[[7]]$R2bestmodel
 # models[[8]]$R2bestmodel
 # models[[9]]$R2bestmodel
 # models[[10]]$R2bestmodel


#  CODE FOR PICKING OUT THE BEST MODEL #  
temp <- 0
besti <- 0
for (i in 1:10){ #  think this runs the loop 10 times - not fully sure thought - but not to do with the number of models I don't think - as when I change to 3, I still get the model with 4 variables as best model
  print(models[[i]]$R2bestmodel)
  #       print(models[[i]]$summarybestmodel$coefficients=-1,4])
  #       if((models[[i]]$R2bestmodel-temp > 0.0) && (all(models[[i]]$summarybestmodel$coefficients[-1,4]<0.1))){
  #         temp <- models[[i]]$R2bestmodel
  #         besti <- i
  #         }
  if((models[[i]]$R2bestmodel-temp > 0.0) && (all(models[[i]]$summarybestmodel$coefficients[-1,4]<0.1))){
    temp <- models[[i]]$R2bestmodel
    besti <- i
  }else{
    finalBestModel <- models[[besti]]$bestmodel
    finalBestModelNames <- models[[besti]]$namesbestmodel
    Sites <- 1:dim(Measurements_livestockpreds_LUR2)[1] # full original model
    #  CVaR2<-escCV_ecoli_LUR3(Sites)[2] # Cross Validation
    maxCD<-max(cooks.distance(finalBestModel))
    if(length(finalBestModelNames)<2){ # vif fn doesnot work when only 1 variable...       # 
      maxVIF<-"NA"
    }else{
      maxVIF<-max(vif(finalBestModel))
    }
    print(paste("This is the best meca LUR model 2: ",besti,
                "(AdjR2: ",format(models[[besti]]$R2bestmodel,digits=3), "; MaxCD: ",format(maxCD,digits=3),"; MaxVIF: ",
                format(maxVIF,digits=3),")", sep=''))
    print(finalBestModelNames)
    break
  }
}

#  the final best model includes the predictors: npoultryWghtDist.3000m.sum.95Win.10to90scaled + AllFarm.3000m.95Win.10to90scaled
meca_LUR2_algorithmmethod <- lm(meca_copiespm3.ln.diffmeth.mean~npoultryWghtDist.3000m.sum.95Win.10to90scaled + AllFarm.3000m.95Win.10to90scaled, data= Measurements_livestockpreds_LUR2)
summary(meca_LUR2_algorithmmethod)

# Calculate RMSE
predicted_meca_LUR2 <- predict(meca_LUR2_algorithmmethod, Measurements_livestockpreds_LUR2)
RMSE_meca_LUR2 <- sqrt(mean((Measurements_livestockpreds_LUR2$meca_copiespm3.ln.diffmeth.mean - predicted_meca_LUR2)^2))
RMSE_meca_LUR2

#  Save these predicted concentrations along with the measured concentrations as an excel file 
#  Create a dataframe 
meca_LUR2_preds_observed <- data.frame(Measurements_livestockpreds_LUR2$Loc_ID,Measurements_livestockpreds_LUR2$meca_copiespm3.ln.diffmeth.mean, predicted_meca_LUR2)
print(meca_LUR2_preds_observed)

#  Save as xls file 
write_xlsx(meca_LUR2_preds_observed,"Output_files//meca_LUR2_preds_observed.xlsx")

#  MODEL CHECKING # 
#  1)Check normality of residuals 
#  2)Check residuals for linearity, independence and homoscedasticity
#  3)Check multicollinearity (VIF)
#  4)Check influential points (Cook's Distance)

#  1) Normality of residuals
boxplot(residuals(meca_LUR2_algorithmmethod),main="boxplot of residuals - meca LUR model 2",xlab="LUR2 model residuals")
qqnorm(residuals(meca_LUR2_algorithmmethod),main="QQ-plot of residuals - meca LUR model 2",xlab="LUR2 model residuals")

#  2)Check residuals for linearity, independence and homoscedasticity
plot(fitted(meca_LUR2_algorithmmethod),residuals(meca_LUR2_algorithmmethod))

#  3)Check multicollinearity (VIF)
maxvif_meca_LUR2 <- max(vif(meca_LUR2_algorithmmethod))
maxvif_meca_LUR2

#  4)Check influential points (Cook's Distance)
ols_plot_cooksd_bar(meca_LUR2_algorithmmethod, print_plot = TRUE)
maxCD_meca_LUR2<-max(cooks.distance(meca_LUR2_algorithmmethod))
maxCD_meca_LUR2
#  won't remove any outliers - none with cook's d > 1 
```
# meca LUR2 model - LOOCV
```{r}
#  LOOCV - LUR model 2 for meca
#  Leave one out cross validation - the goal of cross validation is to get a generalized score of the model. The reason for this generalization is to, hopefully, improve the model’s effectiveness in predicting on future data inputs.
#  It is a type of 'internal' cross validation
Measurements_livestockpreds_LUR2_LOOCV <- Measurements_livestockpreds_LUR2
set.seed(123)
Measurements_livestockpreds_LUR2_LOOCV$meca_LUR2_LOOCV_PRED <- unlist(lapply(1:nrow(Measurements_livestockpreds_LUR2_LOOCV),function(inx){
  train <- Measurements_livestockpreds_LUR2_LOOCV[-inx,,drop=FALSE]
  test <- Measurements_livestockpreds_LUR2_LOOCV[inx,,drop=FALSE]
  cvm <- lm(meca_copiespm3.ln.diffmeth.mean ~ npoultryWghtDist.3000m.sum.95Win.10to90scaled + AllFarm.3000m.95Win.10to90scaled, data=train)
  pred <- predict(cvm,newdata=test)
  return(pred)
}))

predicted_meca_LUR1_LOOCV <- Measurements_livestockpreds_LUR1_LOOCV$meca_LUR1_LOOCV_PRED

#  Save these predicted concentrations along with the measured concentrations as an excel file 
#  Create a dataframe 
meca_LUR2_LOOCV_preds_observed <- data.frame(Measurements_livestockpreds_LUR2_LOOCV$Loc_ID,Measurements_livestockpreds_LUR2_LOOCV$meca_copiespm3.ln.diffmeth.mean, Measurements_livestockpreds_LUR2_LOOCV$meca_LUR2_LOOCV_PRED)
print(meca_LUR2_LOOCV_preds_observed)

#  Save as xls file 
write_xlsx(meca_LUR2_LOOCV_preds_observed,"Output_files//meca_LUR2_LOOCV_preds_observed.xlsx")

# Compute the LOOCV model R2
meca_LUR2_LOOCV_lm <- lm(meca_copiespm3.ln.diffmeth.mean ~ meca_LUR2_LOOCV_PRED, data=Measurements_livestockpreds_LUR2_LOOCV)
summary(meca_LUR2_LOOCV_lm)
#  meca LUR1 model LOOCV multiple R^2 = 0.3271

# Calculate RMSE
preds_meca_LUR2_LOOCV <- predict(meca_LUR2_LOOCV_lm, Measurements_livestockpreds_LUR2_LOOCV)
RMSE_meca_LUR2_LOOCV <- sqrt(mean((Measurements_livestockpreds_LUR2_LOOCV$meca_copiespm3.ln.diffmeth.mean - preds_meca_LUR2_LOOCV)^2))
RMSE_meca_LUR2_LOOCV

#  Plot LOOCV estimations vs. observed concentrations
plot(Measurements_livestockpreds_LUR2_LOOCV$meca_LUR2_LOOCV_PRED, Measurements_livestockpreds_LUR2_LOOCV$meca_copiespm3.ln.diffmeth.mean)
abline(lm(Measurements_livestockpreds_LUR2_LOOCV$meca_copiespm3.ln.diffmeth.mean ~ Measurements_livestockpreds_LUR2_LOOCV$meca_LUR2_LOOCV_PRED))
```
# meca LUR2 - 10-fold CV 
```{r}
options(stringsAsFactors = FALSE) # so that dataframes are not opened in new tabs

# This is the required dataset
Measurements_livestockpreds_LUR2 

#  10-fold hold-out validation is done to assess model robustness. This is done using a random selection of 90% of the measurement sites. 
#  Part 1. Each measurement site gets randomly allocated number out of range 1-10
#  Completely randomly pulling sites
meca_HV_LUR2_df <- Measurements_livestockpreds_LUR2[c(1,5,6:74)] #  new df created with only meca values 
#  Create valID variable 
meca_HV_LUR2_df$valID <- 0
#  Draw 10 samples, thus on average 6 sites per test set (i.e 6 sites are removed from each model and then the model is tested on these 6 sites )
set.seed(123)
VGOB1_FINAL_meca_LUR2 <- c()
for (s in 1:1){
  if (s==1) set <- meca_HV_LUR2_df
  draws <- c(1:nrow(set))
  chosen <- c()
  tempdraws <- draws
  for (d in 1:10){
    list <- sample(tempdraws, length(tempdraws)/(11-d), FALSE)
    set[list,]$valID <- d
    chosen <- c(chosen, list)
    tempdraws <- draws[-chosen]
  }

#  Combine datasets to 1
VGOB1_FINAL_meca_LUR2 <- set
}

summary(set)
rm(set)

#  View the df created
str(VGOB1_FINAL_meca_LUR2, list.len=ncol(VGOB1_FINAL_meca_LUR2))
names(VGOB1_FINAL_meca_LUR2)
summary(VGOB1_FINAL_meca_LUR2)

#  Part 2: Make 10 subsets of dataset based on randomly allocated number (so these are the training datasets) 
#  Then create 10 subsets, each excluding 1 set of 10 sites
VGOB1_subsetA_meca_LUR2 <- subset(VGOB1_FINAL_meca_LUR2, valID != 1)
VGOB1_subsetB_meca_LUR2 <- subset(VGOB1_FINAL_meca_LUR2, valID != 2)  
VGOB1_subsetC_meca_LUR2 <- subset(VGOB1_FINAL_meca_LUR2, valID != 3)
VGOB1_subsetD_meca_LUR2 <- subset(VGOB1_FINAL_meca_LUR2, valID != 4)
VGOB1_subsetE_meca_LUR2 <- subset(VGOB1_FINAL_meca_LUR2, valID != 5)
VGOB1_subsetF_meca_LUR2 <- subset(VGOB1_FINAL_meca_LUR2, valID != 6)
VGOB1_subsetG_meca_LUR2 <- subset(VGOB1_FINAL_meca_LUR2, valID != 7)
VGOB1_subsetH_meca_LUR2 <- subset(VGOB1_FINAL_meca_LUR2, valID != 8)
VGOB1_subsetI_meca_LUR2 <- subset(VGOB1_FINAL_meca_LUR2, valID != 9)
VGOB1_subsetJ_meca_LUR2 <- subset(VGOB1_FINAL_meca_LUR2, valID != 10)

#  Part 3: Build for each subset a LUR model (i.e. go through the whole LUR model script for each subset (so each training set). Start with subset A, until final LUR model. Then subset B, until final LUR model etc.) 

#### A ####
# LUR model building process for subset A
#  This is the dataframe with the relevant predictor vars for LUR2 models for subset A (55 sites)
VGOB1_subsetA_meca_LUR2 # n.b. this dataframe only includes microbial marker concentrations for meca unlike the dataframe Measurements_livestockpreds_LUR2 as previously used for the model building. 

#  Now set the values of some variables that will be needed
nfirstvar_LUR_2 <- 3  
nlastvar_LUR_2 <- 71

# Function building to run the models 
# 1 #  

models<-list()
modeln<-1
models[[modeln]]<-list()

R2<-1
betaaddedvar<-1
addedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_2:nlastvar_LUR_2){
  if (is.numeric(VGOB1_subsetA_meca_LUR2[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetA_meca_LUR2$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetA_meca_LUR2[,i])                            
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    #  Measurements_livestockpreds_LUR2[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR2)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetA_meca_LUR2)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)
models[[modeln]]$results

#  this are the candidates models with the highest R2, not a negative beta for the new, nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)
models[[modeln]]$resultspos

#  rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))
models[[modeln]]$resultspos

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j
models[[modeln]]$indexbestmodel

subset(models[[modeln]]$resultspos, rank==1)
subset(models[[modeln]]$resultspos)

#  this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]
models[[modeln]]$summarybestmodel

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetA_meca_LUR2)[models[[1]]$indexbestmodel])
models[[modeln]]$namesbestmodel

#  this is the r2 of that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2
models[[modeln]]$R2bestmodel

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetA_meca_LUR2$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetA_meca_LUR2[,models[[1]]$indexbestmodel]) 
models[[modeln]]$bestmodel

summary(models[[modeln]]$bestmodel)

#  The first model includes the predictor: nPigMultipFarmWghtDist.3000m.sum.Tr.1P9 - meaning the number of multiplier pig farms weighted to distance in a 3000m buffer

# 2 #  
# Add 2nd variable (the only difference of the above part is that now modeln=2 the model statement has 2 variables)
# and the call for the list of variable names in the model changed slightly

modeln<-2

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_2:nlastvar_LUR_2){
  if (is.numeric(VGOB1_subsetA_meca_LUR2[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetA_meca_LUR2$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetA_meca_LUR2[,models[[1]]$indexbestmodel]+ VGOB1_subsetA_meca_LUR2[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # Measurements_livestockpreds_LUR2[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR2)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetA_meca_LUR2)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  these are the candidate models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)
models[[modeln]]$resultspos

#  rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))
models[[modeln]]$resultspos

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j
models[[modeln]]$indexbestmodel

subset(models[[modeln]]$resultspos, rank==1)

# this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]
models[[modeln]]$summarybestmodel

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetA_meca_LUR2)[models[[1]]$indexbestmodel], names(VGOB1_subsetA_meca_LUR2)[models[[2]]$indexbestmodel] )
models[[modeln]]$namesbestmodel

# this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2
models[[modeln]]$R2bestmodel

# this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetA_meca_LUR2$meca_copiespm3.ln.diffmeth.mean~                               VGOB1_subsetA_meca_LUR2[,models[[1]]$indexbestmodel]+                           VGOB1_subsetA_meca_LUR2[,models[[2]]$indexbestmodel]) 

models[[modeln]]$bestmodel

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel


# 3 #  
# add third variable (the only difference of the above part is that now modeln=3 the model statement has 3 variables)
# and the call for the list of variable names in the model changed slightly

modeln<-3

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_2:nlastvar_LUR_2){
  if (is.numeric(VGOB1_subsetA_meca_LUR2[,i])==TRUE){  
    modeltry<-lm(VGOB1_subsetA_meca_LUR2$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetA_meca_LUR2[,models[[1]]$indexbestmodel]+VGOB1_subsetA_meca_LUR2[,models[[2]]$indexbestmodel]+ VGOB1_subsetA_meca_LUR2[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # All[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR2)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetA_meca_LUR2)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

#  rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

#  this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

#  here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetA_meca_LUR2)[models[[1]]$indexbestmodel], names(VGOB1_subsetA_meca_LUR2)[models[[2]]$indexbestmodel], names(VGOB1_subsetA_meca_LUR2)[models[[3]]$indexbestmodel])

#  this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetA_meca_LUR2$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetA_meca_LUR2[,models[[1]]$indexbestmodel]+ VGOB1_subsetA_meca_LUR2[,models[[2]]$indexbestmodel]+ VGOB1_subsetA_meca_LUR2[,models[[3]]$indexbestmodel]) 

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel


# 4 #  
#  add forth variable (the only difference of the above part is that now model n=4 the model statement more variables)
#  and the call for the list of variable names in the model changed slightly
modeln<-4

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1


for (i in nfirstvar_LUR_2:nlastvar_LUR_2){
  if (is.numeric(VGOB1_subsetA_meca_LUR2[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetA_meca_LUR2$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetA_meca_LUR2[,models[[1]]$indexbestmodel]+VGOB1_subsetA_meca_LUR2[,models[[2]]$indexbestmodel]+VGOB1_subsetA_meca_LUR2[,models[[3]]$indexbestmodel]+VGOB1_subsetA_meca_LUR2[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    #  the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    #  All[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR2)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetA_meca_LUR2)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

#  this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

#  here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetA_meca_LUR2)[models[[1]]$indexbestmodel], names(VGOB1_subsetA_meca_LUR2)[models[[2]]$indexbestmodel], names(VGOB1_subsetA_meca_LUR2)[models[[3]]$indexbestmodel], names(VGOB1_subsetA_meca_LUR2)[models[[4]]$indexbestmodel])

#  this is the r2 of that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetA_meca_LUR2$meca_copiespm3.ln.diffmeth.mean~ VGOB1_subsetA_meca_LUR2[,models[[1]]$indexbestmodel]+ VGOB1_subsetA_meca_LUR2[,models[[2]]$indexbestmodel]+VGOB1_subsetA_meca_LUR2[,models[[3]]$indexbestmodel]+ VGOB1_subsetA_meca_LUR2[,models[[4]]$indexbestmodel]) 


models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel


# 5 #  
# add fifth variable (the only difference of the above part is that now modeln=5 the model statement more variables)
# and the call for the list of variable names in the model changed slightly
modeln<-5

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_2:nlastvar_LUR_2){
  if (is.numeric(VGOB1_subsetA_meca_LUR2[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetA_meca_LUR2$meca_copiespm3.ln.diffmeth.mean~ VGOB1_subsetA_meca_LUR2[,models[[1]]$indexbestmodel]+ VGOB1_subsetA_meca_LUR2[,models[[2]]$indexbestmodel]+ VGOB1_subsetA_meca_LUR2[,models[[3]]$indexbestmodel]+ VGOB1_subsetA_meca_LUR2[,models[[4]]$indexbestmodel]+ VGOB1_subsetA_meca_LUR2[,i]) 
  
R2<-rbind(R2,summary(modeltry)$adj.r.squared)
# the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # All[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR2)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetA_meca_LUR2)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

#  this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetA_meca_LUR2)[models[[1]]$indexbestmodel], names(VGOB1_subsetA_meca_LUR2)[models[[2]]$indexbestmodel], names(VGOB1_subsetA_meca_LUR2)[models[[3]]$indexbestmodel], names(VGOB1_subsetA_meca_LUR2)[models[[4]]$indexbestmodel], names(VGOB1_subsetA_meca_LUR2)[models[[5]]$indexbestmodel])

#  this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetA_meca_LUR2$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetA_meca_LUR2[,models[[1]]$indexbestmodel]+VGOB1_subsetA_meca_LUR2[,models[[2]]$indexbestmodel]+VGOB1_subsetA_meca_LUR2[,models[[3]]$indexbestmodel]+ VGOB1_subsetA_meca_LUR2[,models[[4]]$indexbestmodel]+ VGOB1_subsetA_meca_LUR2[,models[[5]]$indexbestmodel]) 
models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[5]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[5]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel
models[[5]]$R2bestmodel

# 6 #  
# add sixth variable (the only difference of the above part is that now model n=6 the model statement more variables)
#  and the call for the list of variable names in the model changed slightly

modeln<-6

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_2 :nlastvar_LUR_2){
  if (is.numeric(VGOB1_subsetA_meca_LUR2[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetA_meca_LUR2$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetA_meca_LUR2[,models[[1]]$indexbestmodel]+VGOB1_subsetA_meca_LUR2[,models[[2]]$indexbestmodel]+VGOB1_subsetA_meca_LUR2[,models[[3]]$indexbestmodel]+VGOB1_subsetA_meca_LUR2[,models[[4]]$indexbestmodel]+VGOB1_subsetA_meca_LUR2[,models[[5]]$indexbestmodel]+ VGOB1_subsetA_meca_LUR2[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # All[,i] is the row that's being tried out now. the name of that row can be found in  names(All)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetA_meca_LUR2)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

# this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetA_meca_LUR2)[models[[1]]$indexbestmodel], names(VGOB1_subsetA_meca_LUR2)[models[[2]]$indexbestmodel] , names(VGOB1_subsetA_meca_LUR2)[models[[3]]$indexbestmodel], names(VGOB1_subsetA_meca_LUR2)[models[[4]]$indexbestmodel], names(VGOB1_subsetA_meca_LUR2)[models[[5]]$indexbestmodel], names(VGOB1_subsetA_meca_LUR2)[models[[6]]$indexbestmodel])

#  this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetA_meca_LUR2$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetA_meca_LUR2[,models[[1]]$indexbestmodel]+VGOB1_subsetA_meca_LUR2[,models[[2]]$indexbestmodel]+VGOB1_subsetA_meca_LUR2[,models[[3]]$indexbestmodel]+ VGOB1_subsetA_meca_LUR2[,models[[4]]$indexbestmodel]+ VGOB1_subsetA_meca_LUR2[,models[[5]]$indexbestmodel]+ VGOB1_subsetA_meca_LUR2[,models[[6]]$indexbestmodel]) 

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[5]]$summarybestmodel
models[[6]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[5]]$namesbestmodel
models[[6]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel
models[[5]]$R2bestmodel
models[[6]]$R2bestmodel


# 7 #  
# add seventh variable (the only difference of the above part is that now model n=7 the model statement more variables)
#  and the call for the list of variable names in the model changed slightly

modeln<-7

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_2 :nlastvar_LUR_2){
  if (is.numeric(VGOB1_subsetA_meca_LUR2[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetA_meca_LUR2$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetA_meca_LUR2[,models[[1]]$indexbestmodel]+VGOB1_subsetA_meca_LUR2[,models[[2]]$indexbestmodel]+VGOB1_subsetA_meca_LUR2[,models[[3]]$indexbestmodel]+VGOB1_subsetA_meca_LUR2[,models[[4]]$indexbestmodel]+VGOB1_subsetA_meca_LUR2[,models[[5]]$indexbestmodel]+VGOB1_subsetA_meca_LUR2[,models[[6]]$indexbestmodel]+ VGOB1_subsetA_meca_LUR2[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # Measurements_livestockpreds_LUR2[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR2)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetA_meca_LUR2)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

# this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetA_meca_LUR2)[models[[1]]$indexbestmodel], names(VGOB1_subsetA_meca_LUR2)[models[[2]]$indexbestmodel] , names(VGOB1_subsetA_meca_LUR2)[models[[3]]$indexbestmodel], names(VGOB1_subsetA_meca_LUR2)[models[[4]]$indexbestmodel], names(VGOB1_subsetA_meca_LUR2)[models[[5]]$indexbestmodel], names(VGOB1_subsetA_meca_LUR2)[models[[6]]$indexbestmodel], names(VGOB1_subsetA_meca_LUR2)[models[[7]]$indexbestmodel])

#  this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetA_meca_LUR2$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetA_meca_LUR2[,models[[1]]$indexbestmodel]+VGOB1_subsetA_meca_LUR2[,models[[2]]$indexbestmodel]+VGOB1_subsetA_meca_LUR2[,models[[3]]$indexbestmodel]+ VGOB1_subsetA_meca_LUR2[,models[[4]]$indexbestmodel]+ VGOB1_subsetA_meca_LUR2[,models[[5]]$indexbestmodel]+ VGOB1_subsetA_meca_LUR2[,models[[6]]$indexbestmodel]+ VGOB1_subsetA_meca_LUR2[,models[[7]]$indexbestmodel]) 

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[5]]$summarybestmodel
models[[6]]$summarybestmodel
models[[7]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[5]]$namesbestmodel
models[[6]]$namesbestmodel
models[[7]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel
models[[5]]$R2bestmodel
models[[6]]$R2bestmodel
models[[7]]$R2bestmodel

# 8 #  
# add eighth variable (the only difference of the above part is that now modeln=7 the model statement more variables)
# and the call for the list of variable names in the model changed slightly

modeln<-8

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_2 :nlastvar_LUR_2){
  if (is.numeric(VGOB1_subsetA_meca_LUR2[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetA_meca_LUR2$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetA_meca_LUR2[,models[[1]]$indexbestmodel]+VGOB1_subsetA_meca_LUR2[,models[[2]]$indexbestmodel]+VGOB1_subsetA_meca_LUR2[,models[[3]]$indexbestmodel]+VGOB1_subsetA_meca_LUR2[,models[[4]]$indexbestmodel]+VGOB1_subsetA_meca_LUR2[,models[[5]]$indexbestmodel]+VGOB1_subsetA_meca_LUR2[,models[[6]]$indexbestmodel]+ VGOB1_subsetA_meca_LUR2[,models[[7]]$indexbestmodel]+ VGOB1_subsetA_meca_LUR2[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # Measurements_livestockpreds_LUR2[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR2)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetA_meca_LUR2)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

# this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetA_meca_LUR2)[models[[1]]$indexbestmodel], names(VGOB1_subsetA_meca_LUR2)[models[[2]]$indexbestmodel] , names(VGOB1_subsetA_meca_LUR2)[models[[3]]$indexbestmodel], names(VGOB1_subsetA_meca_LUR2)[models[[4]]$indexbestmodel], names(VGOB1_subsetA_meca_LUR2)[models[[5]]$indexbestmodel], names(VGOB1_subsetA_meca_LUR2)[models[[6]]$indexbestmodel], names(VGOB1_subsetA_meca_LUR2)[models[[7]]$indexbestmodel], names(VGOB1_subsetA_meca_LUR2)[models[[8]]$indexbestmodel])

#  this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetA_meca_LUR2$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetA_meca_LUR2[,models[[1]]$indexbestmodel]+VGOB1_subsetA_meca_LUR2[,models[[2]]$indexbestmodel]+VGOB1_subsetA_meca_LUR2[,models[[3]]$indexbestmodel]+ VGOB1_subsetA_meca_LUR2[,models[[4]]$indexbestmodel]+ VGOB1_subsetA_meca_LUR2[,models[[5]]$indexbestmodel]+ VGOB1_subsetA_meca_LUR2[,models[[6]]$indexbestmodel]+ VGOB1_subsetA_meca_LUR2[,models[[7]]$indexbestmodel]+ VGOB1_subsetA_meca_LUR2[,models[[8]]$indexbestmodel]) 

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[5]]$summarybestmodel
models[[6]]$summarybestmodel
models[[7]]$summarybestmodel
models[[8]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[5]]$namesbestmodel
models[[6]]$namesbestmodel
models[[7]]$namesbestmodel
models[[8]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel
models[[5]]$R2bestmodel
models[[6]]$R2bestmodel
models[[7]]$R2bestmodel
models[[8]]$R2bestmodel

# The next part of the code (n=9-10) does not work
# This is because one of the coefficients included in the model with 6 variables is negative, the code does not allow for this. I can stop here.

# # 9 #  
# # add ninth variable (the only difference of the above part is that now modeln=9 the model statement more variables)
# # and the call for the list of variable names in the model changed slightly
# 
# modeln<-9
# 
# models[[modeln]]<-list()
# 
# R2<-1
# addedvar<-1
# betaaddedvar<-1
# minbetas<-1
# j<-1
# 
# for (i in nfirstvar_LUR_2 :nlastvar_LUR_2){
#   if (is.numeric(VGOB1_subsetA_meca_LUR2[,i])==TRUE){
#       modeltry<-lm(VGOB1_subsetA_meca_LUR2$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetA_meca_LUR2[,models[[1]]$indexbestmodel]+VGOB1_subsetA_meca_LUR2[,models[[2]]$indexbestmodel]+VGOB1_subsetA_meca_LUR2[,models[[3]]$indexbestmodel]+VGOB1_subsetA_meca_LUR2[,models[[4]]$indexbestmodel]+VGOB1_subsetA_meca_LUR2[,models[[5]]$indexbestmodel]+VGOB1_subsetA_meca_LUR2[,models[[6]]$indexbestmodel]+ VGOB1_subsetA_meca_LUR2[,models[[7]]$indexbestmodel]+ VGOB1_subsetA_meca_LUR2[,models[[8]]$indexbestmodel]+ VGOB1_subsetA_meca_LUR2[,i]) 
#         R2<-rbind(R2,summary(modeltry)$adj.r.squared)
#     # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
#     betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
#     #  find out if there is a negative beta at All. The intercept does not count [-1]!
#     minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
#     # Measurements_livestockpreds_LUR2[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR2)[i]
#     addedvar<-rbind(addedvar,names(VGOB1_subsetA_meca_LUR2)[i])
#     j<-rbind(j, i)
#     models[[modeln]][[i]]<-summary(modeltry)
#   }
# }
# 
# models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)
# 
# #  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
# models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)
# 
# # rank the R2's of these models
# models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))
# 
# #  this is the index of the row with the highest R2 and  no negative betas in this subset
# models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j
# 
# subset(models[[modeln]]$resultspos, rank==1)
# 
# # this is the model
# models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]
# 
# # here are the names
# models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetA_meca_LUR2)[models[[1]]$indexbestmodel], names(VGOB1_subsetA_meca_LUR2)[models[[2]]$indexbestmodel] , names(VGOB1_subsetA_meca_LUR2)[models[[3]]$indexbestmodel], names(VGOB1_subsetA_meca_LUR2)[models[[4]]$indexbestmodel], names(VGOB1_subsetA_meca_LUR2)[models[[5]]$indexbestmodel], names(VGOB1_subsetA_meca_LUR2)[models[[6]]$indexbestmodel], names(VGOB1_subsetA_meca_LUR2)[models[[7]]$indexbestmodel], names(VGOB1_subsetA_meca_LUR2)[models[[8]]$indexbestmodel],  names(VGOB1_subsetA_meca_LUR2)[models[[9]]$indexbestmodel])
# 
# #  this is the r2 or that model
# models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2
# 
# #  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
# models[[modeln]]$bestmodel <- lm(VGOB1_subsetA_meca_LUR2$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetA_meca_LUR2[,models[[1]]$indexbestmodel]+VGOB1_subsetA_meca_LUR2[,models[[2]]$indexbestmodel]+VGOB1_subsetA_meca_LUR2[,models[[3]]$indexbestmodel]+ VGOB1_subsetA_meca_LUR2[,models[[4]]$indexbestmodel]+ VGOB1_subsetA_meca_LUR2[,models[[5]]$indexbestmodel]+ VGOB1_subsetA_meca_LUR2[,models[[6]]$indexbestmodel]+ VGOB1_subsetA_meca_LUR2[,models[[7]]$indexbestmodel]+ VGOB1_subsetA_meca_LUR2[,models[[8]]$indexbestmodel]+ VGOB1_subsetA_meca_LUR2[,models[[9]]$indexbestmodel]) 
# 
# models[[1]]$summarybestmodel
# models[[2]]$summarybestmodel
# models[[3]]$summarybestmodel
# models[[4]]$summarybestmodel
# models[[5]]$summarybestmodel
# models[[6]]$summarybestmodel
# models[[7]]$summarybestmodel
# models[[8]]$summarybestmodel
# models[[9]]$summarybestmodel
# models[[1]]$namesbestmodel
# models[[2]]$namesbestmodel
# models[[3]]$namesbestmodel
# models[[4]]$namesbestmodel
# models[[5]]$namesbestmodel
# models[[6]]$namesbestmodel
# models[[7]]$namesbestmodel
# models[[8]]$namesbestmodel
# models[[9]]$namesbestmodel
# models[[1]]$R2bestmodel
# models[[2]]$R2bestmodel
# models[[3]]$R2bestmodel
# models[[4]]$R2bestmodel
# models[[5]]$R2bestmodel
# models[[6]]$R2bestmodel
# models[[7]]$R2bestmodel
# models[[8]]$R2bestmodel
# models[[9]]$R2bestmodel
# 
# # 10 #  
# #  add tenth variable (the only difference of the above part is that now model n=10 the model statement more variables)
# #  and the call for the list of variable names in the model changed slightly
# 
# modeln<-10
# 
# models[[modeln]]<-list()
# 
# R2<-1
# addedvar<-1
# betaaddedvar<-1
# minbetas<-1
# j<-1
# 
# for (i in nfirstvar_LUR_2 :nlastvar_LUR_2){if (is.numeric(VGOB1_subsetA_meca_LUR2[,i])==TRUE){ modeltry<-lm(VGOB1_subsetA_meca_LUR2$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetA_meca_LUR2[,models[[1]]$indexbestmodel]+VGOB1_subsetA_meca_LUR2[,models[[2]]$indexbestmodel]+ VGOB1_subsetA_meca_LUR2[,models[[3]]$indexbestmodel]+VGOB1_subsetA_meca_LUR2[,models[[4]]$indexbestmodel]+ VGOB1_subsetA_meca_LUR2[,models[[5]]$indexbestmodel]+ VGOB1_subsetA_meca_LUR2[,models[[6]]$indexbestmodel]+ VGOB1_subsetA_meca_LUR2[,models[[7]]$indexbestmodel]+ VGOB1_subsetA_meca_LUR2[,models[[8]]$indexbestmodel]+ VGOB1_subsetA_meca_LUR2[,models[[9]]$indexbestmodel]+ VGOB1_subsetA_meca_LUR2[,i]) 
# 
# R2<-rbind(R2,summary(modeltry)$adj.r.squared)
# # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
#     betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
#     #  find out if there is a negative beta at All. The intercept does not count [-1]!
#     minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
#     # Measurements_livestockpreds_LUR2[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR2)[i]
#     addedvar<-rbind(addedvar,names(VGOB1_subsetA_meca_LUR2)[i])
#     j<-rbind(j, i)
#     models[[modeln]][[i]]<-summary(modeltry)
#   }
# }
# 
# models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)
# 
# #  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
# models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)
# 
# # rank the R2's of these models
# models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))
# 
# #  this is the index of the row with the highest R2 and  no negative betas in this subset
# models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j
# 
# subset(models[[modeln]]$resultspos, rank==1)
# 
# # this is the model
# models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]
# 
# # here are the names
# models[[modeln]]$namesbestmodel<-c( names(VGOB1_subsetA_meca_LUR2)[models[[1]]$indexbestmodel],                   names(VGOB1_subsetA_meca_LUR2)[models[[2]]$indexbestmodel] , names(VGOB1_subsetA_meca_LUR2)[models[[3]]$indexbestmodel], names(VGOB1_subsetA_meca_LUR2)[models[[4]]$indexbestmodel], names(VGOB1_subsetA_meca_LUR2)[models[[5]]$indexbestmodel], names(VGOB1_subsetA_meca_LUR2)[models[[6]]$indexbestmodel], names(VGOB1_subsetA_meca_LUR2)[models[[7]]$indexbestmodel], names(VGOB1_subsetA_meca_LUR2)[models[[8]]$indexbestmodel], names(VGOB1_subsetA_meca_LUR2)[models[[9]]$indexbestmodel], names(VGOB1_subsetA_meca_LUR2)[models[[10]]$indexbestmodel])
# 
# #  this is the r2 or that model
# models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2
# 
# #  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
# models[[modeln]]$bestmodel <- lm(VGOB1_subsetA_meca_LUR2$meca_copiespm3.ln.diffmeth.mean~                                VGOB1_subsetA_meca_LUR2[,models[[1]]$indexbestmodel]+ VGOB1_subsetA_meca_LUR2[,models[[2]]$indexbestmodel]+                           VGOB1_subsetA_meca_LUR2[,models[[3]]$indexbestmodel]+ VGOB1_subsetA_meca_LUR2[,models[[4]]$indexbestmodel]+ VGOB1_subsetA_meca_LUR2[,models[[5]]$indexbestmodel]+ VGOB1_subsetA_meca_LUR2[,models[[6]]$indexbestmodel]+ VGOB1_subsetA_meca_LUR2[,models[[7]]$indexbestmodel]+ VGOB1_subsetA_meca_LUR2[,models[[8]]$indexbestmodel]+ VGOB1_subsetA_meca_LUR2[,models[[9]]$indexbestmodel]+ VGOB1_subsetA_meca_LUR2[,models[[10]]$indexbestmodel]) 
# 
# models[[1]]$summarybestmodel
# models[[2]]$summarybestmodel
# models[[3]]$summarybestmodel
# models[[4]]$summarybestmodel
# models[[5]]$summarybestmodel
# models[[6]]$summarybestmodel
# models[[7]]$summarybestmodel
# models[[8]]$summarybestmodel
# models[[9]]$summarybestmodel
# models[[10]]$summarybestmodel
# models[[1]]$namesbestmodel
# models[[2]]$namesbestmodel
# models[[3]]$namesbestmodel
# models[[4]]$namesbestmodel
# models[[5]]$namesbestmodel
# models[[6]]$namesbestmodel
# models[[7]]$namesbestmodel
# models[[8]]$namesbestmodel
# models[[9]]$namesbestmodel
# models[[10]]$namesbestmodel
# models[[1]]$R2bestmodel
# models[[2]]$R2bestmodel
# models[[3]]$R2bestmodel
# models[[4]]$R2bestmodel
# models[[5]]$R2bestmodel
# models[[6]]$R2bestmodel
# models[[7]]$R2bestmodel
# models[[8]]$R2bestmodel
# models[[9]]$R2bestmodel
# models[[10]]$R2bestmodel


#   CODE FOR PICKING OUT THE BEST MODEL #   
temp <- 0
besti <- 0
for (i in 1:10){ #  think this runs the loop 10 times - not fully sure thought - but not to do with the number of models I don't think - as when I change to 3, I still get the model with 4 variables as best model
  print(models[[i]]$R2bestmodel)
  #       print(models[[i]]$summarybestmodel$coefficients=-1,4])
  #       if((models[[i]]$R2bestmodel-temp > 0.0) && (all(models[[i]]$summarybestmodel$coefficients[-1,4]<0.1))){
  #         temp <- models[[i]]$R2bestmodel
  #         besti <- i
  #         }
  if((models[[i]]$R2bestmodel-temp > 0.0) && (all(models[[i]]$summarybestmodel$coefficients[-1,4]<0.1))){
    temp <- models[[i]]$R2bestmodel
    besti <- i
  }else{
    finalBestModel_meca_LUR2_subsetA <- models[[besti]]$bestmodel
    finalBestModelNames_meca_subsetA <- models[[besti]]$namesbestmodel
    Sites <- 1:dim(VGOB1_subsetA_meca_LUR2)[1] # full original model
    #  CVaR2<-escCV_meca_LUR2(Sites)[2] # Cross Validation
    maxCD<-max(cooks.distance(finalBestModel_meca_LUR2_subsetA))
    if(length(finalBestModelNames_meca_subsetA)<2){ # vif fn doesnot work when only 1 variable...       # 
      maxVIF<-"NA"
    }else{
      maxVIF<-max(vif(finalBestModel_meca_LUR2_subsetA))
    }
    print(paste("This is the best meca model for subset A: ",besti,
                "(AdjR2: ",format(models[[besti]]$R2bestmodel,digits=3), "; MaxCD: ",format(maxCD,digits=3),"; MaxVIF: ",
                format(maxVIF,digits=3),")", sep=''))
    print(finalBestModelNames_meca_subsetA)
    break
  }
}

#  Overview of the final best model using the algorithm selection process (taking into account VIF, R^2, and p-values)
finalBestModel_meca_LUR2_subsetA 
finalBestModelNames_meca_subsetA
models[[besti]]$summarybestmodel
models[[besti]]$R2bestmodel

#### B ####
# LUR model building process for subset B
# This is the dataframe with the relevant predictor vars for LUR2 models for subset B (55 sites)
VGOB1_subsetB_meca_LUR2 # n.b. this dataframe only includes microbial marker concentrations for meca unlike the dataframe Measurements_livestockpreds_LUR2 as previously used for the model building. 

#  Now set the values of some variables that will be needed
nfirstvar_LUR_2 <- 3  
nlastvar_LUR_2 <- 71

# Function building to run the models 
# 1 #  

models<-list()
modeln<-1
models[[modeln]]<-list()

R2<-1
betaaddedvar<-1
addedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_2:nlastvar_LUR_2){
  if (is.numeric(VGOB1_subsetB_meca_LUR2[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetB_meca_LUR2$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetB_meca_LUR2[,i])                            
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    #  Measurements_livestockpreds_LUR2[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR2)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetB_meca_LUR2)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)
models[[modeln]]$results

#  this are the candidates models with the highest R2, not a negative beta for the new, nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)
models[[modeln]]$resultspos

#  rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))
models[[modeln]]$resultspos

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j
models[[modeln]]$indexbestmodel

subset(models[[modeln]]$resultspos, rank==1)
subset(models[[modeln]]$resultspos)

#  this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]
models[[modeln]]$summarybestmodel

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetB_meca_LUR2)[models[[1]]$indexbestmodel])
models[[modeln]]$namesbestmodel

#  this is the r2 of that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2
models[[modeln]]$R2bestmodel

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetB_meca_LUR2$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetB_meca_LUR2[,models[[1]]$indexbestmodel]) 
models[[modeln]]$bestmodel

summary(models[[modeln]]$bestmodel)

#  The first model includes the predictor: nPigMultipFarmWghtDist.3000m.sum.Tr.1P9 - meaning the number of multiplier pig farms weighted to distance in a 3000m buffer

# 2 #  
# Add 2nd variable (the only difference of the above part is that now modeln=2 the model statement has 2 variables)
# and the call for the list of variable names in the model changed slightly

modeln<-2

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_2:nlastvar_LUR_2){
  if (is.numeric(VGOB1_subsetB_meca_LUR2[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetB_meca_LUR2$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetB_meca_LUR2[,models[[1]]$indexbestmodel]+ VGOB1_subsetB_meca_LUR2[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # Measurements_livestockpreds_LUR2[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR2)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetB_meca_LUR2)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  these are the candidate models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)
models[[modeln]]$resultspos

#  rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))
models[[modeln]]$resultspos

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j
models[[modeln]]$indexbestmodel

subset(models[[modeln]]$resultspos, rank==1)

# this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]
models[[modeln]]$summarybestmodel

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetB_meca_LUR2)[models[[1]]$indexbestmodel], names(VGOB1_subsetB_meca_LUR2)[models[[2]]$indexbestmodel] )
models[[modeln]]$namesbestmodel

# this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2
models[[modeln]]$R2bestmodel

# this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetB_meca_LUR2$meca_copiespm3.ln.diffmeth.mean~                               VGOB1_subsetB_meca_LUR2[,models[[1]]$indexbestmodel]+                           VGOB1_subsetB_meca_LUR2[,models[[2]]$indexbestmodel]) 

models[[modeln]]$bestmodel

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel


# 3 #  
# add third variable (the only difference of the above part is that now modeln=3 the model statement has 3 variables)
# and the call for the list of variable names in the model changed slightly

modeln<-3

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_2:nlastvar_LUR_2){
  if (is.numeric(VGOB1_subsetB_meca_LUR2[,i])==TRUE){  
    modeltry<-lm(VGOB1_subsetB_meca_LUR2$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetB_meca_LUR2[,models[[1]]$indexbestmodel]+VGOB1_subsetB_meca_LUR2[,models[[2]]$indexbestmodel]+ VGOB1_subsetB_meca_LUR2[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # All[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR2)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetB_meca_LUR2)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

#  rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

#  this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

#  here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetB_meca_LUR2)[models[[1]]$indexbestmodel], names(VGOB1_subsetB_meca_LUR2)[models[[2]]$indexbestmodel], names(VGOB1_subsetB_meca_LUR2)[models[[3]]$indexbestmodel])

#  this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetB_meca_LUR2$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetB_meca_LUR2[,models[[1]]$indexbestmodel]+ VGOB1_subsetB_meca_LUR2[,models[[2]]$indexbestmodel]+ VGOB1_subsetB_meca_LUR2[,models[[3]]$indexbestmodel]) 

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel


# 4 #  
#  add forth variable (the only difference of the above part is that now model n=4 the model statement more variables)
#  and the call for the list of variable names in the model changed slightly
modeln<-4

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1


for (i in nfirstvar_LUR_2:nlastvar_LUR_2){
  if (is.numeric(VGOB1_subsetB_meca_LUR2[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetB_meca_LUR2$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetB_meca_LUR2[,models[[1]]$indexbestmodel]+VGOB1_subsetB_meca_LUR2[,models[[2]]$indexbestmodel]+VGOB1_subsetB_meca_LUR2[,models[[3]]$indexbestmodel]+VGOB1_subsetB_meca_LUR2[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    #  the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    #  All[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR2)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetB_meca_LUR2)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

#  this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

#  here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetB_meca_LUR2)[models[[1]]$indexbestmodel], names(VGOB1_subsetB_meca_LUR2)[models[[2]]$indexbestmodel], names(VGOB1_subsetB_meca_LUR2)[models[[3]]$indexbestmodel], names(VGOB1_subsetB_meca_LUR2)[models[[4]]$indexbestmodel])

#  this is the r2 of that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetB_meca_LUR2$meca_copiespm3.ln.diffmeth.mean~ VGOB1_subsetB_meca_LUR2[,models[[1]]$indexbestmodel]+ VGOB1_subsetB_meca_LUR2[,models[[2]]$indexbestmodel]+ VGOB1_subsetB_meca_LUR2[,models[[3]]$indexbestmodel]+ VGOB1_subsetB_meca_LUR2[,models[[4]]$indexbestmodel]) 


models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel


# 5 #  
# add fifth variable (the only difference of the above part is that now modeln=5 the model statement more variables)
# and the call for the list of variable names in the model changed slightly
modeln<-5

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_2:nlastvar_LUR_2){
  if (is.numeric(VGOB1_subsetB_meca_LUR2[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetB_meca_LUR2$meca_copiespm3.ln.diffmeth.mean~ VGOB1_subsetB_meca_LUR2[,models[[1]]$indexbestmodel]+ VGOB1_subsetB_meca_LUR2[,models[[2]]$indexbestmodel]+ VGOB1_subsetB_meca_LUR2[,models[[3]]$indexbestmodel]+ VGOB1_subsetB_meca_LUR2[,models[[4]]$indexbestmodel]+ VGOB1_subsetB_meca_LUR2[,i]) 
  
R2<-rbind(R2,summary(modeltry)$adj.r.squared)
# the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # All[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR2)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetB_meca_LUR2)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

#  this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetB_meca_LUR2)[models[[1]]$indexbestmodel], names(VGOB1_subsetB_meca_LUR2)[models[[2]]$indexbestmodel], names(VGOB1_subsetB_meca_LUR2)[models[[3]]$indexbestmodel], names(VGOB1_subsetB_meca_LUR2)[models[[4]]$indexbestmodel], names(VGOB1_subsetB_meca_LUR2)[models[[5]]$indexbestmodel])

#  this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetB_meca_LUR2$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetB_meca_LUR2[,models[[1]]$indexbestmodel]+VGOB1_subsetB_meca_LUR2[,models[[2]]$indexbestmodel]+VGOB1_subsetB_meca_LUR2[,models[[3]]$indexbestmodel]+ VGOB1_subsetB_meca_LUR2[,models[[4]]$indexbestmodel]+ VGOB1_subsetB_meca_LUR2[,models[[5]]$indexbestmodel]) 
models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[5]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[5]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel
models[[5]]$R2bestmodel

# 6 #  
# add sixth variable (the only difference of the above part is that now model n=6 the model statement more variables)
#  and the call for the list of variable names in the model changed slightly

modeln<-6

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_2 :nlastvar_LUR_2){
  if (is.numeric(VGOB1_subsetB_meca_LUR2[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetB_meca_LUR2$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetB_meca_LUR2[,models[[1]]$indexbestmodel]+VGOB1_subsetB_meca_LUR2[,models[[2]]$indexbestmodel]+VGOB1_subsetB_meca_LUR2[,models[[3]]$indexbestmodel]+VGOB1_subsetB_meca_LUR2[,models[[4]]$indexbestmodel]+VGOB1_subsetB_meca_LUR2[,models[[5]]$indexbestmodel]+ VGOB1_subsetB_meca_LUR2[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # All[,i] is the row that's being tried out now. the name of that row can be found in  names(All)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetB_meca_LUR2)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

# this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetB_meca_LUR2)[models[[1]]$indexbestmodel], names(VGOB1_subsetB_meca_LUR2)[models[[2]]$indexbestmodel] , names(VGOB1_subsetB_meca_LUR2)[models[[3]]$indexbestmodel], names(VGOB1_subsetB_meca_LUR2)[models[[4]]$indexbestmodel], names(VGOB1_subsetB_meca_LUR2)[models[[5]]$indexbestmodel], names(VGOB1_subsetB_meca_LUR2)[models[[6]]$indexbestmodel])

#  this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetB_meca_LUR2$meca_copiespm3.ln.diffmeth.mean~ VGOB1_subsetB_meca_LUR2[,models[[1]]$indexbestmodel]+ VGOB1_subsetB_meca_LUR2[,models[[2]]$indexbestmodel]+ VGOB1_subsetB_meca_LUR2[,models[[3]]$indexbestmodel]+ VGOB1_subsetB_meca_LUR2[,models[[4]]$indexbestmodel]+ VGOB1_subsetB_meca_LUR2[,models[[5]]$indexbestmodel]+ VGOB1_subsetB_meca_LUR2[,models[[6]]$indexbestmodel]) 

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[5]]$summarybestmodel
models[[6]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[5]]$namesbestmodel
models[[6]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel
models[[5]]$R2bestmodel
models[[6]]$R2bestmodel


# 7 #  
# add seventh variable (the only difference of the above part is that now model n=7 the model statement more variables)
#  and the call for the list of variable names in the model changed slightly

modeln<-7

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_2 :nlastvar_LUR_2){
  if (is.numeric(VGOB1_subsetB_meca_LUR2[,i])==TRUE){
    modeltry<- lm(VGOB1_subsetB_meca_LUR2$meca_copiespm3.ln.diffmeth.mean~ VGOB1_subsetB_meca_LUR2[,models[[1]]$indexbestmodel]+ VGOB1_subsetB_meca_LUR2[,models[[2]]$indexbestmodel]+ VGOB1_subsetB_meca_LUR2[,models[[3]]$indexbestmodel]+ VGOB1_subsetB_meca_LUR2[,models[[4]]$indexbestmodel]+ VGOB1_subsetB_meca_LUR2[,models[[5]]$indexbestmodel]+ VGOB1_subsetB_meca_LUR2[,models[[6]]$indexbestmodel]+ VGOB1_subsetB_meca_LUR2[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # Measurements_livestockpreds_LUR2[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR2)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetB_meca_LUR2)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

# this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetB_meca_LUR2)[models[[1]]$indexbestmodel], names(VGOB1_subsetB_meca_LUR2)[models[[2]]$indexbestmodel] , names(VGOB1_subsetB_meca_LUR2)[models[[3]]$indexbestmodel], names(VGOB1_subsetB_meca_LUR2)[models[[4]]$indexbestmodel], names(VGOB1_subsetB_meca_LUR2)[models[[5]]$indexbestmodel], names(VGOB1_subsetB_meca_LUR2)[models[[6]]$indexbestmodel], names(VGOB1_subsetB_meca_LUR2)[models[[7]]$indexbestmodel])

#  this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetB_meca_LUR2$meca_copiespm3.ln.diffmeth.mean~ VGOB1_subsetB_meca_LUR2[,models[[1]]$indexbestmodel]+ VGOB1_subsetB_meca_LUR2[,models[[2]]$indexbestmodel]+ VGOB1_subsetB_meca_LUR2[,models[[3]]$indexbestmodel]+ VGOB1_subsetB_meca_LUR2[,models[[4]]$indexbestmodel]+ VGOB1_subsetB_meca_LUR2[,models[[5]]$indexbestmodel]+ VGOB1_subsetB_meca_LUR2[,models[[6]]$indexbestmodel]+ VGOB1_subsetB_meca_LUR2[,models[[7]]$indexbestmodel]) 

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[5]]$summarybestmodel
models[[6]]$summarybestmodel
models[[7]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[5]]$namesbestmodel
models[[6]]$namesbestmodel
models[[7]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel
models[[5]]$R2bestmodel
models[[6]]$R2bestmodel
models[[7]]$R2bestmodel

# 8 #  
# add eighth variable (the only difference of the above part is that now modeln=7 the model statement more variables)
# and the call for the list of variable names in the model changed slightly

modeln<-8

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_2 :nlastvar_LUR_2){
  if (is.numeric(VGOB1_subsetB_meca_LUR2[,i])==TRUE){
    modeltry<- lm(VGOB1_subsetB_meca_LUR2$meca_copiespm3.ln.diffmeth.mean~ VGOB1_subsetB_meca_LUR2[,models[[1]]$indexbestmodel]+ VGOB1_subsetB_meca_LUR2[,models[[2]]$indexbestmodel]+ VGOB1_subsetB_meca_LUR2[,models[[3]]$indexbestmodel]+ VGOB1_subsetB_meca_LUR2[,models[[4]]$indexbestmodel]+ VGOB1_subsetB_meca_LUR2[,models[[5]]$indexbestmodel]+ VGOB1_subsetB_meca_LUR2[,models[[6]]$indexbestmodel]+ VGOB1_subsetB_meca_LUR2[,models[[7]]$indexbestmodel]+ VGOB1_subsetB_meca_LUR2[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # Measurements_livestockpreds_LUR2[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR2)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetB_meca_LUR2)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

# this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetB_meca_LUR2)[models[[1]]$indexbestmodel], names(VGOB1_subsetB_meca_LUR2)[models[[2]]$indexbestmodel] , names(VGOB1_subsetB_meca_LUR2)[models[[3]]$indexbestmodel], names(VGOB1_subsetB_meca_LUR2)[models[[4]]$indexbestmodel], names(VGOB1_subsetB_meca_LUR2)[models[[5]]$indexbestmodel], names(VGOB1_subsetB_meca_LUR2)[models[[6]]$indexbestmodel], names(VGOB1_subsetB_meca_LUR2)[models[[7]]$indexbestmodel], names(VGOB1_subsetB_meca_LUR2)[models[[8]]$indexbestmodel])

#  this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetB_meca_LUR2$meca_copiespm3.ln.diffmeth.mean~ VGOB1_subsetB_meca_LUR2[,models[[1]]$indexbestmodel]+ VGOB1_subsetB_meca_LUR2[,models[[2]]$indexbestmodel]+ VGOB1_subsetB_meca_LUR2[,models[[3]]$indexbestmodel]+ VGOB1_subsetB_meca_LUR2[,models[[4]]$indexbestmodel]+ VGOB1_subsetB_meca_LUR2[,models[[5]]$indexbestmodel]+ VGOB1_subsetB_meca_LUR2[,models[[6]]$indexbestmodel]+ VGOB1_subsetB_meca_LUR2[,models[[7]]$indexbestmodel]+ VGOB1_subsetB_meca_LUR2[,models[[8]]$indexbestmodel]) 

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[5]]$summarybestmodel
models[[6]]$summarybestmodel
models[[7]]$summarybestmodel
models[[8]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[5]]$namesbestmodel
models[[6]]$namesbestmodel
models[[7]]$namesbestmodel
models[[8]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel
models[[5]]$R2bestmodel
models[[6]]$R2bestmodel
models[[7]]$R2bestmodel
models[[8]]$R2bestmodel


# The next part of the code (n=9-10) does not work
# This is because one of the coefficients included in the model with 6 variables is negative, the code does not allow for this. I can stop here.

# 9 #
# add ninth variable (the only difference of the above part is that now modeln=9 the model statement more variables)
# and the call for the list of variable names in the model changed slightly

modeln<-9

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_2 :nlastvar_LUR_2){
  if (is.numeric(VGOB1_subsetB_meca_LUR2[,i])==TRUE){
      modeltry<-lm(VGOB1_subsetB_meca_LUR2$meca_copiespm3.ln.diffmeth.mean~ VGOB1_subsetB_meca_LUR2[,models[[1]]$indexbestmodel]+ VGOB1_subsetB_meca_LUR2[,models[[2]]$indexbestmodel]+ VGOB1_subsetB_meca_LUR2[,models[[3]]$indexbestmodel]+ VGOB1_subsetB_meca_LUR2[,models[[4]]$indexbestmodel]+ VGOB1_subsetB_meca_LUR2[,models[[5]]$indexbestmodel]+ VGOB1_subsetB_meca_LUR2[,models[[6]]$indexbestmodel]+ VGOB1_subsetB_meca_LUR2[,models[[7]]$indexbestmodel]+ VGOB1_subsetB_meca_LUR2[,models[[8]]$indexbestmodel]+ VGOB1_subsetB_meca_LUR2[,i])
        R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])#
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # Measurements_livestockpreds_LUR2[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR2)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetB_meca_LUR2)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

# this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetB_meca_LUR2)[models[[1]]$indexbestmodel], names(VGOB1_subsetB_meca_LUR2)[models[[2]]$indexbestmodel] , names(VGOB1_subsetB_meca_LUR2)[models[[3]]$indexbestmodel], names(VGOB1_subsetB_meca_LUR2)[models[[4]]$indexbestmodel], names(VGOB1_subsetB_meca_LUR2)[models[[5]]$indexbestmodel], names(VGOB1_subsetB_meca_LUR2)[models[[6]]$indexbestmodel], names(VGOB1_subsetB_meca_LUR2)[models[[7]]$indexbestmodel], names(VGOB1_subsetB_meca_LUR2)[models[[8]]$indexbestmodel],  names(VGOB1_subsetB_meca_LUR2)[models[[9]]$indexbestmodel])

#  this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetB_meca_LUR2$meca_copiespm3.ln.diffmeth.mean~ VGOB1_subsetB_meca_LUR2[,models[[1]]$indexbestmodel]+ VGOB1_subsetB_meca_LUR2[,models[[2]]$indexbestmodel]+ VGOB1_subsetB_meca_LUR2[,models[[3]]$indexbestmodel]+ VGOB1_subsetB_meca_LUR2[,models[[4]]$indexbestmodel]+ VGOB1_subsetB_meca_LUR2[,models[[5]]$indexbestmodel]+ VGOB1_subsetB_meca_LUR2[,models[[6]]$indexbestmodel]+ VGOB1_subsetB_meca_LUR2[,models[[7]]$indexbestmodel]+ VGOB1_subsetB_meca_LUR2[,models[[8]]$indexbestmodel]+ VGOB1_subsetB_meca_LUR2[,models[[9]]$indexbestmodel])

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[5]]$summarybestmodel
models[[6]]$summarybestmodel
models[[7]]$summarybestmodel
models[[8]]$summarybestmodel
models[[9]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[5]]$namesbestmodel
models[[6]]$namesbestmodel
models[[7]]$namesbestmodel
models[[8]]$namesbestmodel
models[[9]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel
models[[5]]$R2bestmodel
models[[6]]$R2bestmodel
models[[7]]$R2bestmodel
models[[8]]$R2bestmodel
models[[9]]$R2bestmodel

# 10 #
#  add tenth variable (the only difference of the above part is that now model n=10 the model statement more variables)
#  and the call for the list of variable names in the model changed slightly

modeln<-10

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_2 :nlastvar_LUR_2){if (is.numeric(VGOB1_subsetB_meca_LUR2[,i])==TRUE){ modeltry<-lm(VGOB1_subsetB_meca_LUR2$meca_copiespm3.ln.diffmeth.mean~ VGOB1_subsetB_meca_LUR2[,models[[1]]$indexbestmodel]+ VGOB1_subsetB_meca_LUR2[,models[[2]]$indexbestmodel]+ VGOB1_subsetB_meca_LUR2[,models[[3]]$indexbestmodel]+ VGOB1_subsetB_meca_LUR2[,models[[4]]$indexbestmodel]+ VGOB1_subsetB_meca_LUR2[,models[[5]]$indexbestmodel]+ VGOB1_subsetB_meca_LUR2[,models[[6]]$indexbestmodel]+ VGOB1_subsetB_meca_LUR2[,models[[7]]$indexbestmodel]+ VGOB1_subsetB_meca_LUR2[,models[[8]]$indexbestmodel]+ VGOB1_subsetB_meca_LUR2[,models[[9]]$indexbestmodel]+ VGOB1_subsetB_meca_LUR2[,i])

R2<-rbind(R2,summary(modeltry)$adj.r.squared)
# the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])#
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # Measurements_livestockpreds_LUR2[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR2)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetB_meca_LUR2)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

# this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetB_meca_LUR2)[models[[1]]$indexbestmodel],    names(VGOB1_subsetB_meca_LUR2)[models[[2]]$indexbestmodel], names(VGOB1_subsetB_meca_LUR2)[models[[3]]$indexbestmodel], names(VGOB1_subsetB_meca_LUR2)[models[[4]]$indexbestmodel], names(VGOB1_subsetB_meca_LUR2)[models[[5]]$indexbestmodel], names(VGOB1_subsetB_meca_LUR2)[models[[6]]$indexbestmodel], names(VGOB1_subsetB_meca_LUR2)[models[[7]]$indexbestmodel], names(VGOB1_subsetB_meca_LUR2)[models[[8]]$indexbestmodel], names(VGOB1_subsetB_meca_LUR2)[models[[9]]$indexbestmodel], names(VGOB1_subsetB_meca_LUR2)[models[[10]]$indexbestmodel])

#  this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetB_meca_LUR2$meca_copiespm3.ln.diffmeth.mean~        VGOB1_subsetB_meca_LUR2[,models[[1]]$indexbestmodel]+ VGOB1_subsetB_meca_LUR2[,models[[2]]$indexbestmodel]+  VGOB1_subsetB_meca_LUR2[,models[[3]]$indexbestmodel]+ VGOB1_subsetB_meca_LUR2[,models[[4]]$indexbestmodel]+ VGOB1_subsetB_meca_LUR2[,models[[5]]$indexbestmodel]+ VGOB1_subsetB_meca_LUR2[,models[[6]]$indexbestmodel]+ VGOB1_subsetB_meca_LUR2[,models[[7]]$indexbestmodel]+ VGOB1_subsetB_meca_LUR2[,models[[8]]$indexbestmodel]+ VGOB1_subsetB_meca_LUR2[,models[[9]]$indexbestmodel]+ VGOB1_subsetB_meca_LUR2[,models[[10]]$indexbestmodel])

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[5]]$summarybestmodel
models[[6]]$summarybestmodel
models[[7]]$summarybestmodel
models[[8]]$summarybestmodel
models[[9]]$summarybestmodel
models[[10]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[5]]$namesbestmodel
models[[6]]$namesbestmodel
models[[7]]$namesbestmodel
models[[8]]$namesbestmodel
models[[9]]$namesbestmodel
models[[10]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel
models[[5]]$R2bestmodel
models[[6]]$R2bestmodel
models[[7]]$R2bestmodel
models[[8]]$R2bestmodel
models[[9]]$R2bestmodel
models[[10]]$R2bestmodel


#   CODE FOR PICKING OUT THE BEST MODEL #   
temp <- 0
besti <- 0
for (i in 1:10){ #  think this runs the loop 10 times - not fully sure thought - but not to do with the number of models I don't think - as when I change to 3, I still get the model with 4 variables as best model
  print(models[[i]]$R2bestmodel)
  #       print(models[[i]]$summarybestmodel$coefficients=-1,4])
  #       if((models[[i]]$R2bestmodel-temp > 0.0) && (all(models[[i]]$summarybestmodel$coefficients[-1,4]<0.1))){
  #         temp <- models[[i]]$R2bestmodel
  #         besti <- i
  #         }
  if((models[[i]]$R2bestmodel-temp > 0.0) && (all(models[[i]]$summarybestmodel$coefficients[-1,4]<0.1))){
    temp <- models[[i]]$R2bestmodel
    besti <- i
  }else{
    finalBestModel_meca_LUR2_subsetB <- models[[besti]]$bestmodel
    finalBestModelNames_meca_subsetB <- models[[besti]]$namesbestmodel
    Sites <- 1:dim(VGOB1_subsetB_meca_LUR2)[1] # full original model
    #  CVaR2<-escCV_meca_LUR2(Sites)[2] # Cross Validation
    maxCD<-max(cooks.distance(finalBestModel_meca_LUR2_subsetB))
    if(length(finalBestModelNames_meca_subsetB)<2){ # vif fn doesnot work when only 1 variable...       # 
      maxVIF<-"NA"
    }else{
      maxVIF<-max(vif(finalBestModel_meca_LUR2_subsetB))
    }
    print(paste("This is the best meca model for subset B of 10-fold CV: ",besti,
                "(AdjR2: ",format(models[[besti]]$R2bestmodel,digits=3), "; MaxCD: ",format(maxCD,digits=3),"; MaxVIF: ",
                format(maxVIF,digits=3),")", sep=''))
    print(finalBestModelNames_meca_subsetB)
    break
  }
}

#  Overview of the final best model using the algorithm selection process (taking into account VIF, R^2, and p-values)
finalBestModel_meca_LUR2_subsetB 
finalBestModelNames_meca_subsetB 
models[[besti]]$summarybestmodel
models[[besti]]$R2bestmodel

#### C ####
# LUR model building process for subset C
#  This is the dataframe with the relevant predictor vars for LUR2 models for subset C (55 sites)
VGOB1_subsetC_meca_LUR2 # n.b. this dataframe only includes microbial marker concentrations for meca unlike the dataframe Measurements_livestockpreds_LUR2 as previously used for the model building. 

#  Now set the values of some variables that will be needed
nfirstvar_LUR_2 <- 3  
nlastvar_LUR_2 <- 71

# Function building to run the models 
# 1 #  

models<-list()
modeln<-1
models[[modeln]]<-list()

R2<-1
betaaddedvar<-1
addedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_2:nlastvar_LUR_2){
  if (is.numeric(VGOB1_subsetC_meca_LUR2[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetC_meca_LUR2$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetC_meca_LUR2[,i])                            
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    #  Measurements_livestockpreds_LUR2[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR2)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetC_meca_LUR2)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)
models[[modeln]]$results

#  this are the candidates models with the highest R2, not a negative beta for the new, nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)
models[[modeln]]$resultspos

#  rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))
models[[modeln]]$resultspos

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j
models[[modeln]]$indexbestmodel

subset(models[[modeln]]$resultspos, rank==1)
subset(models[[modeln]]$resultspos)

#  this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]
models[[modeln]]$summarybestmodel

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetC_meca_LUR2)[models[[1]]$indexbestmodel])
models[[modeln]]$namesbestmodel

#  this is the r2 of that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2
models[[modeln]]$R2bestmodel

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetC_meca_LUR2$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetC_meca_LUR2[,models[[1]]$indexbestmodel]) 
models[[modeln]]$bestmodel

summary(models[[modeln]]$bestmodel)

#  The first model includes the predictor: nPigMultipFarmWghtDist.3000m.sum.Tr.1P9 - meaning the number of multiplier pig farms weighted to distance in a 3000m buffer

# 2 #  
# Add 2nd variable (the only difference of the above part is that now modeln=2 the model statement has 2 variables)
# and the call for the list of variable names in the model changed slightly

modeln<-2

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_2:nlastvar_LUR_2){
  if (is.numeric(VGOB1_subsetC_meca_LUR2[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetC_meca_LUR2$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetC_meca_LUR2[,models[[1]]$indexbestmodel]+ VGOB1_subsetC_meca_LUR2[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # Measurements_livestockpreds_LUR2[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR2)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetC_meca_LUR2)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  these are the candidate models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)
models[[modeln]]$resultspos

#  rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))
models[[modeln]]$resultspos

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j
models[[modeln]]$indexbestmodel

subset(models[[modeln]]$resultspos, rank==1)

# this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]
models[[modeln]]$summarybestmodel

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetC_meca_LUR2)[models[[1]]$indexbestmodel], names(VGOB1_subsetC_meca_LUR2)[models[[2]]$indexbestmodel] )
models[[modeln]]$namesbestmodel

# this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2
models[[modeln]]$R2bestmodel

# this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetC_meca_LUR2$meca_copiespm3.ln.diffmeth.mean~                               VGOB1_subsetC_meca_LUR2[,models[[1]]$indexbestmodel]+                           VGOB1_subsetC_meca_LUR2[,models[[2]]$indexbestmodel]) 

models[[modeln]]$bestmodel

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel


# 3 #  
# add third variable (the only difference of the above part is that now modeln=3 the model statement has 3 variables)
# and the call for the list of variable names in the model changed slightly

modeln<-3

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_2:nlastvar_LUR_2){
  if (is.numeric(VGOB1_subsetC_meca_LUR2[,i])==TRUE){  
    modeltry<-lm(VGOB1_subsetC_meca_LUR2$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetC_meca_LUR2[,models[[1]]$indexbestmodel]+VGOB1_subsetC_meca_LUR2[,models[[2]]$indexbestmodel]+ VGOB1_subsetC_meca_LUR2[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # All[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR2)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetC_meca_LUR2)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

#  rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

#  this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

#  here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetC_meca_LUR2)[models[[1]]$indexbestmodel], names(VGOB1_subsetC_meca_LUR2)[models[[2]]$indexbestmodel], names(VGOB1_subsetC_meca_LUR2)[models[[3]]$indexbestmodel])

#  this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetC_meca_LUR2$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetC_meca_LUR2[,models[[1]]$indexbestmodel]+ VGOB1_subsetC_meca_LUR2[,models[[2]]$indexbestmodel]+ VGOB1_subsetC_meca_LUR2[,models[[3]]$indexbestmodel]) 

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel


# 4 #  
#  add forth variable (the only difference of the above part is that now model n=4 the model statement more variables)
#  and the call for the list of variable names in the model changed slightly
modeln<-4

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1


for (i in nfirstvar_LUR_2:nlastvar_LUR_2){
  if (is.numeric(VGOB1_subsetC_meca_LUR2[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetC_meca_LUR2$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetC_meca_LUR2[,models[[1]]$indexbestmodel]+VGOB1_subsetC_meca_LUR2[,models[[2]]$indexbestmodel]+VGOB1_subsetC_meca_LUR2[,models[[3]]$indexbestmodel]+VGOB1_subsetC_meca_LUR2[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    #  the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    #  All[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR2)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetC_meca_LUR2)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

#  this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

#  here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetC_meca_LUR2)[models[[1]]$indexbestmodel], names(VGOB1_subsetC_meca_LUR2)[models[[2]]$indexbestmodel], names(VGOB1_subsetC_meca_LUR2)[models[[3]]$indexbestmodel], names(VGOB1_subsetC_meca_LUR2)[models[[4]]$indexbestmodel])

#  this is the r2 of that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetC_meca_LUR2$meca_copiespm3.ln.diffmeth.mean~ VGOB1_subsetC_meca_LUR2[,models[[1]]$indexbestmodel]+ VGOB1_subsetC_meca_LUR2[,models[[2]]$indexbestmodel]+VGOB1_subsetC_meca_LUR2[,models[[3]]$indexbestmodel]+ VGOB1_subsetC_meca_LUR2[,models[[4]]$indexbestmodel]) 


models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel


# 5 #  
# add fifth variable (the only difference of the above part is that now modeln=5 the model statement more variables)
# and the call for the list of variable names in the model changed slightly
modeln<-5

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_2:nlastvar_LUR_2){
  if (is.numeric(VGOB1_subsetC_meca_LUR2[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetC_meca_LUR2$meca_copiespm3.ln.diffmeth.mean~ VGOB1_subsetC_meca_LUR2[,models[[1]]$indexbestmodel]+ VGOB1_subsetC_meca_LUR2[,models[[2]]$indexbestmodel]+ VGOB1_subsetC_meca_LUR2[,models[[3]]$indexbestmodel]+ VGOB1_subsetC_meca_LUR2[,models[[4]]$indexbestmodel]+ VGOB1_subsetC_meca_LUR2[,i]) 
  
R2<-rbind(R2,summary(modeltry)$adj.r.squared)
# the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # All[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR2)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetC_meca_LUR2)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

#  this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetC_meca_LUR2)[models[[1]]$indexbestmodel], names(VGOB1_subsetC_meca_LUR2)[models[[2]]$indexbestmodel], names(VGOB1_subsetC_meca_LUR2)[models[[3]]$indexbestmodel], names(VGOB1_subsetC_meca_LUR2)[models[[4]]$indexbestmodel], names(VGOB1_subsetC_meca_LUR2)[models[[5]]$indexbestmodel])

#  this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetC_meca_LUR2$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetC_meca_LUR2[,models[[1]]$indexbestmodel]+VGOB1_subsetC_meca_LUR2[,models[[2]]$indexbestmodel]+VGOB1_subsetC_meca_LUR2[,models[[3]]$indexbestmodel]+ VGOB1_subsetC_meca_LUR2[,models[[4]]$indexbestmodel]+ VGOB1_subsetC_meca_LUR2[,models[[5]]$indexbestmodel]) 
models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[5]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[5]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel
models[[5]]$R2bestmodel

# 6 #  
# add sixth variable (the only difference of the above part is that now model n=6 the model statement more variables)
#  and the call for the list of variable names in the model changed slightly

modeln<-6

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_2 :nlastvar_LUR_2){
  if (is.numeric(VGOB1_subsetC_meca_LUR2[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetC_meca_LUR2$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetC_meca_LUR2[,models[[1]]$indexbestmodel]+VGOB1_subsetC_meca_LUR2[,models[[2]]$indexbestmodel]+VGOB1_subsetC_meca_LUR2[,models[[3]]$indexbestmodel]+VGOB1_subsetC_meca_LUR2[,models[[4]]$indexbestmodel]+VGOB1_subsetC_meca_LUR2[,models[[5]]$indexbestmodel]+ VGOB1_subsetC_meca_LUR2[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # All[,i] is the row that's being tried out now. the name of that row can be found in  names(All)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetC_meca_LUR2)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

# this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetC_meca_LUR2)[models[[1]]$indexbestmodel], names(VGOB1_subsetC_meca_LUR2)[models[[2]]$indexbestmodel] , names(VGOB1_subsetC_meca_LUR2)[models[[3]]$indexbestmodel], names(VGOB1_subsetC_meca_LUR2)[models[[4]]$indexbestmodel], names(VGOB1_subsetC_meca_LUR2)[models[[5]]$indexbestmodel], names(VGOB1_subsetC_meca_LUR2)[models[[6]]$indexbestmodel])

#  this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetC_meca_LUR2$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetC_meca_LUR2[,models[[1]]$indexbestmodel]+VGOB1_subsetC_meca_LUR2[,models[[2]]$indexbestmodel]+VGOB1_subsetC_meca_LUR2[,models[[3]]$indexbestmodel]+ VGOB1_subsetC_meca_LUR2[,models[[4]]$indexbestmodel]+ VGOB1_subsetC_meca_LUR2[,models[[5]]$indexbestmodel]+ VGOB1_subsetC_meca_LUR2[,models[[6]]$indexbestmodel]) 

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[5]]$summarybestmodel
models[[6]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[5]]$namesbestmodel
models[[6]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel
models[[5]]$R2bestmodel
models[[6]]$R2bestmodel


# 7 #  
# add seventh variable (the only difference of the above part is that now model n=7 the model statement more variables)
#  and the call for the list of variable names in the model changed slightly

modeln<-7

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_2 :nlastvar_LUR_2){
  if (is.numeric(VGOB1_subsetC_meca_LUR2[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetC_meca_LUR2$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetC_meca_LUR2[,models[[1]]$indexbestmodel]+VGOB1_subsetC_meca_LUR2[,models[[2]]$indexbestmodel]+VGOB1_subsetC_meca_LUR2[,models[[3]]$indexbestmodel]+VGOB1_subsetC_meca_LUR2[,models[[4]]$indexbestmodel]+VGOB1_subsetC_meca_LUR2[,models[[5]]$indexbestmodel]+VGOB1_subsetC_meca_LUR2[,models[[6]]$indexbestmodel]+ VGOB1_subsetC_meca_LUR2[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # Measurements_livestockpreds_LUR2[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR2)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetC_meca_LUR2)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

# this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetC_meca_LUR2)[models[[1]]$indexbestmodel], names(VGOB1_subsetC_meca_LUR2)[models[[2]]$indexbestmodel] , names(VGOB1_subsetC_meca_LUR2)[models[[3]]$indexbestmodel], names(VGOB1_subsetC_meca_LUR2)[models[[4]]$indexbestmodel], names(VGOB1_subsetC_meca_LUR2)[models[[5]]$indexbestmodel], names(VGOB1_subsetC_meca_LUR2)[models[[6]]$indexbestmodel], names(VGOB1_subsetC_meca_LUR2)[models[[7]]$indexbestmodel])

#  this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetC_meca_LUR2$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetC_meca_LUR2[,models[[1]]$indexbestmodel]+VGOB1_subsetC_meca_LUR2[,models[[2]]$indexbestmodel]+VGOB1_subsetC_meca_LUR2[,models[[3]]$indexbestmodel]+ VGOB1_subsetC_meca_LUR2[,models[[4]]$indexbestmodel]+ VGOB1_subsetC_meca_LUR2[,models[[5]]$indexbestmodel]+ VGOB1_subsetC_meca_LUR2[,models[[6]]$indexbestmodel]+ VGOB1_subsetC_meca_LUR2[,models[[7]]$indexbestmodel]) 

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[5]]$summarybestmodel
models[[6]]$summarybestmodel
models[[7]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[5]]$namesbestmodel
models[[6]]$namesbestmodel
models[[7]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel
models[[5]]$R2bestmodel
models[[6]]$R2bestmodel
models[[7]]$R2bestmodel

# 8 #  
# add eighth variable (the only difference of the above part is that now modeln=7 the model statement more variables)
# and the call for the list of variable names in the model changed slightly

modeln<-8

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_2 :nlastvar_LUR_2){
  if (is.numeric(VGOB1_subsetC_meca_LUR2[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetC_meca_LUR2$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetC_meca_LUR2[,models[[1]]$indexbestmodel]+VGOB1_subsetC_meca_LUR2[,models[[2]]$indexbestmodel]+VGOB1_subsetC_meca_LUR2[,models[[3]]$indexbestmodel]+VGOB1_subsetC_meca_LUR2[,models[[4]]$indexbestmodel]+VGOB1_subsetC_meca_LUR2[,models[[5]]$indexbestmodel]+VGOB1_subsetC_meca_LUR2[,models[[6]]$indexbestmodel]+ VGOB1_subsetC_meca_LUR2[,models[[7]]$indexbestmodel]+ VGOB1_subsetC_meca_LUR2[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # Measurements_livestockpreds_LUR2[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR2)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetC_meca_LUR2)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

# this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetC_meca_LUR2)[models[[1]]$indexbestmodel], names(VGOB1_subsetC_meca_LUR2)[models[[2]]$indexbestmodel] , names(VGOB1_subsetC_meca_LUR2)[models[[3]]$indexbestmodel], names(VGOB1_subsetC_meca_LUR2)[models[[4]]$indexbestmodel], names(VGOB1_subsetC_meca_LUR2)[models[[5]]$indexbestmodel], names(VGOB1_subsetC_meca_LUR2)[models[[6]]$indexbestmodel], names(VGOB1_subsetC_meca_LUR2)[models[[7]]$indexbestmodel], names(VGOB1_subsetC_meca_LUR2)[models[[8]]$indexbestmodel])

#  this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetC_meca_LUR2$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetC_meca_LUR2[,models[[1]]$indexbestmodel]+VGOB1_subsetC_meca_LUR2[,models[[2]]$indexbestmodel]+VGOB1_subsetC_meca_LUR2[,models[[3]]$indexbestmodel]+ VGOB1_subsetC_meca_LUR2[,models[[4]]$indexbestmodel]+ VGOB1_subsetC_meca_LUR2[,models[[5]]$indexbestmodel]+ VGOB1_subsetC_meca_LUR2[,models[[6]]$indexbestmodel]+ VGOB1_subsetC_meca_LUR2[,models[[7]]$indexbestmodel]+ VGOB1_subsetC_meca_LUR2[,models[[8]]$indexbestmodel]) 

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[5]]$summarybestmodel
models[[6]]$summarybestmodel
models[[7]]$summarybestmodel
models[[8]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[5]]$namesbestmodel
models[[6]]$namesbestmodel
models[[7]]$namesbestmodel
models[[8]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel
models[[5]]$R2bestmodel
models[[6]]$R2bestmodel
models[[7]]$R2bestmodel
models[[8]]$R2bestmodel

# 9 #  
# add ninth variable (the only difference of the above part is that now modeln=9 the model statement more variables)
# and the call for the list of variable names in the model changed slightly

modeln<-9

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_2 :nlastvar_LUR_2){
  if (is.numeric(VGOB1_subsetC_meca_LUR2[,i])==TRUE){
      modeltry<-lm(VGOB1_subsetC_meca_LUR2$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetC_meca_LUR2[,models[[1]]$indexbestmodel]+VGOB1_subsetC_meca_LUR2[,models[[2]]$indexbestmodel]+VGOB1_subsetC_meca_LUR2[,models[[3]]$indexbestmodel]+VGOB1_subsetC_meca_LUR2[,models[[4]]$indexbestmodel]+VGOB1_subsetC_meca_LUR2[,models[[5]]$indexbestmodel]+VGOB1_subsetC_meca_LUR2[,models[[6]]$indexbestmodel]+ VGOB1_subsetC_meca_LUR2[,models[[7]]$indexbestmodel]+ VGOB1_subsetC_meca_LUR2[,models[[8]]$indexbestmodel]+ VGOB1_subsetC_meca_LUR2[,i]) 
        R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # Measurements_livestockpreds_LUR2[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR2)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetC_meca_LUR2)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

# this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetC_meca_LUR2)[models[[1]]$indexbestmodel], names(VGOB1_subsetC_meca_LUR2)[models[[2]]$indexbestmodel] , names(VGOB1_subsetC_meca_LUR2)[models[[3]]$indexbestmodel], names(VGOB1_subsetC_meca_LUR2)[models[[4]]$indexbestmodel], names(VGOB1_subsetC_meca_LUR2)[models[[5]]$indexbestmodel], names(VGOB1_subsetC_meca_LUR2)[models[[6]]$indexbestmodel], names(VGOB1_subsetC_meca_LUR2)[models[[7]]$indexbestmodel], names(VGOB1_subsetC_meca_LUR2)[models[[8]]$indexbestmodel],  names(VGOB1_subsetC_meca_LUR2)[models[[9]]$indexbestmodel])

#  this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetC_meca_LUR2$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetC_meca_LUR2[,models[[1]]$indexbestmodel]+VGOB1_subsetC_meca_LUR2[,models[[2]]$indexbestmodel]+VGOB1_subsetC_meca_LUR2[,models[[3]]$indexbestmodel]+ VGOB1_subsetC_meca_LUR2[,models[[4]]$indexbestmodel]+ VGOB1_subsetC_meca_LUR2[,models[[5]]$indexbestmodel]+ VGOB1_subsetC_meca_LUR2[,models[[6]]$indexbestmodel]+ VGOB1_subsetC_meca_LUR2[,models[[7]]$indexbestmodel]+ VGOB1_subsetC_meca_LUR2[,models[[8]]$indexbestmodel]+ VGOB1_subsetC_meca_LUR2[,models[[9]]$indexbestmodel]) 

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[5]]$summarybestmodel
models[[6]]$summarybestmodel
models[[7]]$summarybestmodel
models[[8]]$summarybestmodel
models[[9]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[5]]$namesbestmodel
models[[6]]$namesbestmodel
models[[7]]$namesbestmodel
models[[8]]$namesbestmodel
models[[9]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel
models[[5]]$R2bestmodel
models[[6]]$R2bestmodel
models[[7]]$R2bestmodel
models[[8]]$R2bestmodel
models[[9]]$R2bestmodel

# 10 #  
#  add tenth variable (the only difference of the above part is that now model n=10 the model statement more variables)
#  and the call for the list of variable names in the model changed slightly

modeln<-10

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_2 :nlastvar_LUR_2){if (is.numeric(VGOB1_subsetC_meca_LUR2[,i])==TRUE){ modeltry<-lm(VGOB1_subsetC_meca_LUR2$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetC_meca_LUR2[,models[[1]]$indexbestmodel]+VGOB1_subsetC_meca_LUR2[,models[[2]]$indexbestmodel]+ VGOB1_subsetC_meca_LUR2[,models[[3]]$indexbestmodel]+VGOB1_subsetC_meca_LUR2[,models[[4]]$indexbestmodel]+ VGOB1_subsetC_meca_LUR2[,models[[5]]$indexbestmodel]+ VGOB1_subsetC_meca_LUR2[,models[[6]]$indexbestmodel]+ VGOB1_subsetC_meca_LUR2[,models[[7]]$indexbestmodel]+ VGOB1_subsetC_meca_LUR2[,models[[8]]$indexbestmodel]+ VGOB1_subsetC_meca_LUR2[,models[[9]]$indexbestmodel]+ VGOB1_subsetC_meca_LUR2[,i]) 

R2<-rbind(R2,summary(modeltry)$adj.r.squared)
# the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # Measurements_livestockpreds_LUR2[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR2)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetC_meca_LUR2)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

# this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

# here are the names
models[[modeln]]$namesbestmodel<-c( names(VGOB1_subsetC_meca_LUR2)[models[[1]]$indexbestmodel],                   names(VGOB1_subsetC_meca_LUR2)[models[[2]]$indexbestmodel] , names(VGOB1_subsetC_meca_LUR2)[models[[3]]$indexbestmodel], names(VGOB1_subsetC_meca_LUR2)[models[[4]]$indexbestmodel], names(VGOB1_subsetC_meca_LUR2)[models[[5]]$indexbestmodel], names(VGOB1_subsetC_meca_LUR2)[models[[6]]$indexbestmodel], names(VGOB1_subsetC_meca_LUR2)[models[[7]]$indexbestmodel], names(VGOB1_subsetC_meca_LUR2)[models[[8]]$indexbestmodel], names(VGOB1_subsetC_meca_LUR2)[models[[9]]$indexbestmodel], names(VGOB1_subsetC_meca_LUR2)[models[[10]]$indexbestmodel])

#  this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetC_meca_LUR2$meca_copiespm3.ln.diffmeth.mean~                                VGOB1_subsetC_meca_LUR2[,models[[1]]$indexbestmodel]+ VGOB1_subsetC_meca_LUR2[,models[[2]]$indexbestmodel]+                           VGOB1_subsetC_meca_LUR2[,models[[3]]$indexbestmodel]+ VGOB1_subsetC_meca_LUR2[,models[[4]]$indexbestmodel]+ VGOB1_subsetC_meca_LUR2[,models[[5]]$indexbestmodel]+ VGOB1_subsetC_meca_LUR2[,models[[6]]$indexbestmodel]+ VGOB1_subsetC_meca_LUR2[,models[[7]]$indexbestmodel]+ VGOB1_subsetC_meca_LUR2[,models[[8]]$indexbestmodel]+ VGOB1_subsetC_meca_LUR2[,models[[9]]$indexbestmodel]+ VGOB1_subsetC_meca_LUR2[,models[[10]]$indexbestmodel]) 

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[5]]$summarybestmodel
models[[6]]$summarybestmodel
models[[7]]$summarybestmodel
models[[8]]$summarybestmodel
models[[9]]$summarybestmodel
models[[10]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[5]]$namesbestmodel
models[[6]]$namesbestmodel
models[[7]]$namesbestmodel
models[[8]]$namesbestmodel
models[[9]]$namesbestmodel
models[[10]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel
models[[5]]$R2bestmodel
models[[6]]$R2bestmodel
models[[7]]$R2bestmodel
models[[8]]$R2bestmodel
models[[9]]$R2bestmodel
models[[10]]$R2bestmodel

#  at this point I always check whether the next model is more than 1% better than the one before and if not I end here

#   CODE FOR PICKING OUT THE BEST MODEL #   
temp <- 0
besti <- 0
for (i in 1:10){ #  think this runs the loop 10 times - not fully sure thought - but not to do with the number of models I don't think - as when I change to 3, I still get the model with 4 variables as best model
  print(models[[i]]$R2bestmodel)
  #       print(models[[i]]$summarybestmodel$coefficients=-1,4])
  #       if((models[[i]]$R2bestmodel-temp > 0.0) && (all(models[[i]]$summarybestmodel$coefficients[-1,4]<0.1))){
  #         temp <- models[[i]]$R2bestmodel
  #         besti <- i
  #         }
  if((models[[i]]$R2bestmodel-temp > 0.0) && (all(models[[i]]$summarybestmodel$coefficients[-1,4]<0.1))){
    temp <- models[[i]]$R2bestmodel
    besti <- i
  }else{
    finalBestModel_meca_LUR2_subsetC <- models[[besti]]$bestmodel
    finalBestModelNames_meca_subsetC <- models[[besti]]$namesbestmodel
    Sites <- 1:dim(VGOB1_subsetC_meca_LUR2)[1] # full original model
    #  CVaR2<-escCV_meca_LUR2(Sites)[2] # Cross Validation
    maxCD<-max(cooks.distance(finalBestModel_meca_LUR2_subsetC))
    if(length(finalBestModelNames_meca_subsetC)<2){ # vif fn doesnot work when only 1 variable...       # 
      maxVIF<-"NA"
    }else{
      maxVIF<-max(vif(finalBestModel_meca_LUR2_subsetC))
    }
    print(paste("This is the best meca model for subset C: ",besti,
                "(AdjR2: ",format(models[[besti]]$R2bestmodel,digits=3), "; MaxCD: ",format(maxCD,digits=3),"; MaxVIF: ",
                format(maxVIF,digits=3),")", sep=''))
    print(finalBestModelNames_meca_subsetC)
    break
  }
}

#  Overview of the final best model using the algorithm selection process (taking into account VIF, R^2, and p-values)
finalBestModel_meca_LUR2_subsetC
finalBestModelNames_meca_subsetC
models[[besti]]$summarybestmodel
models[[besti]]$R2bestmodel

#### D ####
# LUR model building process for subset D
#  This is the dataframe with the relevant predictor vars for LUR2 models for subset D (55 sites)
VGOB1_subsetD_meca_LUR2 # n.b. this dataframe only includes microbial marker concentrations for meca unlike the dataframe Measurements_livestockpreds_LUR2 as previously used for the model building. 

#  Now set the values of some variables that will be needed
nfirstvar_LUR_2 <- 3  
nlastvar_LUR_2 <- 71

# Function building to run the models 
# 1 #  

models<-list()
modeln<-1
models[[modeln]]<-list()

R2<-1
betaaddedvar<-1
addedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_2:nlastvar_LUR_2){
  if (is.numeric(VGOB1_subsetD_meca_LUR2[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetD_meca_LUR2$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetD_meca_LUR2[,i])                            
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    #  Measurements_livestockpreds_LUR2[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR2)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetD_meca_LUR2)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)
models[[modeln]]$results

#  this are the candidates models with the highest R2, not a negative beta for the new, nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)
models[[modeln]]$resultspos

#  rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))
models[[modeln]]$resultspos

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j
models[[modeln]]$indexbestmodel

subset(models[[modeln]]$resultspos, rank==1)
subset(models[[modeln]]$resultspos)

#  this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]
models[[modeln]]$summarybestmodel

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetD_meca_LUR2)[models[[1]]$indexbestmodel])
models[[modeln]]$namesbestmodel

#  this is the r2 of that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2
models[[modeln]]$R2bestmodel

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetD_meca_LUR2$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetD_meca_LUR2[,models[[1]]$indexbestmodel]) 
models[[modeln]]$bestmodel

summary(models[[modeln]]$bestmodel)

#  The first model includes the predictor: nPigMultipFarmWghtDist.3000m.sum.Tr.1P9 - meaning the number of multiplier pig farms weighted to distance in a 3000m buffer

# 2 #  
# Add 2nd variable (the only difference of the above part is that now modeln=2 the model statement has 2 variables)
# and the call for the list of variable names in the model changed slightly

modeln<-2

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_2:nlastvar_LUR_2){
  if (is.numeric(VGOB1_subsetD_meca_LUR2[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetD_meca_LUR2$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetD_meca_LUR2[,models[[1]]$indexbestmodel]+ VGOB1_subsetD_meca_LUR2[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # Measurements_livestockpreds_LUR2[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR2)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetD_meca_LUR2)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  these are the candidate models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)
models[[modeln]]$resultspos

#  rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))
models[[modeln]]$resultspos

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j
models[[modeln]]$indexbestmodel

subset(models[[modeln]]$resultspos, rank==1)

# this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]
models[[modeln]]$summarybestmodel

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetD_meca_LUR2)[models[[1]]$indexbestmodel], names(VGOB1_subsetD_meca_LUR2)[models[[2]]$indexbestmodel] )
models[[modeln]]$namesbestmodel

# this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2
models[[modeln]]$R2bestmodel

# this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetD_meca_LUR2$meca_copiespm3.ln.diffmeth.mean~                               VGOB1_subsetD_meca_LUR2[,models[[1]]$indexbestmodel]+                           VGOB1_subsetD_meca_LUR2[,models[[2]]$indexbestmodel]) 

models[[modeln]]$bestmodel

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel


# 3 #  
# add third variable (the only difference of the above part is that now modeln=3 the model statement has 3 variables)
# and the call for the list of variable names in the model changed slightly

modeln<-3

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_2:nlastvar_LUR_2){
  if (is.numeric(VGOB1_subsetD_meca_LUR2[,i])==TRUE){  
    modeltry<-lm(VGOB1_subsetD_meca_LUR2$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetD_meca_LUR2[,models[[1]]$indexbestmodel]+VGOB1_subsetD_meca_LUR2[,models[[2]]$indexbestmodel]+ VGOB1_subsetD_meca_LUR2[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # All[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR2)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetD_meca_LUR2)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

#  rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

#  this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

#  here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetD_meca_LUR2)[models[[1]]$indexbestmodel], names(VGOB1_subsetD_meca_LUR2)[models[[2]]$indexbestmodel], names(VGOB1_subsetD_meca_LUR2)[models[[3]]$indexbestmodel])

#  this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetD_meca_LUR2$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetD_meca_LUR2[,models[[1]]$indexbestmodel]+ VGOB1_subsetD_meca_LUR2[,models[[2]]$indexbestmodel]+ VGOB1_subsetD_meca_LUR2[,models[[3]]$indexbestmodel]) 

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel


# 4 #  
#  add forth variable (the only difference of the above part is that now model n=4 the model statement more variables)
#  and the call for the list of variable names in the model changed slightly
modeln<-4

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1


for (i in nfirstvar_LUR_2:nlastvar_LUR_2){
  if (is.numeric(VGOB1_subsetD_meca_LUR2[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetD_meca_LUR2$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetD_meca_LUR2[,models[[1]]$indexbestmodel]+VGOB1_subsetD_meca_LUR2[,models[[2]]$indexbestmodel]+VGOB1_subsetD_meca_LUR2[,models[[3]]$indexbestmodel]+VGOB1_subsetD_meca_LUR2[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    #  the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    #  All[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR2)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetD_meca_LUR2)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

#  this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

#  here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetD_meca_LUR2)[models[[1]]$indexbestmodel], names(VGOB1_subsetD_meca_LUR2)[models[[2]]$indexbestmodel], names(VGOB1_subsetD_meca_LUR2)[models[[3]]$indexbestmodel], names(VGOB1_subsetD_meca_LUR2)[models[[4]]$indexbestmodel])

#  this is the r2 of that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetD_meca_LUR2$meca_copiespm3.ln.diffmeth.mean~ VGOB1_subsetD_meca_LUR2[,models[[1]]$indexbestmodel]+ VGOB1_subsetD_meca_LUR2[,models[[2]]$indexbestmodel]+VGOB1_subsetD_meca_LUR2[,models[[3]]$indexbestmodel]+ VGOB1_subsetD_meca_LUR2[,models[[4]]$indexbestmodel]) 


models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel


# 5 #  
# add fifth variable (the only difference of the above part is that now modeln=5 the model statement more variables)
# and the call for the list of variable names in the model changed slightly
modeln<-5

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_2:nlastvar_LUR_2){
  if (is.numeric(VGOB1_subsetD_meca_LUR2[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetD_meca_LUR2$meca_copiespm3.ln.diffmeth.mean~ VGOB1_subsetD_meca_LUR2[,models[[1]]$indexbestmodel]+ VGOB1_subsetD_meca_LUR2[,models[[2]]$indexbestmodel]+ VGOB1_subsetD_meca_LUR2[,models[[3]]$indexbestmodel]+ VGOB1_subsetD_meca_LUR2[,models[[4]]$indexbestmodel]+ VGOB1_subsetD_meca_LUR2[,i]) 
  
R2<-rbind(R2,summary(modeltry)$adj.r.squared)
# the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # All[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR2)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetD_meca_LUR2)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

#  this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetD_meca_LUR2)[models[[1]]$indexbestmodel], names(VGOB1_subsetD_meca_LUR2)[models[[2]]$indexbestmodel], names(VGOB1_subsetD_meca_LUR2)[models[[3]]$indexbestmodel], names(VGOB1_subsetD_meca_LUR2)[models[[4]]$indexbestmodel], names(VGOB1_subsetD_meca_LUR2)[models[[5]]$indexbestmodel])

#  this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetD_meca_LUR2$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetD_meca_LUR2[,models[[1]]$indexbestmodel]+VGOB1_subsetD_meca_LUR2[,models[[2]]$indexbestmodel]+VGOB1_subsetD_meca_LUR2[,models[[3]]$indexbestmodel]+ VGOB1_subsetD_meca_LUR2[,models[[4]]$indexbestmodel]+ VGOB1_subsetD_meca_LUR2[,models[[5]]$indexbestmodel]) 
models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[5]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[5]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel
models[[5]]$R2bestmodel

# 6 #  
# add sixth variable (the only difference of the above part is that now model n=6 the model statement more variables)
#  and the call for the list of variable names in the model changed slightly

modeln<-6

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_2 :nlastvar_LUR_2){
  if (is.numeric(VGOB1_subsetD_meca_LUR2[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetD_meca_LUR2$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetD_meca_LUR2[,models[[1]]$indexbestmodel]+VGOB1_subsetD_meca_LUR2[,models[[2]]$indexbestmodel]+VGOB1_subsetD_meca_LUR2[,models[[3]]$indexbestmodel]+VGOB1_subsetD_meca_LUR2[,models[[4]]$indexbestmodel]+VGOB1_subsetD_meca_LUR2[,models[[5]]$indexbestmodel]+ VGOB1_subsetD_meca_LUR2[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # All[,i] is the row that's being tried out now. the name of that row can be found in  names(All)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetD_meca_LUR2)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

# this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetD_meca_LUR2)[models[[1]]$indexbestmodel], names(VGOB1_subsetD_meca_LUR2)[models[[2]]$indexbestmodel] , names(VGOB1_subsetD_meca_LUR2)[models[[3]]$indexbestmodel], names(VGOB1_subsetD_meca_LUR2)[models[[4]]$indexbestmodel], names(VGOB1_subsetD_meca_LUR2)[models[[5]]$indexbestmodel], names(VGOB1_subsetD_meca_LUR2)[models[[6]]$indexbestmodel])

#  this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetD_meca_LUR2$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetD_meca_LUR2[,models[[1]]$indexbestmodel]+VGOB1_subsetD_meca_LUR2[,models[[2]]$indexbestmodel]+VGOB1_subsetD_meca_LUR2[,models[[3]]$indexbestmodel]+ VGOB1_subsetD_meca_LUR2[,models[[4]]$indexbestmodel]+ VGOB1_subsetD_meca_LUR2[,models[[5]]$indexbestmodel]+ VGOB1_subsetD_meca_LUR2[,models[[6]]$indexbestmodel]) 

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[5]]$summarybestmodel
models[[6]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[5]]$namesbestmodel
models[[6]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel
models[[5]]$R2bestmodel
models[[6]]$R2bestmodel


# 7 #  
# add seventh variable (the only difference of the above part is that now model n=7 the model statement more variables)
#  and the call for the list of variable names in the model changed slightly

modeln<-7

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_2 :nlastvar_LUR_2){
  if (is.numeric(VGOB1_subsetD_meca_LUR2[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetD_meca_LUR2$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetD_meca_LUR2[,models[[1]]$indexbestmodel]+VGOB1_subsetD_meca_LUR2[,models[[2]]$indexbestmodel]+VGOB1_subsetD_meca_LUR2[,models[[3]]$indexbestmodel]+VGOB1_subsetD_meca_LUR2[,models[[4]]$indexbestmodel]+VGOB1_subsetD_meca_LUR2[,models[[5]]$indexbestmodel]+VGOB1_subsetD_meca_LUR2[,models[[6]]$indexbestmodel]+ VGOB1_subsetD_meca_LUR2[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # Measurements_livestockpreds_LUR2[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR2)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetD_meca_LUR2)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

# this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetD_meca_LUR2)[models[[1]]$indexbestmodel], names(VGOB1_subsetD_meca_LUR2)[models[[2]]$indexbestmodel] , names(VGOB1_subsetD_meca_LUR2)[models[[3]]$indexbestmodel], names(VGOB1_subsetD_meca_LUR2)[models[[4]]$indexbestmodel], names(VGOB1_subsetD_meca_LUR2)[models[[5]]$indexbestmodel], names(VGOB1_subsetD_meca_LUR2)[models[[6]]$indexbestmodel], names(VGOB1_subsetD_meca_LUR2)[models[[7]]$indexbestmodel])

#  this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetD_meca_LUR2$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetD_meca_LUR2[,models[[1]]$indexbestmodel]+VGOB1_subsetD_meca_LUR2[,models[[2]]$indexbestmodel]+VGOB1_subsetD_meca_LUR2[,models[[3]]$indexbestmodel]+ VGOB1_subsetD_meca_LUR2[,models[[4]]$indexbestmodel]+ VGOB1_subsetD_meca_LUR2[,models[[5]]$indexbestmodel]+ VGOB1_subsetD_meca_LUR2[,models[[6]]$indexbestmodel]+ VGOB1_subsetD_meca_LUR2[,models[[7]]$indexbestmodel]) 

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[5]]$summarybestmodel
models[[6]]$summarybestmodel
models[[7]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[5]]$namesbestmodel
models[[6]]$namesbestmodel
models[[7]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel
models[[5]]$R2bestmodel
models[[6]]$R2bestmodel
models[[7]]$R2bestmodel

# 8 #  
# add eighth variable (the only difference of the above part is that now modeln=7 the model statement more variables)
# and the call for the list of variable names in the model changed slightly

modeln<-8

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_2 :nlastvar_LUR_2){
  if (is.numeric(VGOB1_subsetD_meca_LUR2[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetD_meca_LUR2$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetD_meca_LUR2[,models[[1]]$indexbestmodel]+VGOB1_subsetD_meca_LUR2[,models[[2]]$indexbestmodel]+VGOB1_subsetD_meca_LUR2[,models[[3]]$indexbestmodel]+VGOB1_subsetD_meca_LUR2[,models[[4]]$indexbestmodel]+VGOB1_subsetD_meca_LUR2[,models[[5]]$indexbestmodel]+VGOB1_subsetD_meca_LUR2[,models[[6]]$indexbestmodel]+ VGOB1_subsetD_meca_LUR2[,models[[7]]$indexbestmodel]+ VGOB1_subsetD_meca_LUR2[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # Measurements_livestockpreds_LUR2[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR2)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetD_meca_LUR2)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

# this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetD_meca_LUR2)[models[[1]]$indexbestmodel], names(VGOB1_subsetD_meca_LUR2)[models[[2]]$indexbestmodel] , names(VGOB1_subsetD_meca_LUR2)[models[[3]]$indexbestmodel], names(VGOB1_subsetD_meca_LUR2)[models[[4]]$indexbestmodel], names(VGOB1_subsetD_meca_LUR2)[models[[5]]$indexbestmodel], names(VGOB1_subsetD_meca_LUR2)[models[[6]]$indexbestmodel], names(VGOB1_subsetD_meca_LUR2)[models[[7]]$indexbestmodel], names(VGOB1_subsetD_meca_LUR2)[models[[8]]$indexbestmodel])

#  this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetD_meca_LUR2$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetD_meca_LUR2[,models[[1]]$indexbestmodel]+VGOB1_subsetD_meca_LUR2[,models[[2]]$indexbestmodel]+VGOB1_subsetD_meca_LUR2[,models[[3]]$indexbestmodel]+ VGOB1_subsetD_meca_LUR2[,models[[4]]$indexbestmodel]+ VGOB1_subsetD_meca_LUR2[,models[[5]]$indexbestmodel]+ VGOB1_subsetD_meca_LUR2[,models[[6]]$indexbestmodel]+ VGOB1_subsetD_meca_LUR2[,models[[7]]$indexbestmodel]+ VGOB1_subsetD_meca_LUR2[,models[[8]]$indexbestmodel]) 

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[5]]$summarybestmodel
models[[6]]$summarybestmodel
models[[7]]$summarybestmodel
models[[8]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[5]]$namesbestmodel
models[[6]]$namesbestmodel
models[[7]]$namesbestmodel
models[[8]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel
models[[5]]$R2bestmodel
models[[6]]$R2bestmodel
models[[7]]$R2bestmodel
models[[8]]$R2bestmodel

# 9 #  
# add ninth variable (the only difference of the above part is that now modeln=9 the model statement more variables)
# and the call for the list of variable names in the model changed slightly

modeln<-9

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_2 :nlastvar_LUR_2){
  if (is.numeric(VGOB1_subsetD_meca_LUR2[,i])==TRUE){
      modeltry<-lm(VGOB1_subsetD_meca_LUR2$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetD_meca_LUR2[,models[[1]]$indexbestmodel]+VGOB1_subsetD_meca_LUR2[,models[[2]]$indexbestmodel]+VGOB1_subsetD_meca_LUR2[,models[[3]]$indexbestmodel]+VGOB1_subsetD_meca_LUR2[,models[[4]]$indexbestmodel]+VGOB1_subsetD_meca_LUR2[,models[[5]]$indexbestmodel]+VGOB1_subsetD_meca_LUR2[,models[[6]]$indexbestmodel]+ VGOB1_subsetD_meca_LUR2[,models[[7]]$indexbestmodel]+ VGOB1_subsetD_meca_LUR2[,models[[8]]$indexbestmodel]+ VGOB1_subsetD_meca_LUR2[,i]) 
        R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # Measurements_livestockpreds_LUR2[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR2)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetD_meca_LUR2)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

# this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetD_meca_LUR2)[models[[1]]$indexbestmodel], names(VGOB1_subsetD_meca_LUR2)[models[[2]]$indexbestmodel] , names(VGOB1_subsetD_meca_LUR2)[models[[3]]$indexbestmodel], names(VGOB1_subsetD_meca_LUR2)[models[[4]]$indexbestmodel], names(VGOB1_subsetD_meca_LUR2)[models[[5]]$indexbestmodel], names(VGOB1_subsetD_meca_LUR2)[models[[6]]$indexbestmodel], names(VGOB1_subsetD_meca_LUR2)[models[[7]]$indexbestmodel], names(VGOB1_subsetD_meca_LUR2)[models[[8]]$indexbestmodel],  names(VGOB1_subsetD_meca_LUR2)[models[[9]]$indexbestmodel])

#  this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetD_meca_LUR2$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetD_meca_LUR2[,models[[1]]$indexbestmodel]+VGOB1_subsetD_meca_LUR2[,models[[2]]$indexbestmodel]+VGOB1_subsetD_meca_LUR2[,models[[3]]$indexbestmodel]+ VGOB1_subsetD_meca_LUR2[,models[[4]]$indexbestmodel]+ VGOB1_subsetD_meca_LUR2[,models[[5]]$indexbestmodel]+ VGOB1_subsetD_meca_LUR2[,models[[6]]$indexbestmodel]+ VGOB1_subsetD_meca_LUR2[,models[[7]]$indexbestmodel]+ VGOB1_subsetD_meca_LUR2[,models[[8]]$indexbestmodel]+ VGOB1_subsetD_meca_LUR2[,models[[9]]$indexbestmodel]) 

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[5]]$summarybestmodel
models[[6]]$summarybestmodel
models[[7]]$summarybestmodel
models[[8]]$summarybestmodel
models[[9]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[5]]$namesbestmodel
models[[6]]$namesbestmodel
models[[7]]$namesbestmodel
models[[8]]$namesbestmodel
models[[9]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel
models[[5]]$R2bestmodel
models[[6]]$R2bestmodel
models[[7]]$R2bestmodel
models[[8]]$R2bestmodel
models[[9]]$R2bestmodel

# 10 #  
#  add tenth variable (the only difference of the above part is that now model n=10 the model statement more variables)
#  and the call for the list of variable names in the model changed slightly

modeln<-10

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_2 :nlastvar_LUR_2){if (is.numeric(VGOB1_subsetD_meca_LUR2[,i])==TRUE){ modeltry<-lm(VGOB1_subsetD_meca_LUR2$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetD_meca_LUR2[,models[[1]]$indexbestmodel]+VGOB1_subsetD_meca_LUR2[,models[[2]]$indexbestmodel]+ VGOB1_subsetD_meca_LUR2[,models[[3]]$indexbestmodel]+VGOB1_subsetD_meca_LUR2[,models[[4]]$indexbestmodel]+ VGOB1_subsetD_meca_LUR2[,models[[5]]$indexbestmodel]+ VGOB1_subsetD_meca_LUR2[,models[[6]]$indexbestmodel]+ VGOB1_subsetD_meca_LUR2[,models[[7]]$indexbestmodel]+ VGOB1_subsetD_meca_LUR2[,models[[8]]$indexbestmodel]+ VGOB1_subsetD_meca_LUR2[,models[[9]]$indexbestmodel]+ VGOB1_subsetD_meca_LUR2[,i]) 

R2<-rbind(R2,summary(modeltry)$adj.r.squared)
# the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # Measurements_livestockpreds_LUR2[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR2)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetD_meca_LUR2)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

# this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

# here are the names
models[[modeln]]$namesbestmodel<-c( names(VGOB1_subsetD_meca_LUR2)[models[[1]]$indexbestmodel],                   names(VGOB1_subsetD_meca_LUR2)[models[[2]]$indexbestmodel] , names(VGOB1_subsetD_meca_LUR2)[models[[3]]$indexbestmodel], names(VGOB1_subsetD_meca_LUR2)[models[[4]]$indexbestmodel], names(VGOB1_subsetD_meca_LUR2)[models[[5]]$indexbestmodel], names(VGOB1_subsetD_meca_LUR2)[models[[6]]$indexbestmodel], names(VGOB1_subsetD_meca_LUR2)[models[[7]]$indexbestmodel], names(VGOB1_subsetD_meca_LUR2)[models[[8]]$indexbestmodel], names(VGOB1_subsetD_meca_LUR2)[models[[9]]$indexbestmodel], names(VGOB1_subsetD_meca_LUR2)[models[[10]]$indexbestmodel])

#  this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetD_meca_LUR2$meca_copiespm3.ln.diffmeth.mean~                                VGOB1_subsetD_meca_LUR2[,models[[1]]$indexbestmodel]+ VGOB1_subsetD_meca_LUR2[,models[[2]]$indexbestmodel]+                           VGOB1_subsetD_meca_LUR2[,models[[3]]$indexbestmodel]+ VGOB1_subsetD_meca_LUR2[,models[[4]]$indexbestmodel]+ VGOB1_subsetD_meca_LUR2[,models[[5]]$indexbestmodel]+ VGOB1_subsetD_meca_LUR2[,models[[6]]$indexbestmodel]+ VGOB1_subsetD_meca_LUR2[,models[[7]]$indexbestmodel]+ VGOB1_subsetD_meca_LUR2[,models[[8]]$indexbestmodel]+ VGOB1_subsetD_meca_LUR2[,models[[9]]$indexbestmodel]+ VGOB1_subsetD_meca_LUR2[,models[[10]]$indexbestmodel]) 

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[5]]$summarybestmodel
models[[6]]$summarybestmodel
models[[7]]$summarybestmodel
models[[8]]$summarybestmodel
models[[9]]$summarybestmodel
models[[10]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[5]]$namesbestmodel
models[[6]]$namesbestmodel
models[[7]]$namesbestmodel
models[[8]]$namesbestmodel
models[[9]]$namesbestmodel
models[[10]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel
models[[5]]$R2bestmodel
models[[6]]$R2bestmodel
models[[7]]$R2bestmodel
models[[8]]$R2bestmodel
models[[9]]$R2bestmodel
models[[10]]$R2bestmodel

#  at this point I always check whether the next model is more than 1% better than the one before and if not I end here

#   CODE FOR PICKING OUT THE BEST MODEL #   
temp <- 0
besti <- 0
for (i in 1:10){ #  think this runs the loop 10 times - not fully sure thought - but not to do with the number of models I don't think - as when I change to 3, I still get the model with 4 variables as best model
  print(models[[i]]$R2bestmodel)
  #       print(models[[i]]$summarybestmodel$coefficients=-1,4])
  #       if((models[[i]]$R2bestmodel-temp > 0.0) && (all(models[[i]]$summarybestmodel$coefficients[-1,4]<0.1))){
  #         temp <- models[[i]]$R2bestmodel
  #         besti <- i
  #         }
  if((models[[i]]$R2bestmodel-temp > 0.0) && (all(models[[i]]$summarybestmodel$coefficients[-1,4]<0.1))){
    temp <- models[[i]]$R2bestmodel
    besti <- i
  }else{
    finalBestModel_meca_LUR2_subsetD <- models[[besti]]$bestmodel
    finalBestModelNames_meca_subsetD <- models[[besti]]$namesbestmodel
    Sites <- 1:dim(VGOB1_subsetD_meca_LUR2)[1] # full original model
    #  CVaR2<-escCV_meca_LUR2(Sites)[2] # Cross Validation
    maxCD<-max(cooks.distance(finalBestModel_meca_LUR2_subsetD))
    if(length(finalBestModelNames_meca_subsetD)<2){ # vif fn doesnot work when only 1 variable...       # 
      maxVIF<-"NA"
    }else{
      maxVIF<-max(vif(finalBestModel_meca_LUR2_subsetD))
    }
    print(paste("This is the best meca model for subset D: ",besti,
                "(AdjR2: ",format(models[[besti]]$R2bestmodel,digits=3), "; MaxCD: ",format(maxCD,digits=3),"; MaxVIF: ",
                format(maxVIF,digits=3),")", sep=''))
    print(finalBestModelNames_meca_subsetD)
    break
  }
}

#  Overview of the final best model using the algorithm selection process (taking into account VIF, R^2, and p-values)
finalBestModel_meca_LUR2_subsetD
finalBestModelNames_meca_subsetD
models[[besti]]$summarybestmodel
models[[besti]]$R2bestmodel


#### E ####
# LUR model building process for subset E
#  This is the dataframe with the relevant predictor vars for LUR2 models for subset E (55 sites)
VGOB1_subsetE_meca_LUR2 # n.b. this dataframe only includes microbial marker concentrations for meca unlike the dataframe Measurements_livestockpreds_LUR2 as previously used for the model building. 

#  Now set the values of some variables that will be needed
nfirstvar_LUR_2 <- 3  
nlastvar_LUR_2 <- 71

# Function building to run the models 
# 1 #  

models<-list()
modeln<-1
models[[modeln]]<-list()

R2<-1
betaaddedvar<-1
addedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_2:nlastvar_LUR_2){
  if (is.numeric(VGOB1_subsetE_meca_LUR2[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetE_meca_LUR2$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetE_meca_LUR2[,i])                            
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    #  Measurements_livestockpreds_LUR2[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR2)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetE_meca_LUR2)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)
models[[modeln]]$results

#  this are the candidates models with the highest R2, not a negative beta for the new, nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)
models[[modeln]]$resultspos

#  rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))
models[[modeln]]$resultspos

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j
models[[modeln]]$indexbestmodel

subset(models[[modeln]]$resultspos, rank==1)
subset(models[[modeln]]$resultspos)

#  this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]
models[[modeln]]$summarybestmodel

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetE_meca_LUR2)[models[[1]]$indexbestmodel])
models[[modeln]]$namesbestmodel

#  this is the r2 of that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2
models[[modeln]]$R2bestmodel

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetE_meca_LUR2$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetE_meca_LUR2[,models[[1]]$indexbestmodel]) 
models[[modeln]]$bestmodel

summary(models[[modeln]]$bestmodel)

#  The first model includes the predictor: nPigMultipFarmWghtDist.3000m.sum.Tr.1P9 - meaning the number of multiplier pig farms weighted to distance in a 3000m buffer

# 2 #  
# Add 2nd variable (the only difference of the above part is that now modeln=2 the model statement has 2 variables)
# and the call for the list of variable names in the model changed slightly

modeln<-2

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_2:nlastvar_LUR_2){
  if (is.numeric(VGOB1_subsetE_meca_LUR2[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetE_meca_LUR2$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetE_meca_LUR2[,models[[1]]$indexbestmodel]+ VGOB1_subsetE_meca_LUR2[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # Measurements_livestockpreds_LUR2[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR2)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetE_meca_LUR2)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  these are the candidate models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)
models[[modeln]]$resultspos

#  rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))
models[[modeln]]$resultspos

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j
models[[modeln]]$indexbestmodel

subset(models[[modeln]]$resultspos, rank==1)

# this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]
models[[modeln]]$summarybestmodel

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetE_meca_LUR2)[models[[1]]$indexbestmodel], names(VGOB1_subsetE_meca_LUR2)[models[[2]]$indexbestmodel] )
models[[modeln]]$namesbestmodel

# this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2
models[[modeln]]$R2bestmodel

# this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetE_meca_LUR2$meca_copiespm3.ln.diffmeth.mean~                               VGOB1_subsetE_meca_LUR2[,models[[1]]$indexbestmodel]+                           VGOB1_subsetE_meca_LUR2[,models[[2]]$indexbestmodel]) 

models[[modeln]]$bestmodel

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel


# 3 #  
# add third variable (the only difference of the above part is that now modeln=3 the model statement has 3 variables)
# and the call for the list of variable names in the model changed slightly

modeln<-3

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_2:nlastvar_LUR_2){
  if (is.numeric(VGOB1_subsetE_meca_LUR2[,i])==TRUE){  
    modeltry<-lm(VGOB1_subsetE_meca_LUR2$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetE_meca_LUR2[,models[[1]]$indexbestmodel]+VGOB1_subsetE_meca_LUR2[,models[[2]]$indexbestmodel]+ VGOB1_subsetE_meca_LUR2[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # All[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR2)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetE_meca_LUR2)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

#  rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

#  this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

#  here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetE_meca_LUR2)[models[[1]]$indexbestmodel], names(VGOB1_subsetE_meca_LUR2)[models[[2]]$indexbestmodel], names(VGOB1_subsetE_meca_LUR2)[models[[3]]$indexbestmodel])

#  this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetE_meca_LUR2$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetE_meca_LUR2[,models[[1]]$indexbestmodel]+ VGOB1_subsetE_meca_LUR2[,models[[2]]$indexbestmodel]+ VGOB1_subsetE_meca_LUR2[,models[[3]]$indexbestmodel]) 

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel


# 4 #  
#  add forth variable (the only difference of the above part is that now model n=4 the model statement more variables)
#  and the call for the list of variable names in the model changed slightly
modeln<-4

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1


for (i in nfirstvar_LUR_2:nlastvar_LUR_2){
  if (is.numeric(VGOB1_subsetE_meca_LUR2[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetE_meca_LUR2$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetE_meca_LUR2[,models[[1]]$indexbestmodel]+VGOB1_subsetE_meca_LUR2[,models[[2]]$indexbestmodel]+VGOB1_subsetE_meca_LUR2[,models[[3]]$indexbestmodel]+VGOB1_subsetE_meca_LUR2[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    #  the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    #  All[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR2)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetE_meca_LUR2)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

#  this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

#  here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetE_meca_LUR2)[models[[1]]$indexbestmodel], names(VGOB1_subsetE_meca_LUR2)[models[[2]]$indexbestmodel], names(VGOB1_subsetE_meca_LUR2)[models[[3]]$indexbestmodel], names(VGOB1_subsetE_meca_LUR2)[models[[4]]$indexbestmodel])

#  this is the r2 of that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetE_meca_LUR2$meca_copiespm3.ln.diffmeth.mean~ VGOB1_subsetE_meca_LUR2[,models[[1]]$indexbestmodel]+ VGOB1_subsetE_meca_LUR2[,models[[2]]$indexbestmodel]+VGOB1_subsetE_meca_LUR2[,models[[3]]$indexbestmodel]+ VGOB1_subsetE_meca_LUR2[,models[[4]]$indexbestmodel]) 


models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel


# 5 #  
# add fifth variable (the only difference of the above part is that now modeln=5 the model statement more variables)
# and the call for the list of variable names in the model changed slightly
modeln<-5

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_2:nlastvar_LUR_2){
  if (is.numeric(VGOB1_subsetE_meca_LUR2[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetE_meca_LUR2$meca_copiespm3.ln.diffmeth.mean~ VGOB1_subsetE_meca_LUR2[,models[[1]]$indexbestmodel]+ VGOB1_subsetE_meca_LUR2[,models[[2]]$indexbestmodel]+ VGOB1_subsetE_meca_LUR2[,models[[3]]$indexbestmodel]+ VGOB1_subsetE_meca_LUR2[,models[[4]]$indexbestmodel]+ VGOB1_subsetE_meca_LUR2[,i]) 
  
R2<-rbind(R2,summary(modeltry)$adj.r.squared)
# the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # All[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR2)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetE_meca_LUR2)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

#  this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetE_meca_LUR2)[models[[1]]$indexbestmodel], names(VGOB1_subsetE_meca_LUR2)[models[[2]]$indexbestmodel], names(VGOB1_subsetE_meca_LUR2)[models[[3]]$indexbestmodel], names(VGOB1_subsetE_meca_LUR2)[models[[4]]$indexbestmodel], names(VGOB1_subsetE_meca_LUR2)[models[[5]]$indexbestmodel])

#  this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetE_meca_LUR2$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetE_meca_LUR2[,models[[1]]$indexbestmodel]+VGOB1_subsetE_meca_LUR2[,models[[2]]$indexbestmodel]+VGOB1_subsetE_meca_LUR2[,models[[3]]$indexbestmodel]+ VGOB1_subsetE_meca_LUR2[,models[[4]]$indexbestmodel]+ VGOB1_subsetE_meca_LUR2[,models[[5]]$indexbestmodel]) 
models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[5]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[5]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel
models[[5]]$R2bestmodel

# 6 #  
# add sixth variable (the only difference of the above part is that now model n=6 the model statement more variables)
#  and the call for the list of variable names in the model changed slightly

modeln<-6

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_2 :nlastvar_LUR_2){
  if (is.numeric(VGOB1_subsetE_meca_LUR2[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetE_meca_LUR2$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetE_meca_LUR2[,models[[1]]$indexbestmodel]+VGOB1_subsetE_meca_LUR2[,models[[2]]$indexbestmodel]+VGOB1_subsetE_meca_LUR2[,models[[3]]$indexbestmodel]+VGOB1_subsetE_meca_LUR2[,models[[4]]$indexbestmodel]+VGOB1_subsetE_meca_LUR2[,models[[5]]$indexbestmodel]+ VGOB1_subsetE_meca_LUR2[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # All[,i] is the row that's being tried out now. the name of that row can be found in  names(All)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetE_meca_LUR2)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

# this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetE_meca_LUR2)[models[[1]]$indexbestmodel], names(VGOB1_subsetE_meca_LUR2)[models[[2]]$indexbestmodel] , names(VGOB1_subsetE_meca_LUR2)[models[[3]]$indexbestmodel], names(VGOB1_subsetE_meca_LUR2)[models[[4]]$indexbestmodel], names(VGOB1_subsetE_meca_LUR2)[models[[5]]$indexbestmodel], names(VGOB1_subsetE_meca_LUR2)[models[[6]]$indexbestmodel])

#  this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetE_meca_LUR2$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetE_meca_LUR2[,models[[1]]$indexbestmodel]+VGOB1_subsetE_meca_LUR2[,models[[2]]$indexbestmodel]+VGOB1_subsetE_meca_LUR2[,models[[3]]$indexbestmodel]+ VGOB1_subsetE_meca_LUR2[,models[[4]]$indexbestmodel]+ VGOB1_subsetE_meca_LUR2[,models[[5]]$indexbestmodel]+ VGOB1_subsetE_meca_LUR2[,models[[6]]$indexbestmodel]) 

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[5]]$summarybestmodel
models[[6]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[5]]$namesbestmodel
models[[6]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel
models[[5]]$R2bestmodel
models[[6]]$R2bestmodel


# 7 #  
# add seventh variable (the only difference of the above part is that now model n=7 the model statement more variables)
#  and the call for the list of variable names in the model changed slightly

modeln<-7

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_2 :nlastvar_LUR_2){
  if (is.numeric(VGOB1_subsetE_meca_LUR2[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetE_meca_LUR2$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetE_meca_LUR2[,models[[1]]$indexbestmodel]+VGOB1_subsetE_meca_LUR2[,models[[2]]$indexbestmodel]+VGOB1_subsetE_meca_LUR2[,models[[3]]$indexbestmodel]+VGOB1_subsetE_meca_LUR2[,models[[4]]$indexbestmodel]+VGOB1_subsetE_meca_LUR2[,models[[5]]$indexbestmodel]+VGOB1_subsetE_meca_LUR2[,models[[6]]$indexbestmodel]+ VGOB1_subsetE_meca_LUR2[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # Measurements_livestockpreds_LUR2[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR2)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetE_meca_LUR2)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

# this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetE_meca_LUR2)[models[[1]]$indexbestmodel], names(VGOB1_subsetE_meca_LUR2)[models[[2]]$indexbestmodel] , names(VGOB1_subsetE_meca_LUR2)[models[[3]]$indexbestmodel], names(VGOB1_subsetE_meca_LUR2)[models[[4]]$indexbestmodel], names(VGOB1_subsetE_meca_LUR2)[models[[5]]$indexbestmodel], names(VGOB1_subsetE_meca_LUR2)[models[[6]]$indexbestmodel], names(VGOB1_subsetE_meca_LUR2)[models[[7]]$indexbestmodel])

#  this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetE_meca_LUR2$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetE_meca_LUR2[,models[[1]]$indexbestmodel]+VGOB1_subsetE_meca_LUR2[,models[[2]]$indexbestmodel]+VGOB1_subsetE_meca_LUR2[,models[[3]]$indexbestmodel]+ VGOB1_subsetE_meca_LUR2[,models[[4]]$indexbestmodel]+ VGOB1_subsetE_meca_LUR2[,models[[5]]$indexbestmodel]+ VGOB1_subsetE_meca_LUR2[,models[[6]]$indexbestmodel]+ VGOB1_subsetE_meca_LUR2[,models[[7]]$indexbestmodel]) 

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[5]]$summarybestmodel
models[[6]]$summarybestmodel
models[[7]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[5]]$namesbestmodel
models[[6]]$namesbestmodel
models[[7]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel
models[[5]]$R2bestmodel
models[[6]]$R2bestmodel
models[[7]]$R2bestmodel

# 8 #  
# add eighth variable (the only difference of the above part is that now modeln=7 the model statement more variables)
# and the call for the list of variable names in the model changed slightly

modeln<-8

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_2 :nlastvar_LUR_2){
  if (is.numeric(VGOB1_subsetE_meca_LUR2[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetE_meca_LUR2$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetE_meca_LUR2[,models[[1]]$indexbestmodel]+VGOB1_subsetE_meca_LUR2[,models[[2]]$indexbestmodel]+VGOB1_subsetE_meca_LUR2[,models[[3]]$indexbestmodel]+VGOB1_subsetE_meca_LUR2[,models[[4]]$indexbestmodel]+VGOB1_subsetE_meca_LUR2[,models[[5]]$indexbestmodel]+VGOB1_subsetE_meca_LUR2[,models[[6]]$indexbestmodel]+ VGOB1_subsetE_meca_LUR2[,models[[7]]$indexbestmodel]+ VGOB1_subsetE_meca_LUR2[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # Measurements_livestockpreds_LUR2[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR2)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetE_meca_LUR2)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

# this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetE_meca_LUR2)[models[[1]]$indexbestmodel], names(VGOB1_subsetE_meca_LUR2)[models[[2]]$indexbestmodel] , names(VGOB1_subsetE_meca_LUR2)[models[[3]]$indexbestmodel], names(VGOB1_subsetE_meca_LUR2)[models[[4]]$indexbestmodel], names(VGOB1_subsetE_meca_LUR2)[models[[5]]$indexbestmodel], names(VGOB1_subsetE_meca_LUR2)[models[[6]]$indexbestmodel], names(VGOB1_subsetE_meca_LUR2)[models[[7]]$indexbestmodel], names(VGOB1_subsetE_meca_LUR2)[models[[8]]$indexbestmodel])

#  this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetE_meca_LUR2$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetE_meca_LUR2[,models[[1]]$indexbestmodel]+VGOB1_subsetE_meca_LUR2[,models[[2]]$indexbestmodel]+VGOB1_subsetE_meca_LUR2[,models[[3]]$indexbestmodel]+ VGOB1_subsetE_meca_LUR2[,models[[4]]$indexbestmodel]+ VGOB1_subsetE_meca_LUR2[,models[[5]]$indexbestmodel]+ VGOB1_subsetE_meca_LUR2[,models[[6]]$indexbestmodel]+ VGOB1_subsetE_meca_LUR2[,models[[7]]$indexbestmodel]+ VGOB1_subsetE_meca_LUR2[,models[[8]]$indexbestmodel]) 

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[5]]$summarybestmodel
models[[6]]$summarybestmodel
models[[7]]$summarybestmodel
models[[8]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[5]]$namesbestmodel
models[[6]]$namesbestmodel
models[[7]]$namesbestmodel
models[[8]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel
models[[5]]$R2bestmodel
models[[6]]$R2bestmodel
models[[7]]$R2bestmodel
models[[8]]$R2bestmodel

# 9 #  
# add ninth variable (the only difference of the above part is that now modeln=9 the model statement more variables)
# and the call for the list of variable names in the model changed slightly

modeln<-9

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_2 :nlastvar_LUR_2){
  if (is.numeric(VGOB1_subsetE_meca_LUR2[,i])==TRUE){
      modeltry<-lm(VGOB1_subsetE_meca_LUR2$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetE_meca_LUR2[,models[[1]]$indexbestmodel]+VGOB1_subsetE_meca_LUR2[,models[[2]]$indexbestmodel]+VGOB1_subsetE_meca_LUR2[,models[[3]]$indexbestmodel]+VGOB1_subsetE_meca_LUR2[,models[[4]]$indexbestmodel]+VGOB1_subsetE_meca_LUR2[,models[[5]]$indexbestmodel]+VGOB1_subsetE_meca_LUR2[,models[[6]]$indexbestmodel]+ VGOB1_subsetE_meca_LUR2[,models[[7]]$indexbestmodel]+ VGOB1_subsetE_meca_LUR2[,models[[8]]$indexbestmodel]+ VGOB1_subsetE_meca_LUR2[,i]) 
        R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # Measurements_livestockpreds_LUR2[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR2)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetE_meca_LUR2)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

# this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetE_meca_LUR2)[models[[1]]$indexbestmodel], names(VGOB1_subsetE_meca_LUR2)[models[[2]]$indexbestmodel] , names(VGOB1_subsetE_meca_LUR2)[models[[3]]$indexbestmodel], names(VGOB1_subsetE_meca_LUR2)[models[[4]]$indexbestmodel], names(VGOB1_subsetE_meca_LUR2)[models[[5]]$indexbestmodel], names(VGOB1_subsetE_meca_LUR2)[models[[6]]$indexbestmodel], names(VGOB1_subsetE_meca_LUR2)[models[[7]]$indexbestmodel], names(VGOB1_subsetE_meca_LUR2)[models[[8]]$indexbestmodel],  names(VGOB1_subsetE_meca_LUR2)[models[[9]]$indexbestmodel])

#  this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetE_meca_LUR2$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetE_meca_LUR2[,models[[1]]$indexbestmodel]+VGOB1_subsetE_meca_LUR2[,models[[2]]$indexbestmodel]+VGOB1_subsetE_meca_LUR2[,models[[3]]$indexbestmodel]+ VGOB1_subsetE_meca_LUR2[,models[[4]]$indexbestmodel]+ VGOB1_subsetE_meca_LUR2[,models[[5]]$indexbestmodel]+ VGOB1_subsetE_meca_LUR2[,models[[6]]$indexbestmodel]+ VGOB1_subsetE_meca_LUR2[,models[[7]]$indexbestmodel]+ VGOB1_subsetE_meca_LUR2[,models[[8]]$indexbestmodel]+ VGOB1_subsetE_meca_LUR2[,models[[9]]$indexbestmodel]) 

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[5]]$summarybestmodel
models[[6]]$summarybestmodel
models[[7]]$summarybestmodel
models[[8]]$summarybestmodel
models[[9]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[5]]$namesbestmodel
models[[6]]$namesbestmodel
models[[7]]$namesbestmodel
models[[8]]$namesbestmodel
models[[9]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel
models[[5]]$R2bestmodel
models[[6]]$R2bestmodel
models[[7]]$R2bestmodel
models[[8]]$R2bestmodel
models[[9]]$R2bestmodel

# 10 #  
#  add tenth variable (the only difference of the above part is that now model n=10 the model statement more variables)
#  and the call for the list of variable names in the model changed slightly

modeln<-10

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_2 :nlastvar_LUR_2){if (is.numeric(VGOB1_subsetE_meca_LUR2[,i])==TRUE){ modeltry<-lm(VGOB1_subsetE_meca_LUR2$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetE_meca_LUR2[,models[[1]]$indexbestmodel]+VGOB1_subsetE_meca_LUR2[,models[[2]]$indexbestmodel]+ VGOB1_subsetE_meca_LUR2[,models[[3]]$indexbestmodel]+VGOB1_subsetE_meca_LUR2[,models[[4]]$indexbestmodel]+ VGOB1_subsetE_meca_LUR2[,models[[5]]$indexbestmodel]+ VGOB1_subsetE_meca_LUR2[,models[[6]]$indexbestmodel]+ VGOB1_subsetE_meca_LUR2[,models[[7]]$indexbestmodel]+ VGOB1_subsetE_meca_LUR2[,models[[8]]$indexbestmodel]+ VGOB1_subsetE_meca_LUR2[,models[[9]]$indexbestmodel]+ VGOB1_subsetE_meca_LUR2[,i]) 

R2<-rbind(R2,summary(modeltry)$adj.r.squared)
# the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # Measurements_livestockpreds_LUR2[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR2)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetE_meca_LUR2)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

# this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

# here are the names
models[[modeln]]$namesbestmodel<-c( names(VGOB1_subsetE_meca_LUR2)[models[[1]]$indexbestmodel],                   names(VGOB1_subsetE_meca_LUR2)[models[[2]]$indexbestmodel] , names(VGOB1_subsetE_meca_LUR2)[models[[3]]$indexbestmodel], names(VGOB1_subsetE_meca_LUR2)[models[[4]]$indexbestmodel], names(VGOB1_subsetE_meca_LUR2)[models[[5]]$indexbestmodel], names(VGOB1_subsetE_meca_LUR2)[models[[6]]$indexbestmodel], names(VGOB1_subsetE_meca_LUR2)[models[[7]]$indexbestmodel], names(VGOB1_subsetE_meca_LUR2)[models[[8]]$indexbestmodel], names(VGOB1_subsetE_meca_LUR2)[models[[9]]$indexbestmodel], names(VGOB1_subsetE_meca_LUR2)[models[[10]]$indexbestmodel])

#  this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetE_meca_LUR2$meca_copiespm3.ln.diffmeth.mean~                                VGOB1_subsetE_meca_LUR2[,models[[1]]$indexbestmodel]+ VGOB1_subsetE_meca_LUR2[,models[[2]]$indexbestmodel]+                           VGOB1_subsetE_meca_LUR2[,models[[3]]$indexbestmodel]+ VGOB1_subsetE_meca_LUR2[,models[[4]]$indexbestmodel]+ VGOB1_subsetE_meca_LUR2[,models[[5]]$indexbestmodel]+ VGOB1_subsetE_meca_LUR2[,models[[6]]$indexbestmodel]+ VGOB1_subsetE_meca_LUR2[,models[[7]]$indexbestmodel]+ VGOB1_subsetE_meca_LUR2[,models[[8]]$indexbestmodel]+ VGOB1_subsetE_meca_LUR2[,models[[9]]$indexbestmodel]+ VGOB1_subsetE_meca_LUR2[,models[[10]]$indexbestmodel]) 

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[5]]$summarybestmodel
models[[6]]$summarybestmodel
models[[7]]$summarybestmodel
models[[8]]$summarybestmodel
models[[9]]$summarybestmodel
models[[10]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[5]]$namesbestmodel
models[[6]]$namesbestmodel
models[[7]]$namesbestmodel
models[[8]]$namesbestmodel
models[[9]]$namesbestmodel
models[[10]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel
models[[5]]$R2bestmodel
models[[6]]$R2bestmodel
models[[7]]$R2bestmodel
models[[8]]$R2bestmodel
models[[9]]$R2bestmodel
models[[10]]$R2bestmodel

#  at this point I always check whether the next model is more than 1% better than the one before and if not I end here

#   CODE FOR PICKING OUT THE BEST MODEL #   
temp <- 0
besti <- 0
for (i in 1:10){ #  think this runs the loop 10 times - not fully sure thought - but not to do with the number of models I don't think - as when I change to 3, I still get the model with 4 variables as best model
  print(models[[i]]$R2bestmodel)
  #       print(models[[i]]$summarybestmodel$coefficients=-1,4])
  #       if((models[[i]]$R2bestmodel-temp > 0.0) && (all(models[[i]]$summarybestmodel$coefficients[-1,4]<0.1))){
  #         temp <- models[[i]]$R2bestmodel
  #         besti <- i
  #         }
  if((models[[i]]$R2bestmodel-temp > 0.0) && (all(models[[i]]$summarybestmodel$coefficients[-1,4]<0.1))){
    temp <- models[[i]]$R2bestmodel
    besti <- i
  }else{
    finalBestModel_meca_LUR2_subsetE <- models[[besti]]$bestmodel
    finalBestModelNames_meca_subsetE <- models[[besti]]$namesbestmodel
    Sites <- 1:dim(VGOB1_subsetE_meca_LUR2)[1] # full original model
    #  CVaR2<-escCV_meca_LUR2(Sites)[2] # Cross Validation
    maxCD<-max(cooks.distance(finalBestModel_meca_LUR2_subsetE))
    if(length(finalBestModelNames_meca_subsetE)<2){ # vif fn doesnot work when only 1 variable...       # 
      maxVIF<-"NA"
    }else{
      maxVIF<-max(vif(finalBestModel_meca_LUR2_subsetE))
    }
    print(paste("This is the best meca model for subset E: ",besti,
                "(AdjR2: ",format(models[[besti]]$R2bestmodel,digits=3), "; MaxCD: ",format(maxCD,digits=3),"; MaxVIF: ",
                format(maxVIF,digits=3),")", sep=''))
    print(finalBestModelNames_meca_subsetE)
    break
  }
}

#  Overview of the final best model using the algorithm selection process (taking into account VIF, R^2, and p-values)
finalBestModel_meca_LUR2_subsetE
finalBestModelNames_meca_subsetE
models[[besti]]$summarybestmodel
models[[besti]]$R2bestmodel

#### F ####
# LUR model building process for subset F
#  This is the dataframe with the relevant predictor vars for LUR2 models for subset F (55 sites)
VGOB1_subsetF_meca_LUR2 # n.b. this dataframe only includes microbial marker concentrations for meca unlike the dataframe Measurements_livestockpreds_LUR2 as previously used for the model building. 

#  Now set the values of some variables that will be needed
nfirstvar_LUR_2 <- 3  
nlastvar_LUR_2 <- 71

# Function building to run the models 
# 1 #  

models<-list()
modeln<-1
models[[modeln]]<-list()

R2<-1
betaaddedvar<-1
addedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_2:nlastvar_LUR_2){
  if (is.numeric(VGOB1_subsetF_meca_LUR2[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetF_meca_LUR2$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetF_meca_LUR2[,i])                            
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    #  Measurements_livestockpreds_LUR2[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR2)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetF_meca_LUR2)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)
models[[modeln]]$results

#  this are the candidates models with the highest R2, not a negative beta for the new, nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)
models[[modeln]]$resultspos

#  rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))
models[[modeln]]$resultspos

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j
models[[modeln]]$indexbestmodel

subset(models[[modeln]]$resultspos, rank==1)
subset(models[[modeln]]$resultspos)

#  this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]
models[[modeln]]$summarybestmodel

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetF_meca_LUR2)[models[[1]]$indexbestmodel])
models[[modeln]]$namesbestmodel

#  this is the r2 of that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2
models[[modeln]]$R2bestmodel

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetF_meca_LUR2$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetF_meca_LUR2[,models[[1]]$indexbestmodel]) 
models[[modeln]]$bestmodel

summary(models[[modeln]]$bestmodel)

#  The first model includes the predictor: nPigMultipFarmWghtDist.3000m.sum.Tr.1P9 - meaning the number of multiplier pig farms weighted to distance in a 3000m buffer

# 2 #  
# Add 2nd variable (the only difference of the above part is that now modeln=2 the model statement has 2 variables)
# and the call for the list of variable names in the model changed slightly

modeln<-2

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_2:nlastvar_LUR_2){
  if (is.numeric(VGOB1_subsetF_meca_LUR2[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetF_meca_LUR2$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetF_meca_LUR2[,models[[1]]$indexbestmodel]+ VGOB1_subsetF_meca_LUR2[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # Measurements_livestockpreds_LUR2[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR2)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetF_meca_LUR2)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  these are the candidate models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)
models[[modeln]]$resultspos

#  rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))
models[[modeln]]$resultspos

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j
models[[modeln]]$indexbestmodel

subset(models[[modeln]]$resultspos, rank==1)

# this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]
models[[modeln]]$summarybestmodel

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetF_meca_LUR2)[models[[1]]$indexbestmodel], names(VGOB1_subsetF_meca_LUR2)[models[[2]]$indexbestmodel] )
models[[modeln]]$namesbestmodel

# this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2
models[[modeln]]$R2bestmodel

# this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetF_meca_LUR2$meca_copiespm3.ln.diffmeth.mean~                               VGOB1_subsetF_meca_LUR2[,models[[1]]$indexbestmodel]+                           VGOB1_subsetF_meca_LUR2[,models[[2]]$indexbestmodel]) 

models[[modeln]]$bestmodel

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel


# 3 #  
# add third variable (the only difference of the above part is that now modeln=3 the model statement has 3 variables)
# and the call for the list of variable names in the model changed slightly

modeln<-3

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_2:nlastvar_LUR_2){
  if (is.numeric(VGOB1_subsetF_meca_LUR2[,i])==TRUE){  
    modeltry<-lm(VGOB1_subsetF_meca_LUR2$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetF_meca_LUR2[,models[[1]]$indexbestmodel]+VGOB1_subsetF_meca_LUR2[,models[[2]]$indexbestmodel]+ VGOB1_subsetF_meca_LUR2[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # All[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR2)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetF_meca_LUR2)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

#  rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

#  this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

#  here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetF_meca_LUR2)[models[[1]]$indexbestmodel], names(VGOB1_subsetF_meca_LUR2)[models[[2]]$indexbestmodel], names(VGOB1_subsetF_meca_LUR2)[models[[3]]$indexbestmodel])

#  this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetF_meca_LUR2$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetF_meca_LUR2[,models[[1]]$indexbestmodel]+ VGOB1_subsetF_meca_LUR2[,models[[2]]$indexbestmodel]+ VGOB1_subsetF_meca_LUR2[,models[[3]]$indexbestmodel]) 

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel


# 4 #  
#  add forth variable (the only difference of the above part is that now model n=4 the model statement more variables)
#  and the call for the list of variable names in the model changed slightly
modeln<-4

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1


for (i in nfirstvar_LUR_2:nlastvar_LUR_2){
  if (is.numeric(VGOB1_subsetF_meca_LUR2[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetF_meca_LUR2$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetF_meca_LUR2[,models[[1]]$indexbestmodel]+VGOB1_subsetF_meca_LUR2[,models[[2]]$indexbestmodel]+VGOB1_subsetF_meca_LUR2[,models[[3]]$indexbestmodel]+VGOB1_subsetF_meca_LUR2[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    #  the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    #  All[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR2)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetF_meca_LUR2)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

#  this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

#  here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetF_meca_LUR2)[models[[1]]$indexbestmodel], names(VGOB1_subsetF_meca_LUR2)[models[[2]]$indexbestmodel], names(VGOB1_subsetF_meca_LUR2)[models[[3]]$indexbestmodel], names(VGOB1_subsetF_meca_LUR2)[models[[4]]$indexbestmodel])

#  this is the r2 of that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetF_meca_LUR2$meca_copiespm3.ln.diffmeth.mean~ VGOB1_subsetF_meca_LUR2[,models[[1]]$indexbestmodel]+ VGOB1_subsetF_meca_LUR2[,models[[2]]$indexbestmodel]+VGOB1_subsetF_meca_LUR2[,models[[3]]$indexbestmodel]+ VGOB1_subsetF_meca_LUR2[,models[[4]]$indexbestmodel]) 


models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel


# 5 #  
# add fifth variable (the only difference of the above part is that now modeln=5 the model statement more variables)
# and the call for the list of variable names in the model changed slightly
modeln<-5

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_2:nlastvar_LUR_2){
  if (is.numeric(VGOB1_subsetF_meca_LUR2[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetF_meca_LUR2$meca_copiespm3.ln.diffmeth.mean~ VGOB1_subsetF_meca_LUR2[,models[[1]]$indexbestmodel]+ VGOB1_subsetF_meca_LUR2[,models[[2]]$indexbestmodel]+ VGOB1_subsetF_meca_LUR2[,models[[3]]$indexbestmodel]+ VGOB1_subsetF_meca_LUR2[,models[[4]]$indexbestmodel]+ VGOB1_subsetF_meca_LUR2[,i]) 
  
R2<-rbind(R2,summary(modeltry)$adj.r.squared)
# the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # All[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR2)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetF_meca_LUR2)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

#  this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetF_meca_LUR2)[models[[1]]$indexbestmodel], names(VGOB1_subsetF_meca_LUR2)[models[[2]]$indexbestmodel], names(VGOB1_subsetF_meca_LUR2)[models[[3]]$indexbestmodel], names(VGOB1_subsetF_meca_LUR2)[models[[4]]$indexbestmodel], names(VGOB1_subsetF_meca_LUR2)[models[[5]]$indexbestmodel])

#  this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetF_meca_LUR2$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetF_meca_LUR2[,models[[1]]$indexbestmodel]+VGOB1_subsetF_meca_LUR2[,models[[2]]$indexbestmodel]+VGOB1_subsetF_meca_LUR2[,models[[3]]$indexbestmodel]+ VGOB1_subsetF_meca_LUR2[,models[[4]]$indexbestmodel]+ VGOB1_subsetF_meca_LUR2[,models[[5]]$indexbestmodel]) 
models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[5]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[5]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel
models[[5]]$R2bestmodel

# 6 #  
# add sixth variable (the only difference of the above part is that now model n=6 the model statement more variables)
#  and the call for the list of variable names in the model changed slightly

modeln<-6

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_2 :nlastvar_LUR_2){
  if (is.numeric(VGOB1_subsetF_meca_LUR2[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetF_meca_LUR2$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetF_meca_LUR2[,models[[1]]$indexbestmodel]+VGOB1_subsetF_meca_LUR2[,models[[2]]$indexbestmodel]+VGOB1_subsetF_meca_LUR2[,models[[3]]$indexbestmodel]+VGOB1_subsetF_meca_LUR2[,models[[4]]$indexbestmodel]+VGOB1_subsetF_meca_LUR2[,models[[5]]$indexbestmodel]+ VGOB1_subsetF_meca_LUR2[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # All[,i] is the row that's being tried out now. the name of that row can be found in  names(All)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetF_meca_LUR2)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

# this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetF_meca_LUR2)[models[[1]]$indexbestmodel], names(VGOB1_subsetF_meca_LUR2)[models[[2]]$indexbestmodel] , names(VGOB1_subsetF_meca_LUR2)[models[[3]]$indexbestmodel], names(VGOB1_subsetF_meca_LUR2)[models[[4]]$indexbestmodel], names(VGOB1_subsetF_meca_LUR2)[models[[5]]$indexbestmodel], names(VGOB1_subsetF_meca_LUR2)[models[[6]]$indexbestmodel])

#  this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetF_meca_LUR2$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetF_meca_LUR2[,models[[1]]$indexbestmodel]+VGOB1_subsetF_meca_LUR2[,models[[2]]$indexbestmodel]+VGOB1_subsetF_meca_LUR2[,models[[3]]$indexbestmodel]+ VGOB1_subsetF_meca_LUR2[,models[[4]]$indexbestmodel]+ VGOB1_subsetF_meca_LUR2[,models[[5]]$indexbestmodel]+ VGOB1_subsetF_meca_LUR2[,models[[6]]$indexbestmodel]) 

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[5]]$summarybestmodel
models[[6]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[5]]$namesbestmodel
models[[6]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel
models[[5]]$R2bestmodel
models[[6]]$R2bestmodel


# 7 #  
# add seventh variable (the only difference of the above part is that now model n=7 the model statement more variables)
#  and the call for the list of variable names in the model changed slightly

modeln<-7

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_2 :nlastvar_LUR_2){
  if (is.numeric(VGOB1_subsetF_meca_LUR2[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetF_meca_LUR2$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetF_meca_LUR2[,models[[1]]$indexbestmodel]+VGOB1_subsetF_meca_LUR2[,models[[2]]$indexbestmodel]+VGOB1_subsetF_meca_LUR2[,models[[3]]$indexbestmodel]+VGOB1_subsetF_meca_LUR2[,models[[4]]$indexbestmodel]+VGOB1_subsetF_meca_LUR2[,models[[5]]$indexbestmodel]+VGOB1_subsetF_meca_LUR2[,models[[6]]$indexbestmodel]+ VGOB1_subsetF_meca_LUR2[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # Measurements_livestockpreds_LUR2[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR2)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetF_meca_LUR2)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

# this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetF_meca_LUR2)[models[[1]]$indexbestmodel], names(VGOB1_subsetF_meca_LUR2)[models[[2]]$indexbestmodel] , names(VGOB1_subsetF_meca_LUR2)[models[[3]]$indexbestmodel], names(VGOB1_subsetF_meca_LUR2)[models[[4]]$indexbestmodel], names(VGOB1_subsetF_meca_LUR2)[models[[5]]$indexbestmodel], names(VGOB1_subsetF_meca_LUR2)[models[[6]]$indexbestmodel], names(VGOB1_subsetF_meca_LUR2)[models[[7]]$indexbestmodel])

#  this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetF_meca_LUR2$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetF_meca_LUR2[,models[[1]]$indexbestmodel]+VGOB1_subsetF_meca_LUR2[,models[[2]]$indexbestmodel]+VGOB1_subsetF_meca_LUR2[,models[[3]]$indexbestmodel]+ VGOB1_subsetF_meca_LUR2[,models[[4]]$indexbestmodel]+ VGOB1_subsetF_meca_LUR2[,models[[5]]$indexbestmodel]+ VGOB1_subsetF_meca_LUR2[,models[[6]]$indexbestmodel]+ VGOB1_subsetF_meca_LUR2[,models[[7]]$indexbestmodel]) 

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[5]]$summarybestmodel
models[[6]]$summarybestmodel
models[[7]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[5]]$namesbestmodel
models[[6]]$namesbestmodel
models[[7]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel
models[[5]]$R2bestmodel
models[[6]]$R2bestmodel
models[[7]]$R2bestmodel

# 8 #  
# add eighth variable (the only difference of the above part is that now modeln=7 the model statement more variables)
# and the call for the list of variable names in the model changed slightly

modeln<-8

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_2 :nlastvar_LUR_2){
  if (is.numeric(VGOB1_subsetF_meca_LUR2[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetF_meca_LUR2$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetF_meca_LUR2[,models[[1]]$indexbestmodel]+VGOB1_subsetF_meca_LUR2[,models[[2]]$indexbestmodel]+VGOB1_subsetF_meca_LUR2[,models[[3]]$indexbestmodel]+VGOB1_subsetF_meca_LUR2[,models[[4]]$indexbestmodel]+VGOB1_subsetF_meca_LUR2[,models[[5]]$indexbestmodel]+VGOB1_subsetF_meca_LUR2[,models[[6]]$indexbestmodel]+ VGOB1_subsetF_meca_LUR2[,models[[7]]$indexbestmodel]+ VGOB1_subsetF_meca_LUR2[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # Measurements_livestockpreds_LUR2[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR2)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetF_meca_LUR2)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

# this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetF_meca_LUR2)[models[[1]]$indexbestmodel], names(VGOB1_subsetF_meca_LUR2)[models[[2]]$indexbestmodel] , names(VGOB1_subsetF_meca_LUR2)[models[[3]]$indexbestmodel], names(VGOB1_subsetF_meca_LUR2)[models[[4]]$indexbestmodel], names(VGOB1_subsetF_meca_LUR2)[models[[5]]$indexbestmodel], names(VGOB1_subsetF_meca_LUR2)[models[[6]]$indexbestmodel], names(VGOB1_subsetF_meca_LUR2)[models[[7]]$indexbestmodel], names(VGOB1_subsetF_meca_LUR2)[models[[8]]$indexbestmodel])

#  this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetF_meca_LUR2$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetF_meca_LUR2[,models[[1]]$indexbestmodel]+VGOB1_subsetF_meca_LUR2[,models[[2]]$indexbestmodel]+VGOB1_subsetF_meca_LUR2[,models[[3]]$indexbestmodel]+ VGOB1_subsetF_meca_LUR2[,models[[4]]$indexbestmodel]+ VGOB1_subsetF_meca_LUR2[,models[[5]]$indexbestmodel]+ VGOB1_subsetF_meca_LUR2[,models[[6]]$indexbestmodel]+ VGOB1_subsetF_meca_LUR2[,models[[7]]$indexbestmodel]+ VGOB1_subsetF_meca_LUR2[,models[[8]]$indexbestmodel]) 

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[5]]$summarybestmodel
models[[6]]$summarybestmodel
models[[7]]$summarybestmodel
models[[8]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[5]]$namesbestmodel
models[[6]]$namesbestmodel
models[[7]]$namesbestmodel
models[[8]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel
models[[5]]$R2bestmodel
models[[6]]$R2bestmodel
models[[7]]$R2bestmodel
models[[8]]$R2bestmodel

# 9 #  
# add ninth variable (the only difference of the above part is that now modeln=9 the model statement more variables)
# and the call for the list of variable names in the model changed slightly

modeln<-9

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_2 :nlastvar_LUR_2){
  if (is.numeric(VGOB1_subsetF_meca_LUR2[,i])==TRUE){
      modeltry<-lm(VGOB1_subsetF_meca_LUR2$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetF_meca_LUR2[,models[[1]]$indexbestmodel]+VGOB1_subsetF_meca_LUR2[,models[[2]]$indexbestmodel]+VGOB1_subsetF_meca_LUR2[,models[[3]]$indexbestmodel]+VGOB1_subsetF_meca_LUR2[,models[[4]]$indexbestmodel]+VGOB1_subsetF_meca_LUR2[,models[[5]]$indexbestmodel]+VGOB1_subsetF_meca_LUR2[,models[[6]]$indexbestmodel]+ VGOB1_subsetF_meca_LUR2[,models[[7]]$indexbestmodel]+ VGOB1_subsetF_meca_LUR2[,models[[8]]$indexbestmodel]+ VGOB1_subsetF_meca_LUR2[,i]) 
        R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # Measurements_livestockpreds_LUR2[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR2)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetF_meca_LUR2)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

# this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetF_meca_LUR2)[models[[1]]$indexbestmodel], names(VGOB1_subsetF_meca_LUR2)[models[[2]]$indexbestmodel] , names(VGOB1_subsetF_meca_LUR2)[models[[3]]$indexbestmodel], names(VGOB1_subsetF_meca_LUR2)[models[[4]]$indexbestmodel], names(VGOB1_subsetF_meca_LUR2)[models[[5]]$indexbestmodel], names(VGOB1_subsetF_meca_LUR2)[models[[6]]$indexbestmodel], names(VGOB1_subsetF_meca_LUR2)[models[[7]]$indexbestmodel], names(VGOB1_subsetF_meca_LUR2)[models[[8]]$indexbestmodel],  names(VGOB1_subsetF_meca_LUR2)[models[[9]]$indexbestmodel])

#  this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetF_meca_LUR2$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetF_meca_LUR2[,models[[1]]$indexbestmodel]+VGOB1_subsetF_meca_LUR2[,models[[2]]$indexbestmodel]+VGOB1_subsetF_meca_LUR2[,models[[3]]$indexbestmodel]+ VGOB1_subsetF_meca_LUR2[,models[[4]]$indexbestmodel]+ VGOB1_subsetF_meca_LUR2[,models[[5]]$indexbestmodel]+ VGOB1_subsetF_meca_LUR2[,models[[6]]$indexbestmodel]+ VGOB1_subsetF_meca_LUR2[,models[[7]]$indexbestmodel]+ VGOB1_subsetF_meca_LUR2[,models[[8]]$indexbestmodel]+ VGOB1_subsetF_meca_LUR2[,models[[9]]$indexbestmodel]) 

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[5]]$summarybestmodel
models[[6]]$summarybestmodel
models[[7]]$summarybestmodel
models[[8]]$summarybestmodel
models[[9]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[5]]$namesbestmodel
models[[6]]$namesbestmodel
models[[7]]$namesbestmodel
models[[8]]$namesbestmodel
models[[9]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel
models[[5]]$R2bestmodel
models[[6]]$R2bestmodel
models[[7]]$R2bestmodel
models[[8]]$R2bestmodel
models[[9]]$R2bestmodel

# 10 #  
#  add tenth variable (the only difference of the above part is that now model n=10 the model statement more variables)
#  and the call for the list of variable names in the model changed slightly

modeln<-10

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_2 :nlastvar_LUR_2){if (is.numeric(VGOB1_subsetF_meca_LUR2[,i])==TRUE){ modeltry<-lm(VGOB1_subsetF_meca_LUR2$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetF_meca_LUR2[,models[[1]]$indexbestmodel]+VGOB1_subsetF_meca_LUR2[,models[[2]]$indexbestmodel]+ VGOB1_subsetF_meca_LUR2[,models[[3]]$indexbestmodel]+VGOB1_subsetF_meca_LUR2[,models[[4]]$indexbestmodel]+ VGOB1_subsetF_meca_LUR2[,models[[5]]$indexbestmodel]+ VGOB1_subsetF_meca_LUR2[,models[[6]]$indexbestmodel]+ VGOB1_subsetF_meca_LUR2[,models[[7]]$indexbestmodel]+ VGOB1_subsetF_meca_LUR2[,models[[8]]$indexbestmodel]+ VGOB1_subsetF_meca_LUR2[,models[[9]]$indexbestmodel]+ VGOB1_subsetF_meca_LUR2[,i]) 

R2<-rbind(R2,summary(modeltry)$adj.r.squared)
# the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # Measurements_livestockpreds_LUR2[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR2)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetF_meca_LUR2)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

# this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

# here are the names
models[[modeln]]$namesbestmodel<-c( names(VGOB1_subsetF_meca_LUR2)[models[[1]]$indexbestmodel],                   names(VGOB1_subsetF_meca_LUR2)[models[[2]]$indexbestmodel] , names(VGOB1_subsetF_meca_LUR2)[models[[3]]$indexbestmodel], names(VGOB1_subsetF_meca_LUR2)[models[[4]]$indexbestmodel], names(VGOB1_subsetF_meca_LUR2)[models[[5]]$indexbestmodel], names(VGOB1_subsetF_meca_LUR2)[models[[6]]$indexbestmodel], names(VGOB1_subsetF_meca_LUR2)[models[[7]]$indexbestmodel], names(VGOB1_subsetF_meca_LUR2)[models[[8]]$indexbestmodel], names(VGOB1_subsetF_meca_LUR2)[models[[9]]$indexbestmodel], names(VGOB1_subsetF_meca_LUR2)[models[[10]]$indexbestmodel])

#  this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetF_meca_LUR2$meca_copiespm3.ln.diffmeth.mean~                                VGOB1_subsetF_meca_LUR2[,models[[1]]$indexbestmodel]+ VGOB1_subsetF_meca_LUR2[,models[[2]]$indexbestmodel]+                           VGOB1_subsetF_meca_LUR2[,models[[3]]$indexbestmodel]+ VGOB1_subsetF_meca_LUR2[,models[[4]]$indexbestmodel]+ VGOB1_subsetF_meca_LUR2[,models[[5]]$indexbestmodel]+ VGOB1_subsetF_meca_LUR2[,models[[6]]$indexbestmodel]+ VGOB1_subsetF_meca_LUR2[,models[[7]]$indexbestmodel]+ VGOB1_subsetF_meca_LUR2[,models[[8]]$indexbestmodel]+ VGOB1_subsetF_meca_LUR2[,models[[9]]$indexbestmodel]+ VGOB1_subsetF_meca_LUR2[,models[[10]]$indexbestmodel]) 

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[5]]$summarybestmodel
models[[6]]$summarybestmodel
models[[7]]$summarybestmodel
models[[8]]$summarybestmodel
models[[9]]$summarybestmodel
models[[10]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[5]]$namesbestmodel
models[[6]]$namesbestmodel
models[[7]]$namesbestmodel
models[[8]]$namesbestmodel
models[[9]]$namesbestmodel
models[[10]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel
models[[5]]$R2bestmodel
models[[6]]$R2bestmodel
models[[7]]$R2bestmodel
models[[8]]$R2bestmodel
models[[9]]$R2bestmodel
models[[10]]$R2bestmodel

#  at this point I always check whether the next model is more than 1% better than the one before and if not I end here

#   CODE FOR PICKING OUT THE BEST MODEL #   
temp <- 0
besti <- 0
for (i in 1:10){ #  think this runs the loop 10 times - not fully sure thought - but not to do with the number of models I don't think - as when I change to 3, I still get the model with 4 variables as best model
  print(models[[i]]$R2bestmodel)
  #       print(models[[i]]$summarybestmodel$coefficients=-1,4])
  #       if((models[[i]]$R2bestmodel-temp > 0.0) && (all(models[[i]]$summarybestmodel$coefficients[-1,4]<0.1))){
  #         temp <- models[[i]]$R2bestmodel
  #         besti <- i
  #         }
  if((models[[i]]$R2bestmodel-temp > 0.0) && (all(models[[i]]$summarybestmodel$coefficients[-1,4]<0.1))){
    temp <- models[[i]]$R2bestmodel
    besti <- i
  }else{
    finalBestModel_meca_LUR2_subsetF <- models[[besti]]$bestmodel
    finalBestModelNames_meca_subsetF <- models[[besti]]$namesbestmodel
    Sites <- 1:dim(VGOB1_subsetF_meca_LUR2)[1] # full original model
    #  CVaR2<-escCV_meca_LUR2(Sites)[2] # Cross Validation
    maxCD<-max(cooks.distance(finalBestModel_meca_LUR2_subsetF))
    if(length(finalBestModelNames_meca_subsetF)<2){ # vif fn doesnot work when only 1 variable...       # 
      maxVIF<-"NA"
    }else{
      maxVIF<-max(vif(finalBestModel_meca_LUR2_subsetF))
    }
    print(paste("This is the best meca model for subset F: ",besti,
                "(AdjR2: ",format(models[[besti]]$R2bestmodel,digits=3), "; MaxCD: ",format(maxCD,digits=3),"; MaxVIF: ",
                format(maxVIF,digits=3),")", sep=''))
    print(finalBestModelNames_meca_subsetF)
    break
  }
}

#  Overview of the final best model using the algorithm selection process (taking into account VIF, R^2, and p-values)
finalBestModel_meca_LUR2_subsetF
finalBestModelNames_meca_subsetF
models[[besti]]$summarybestmodel
models[[besti]]$R2bestmodel

#### G ####
# LUR model building process for subset G
#  This is the dataframe with the relevant predictor vars for LUR2 models for subset G (55 sites)
VGOB1_subsetG_meca_LUR2 # n.b. this dataframe only includes microbial marker concentrations for meca unlike the dataframe Measurements_livestockpreds_LUR2 as previously used for the model building. 

#  Now set the values of some variables that will be needed
nfirstvar_LUR_2 <- 3  
nlastvar_LUR_2 <- 71

# Function building to run the models 
# 1 #  

models<-list()
modeln<-1
models[[modeln]]<-list()

R2<-1
betaaddedvar<-1
addedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_2:nlastvar_LUR_2){
  if (is.numeric(VGOB1_subsetG_meca_LUR2[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetG_meca_LUR2$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetG_meca_LUR2[,i])                            
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    #  Measurements_livestockpreds_LUR2[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR2)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetG_meca_LUR2)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)
models[[modeln]]$results

#  this are the candidates models with the highest R2, not a negative beta for the new, nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)
models[[modeln]]$resultspos

#  rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))
models[[modeln]]$resultspos

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j
models[[modeln]]$indexbestmodel

subset(models[[modeln]]$resultspos, rank==1)
subset(models[[modeln]]$resultspos)

#  this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]
models[[modeln]]$summarybestmodel

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetG_meca_LUR2)[models[[1]]$indexbestmodel])
models[[modeln]]$namesbestmodel

#  this is the r2 of that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2
models[[modeln]]$R2bestmodel

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetG_meca_LUR2$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetG_meca_LUR2[,models[[1]]$indexbestmodel]) 
models[[modeln]]$bestmodel

summary(models[[modeln]]$bestmodel)

#  The first model includes the predictor: nPigMultipFarmWghtDist.3000m.sum.Tr.1P9 - meaning the number of multiplier pig farms weighted to distance in a 3000m buffer

# 2 #  
# Add 2nd variable (the only difference of the above part is that now modeln=2 the model statement has 2 variables)
# and the call for the list of variable names in the model changed slightly

modeln<-2

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_2:nlastvar_LUR_2){
  if (is.numeric(VGOB1_subsetG_meca_LUR2[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetG_meca_LUR2$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetG_meca_LUR2[,models[[1]]$indexbestmodel]+ VGOB1_subsetG_meca_LUR2[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # Measurements_livestockpreds_LUR2[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR2)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetG_meca_LUR2)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  these are the candidate models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)
models[[modeln]]$resultspos

#  rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))
models[[modeln]]$resultspos

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j
models[[modeln]]$indexbestmodel

subset(models[[modeln]]$resultspos, rank==1)

# this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]
models[[modeln]]$summarybestmodel

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetG_meca_LUR2)[models[[1]]$indexbestmodel], names(VGOB1_subsetG_meca_LUR2)[models[[2]]$indexbestmodel] )
models[[modeln]]$namesbestmodel

# this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2
models[[modeln]]$R2bestmodel

# this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetG_meca_LUR2$meca_copiespm3.ln.diffmeth.mean~                               VGOB1_subsetG_meca_LUR2[,models[[1]]$indexbestmodel]+                           VGOB1_subsetG_meca_LUR2[,models[[2]]$indexbestmodel]) 

models[[modeln]]$bestmodel

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel


# 3 #  
# add third variable (the only difference of the above part is that now modeln=3 the model statement has 3 variables)
# and the call for the list of variable names in the model changed slightly

modeln<-3

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_2:nlastvar_LUR_2){
  if (is.numeric(VGOB1_subsetG_meca_LUR2[,i])==TRUE){  
    modeltry<-lm(VGOB1_subsetG_meca_LUR2$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetG_meca_LUR2[,models[[1]]$indexbestmodel]+VGOB1_subsetG_meca_LUR2[,models[[2]]$indexbestmodel]+ VGOB1_subsetG_meca_LUR2[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # All[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR2)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetG_meca_LUR2)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

#  rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

#  this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

#  here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetG_meca_LUR2)[models[[1]]$indexbestmodel], names(VGOB1_subsetG_meca_LUR2)[models[[2]]$indexbestmodel], names(VGOB1_subsetG_meca_LUR2)[models[[3]]$indexbestmodel])

#  this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetG_meca_LUR2$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetG_meca_LUR2[,models[[1]]$indexbestmodel]+ VGOB1_subsetG_meca_LUR2[,models[[2]]$indexbestmodel]+ VGOB1_subsetG_meca_LUR2[,models[[3]]$indexbestmodel]) 

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel


# 4 #  
#  add forth variable (the only difference of the above part is that now model n=4 the model statement more variables)
#  and the call for the list of variable names in the model changed slightly
modeln<-4

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1


for (i in nfirstvar_LUR_2:nlastvar_LUR_2){
  if (is.numeric(VGOB1_subsetG_meca_LUR2[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetG_meca_LUR2$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetG_meca_LUR2[,models[[1]]$indexbestmodel]+VGOB1_subsetG_meca_LUR2[,models[[2]]$indexbestmodel]+VGOB1_subsetG_meca_LUR2[,models[[3]]$indexbestmodel]+VGOB1_subsetG_meca_LUR2[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    #  the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    #  All[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR2)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetG_meca_LUR2)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

#  this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

#  here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetG_meca_LUR2)[models[[1]]$indexbestmodel], names(VGOB1_subsetG_meca_LUR2)[models[[2]]$indexbestmodel], names(VGOB1_subsetG_meca_LUR2)[models[[3]]$indexbestmodel], names(VGOB1_subsetG_meca_LUR2)[models[[4]]$indexbestmodel])

#  this is the r2 of that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetG_meca_LUR2$meca_copiespm3.ln.diffmeth.mean~ VGOB1_subsetG_meca_LUR2[,models[[1]]$indexbestmodel]+ VGOB1_subsetG_meca_LUR2[,models[[2]]$indexbestmodel]+VGOB1_subsetG_meca_LUR2[,models[[3]]$indexbestmodel]+ VGOB1_subsetG_meca_LUR2[,models[[4]]$indexbestmodel]) 


models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel


# 5 #  
# add fifth variable (the only difference of the above part is that now modeln=5 the model statement more variables)
# and the call for the list of variable names in the model changed slightly
modeln<-5

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_2:nlastvar_LUR_2){
  if (is.numeric(VGOB1_subsetG_meca_LUR2[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetG_meca_LUR2$meca_copiespm3.ln.diffmeth.mean~ VGOB1_subsetG_meca_LUR2[,models[[1]]$indexbestmodel]+ VGOB1_subsetG_meca_LUR2[,models[[2]]$indexbestmodel]+ VGOB1_subsetG_meca_LUR2[,models[[3]]$indexbestmodel]+ VGOB1_subsetG_meca_LUR2[,models[[4]]$indexbestmodel]+ VGOB1_subsetG_meca_LUR2[,i]) 
  
R2<-rbind(R2,summary(modeltry)$adj.r.squared)
# the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # All[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR2)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetG_meca_LUR2)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

#  this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetG_meca_LUR2)[models[[1]]$indexbestmodel], names(VGOB1_subsetG_meca_LUR2)[models[[2]]$indexbestmodel], names(VGOB1_subsetG_meca_LUR2)[models[[3]]$indexbestmodel], names(VGOB1_subsetG_meca_LUR2)[models[[4]]$indexbestmodel], names(VGOB1_subsetG_meca_LUR2)[models[[5]]$indexbestmodel])

#  this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetG_meca_LUR2$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetG_meca_LUR2[,models[[1]]$indexbestmodel]+VGOB1_subsetG_meca_LUR2[,models[[2]]$indexbestmodel]+VGOB1_subsetG_meca_LUR2[,models[[3]]$indexbestmodel]+ VGOB1_subsetG_meca_LUR2[,models[[4]]$indexbestmodel]+ VGOB1_subsetG_meca_LUR2[,models[[5]]$indexbestmodel]) 
models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[5]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[5]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel
models[[5]]$R2bestmodel

# 6 #  
# add sixth variable (the only difference of the above part is that now model n=6 the model statement more variables)
#  and the call for the list of variable names in the model changed slightly

modeln<-6

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_2 :nlastvar_LUR_2){
  if (is.numeric(VGOB1_subsetG_meca_LUR2[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetG_meca_LUR2$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetG_meca_LUR2[,models[[1]]$indexbestmodel]+VGOB1_subsetG_meca_LUR2[,models[[2]]$indexbestmodel]+VGOB1_subsetG_meca_LUR2[,models[[3]]$indexbestmodel]+VGOB1_subsetG_meca_LUR2[,models[[4]]$indexbestmodel]+VGOB1_subsetG_meca_LUR2[,models[[5]]$indexbestmodel]+ VGOB1_subsetG_meca_LUR2[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # All[,i] is the row that's being tried out now. the name of that row can be found in  names(All)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetG_meca_LUR2)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

# this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetG_meca_LUR2)[models[[1]]$indexbestmodel], names(VGOB1_subsetG_meca_LUR2)[models[[2]]$indexbestmodel] , names(VGOB1_subsetG_meca_LUR2)[models[[3]]$indexbestmodel], names(VGOB1_subsetG_meca_LUR2)[models[[4]]$indexbestmodel], names(VGOB1_subsetG_meca_LUR2)[models[[5]]$indexbestmodel], names(VGOB1_subsetG_meca_LUR2)[models[[6]]$indexbestmodel])

#  this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetG_meca_LUR2$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetG_meca_LUR2[,models[[1]]$indexbestmodel]+VGOB1_subsetG_meca_LUR2[,models[[2]]$indexbestmodel]+VGOB1_subsetG_meca_LUR2[,models[[3]]$indexbestmodel]+ VGOB1_subsetG_meca_LUR2[,models[[4]]$indexbestmodel]+ VGOB1_subsetG_meca_LUR2[,models[[5]]$indexbestmodel]+ VGOB1_subsetG_meca_LUR2[,models[[6]]$indexbestmodel]) 

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[5]]$summarybestmodel
models[[6]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[5]]$namesbestmodel
models[[6]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel
models[[5]]$R2bestmodel
models[[6]]$R2bestmodel


# 7 #  
# add seventh variable (the only difference of the above part is that now model n=7 the model statement more variables)
#  and the call for the list of variable names in the model changed slightly

modeln<-7

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_2 :nlastvar_LUR_2){
  if (is.numeric(VGOB1_subsetG_meca_LUR2[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetG_meca_LUR2$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetG_meca_LUR2[,models[[1]]$indexbestmodel]+VGOB1_subsetG_meca_LUR2[,models[[2]]$indexbestmodel]+VGOB1_subsetG_meca_LUR2[,models[[3]]$indexbestmodel]+VGOB1_subsetG_meca_LUR2[,models[[4]]$indexbestmodel]+VGOB1_subsetG_meca_LUR2[,models[[5]]$indexbestmodel]+VGOB1_subsetG_meca_LUR2[,models[[6]]$indexbestmodel]+ VGOB1_subsetG_meca_LUR2[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # Measurements_livestockpreds_LUR2[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR2)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetG_meca_LUR2)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

# this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetG_meca_LUR2)[models[[1]]$indexbestmodel], names(VGOB1_subsetG_meca_LUR2)[models[[2]]$indexbestmodel] , names(VGOB1_subsetG_meca_LUR2)[models[[3]]$indexbestmodel], names(VGOB1_subsetG_meca_LUR2)[models[[4]]$indexbestmodel], names(VGOB1_subsetG_meca_LUR2)[models[[5]]$indexbestmodel], names(VGOB1_subsetG_meca_LUR2)[models[[6]]$indexbestmodel], names(VGOB1_subsetG_meca_LUR2)[models[[7]]$indexbestmodel])

#  this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetG_meca_LUR2$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetG_meca_LUR2[,models[[1]]$indexbestmodel]+VGOB1_subsetG_meca_LUR2[,models[[2]]$indexbestmodel]+VGOB1_subsetG_meca_LUR2[,models[[3]]$indexbestmodel]+ VGOB1_subsetG_meca_LUR2[,models[[4]]$indexbestmodel]+ VGOB1_subsetG_meca_LUR2[,models[[5]]$indexbestmodel]+ VGOB1_subsetG_meca_LUR2[,models[[6]]$indexbestmodel]+ VGOB1_subsetG_meca_LUR2[,models[[7]]$indexbestmodel]) 

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[5]]$summarybestmodel
models[[6]]$summarybestmodel
models[[7]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[5]]$namesbestmodel
models[[6]]$namesbestmodel
models[[7]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel
models[[5]]$R2bestmodel
models[[6]]$R2bestmodel
models[[7]]$R2bestmodel

# 8 #
# add eighth variable (the only difference of the above part is that now modeln=7 the model statement more variables)
# and the call for the list of variable names in the model changed slightly

modeln<-8

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_2 :nlastvar_LUR_2){
  if (is.numeric(VGOB1_subsetG_meca_LUR2[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetG_meca_LUR2$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetG_meca_LUR2[,models[[1]]$indexbestmodel]+VGOB1_subsetG_meca_LUR2[,models[[2]]$indexbestmodel]+VGOB1_subsetG_meca_LUR2[,models[[3]]$indexbestmodel]+VGOB1_subsetG_meca_LUR2[,models[[4]]$indexbestmodel]+VGOB1_subsetG_meca_LUR2[,models[[5]]$indexbestmodel]+VGOB1_subsetG_meca_LUR2[,models[[6]]$indexbestmodel]+ VGOB1_subsetG_meca_LUR2[,models[[7]]$indexbestmodel]+ VGOB1_subsetG_meca_LUR2[,i])
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])#
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # Measurements_livestockpreds_LUR2[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR2)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetG_meca_LUR2)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

# this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetG_meca_LUR2)[models[[1]]$indexbestmodel], names(VGOB1_subsetG_meca_LUR2)[models[[2]]$indexbestmodel] , names(VGOB1_subsetG_meca_LUR2)[models[[3]]$indexbestmodel], names(VGOB1_subsetG_meca_LUR2)[models[[4]]$indexbestmodel], names(VGOB1_subsetG_meca_LUR2)[models[[5]]$indexbestmodel], names(VGOB1_subsetG_meca_LUR2)[models[[6]]$indexbestmodel], names(VGOB1_subsetG_meca_LUR2)[models[[7]]$indexbestmodel], names(VGOB1_subsetG_meca_LUR2)[models[[8]]$indexbestmodel])

#  this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetG_meca_LUR2$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetG_meca_LUR2[,models[[1]]$indexbestmodel]+VGOB1_subsetG_meca_LUR2[,models[[2]]$indexbestmodel]+VGOB1_subsetG_meca_LUR2[,models[[3]]$indexbestmodel]+ VGOB1_subsetG_meca_LUR2[,models[[4]]$indexbestmodel]+ VGOB1_subsetG_meca_LUR2[,models[[5]]$indexbestmodel]+ VGOB1_subsetG_meca_LUR2[,models[[6]]$indexbestmodel]+ VGOB1_subsetG_meca_LUR2[,models[[7]]$indexbestmodel]+ VGOB1_subsetG_meca_LUR2[,models[[8]]$indexbestmodel])

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[5]]$summarybestmodel
models[[6]]$summarybestmodel
models[[7]]$summarybestmodel
models[[8]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[5]]$namesbestmodel
models[[6]]$namesbestmodel
models[[7]]$namesbestmodel
models[[8]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel
models[[5]]$R2bestmodel
models[[6]]$R2bestmodel
models[[7]]$R2bestmodel
models[[8]]$R2bestmodel

# 9 #
# add ninth variable (the only difference of the above part is that now modeln=9 the model statement more variables)
# and the call for the list of variable names in the model changed slightly

modeln<-9

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_2 :nlastvar_LUR_2){
  if (is.numeric(VGOB1_subsetG_meca_LUR2[,i])==TRUE){
      modeltry<-lm(VGOB1_subsetG_meca_LUR2$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetG_meca_LUR2[,models[[1]]$indexbestmodel]+VGOB1_subsetG_meca_LUR2[,models[[2]]$indexbestmodel]+VGOB1_subsetG_meca_LUR2[,models[[3]]$indexbestmodel]+VGOB1_subsetG_meca_LUR2[,models[[4]]$indexbestmodel]+VGOB1_subsetG_meca_LUR2[,models[[5]]$indexbestmodel]+VGOB1_subsetG_meca_LUR2[,models[[6]]$indexbestmodel]+ VGOB1_subsetG_meca_LUR2[,models[[7]]$indexbestmodel]+ VGOB1_subsetG_meca_LUR2[,models[[8]]$indexbestmodel]+ VGOB1_subsetG_meca_LUR2[,i])
        R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])#
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # Measurements_livestockpreds_LUR2[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR2)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetG_meca_LUR2)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

# this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetG_meca_LUR2)[models[[1]]$indexbestmodel], names(VGOB1_subsetG_meca_LUR2)[models[[2]]$indexbestmodel] , names(VGOB1_subsetG_meca_LUR2)[models[[3]]$indexbestmodel], names(VGOB1_subsetG_meca_LUR2)[models[[4]]$indexbestmodel], names(VGOB1_subsetG_meca_LUR2)[models[[5]]$indexbestmodel], names(VGOB1_subsetG_meca_LUR2)[models[[6]]$indexbestmodel], names(VGOB1_subsetG_meca_LUR2)[models[[7]]$indexbestmodel], names(VGOB1_subsetG_meca_LUR2)[models[[8]]$indexbestmodel],  names(VGOB1_subsetG_meca_LUR2)[models[[9]]$indexbestmodel])

#  this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetG_meca_LUR2$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetG_meca_LUR2[,models[[1]]$indexbestmodel]+VGOB1_subsetG_meca_LUR2[,models[[2]]$indexbestmodel]+VGOB1_subsetG_meca_LUR2[,models[[3]]$indexbestmodel]+ VGOB1_subsetG_meca_LUR2[,models[[4]]$indexbestmodel]+ VGOB1_subsetG_meca_LUR2[,models[[5]]$indexbestmodel]+ VGOB1_subsetG_meca_LUR2[,models[[6]]$indexbestmodel]+ VGOB1_subsetG_meca_LUR2[,models[[7]]$indexbestmodel]+ VGOB1_subsetG_meca_LUR2[,models[[8]]$indexbestmodel]+ VGOB1_subsetG_meca_LUR2[,models[[9]]$indexbestmodel])

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[5]]$summarybestmodel
models[[6]]$summarybestmodel
models[[7]]$summarybestmodel
models[[8]]$summarybestmodel
models[[9]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[5]]$namesbestmodel
models[[6]]$namesbestmodel
models[[7]]$namesbestmodel
models[[8]]$namesbestmodel
models[[9]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel
models[[5]]$R2bestmodel
models[[6]]$R2bestmodel
models[[7]]$R2bestmodel
models[[8]]$R2bestmodel
models[[9]]$R2bestmodel

# 10 #
#  add tenth variable (the only difference of the above part is that now model n=10 the model statement more variables)
#  and the call for the list of variable names in the model changed slightly

modeln<-10

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_2 :nlastvar_LUR_2){if (is.numeric(VGOB1_subsetG_meca_LUR2[,i])==TRUE){ modeltry<-lm(VGOB1_subsetG_meca_LUR2$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetG_meca_LUR2[,models[[1]]$indexbestmodel]+VGOB1_subsetG_meca_LUR2[,models[[2]]$indexbestmodel]+ VGOB1_subsetG_meca_LUR2[,models[[3]]$indexbestmodel]+VGOB1_subsetG_meca_LUR2[,models[[4]]$indexbestmodel]+ VGOB1_subsetG_meca_LUR2[,models[[5]]$indexbestmodel]+ VGOB1_subsetG_meca_LUR2[,models[[6]]$indexbestmodel]+ VGOB1_subsetG_meca_LUR2[,models[[7]]$indexbestmodel]+ VGOB1_subsetG_meca_LUR2[,models[[8]]$indexbestmodel]+ VGOB1_subsetG_meca_LUR2[,models[[9]]$indexbestmodel]+ VGOB1_subsetG_meca_LUR2[,i])

R2<-rbind(R2,summary(modeltry)$adj.r.squared)
# the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])#
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # Measurements_livestockpreds_LUR2[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR2)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetG_meca_LUR2)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

# this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

# here are the names
models[[modeln]]$namesbestmodel<-c( names(VGOB1_subsetG_meca_LUR2)[models[[1]]$indexbestmodel],                   names(VGOB1_subsetG_meca_LUR2)[models[[2]]$indexbestmodel] , names(VGOB1_subsetG_meca_LUR2)[models[[3]]$indexbestmodel], names(VGOB1_subsetG_meca_LUR2)[models[[4]]$indexbestmodel], names(VGOB1_subsetG_meca_LUR2)[models[[5]]$indexbestmodel], names(VGOB1_subsetG_meca_LUR2)[models[[6]]$indexbestmodel], names(VGOB1_subsetG_meca_LUR2)[models[[7]]$indexbestmodel], names(VGOB1_subsetG_meca_LUR2)[models[[8]]$indexbestmodel], names(VGOB1_subsetG_meca_LUR2)[models[[9]]$indexbestmodel], names(VGOB1_subsetG_meca_LUR2)[models[[10]]$indexbestmodel])

#  this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetG_meca_LUR2$meca_copiespm3.ln.diffmeth.mean~                                VGOB1_subsetG_meca_LUR2[,models[[1]]$indexbestmodel]+ VGOB1_subsetG_meca_LUR2[,models[[2]]$indexbestmodel]+                           VGOB1_subsetG_meca_LUR2[,models[[3]]$indexbestmodel]+ VGOB1_subsetG_meca_LUR2[,models[[4]]$indexbestmodel]+ VGOB1_subsetG_meca_LUR2[,models[[5]]$indexbestmodel]+ VGOB1_subsetG_meca_LUR2[,models[[6]]$indexbestmodel]+ VGOB1_subsetG_meca_LUR2[,models[[7]]$indexbestmodel]+ VGOB1_subsetG_meca_LUR2[,models[[8]]$indexbestmodel]+ VGOB1_subsetG_meca_LUR2[,models[[9]]$indexbestmodel]+ VGOB1_subsetG_meca_LUR2[,models[[10]]$indexbestmodel])

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[5]]$summarybestmodel
models[[6]]$summarybestmodel
models[[7]]$summarybestmodel
models[[8]]$summarybestmodel
models[[9]]$summarybestmodel
models[[10]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[5]]$namesbestmodel
models[[6]]$namesbestmodel
models[[7]]$namesbestmodel
models[[8]]$namesbestmodel
models[[9]]$namesbestmodel
models[[10]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel
models[[5]]$R2bestmodel
models[[6]]$R2bestmodel
models[[7]]$R2bestmodel
models[[8]]$R2bestmodel
models[[9]]$R2bestmodel
models[[10]]$R2bestmodel

#   CODE FOR PICKING OUT THE BEST MODEL #   
temp <- 0
besti <- 0
for (i in 1:10){ #  think this runs the loop 10 times - not fully sure thought - but not to do with the number of models I don't think - as when I change to 3, I still get the model with 4 variables as best model
  print(models[[i]]$R2bestmodel)
  #       print(models[[i]]$summarybestmodel$coefficients=-1,4])
  #       if((models[[i]]$R2bestmodel-temp > 0.0) && (all(models[[i]]$summarybestmodel$coefficients[-1,4]<0.1))){
  #         temp <- models[[i]]$R2bestmodel
  #         besti <- i
  #         }
  if((models[[i]]$R2bestmodel-temp > 0.0) && (all(models[[i]]$summarybestmodel$coefficients[-1,4]<0.1))){
    temp <- models[[i]]$R2bestmodel
    besti <- i
  }else{
    finalBestModel_meca_LUR2_subsetG <- models[[besti]]$bestmodel
    finalBestModelNames_meca_subsetG <- models[[besti]]$namesbestmodel
    Sites <- 1:dim(VGOB1_subsetG_meca_LUR2)[1] # full original model
    #  CVaR2<-escCV_meca_LUR2(Sites)[2] # Cross Validation
    maxCD<-max(cooks.distance(finalBestModel_meca_LUR2_subsetG))
    if(length(finalBestModelNames_meca_subsetG)<2){ # vif fn doesnot work when only 1 variable...       # 
      maxVIF<-"NA"
    }else{
      maxVIF<-max(vif(finalBestModel_meca_LUR2_subsetG))
    }
    print(paste("This is the best meca model for subset G: ",besti,
                "(AdjR2: ",format(models[[besti]]$R2bestmodel,digits=3), "; MaxCD: ",format(maxCD,digits=3),"; MaxVIF: ",
                format(maxVIF,digits=3),")", sep=''))
    print(finalBestModelNames_meca_subsetG)
    break
  }
}

#  Overview of the final best model using the algorithm selection process (taking into account VIF, R^2, and p-values)
finalBestModel_meca_LUR2_subsetG
finalBestModelNames_meca_subsetG
models[[besti]]$summarybestmodel
models[[besti]]$R2bestmodel

#### H ####
# LUR model building process for subset H
#  This is the dataframe with the relevant predictor vars for LUR2 models for subset H (55 sites)
VGOB1_subsetH_meca_LUR2 # n.b. this dataframe only includes microbial marker concentrations for meca unlike the dataframe Measurements_livestockpreds_LUR2 as previously used for the model building. 

#  Now set the values of some variables that will be needed
nfirstvar_LUR_2 <- 3  
nlastvar_LUR_2 <- 71

# Function building to run the models 
# 1 #  

models<-list()
modeln<-1
models[[modeln]]<-list()

R2<-1
betaaddedvar<-1
addedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_2:nlastvar_LUR_2){
  if (is.numeric(VGOB1_subsetH_meca_LUR2[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetH_meca_LUR2$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetH_meca_LUR2[,i])                            
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    #  Measurements_livestockpreds_LUR2[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR2)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetH_meca_LUR2)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)
models[[modeln]]$results

#  this are the candidates models with the highest R2, not a negative beta for the new, nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)
models[[modeln]]$resultspos

#  rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))
models[[modeln]]$resultspos

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j
models[[modeln]]$indexbestmodel

subset(models[[modeln]]$resultspos, rank==1)
subset(models[[modeln]]$resultspos)

#  this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]
models[[modeln]]$summarybestmodel

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetH_meca_LUR2)[models[[1]]$indexbestmodel])
models[[modeln]]$namesbestmodel

#  this is the r2 of that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2
models[[modeln]]$R2bestmodel

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetH_meca_LUR2$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetH_meca_LUR2[,models[[1]]$indexbestmodel]) 
models[[modeln]]$bestmodel

summary(models[[modeln]]$bestmodel)

#  The first model includes the predictor: nPigMultipFarmWghtDist.3000m.sum.Tr.1P9 - meaning the number of multiplier pig farms weighted to distance in a 3000m buffer

# 2 #  
# Add 2nd variable (the only difference of the above part is that now modeln=2 the model statement has 2 variables)
# and the call for the list of variable names in the model changed slightly

modeln<-2

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_2:nlastvar_LUR_2){
  if (is.numeric(VGOB1_subsetH_meca_LUR2[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetH_meca_LUR2$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetH_meca_LUR2[,models[[1]]$indexbestmodel]+ VGOB1_subsetH_meca_LUR2[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # Measurements_livestockpreds_LUR2[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR2)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetH_meca_LUR2)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  these are the candidate models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)
models[[modeln]]$resultspos

#  rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))
models[[modeln]]$resultspos

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j
models[[modeln]]$indexbestmodel

subset(models[[modeln]]$resultspos, rank==1)

# this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]
models[[modeln]]$summarybestmodel

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetH_meca_LUR2)[models[[1]]$indexbestmodel], names(VGOB1_subsetH_meca_LUR2)[models[[2]]$indexbestmodel] )
models[[modeln]]$namesbestmodel

# this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2
models[[modeln]]$R2bestmodel

# this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetH_meca_LUR2$meca_copiespm3.ln.diffmeth.mean~                               VGOB1_subsetH_meca_LUR2[,models[[1]]$indexbestmodel]+                           VGOB1_subsetH_meca_LUR2[,models[[2]]$indexbestmodel]) 

models[[modeln]]$bestmodel

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel


# 3 #  
# add third variable (the only difference of the above part is that now modeln=3 the model statement has 3 variables)
# and the call for the list of variable names in the model changed slightly

modeln<-3

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_2:nlastvar_LUR_2){
  if (is.numeric(VGOB1_subsetH_meca_LUR2[,i])==TRUE){  
    modeltry<-lm(VGOB1_subsetH_meca_LUR2$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetH_meca_LUR2[,models[[1]]$indexbestmodel]+VGOB1_subsetH_meca_LUR2[,models[[2]]$indexbestmodel]+ VGOB1_subsetH_meca_LUR2[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # All[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR2)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetH_meca_LUR2)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

#  rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

#  this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

#  here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetH_meca_LUR2)[models[[1]]$indexbestmodel], names(VGOB1_subsetH_meca_LUR2)[models[[2]]$indexbestmodel], names(VGOB1_subsetH_meca_LUR2)[models[[3]]$indexbestmodel])

#  this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetH_meca_LUR2$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetH_meca_LUR2[,models[[1]]$indexbestmodel]+ VGOB1_subsetH_meca_LUR2[,models[[2]]$indexbestmodel]+ VGOB1_subsetH_meca_LUR2[,models[[3]]$indexbestmodel]) 

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel


# 4 #  
#  add forth variable (the only difference of the above part is that now model n=4 the model statement more variables)
#  and the call for the list of variable names in the model changed slightly
modeln<-4

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1


for (i in nfirstvar_LUR_2:nlastvar_LUR_2){
  if (is.numeric(VGOB1_subsetH_meca_LUR2[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetH_meca_LUR2$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetH_meca_LUR2[,models[[1]]$indexbestmodel]+VGOB1_subsetH_meca_LUR2[,models[[2]]$indexbestmodel]+VGOB1_subsetH_meca_LUR2[,models[[3]]$indexbestmodel]+VGOB1_subsetH_meca_LUR2[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    #  the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    #  All[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR2)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetH_meca_LUR2)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

#  this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

#  here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetH_meca_LUR2)[models[[1]]$indexbestmodel], names(VGOB1_subsetH_meca_LUR2)[models[[2]]$indexbestmodel], names(VGOB1_subsetH_meca_LUR2)[models[[3]]$indexbestmodel], names(VGOB1_subsetH_meca_LUR2)[models[[4]]$indexbestmodel])

#  this is the r2 of that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetH_meca_LUR2$meca_copiespm3.ln.diffmeth.mean~ VGOB1_subsetH_meca_LUR2[,models[[1]]$indexbestmodel]+ VGOB1_subsetH_meca_LUR2[,models[[2]]$indexbestmodel]+VGOB1_subsetH_meca_LUR2[,models[[3]]$indexbestmodel]+ VGOB1_subsetH_meca_LUR2[,models[[4]]$indexbestmodel]) 


models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel


# 5 #  
# add fifth variable (the only difference of the above part is that now modeln=5 the model statement more variables)
# and the call for the list of variable names in the model changed slightly
modeln<-5

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_2:nlastvar_LUR_2){
  if (is.numeric(VGOB1_subsetH_meca_LUR2[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetH_meca_LUR2$meca_copiespm3.ln.diffmeth.mean~ VGOB1_subsetH_meca_LUR2[,models[[1]]$indexbestmodel]+ VGOB1_subsetH_meca_LUR2[,models[[2]]$indexbestmodel]+ VGOB1_subsetH_meca_LUR2[,models[[3]]$indexbestmodel]+ VGOB1_subsetH_meca_LUR2[,models[[4]]$indexbestmodel]+ VGOB1_subsetH_meca_LUR2[,i]) 
  
R2<-rbind(R2,summary(modeltry)$adj.r.squared)
# the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # All[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR2)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetH_meca_LUR2)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

#  this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetH_meca_LUR2)[models[[1]]$indexbestmodel], names(VGOB1_subsetH_meca_LUR2)[models[[2]]$indexbestmodel], names(VGOB1_subsetH_meca_LUR2)[models[[3]]$indexbestmodel], names(VGOB1_subsetH_meca_LUR2)[models[[4]]$indexbestmodel], names(VGOB1_subsetH_meca_LUR2)[models[[5]]$indexbestmodel])

#  this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetH_meca_LUR2$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetH_meca_LUR2[,models[[1]]$indexbestmodel]+VGOB1_subsetH_meca_LUR2[,models[[2]]$indexbestmodel]+VGOB1_subsetH_meca_LUR2[,models[[3]]$indexbestmodel]+ VGOB1_subsetH_meca_LUR2[,models[[4]]$indexbestmodel]+ VGOB1_subsetH_meca_LUR2[,models[[5]]$indexbestmodel]) 
models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[5]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[5]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel
models[[5]]$R2bestmodel

# 6 #  
# add sixth variable (the only difference of the above part is that now model n=6 the model statement more variables)
#  and the call for the list of variable names in the model changed slightly

modeln<-6

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_2 :nlastvar_LUR_2){
  if (is.numeric(VGOB1_subsetH_meca_LUR2[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetH_meca_LUR2$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetH_meca_LUR2[,models[[1]]$indexbestmodel]+VGOB1_subsetH_meca_LUR2[,models[[2]]$indexbestmodel]+VGOB1_subsetH_meca_LUR2[,models[[3]]$indexbestmodel]+VGOB1_subsetH_meca_LUR2[,models[[4]]$indexbestmodel]+VGOB1_subsetH_meca_LUR2[,models[[5]]$indexbestmodel]+ VGOB1_subsetH_meca_LUR2[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # All[,i] is the row that's being tried out now. the name of that row can be found in  names(All)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetH_meca_LUR2)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

# this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetH_meca_LUR2)[models[[1]]$indexbestmodel], names(VGOB1_subsetH_meca_LUR2)[models[[2]]$indexbestmodel] , names(VGOB1_subsetH_meca_LUR2)[models[[3]]$indexbestmodel], names(VGOB1_subsetH_meca_LUR2)[models[[4]]$indexbestmodel], names(VGOB1_subsetH_meca_LUR2)[models[[5]]$indexbestmodel], names(VGOB1_subsetH_meca_LUR2)[models[[6]]$indexbestmodel])

#  this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetH_meca_LUR2$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetH_meca_LUR2[,models[[1]]$indexbestmodel]+VGOB1_subsetH_meca_LUR2[,models[[2]]$indexbestmodel]+VGOB1_subsetH_meca_LUR2[,models[[3]]$indexbestmodel]+ VGOB1_subsetH_meca_LUR2[,models[[4]]$indexbestmodel]+ VGOB1_subsetH_meca_LUR2[,models[[5]]$indexbestmodel]+ VGOB1_subsetH_meca_LUR2[,models[[6]]$indexbestmodel]) 

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[5]]$summarybestmodel
models[[6]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[5]]$namesbestmodel
models[[6]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel
models[[5]]$R2bestmodel
models[[6]]$R2bestmodel


# 7 #  
# add seventh variable (the only difference of the above part is that now model n=7 the model statement more variables)
#  and the call for the list of variable names in the model changed slightly

modeln<-7

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_2 :nlastvar_LUR_2){
  if (is.numeric(VGOB1_subsetH_meca_LUR2[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetH_meca_LUR2$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetH_meca_LUR2[,models[[1]]$indexbestmodel]+VGOB1_subsetH_meca_LUR2[,models[[2]]$indexbestmodel]+VGOB1_subsetH_meca_LUR2[,models[[3]]$indexbestmodel]+VGOB1_subsetH_meca_LUR2[,models[[4]]$indexbestmodel]+VGOB1_subsetH_meca_LUR2[,models[[5]]$indexbestmodel]+VGOB1_subsetH_meca_LUR2[,models[[6]]$indexbestmodel]+ VGOB1_subsetH_meca_LUR2[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # Measurements_livestockpreds_LUR2[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR2)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetH_meca_LUR2)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

# this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetH_meca_LUR2)[models[[1]]$indexbestmodel], names(VGOB1_subsetH_meca_LUR2)[models[[2]]$indexbestmodel] , names(VGOB1_subsetH_meca_LUR2)[models[[3]]$indexbestmodel], names(VGOB1_subsetH_meca_LUR2)[models[[4]]$indexbestmodel], names(VGOB1_subsetH_meca_LUR2)[models[[5]]$indexbestmodel], names(VGOB1_subsetH_meca_LUR2)[models[[6]]$indexbestmodel], names(VGOB1_subsetH_meca_LUR2)[models[[7]]$indexbestmodel])

#  this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetH_meca_LUR2$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetH_meca_LUR2[,models[[1]]$indexbestmodel]+VGOB1_subsetH_meca_LUR2[,models[[2]]$indexbestmodel]+VGOB1_subsetH_meca_LUR2[,models[[3]]$indexbestmodel]+ VGOB1_subsetH_meca_LUR2[,models[[4]]$indexbestmodel]+ VGOB1_subsetH_meca_LUR2[,models[[5]]$indexbestmodel]+ VGOB1_subsetH_meca_LUR2[,models[[6]]$indexbestmodel]+ VGOB1_subsetH_meca_LUR2[,models[[7]]$indexbestmodel]) 

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[5]]$summarybestmodel
models[[6]]$summarybestmodel
models[[7]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[5]]$namesbestmodel
models[[6]]$namesbestmodel
models[[7]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel
models[[5]]$R2bestmodel
models[[6]]$R2bestmodel
models[[7]]$R2bestmodel

# 8 #  
# add eighth variable (the only difference of the above part is that now modeln=7 the model statement more variables)
# and the call for the list of variable names in the model changed slightly

modeln<-8

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_2 :nlastvar_LUR_2){
  if (is.numeric(VGOB1_subsetH_meca_LUR2[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetH_meca_LUR2$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetH_meca_LUR2[,models[[1]]$indexbestmodel]+VGOB1_subsetH_meca_LUR2[,models[[2]]$indexbestmodel]+VGOB1_subsetH_meca_LUR2[,models[[3]]$indexbestmodel]+VGOB1_subsetH_meca_LUR2[,models[[4]]$indexbestmodel]+VGOB1_subsetH_meca_LUR2[,models[[5]]$indexbestmodel]+VGOB1_subsetH_meca_LUR2[,models[[6]]$indexbestmodel]+ VGOB1_subsetH_meca_LUR2[,models[[7]]$indexbestmodel]+ VGOB1_subsetH_meca_LUR2[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # Measurements_livestockpreds_LUR2[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR2)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetH_meca_LUR2)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

# this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetH_meca_LUR2)[models[[1]]$indexbestmodel], names(VGOB1_subsetH_meca_LUR2)[models[[2]]$indexbestmodel] , names(VGOB1_subsetH_meca_LUR2)[models[[3]]$indexbestmodel], names(VGOB1_subsetH_meca_LUR2)[models[[4]]$indexbestmodel], names(VGOB1_subsetH_meca_LUR2)[models[[5]]$indexbestmodel], names(VGOB1_subsetH_meca_LUR2)[models[[6]]$indexbestmodel], names(VGOB1_subsetH_meca_LUR2)[models[[7]]$indexbestmodel], names(VGOB1_subsetH_meca_LUR2)[models[[8]]$indexbestmodel])

#  this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetH_meca_LUR2$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetH_meca_LUR2[,models[[1]]$indexbestmodel]+VGOB1_subsetH_meca_LUR2[,models[[2]]$indexbestmodel]+VGOB1_subsetH_meca_LUR2[,models[[3]]$indexbestmodel]+ VGOB1_subsetH_meca_LUR2[,models[[4]]$indexbestmodel]+ VGOB1_subsetH_meca_LUR2[,models[[5]]$indexbestmodel]+ VGOB1_subsetH_meca_LUR2[,models[[6]]$indexbestmodel]+ VGOB1_subsetH_meca_LUR2[,models[[7]]$indexbestmodel]+ VGOB1_subsetH_meca_LUR2[,models[[8]]$indexbestmodel]) 

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[5]]$summarybestmodel
models[[6]]$summarybestmodel
models[[7]]$summarybestmodel
models[[8]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[5]]$namesbestmodel
models[[6]]$namesbestmodel
models[[7]]$namesbestmodel
models[[8]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel
models[[5]]$R2bestmodel
models[[6]]$R2bestmodel
models[[7]]$R2bestmodel
models[[8]]$R2bestmodel

# 9 #  
# add ninth variable (the only difference of the above part is that now modeln=9 the model statement more variables)
# and the call for the list of variable names in the model changed slightly

modeln<-9

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_2 :nlastvar_LUR_2){
  if (is.numeric(VGOB1_subsetH_meca_LUR2[,i])==TRUE){
      modeltry<-lm(VGOB1_subsetH_meca_LUR2$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetH_meca_LUR2[,models[[1]]$indexbestmodel]+VGOB1_subsetH_meca_LUR2[,models[[2]]$indexbestmodel]+VGOB1_subsetH_meca_LUR2[,models[[3]]$indexbestmodel]+VGOB1_subsetH_meca_LUR2[,models[[4]]$indexbestmodel]+VGOB1_subsetH_meca_LUR2[,models[[5]]$indexbestmodel]+VGOB1_subsetH_meca_LUR2[,models[[6]]$indexbestmodel]+ VGOB1_subsetH_meca_LUR2[,models[[7]]$indexbestmodel]+ VGOB1_subsetH_meca_LUR2[,models[[8]]$indexbestmodel]+ VGOB1_subsetH_meca_LUR2[,i]) 
        R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # Measurements_livestockpreds_LUR2[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR2)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetH_meca_LUR2)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

# this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetH_meca_LUR2)[models[[1]]$indexbestmodel], names(VGOB1_subsetH_meca_LUR2)[models[[2]]$indexbestmodel] , names(VGOB1_subsetH_meca_LUR2)[models[[3]]$indexbestmodel], names(VGOB1_subsetH_meca_LUR2)[models[[4]]$indexbestmodel], names(VGOB1_subsetH_meca_LUR2)[models[[5]]$indexbestmodel], names(VGOB1_subsetH_meca_LUR2)[models[[6]]$indexbestmodel], names(VGOB1_subsetH_meca_LUR2)[models[[7]]$indexbestmodel], names(VGOB1_subsetH_meca_LUR2)[models[[8]]$indexbestmodel],  names(VGOB1_subsetH_meca_LUR2)[models[[9]]$indexbestmodel])

#  this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetH_meca_LUR2$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetH_meca_LUR2[,models[[1]]$indexbestmodel]+VGOB1_subsetH_meca_LUR2[,models[[2]]$indexbestmodel]+VGOB1_subsetH_meca_LUR2[,models[[3]]$indexbestmodel]+ VGOB1_subsetH_meca_LUR2[,models[[4]]$indexbestmodel]+ VGOB1_subsetH_meca_LUR2[,models[[5]]$indexbestmodel]+ VGOB1_subsetH_meca_LUR2[,models[[6]]$indexbestmodel]+ VGOB1_subsetH_meca_LUR2[,models[[7]]$indexbestmodel]+ VGOB1_subsetH_meca_LUR2[,models[[8]]$indexbestmodel]+ VGOB1_subsetH_meca_LUR2[,models[[9]]$indexbestmodel]) 

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[5]]$summarybestmodel
models[[6]]$summarybestmodel
models[[7]]$summarybestmodel
models[[8]]$summarybestmodel
models[[9]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[5]]$namesbestmodel
models[[6]]$namesbestmodel
models[[7]]$namesbestmodel
models[[8]]$namesbestmodel
models[[9]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel
models[[5]]$R2bestmodel
models[[6]]$R2bestmodel
models[[7]]$R2bestmodel
models[[8]]$R2bestmodel
models[[9]]$R2bestmodel



# 10 #
#  add tenth variable (the only difference of the above part is that now model n=10 the model statement more variables)
#  and the call for the list of variable names in the model changed slightly

modeln<-10

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_2 :nlastvar_LUR_2){if (is.numeric(VGOB1_subsetH_meca_LUR2[,i])==TRUE){ modeltry<-lm(VGOB1_subsetH_meca_LUR2$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetH_meca_LUR2[,models[[1]]$indexbestmodel]+VGOB1_subsetH_meca_LUR2[,models[[2]]$indexbestmodel]+ VGOB1_subsetH_meca_LUR2[,models[[3]]$indexbestmodel]+VGOB1_subsetH_meca_LUR2[,models[[4]]$indexbestmodel]+ VGOB1_subsetH_meca_LUR2[,models[[5]]$indexbestmodel]+ VGOB1_subsetH_meca_LUR2[,models[[6]]$indexbestmodel]+ VGOB1_subsetH_meca_LUR2[,models[[7]]$indexbestmodel]+ VGOB1_subsetH_meca_LUR2[,models[[8]]$indexbestmodel]+ VGOB1_subsetH_meca_LUR2[,models[[9]]$indexbestmodel]+ VGOB1_subsetH_meca_LUR2[,i])

R2<-rbind(R2,summary(modeltry)$adj.r.squared)
# the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])#
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # Measurements_livestockpreds_LUR2[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR2)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetH_meca_LUR2)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

# this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

# here are the names
models[[modeln]]$namesbestmodel<-c( names(VGOB1_subsetH_meca_LUR2)[models[[1]]$indexbestmodel],                   names(VGOB1_subsetH_meca_LUR2)[models[[2]]$indexbestmodel] , names(VGOB1_subsetH_meca_LUR2)[models[[3]]$indexbestmodel], names(VGOB1_subsetH_meca_LUR2)[models[[4]]$indexbestmodel], names(VGOB1_subsetH_meca_LUR2)[models[[5]]$indexbestmodel], names(VGOB1_subsetH_meca_LUR2)[models[[6]]$indexbestmodel], names(VGOB1_subsetH_meca_LUR2)[models[[7]]$indexbestmodel], names(VGOB1_subsetH_meca_LUR2)[models[[8]]$indexbestmodel], names(VGOB1_subsetH_meca_LUR2)[models[[9]]$indexbestmodel], names(VGOB1_subsetH_meca_LUR2)[models[[10]]$indexbestmodel])

#  this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetH_meca_LUR2$meca_copiespm3.ln.diffmeth.mean~                                VGOB1_subsetH_meca_LUR2[,models[[1]]$indexbestmodel]+ VGOB1_subsetH_meca_LUR2[,models[[2]]$indexbestmodel]+                           VGOB1_subsetH_meca_LUR2[,models[[3]]$indexbestmodel]+ VGOB1_subsetH_meca_LUR2[,models[[4]]$indexbestmodel]+ VGOB1_subsetH_meca_LUR2[,models[[5]]$indexbestmodel]+ VGOB1_subsetH_meca_LUR2[,models[[6]]$indexbestmodel]+ VGOB1_subsetH_meca_LUR2[,models[[7]]$indexbestmodel]+ VGOB1_subsetH_meca_LUR2[,models[[8]]$indexbestmodel]+ VGOB1_subsetH_meca_LUR2[,models[[9]]$indexbestmodel]+ VGOB1_subsetH_meca_LUR2[,models[[10]]$indexbestmodel])

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[5]]$summarybestmodel
models[[6]]$summarybestmodel
models[[7]]$summarybestmodel
models[[8]]$summarybestmodel
models[[9]]$summarybestmodel
models[[10]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[5]]$namesbestmodel
models[[6]]$namesbestmodel
models[[7]]$namesbestmodel
models[[8]]$namesbestmodel
models[[9]]$namesbestmodel
models[[10]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel
models[[5]]$R2bestmodel
models[[6]]$R2bestmodel
models[[7]]$R2bestmodel
models[[8]]$R2bestmodel
models[[9]]$R2bestmodel
models[[10]]$R2bestmodel

#   CODE FOR PICKING OUT THE BEST MODEL #   
temp <- 0
besti <- 0
for (i in 1:10){ #  think this runs the loop 10 times - not fully sure thought - but not to do with the number of models I don't think - as when I change to 3, I still get the model with 4 variables as best model
  print(models[[i]]$R2bestmodel)
  #       print(models[[i]]$summarybestmodel$coefficients=-1,4])
  #       if((models[[i]]$R2bestmodel-temp > 0.0) && (all(models[[i]]$summarybestmodel$coefficients[-1,4]<0.1))){
  #         temp <- models[[i]]$R2bestmodel
  #         besti <- i
  #         }
  if((models[[i]]$R2bestmodel-temp > 0.0) && (all(models[[i]]$summarybestmodel$coefficients[-1,4]<0.1))){
    temp <- models[[i]]$R2bestmodel
    besti <- i
  }else{
    finalBestModel_meca_LUR2_subsetH <- models[[besti]]$bestmodel
    finalBestModelNames_meca_subsetH <- models[[besti]]$namesbestmodel
    Sites <- 1:dim(VGOB1_subsetH_meca_LUR2)[1] # full original model
    #  CVaR2<-escCV_meca_LUR2(Sites)[2] # Cross Validation
    maxCD<-max(cooks.distance(finalBestModel_meca_LUR2_subsetH))
    if(length(finalBestModelNames_meca_subsetH)<2){ # vif fn doesnot work when only 1 variable...       # 
      maxVIF<-"NA"
    }else{
      maxVIF<-max(vif(finalBestModel_meca_LUR2_subsetH))
    }
    print(paste("This is the best meca model for subset H: ",besti,
                "(AdjR2: ",format(models[[besti]]$R2bestmodel,digits=3), "; MaxCD: ",format(maxCD,digits=3),"; MaxVIF: ",
                format(maxVIF,digits=3),")", sep=''))
    print(finalBestModelNames_meca_subsetH)
    break
  }
}

#  Overview of the final best model using the algorithm selection process (taking into account VIF, R^2, and p-values)
finalBestModel_meca_LUR2_subsetH
finalBestModelNames_meca_subsetH
models[[besti]]$summarybestmodel
models[[besti]]$R2bestmodel


#### I ####
# LUR model building process for subset I
#  This is the dataframe with the relevant predictor vars for LUR2 models for subset I (55 sites)
VGOB1_subsetI_meca_LUR2 # n.b. this dataframe only includes microbial marker concentrations for meca unlike the dataframe Measurements_livestockpreds_LUR2 as previously used for the model building. 

#  Now set the values of some variables that will be needed
nfirstvar_LUR_2 <- 3  
nlastvar_LUR_2 <- 71

# Function building to run the models 
# 1 #  

models<-list()
modeln<-1
models[[modeln]]<-list()

R2<-1
betaaddedvar<-1
addedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_2:nlastvar_LUR_2){
  if (is.numeric(VGOB1_subsetI_meca_LUR2[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetI_meca_LUR2$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetI_meca_LUR2[,i])                            
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    #  Measurements_livestockpreds_LUR2[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR2)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetI_meca_LUR2)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)
models[[modeln]]$results

#  this are the candidates models with the highest R2, not a negative beta for the new, nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)
models[[modeln]]$resultspos

#  rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))
models[[modeln]]$resultspos

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j
models[[modeln]]$indexbestmodel

subset(models[[modeln]]$resultspos, rank==1)
subset(models[[modeln]]$resultspos)

#  this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]
models[[modeln]]$summarybestmodel

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetI_meca_LUR2)[models[[1]]$indexbestmodel])
models[[modeln]]$namesbestmodel

#  this is the r2 of that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2
models[[modeln]]$R2bestmodel

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetI_meca_LUR2$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetI_meca_LUR2[,models[[1]]$indexbestmodel]) 
models[[modeln]]$bestmodel

summary(models[[modeln]]$bestmodel)

#  The first model includes the predictor: nPigMultipFarmWghtDist.3000m.sum.Tr.1P9 - meaning the number of multiplier pig farms weighted to distance in a 3000m buffer

# 2 #  
# Add 2nd variable (the only difference of the above part is that now modeln=2 the model statement has 2 variables)
# and the call for the list of variable names in the model changed slightly

modeln<-2

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_2:nlastvar_LUR_2){
  if (is.numeric(VGOB1_subsetI_meca_LUR2[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetI_meca_LUR2$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetI_meca_LUR2[,models[[1]]$indexbestmodel]+ VGOB1_subsetI_meca_LUR2[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # Measurements_livestockpreds_LUR2[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR2)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetI_meca_LUR2)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  these are the candidate models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)
models[[modeln]]$resultspos

#  rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))
models[[modeln]]$resultspos

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j
models[[modeln]]$indexbestmodel

subset(models[[modeln]]$resultspos, rank==1)

# this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]
models[[modeln]]$summarybestmodel

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetI_meca_LUR2)[models[[1]]$indexbestmodel], names(VGOB1_subsetI_meca_LUR2)[models[[2]]$indexbestmodel] )
models[[modeln]]$namesbestmodel

# this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2
models[[modeln]]$R2bestmodel

# this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetI_meca_LUR2$meca_copiespm3.ln.diffmeth.mean~                               VGOB1_subsetI_meca_LUR2[,models[[1]]$indexbestmodel]+                           VGOB1_subsetI_meca_LUR2[,models[[2]]$indexbestmodel]) 

models[[modeln]]$bestmodel

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel


# 3 #  
# add third variable (the only difference of the above part is that now modeln=3 the model statement has 3 variables)
# and the call for the list of variable names in the model changed slightly

modeln<-3

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_2:nlastvar_LUR_2){
  if (is.numeric(VGOB1_subsetI_meca_LUR2[,i])==TRUE){  
    modeltry<-lm(VGOB1_subsetI_meca_LUR2$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetI_meca_LUR2[,models[[1]]$indexbestmodel]+VGOB1_subsetI_meca_LUR2[,models[[2]]$indexbestmodel]+ VGOB1_subsetI_meca_LUR2[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # All[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR2)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetI_meca_LUR2)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

#  rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

#  this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

#  here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetI_meca_LUR2)[models[[1]]$indexbestmodel], names(VGOB1_subsetI_meca_LUR2)[models[[2]]$indexbestmodel], names(VGOB1_subsetI_meca_LUR2)[models[[3]]$indexbestmodel])

#  this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetI_meca_LUR2$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetI_meca_LUR2[,models[[1]]$indexbestmodel]+ VGOB1_subsetI_meca_LUR2[,models[[2]]$indexbestmodel]+ VGOB1_subsetI_meca_LUR2[,models[[3]]$indexbestmodel]) 

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel


# 4 #  
#  add forth variable (the only difference of the above part is that now model n=4 the model statement more variables)
#  and the call for the list of variable names in the model changed slightly
modeln<-4

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1


for (i in nfirstvar_LUR_2:nlastvar_LUR_2){
  if (is.numeric(VGOB1_subsetI_meca_LUR2[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetI_meca_LUR2$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetI_meca_LUR2[,models[[1]]$indexbestmodel]+VGOB1_subsetI_meca_LUR2[,models[[2]]$indexbestmodel]+VGOB1_subsetI_meca_LUR2[,models[[3]]$indexbestmodel]+VGOB1_subsetI_meca_LUR2[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    #  the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    #  All[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR2)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetI_meca_LUR2)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

#  this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

#  here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetI_meca_LUR2)[models[[1]]$indexbestmodel], names(VGOB1_subsetI_meca_LUR2)[models[[2]]$indexbestmodel], names(VGOB1_subsetI_meca_LUR2)[models[[3]]$indexbestmodel], names(VGOB1_subsetI_meca_LUR2)[models[[4]]$indexbestmodel])

#  this is the r2 of that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetI_meca_LUR2$meca_copiespm3.ln.diffmeth.mean~ VGOB1_subsetI_meca_LUR2[,models[[1]]$indexbestmodel]+ VGOB1_subsetI_meca_LUR2[,models[[2]]$indexbestmodel]+VGOB1_subsetI_meca_LUR2[,models[[3]]$indexbestmodel]+ VGOB1_subsetI_meca_LUR2[,models[[4]]$indexbestmodel]) 


models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel


# 5 #  
# add fifth variable (the only difference of the above part is that now modeln=5 the model statement more variables)
# and the call for the list of variable names in the model changed slightly
modeln<-5

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_2:nlastvar_LUR_2){
  if (is.numeric(VGOB1_subsetI_meca_LUR2[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetI_meca_LUR2$meca_copiespm3.ln.diffmeth.mean~ VGOB1_subsetI_meca_LUR2[,models[[1]]$indexbestmodel]+ VGOB1_subsetI_meca_LUR2[,models[[2]]$indexbestmodel]+ VGOB1_subsetI_meca_LUR2[,models[[3]]$indexbestmodel]+ VGOB1_subsetI_meca_LUR2[,models[[4]]$indexbestmodel]+ VGOB1_subsetI_meca_LUR2[,i]) 
  
R2<-rbind(R2,summary(modeltry)$adj.r.squared)
# the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # All[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR2)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetI_meca_LUR2)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

#  this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetI_meca_LUR2)[models[[1]]$indexbestmodel], names(VGOB1_subsetI_meca_LUR2)[models[[2]]$indexbestmodel], names(VGOB1_subsetI_meca_LUR2)[models[[3]]$indexbestmodel], names(VGOB1_subsetI_meca_LUR2)[models[[4]]$indexbestmodel], names(VGOB1_subsetI_meca_LUR2)[models[[5]]$indexbestmodel])

#  this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetI_meca_LUR2$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetI_meca_LUR2[,models[[1]]$indexbestmodel]+VGOB1_subsetI_meca_LUR2[,models[[2]]$indexbestmodel]+VGOB1_subsetI_meca_LUR2[,models[[3]]$indexbestmodel]+ VGOB1_subsetI_meca_LUR2[,models[[4]]$indexbestmodel]+ VGOB1_subsetI_meca_LUR2[,models[[5]]$indexbestmodel]) 
models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[5]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[5]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel
models[[5]]$R2bestmodel

# 6 #  
# add sixth variable (the only difference of the above part is that now model n=6 the model statement more variables)
#  and the call for the list of variable names in the model changed slightly

modeln<-6

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_2 :nlastvar_LUR_2){
  if (is.numeric(VGOB1_subsetI_meca_LUR2[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetI_meca_LUR2$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetI_meca_LUR2[,models[[1]]$indexbestmodel]+VGOB1_subsetI_meca_LUR2[,models[[2]]$indexbestmodel]+VGOB1_subsetI_meca_LUR2[,models[[3]]$indexbestmodel]+VGOB1_subsetI_meca_LUR2[,models[[4]]$indexbestmodel]+VGOB1_subsetI_meca_LUR2[,models[[5]]$indexbestmodel]+ VGOB1_subsetI_meca_LUR2[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # All[,i] is the row that's being tried out now. the name of that row can be found in  names(All)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetI_meca_LUR2)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

# this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetI_meca_LUR2)[models[[1]]$indexbestmodel], names(VGOB1_subsetI_meca_LUR2)[models[[2]]$indexbestmodel] , names(VGOB1_subsetI_meca_LUR2)[models[[3]]$indexbestmodel], names(VGOB1_subsetI_meca_LUR2)[models[[4]]$indexbestmodel], names(VGOB1_subsetI_meca_LUR2)[models[[5]]$indexbestmodel], names(VGOB1_subsetI_meca_LUR2)[models[[6]]$indexbestmodel])

#  this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetI_meca_LUR2$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetI_meca_LUR2[,models[[1]]$indexbestmodel]+VGOB1_subsetI_meca_LUR2[,models[[2]]$indexbestmodel]+VGOB1_subsetI_meca_LUR2[,models[[3]]$indexbestmodel]+ VGOB1_subsetI_meca_LUR2[,models[[4]]$indexbestmodel]+ VGOB1_subsetI_meca_LUR2[,models[[5]]$indexbestmodel]+ VGOB1_subsetI_meca_LUR2[,models[[6]]$indexbestmodel]) 

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[5]]$summarybestmodel
models[[6]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[5]]$namesbestmodel
models[[6]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel
models[[5]]$R2bestmodel
models[[6]]$R2bestmodel


# 7 #  
# add seventh variable (the only difference of the above part is that now model n=7 the model statement more variables)
#  and the call for the list of variable names in the model changed slightly

modeln<-7

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_2 :nlastvar_LUR_2){
  if (is.numeric(VGOB1_subsetI_meca_LUR2[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetI_meca_LUR2$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetI_meca_LUR2[,models[[1]]$indexbestmodel]+VGOB1_subsetI_meca_LUR2[,models[[2]]$indexbestmodel]+VGOB1_subsetI_meca_LUR2[,models[[3]]$indexbestmodel]+VGOB1_subsetI_meca_LUR2[,models[[4]]$indexbestmodel]+VGOB1_subsetI_meca_LUR2[,models[[5]]$indexbestmodel]+VGOB1_subsetI_meca_LUR2[,models[[6]]$indexbestmodel]+ VGOB1_subsetI_meca_LUR2[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # Measurements_livestockpreds_LUR2[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR2)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetI_meca_LUR2)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

# this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetI_meca_LUR2)[models[[1]]$indexbestmodel], names(VGOB1_subsetI_meca_LUR2)[models[[2]]$indexbestmodel] , names(VGOB1_subsetI_meca_LUR2)[models[[3]]$indexbestmodel], names(VGOB1_subsetI_meca_LUR2)[models[[4]]$indexbestmodel], names(VGOB1_subsetI_meca_LUR2)[models[[5]]$indexbestmodel], names(VGOB1_subsetI_meca_LUR2)[models[[6]]$indexbestmodel], names(VGOB1_subsetI_meca_LUR2)[models[[7]]$indexbestmodel])

#  this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetI_meca_LUR2$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetI_meca_LUR2[,models[[1]]$indexbestmodel]+VGOB1_subsetI_meca_LUR2[,models[[2]]$indexbestmodel]+VGOB1_subsetI_meca_LUR2[,models[[3]]$indexbestmodel]+ VGOB1_subsetI_meca_LUR2[,models[[4]]$indexbestmodel]+ VGOB1_subsetI_meca_LUR2[,models[[5]]$indexbestmodel]+ VGOB1_subsetI_meca_LUR2[,models[[6]]$indexbestmodel]+ VGOB1_subsetI_meca_LUR2[,models[[7]]$indexbestmodel]) 

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[5]]$summarybestmodel
models[[6]]$summarybestmodel
models[[7]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[5]]$namesbestmodel
models[[6]]$namesbestmodel
models[[7]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel
models[[5]]$R2bestmodel
models[[6]]$R2bestmodel
models[[7]]$R2bestmodel

# 8 #  
# add eighth variable (the only difference of the above part is that now modeln=7 the model statement more variables)
# and the call for the list of variable names in the model changed slightly

modeln<-8

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_2 :nlastvar_LUR_2){
  if (is.numeric(VGOB1_subsetI_meca_LUR2[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetI_meca_LUR2$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetI_meca_LUR2[,models[[1]]$indexbestmodel]+VGOB1_subsetI_meca_LUR2[,models[[2]]$indexbestmodel]+VGOB1_subsetI_meca_LUR2[,models[[3]]$indexbestmodel]+VGOB1_subsetI_meca_LUR2[,models[[4]]$indexbestmodel]+VGOB1_subsetI_meca_LUR2[,models[[5]]$indexbestmodel]+VGOB1_subsetI_meca_LUR2[,models[[6]]$indexbestmodel]+ VGOB1_subsetI_meca_LUR2[,models[[7]]$indexbestmodel]+ VGOB1_subsetI_meca_LUR2[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # Measurements_livestockpreds_LUR2[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR2)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetI_meca_LUR2)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

# this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetI_meca_LUR2)[models[[1]]$indexbestmodel], names(VGOB1_subsetI_meca_LUR2)[models[[2]]$indexbestmodel] , names(VGOB1_subsetI_meca_LUR2)[models[[3]]$indexbestmodel], names(VGOB1_subsetI_meca_LUR2)[models[[4]]$indexbestmodel], names(VGOB1_subsetI_meca_LUR2)[models[[5]]$indexbestmodel], names(VGOB1_subsetI_meca_LUR2)[models[[6]]$indexbestmodel], names(VGOB1_subsetI_meca_LUR2)[models[[7]]$indexbestmodel], names(VGOB1_subsetI_meca_LUR2)[models[[8]]$indexbestmodel])

#  this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetI_meca_LUR2$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetI_meca_LUR2[,models[[1]]$indexbestmodel]+VGOB1_subsetI_meca_LUR2[,models[[2]]$indexbestmodel]+VGOB1_subsetI_meca_LUR2[,models[[3]]$indexbestmodel]+ VGOB1_subsetI_meca_LUR2[,models[[4]]$indexbestmodel]+ VGOB1_subsetI_meca_LUR2[,models[[5]]$indexbestmodel]+ VGOB1_subsetI_meca_LUR2[,models[[6]]$indexbestmodel]+ VGOB1_subsetI_meca_LUR2[,models[[7]]$indexbestmodel]+ VGOB1_subsetI_meca_LUR2[,models[[8]]$indexbestmodel]) 

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[5]]$summarybestmodel
models[[6]]$summarybestmodel
models[[7]]$summarybestmodel
models[[8]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[5]]$namesbestmodel
models[[6]]$namesbestmodel
models[[7]]$namesbestmodel
models[[8]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel
models[[5]]$R2bestmodel
models[[6]]$R2bestmodel
models[[7]]$R2bestmodel
models[[8]]$R2bestmodel

# 9 #  
# add ninth variable (the only difference of the above part is that now modeln=9 the model statement more variables)
# and the call for the list of variable names in the model changed slightly

modeln<-9

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_2 :nlastvar_LUR_2){
  if (is.numeric(VGOB1_subsetI_meca_LUR2[,i])==TRUE){
      modeltry<-lm(VGOB1_subsetI_meca_LUR2$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetI_meca_LUR2[,models[[1]]$indexbestmodel]+VGOB1_subsetI_meca_LUR2[,models[[2]]$indexbestmodel]+VGOB1_subsetI_meca_LUR2[,models[[3]]$indexbestmodel]+VGOB1_subsetI_meca_LUR2[,models[[4]]$indexbestmodel]+VGOB1_subsetI_meca_LUR2[,models[[5]]$indexbestmodel]+VGOB1_subsetI_meca_LUR2[,models[[6]]$indexbestmodel]+ VGOB1_subsetI_meca_LUR2[,models[[7]]$indexbestmodel]+ VGOB1_subsetI_meca_LUR2[,models[[8]]$indexbestmodel]+ VGOB1_subsetI_meca_LUR2[,i]) 
        R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # Measurements_livestockpreds_LUR2[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR2)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetI_meca_LUR2)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

# this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetI_meca_LUR2)[models[[1]]$indexbestmodel], names(VGOB1_subsetI_meca_LUR2)[models[[2]]$indexbestmodel] , names(VGOB1_subsetI_meca_LUR2)[models[[3]]$indexbestmodel], names(VGOB1_subsetI_meca_LUR2)[models[[4]]$indexbestmodel], names(VGOB1_subsetI_meca_LUR2)[models[[5]]$indexbestmodel], names(VGOB1_subsetI_meca_LUR2)[models[[6]]$indexbestmodel], names(VGOB1_subsetI_meca_LUR2)[models[[7]]$indexbestmodel], names(VGOB1_subsetI_meca_LUR2)[models[[8]]$indexbestmodel],  names(VGOB1_subsetI_meca_LUR2)[models[[9]]$indexbestmodel])

#  this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetI_meca_LUR2$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetI_meca_LUR2[,models[[1]]$indexbestmodel]+VGOB1_subsetI_meca_LUR2[,models[[2]]$indexbestmodel]+VGOB1_subsetI_meca_LUR2[,models[[3]]$indexbestmodel]+ VGOB1_subsetI_meca_LUR2[,models[[4]]$indexbestmodel]+ VGOB1_subsetI_meca_LUR2[,models[[5]]$indexbestmodel]+ VGOB1_subsetI_meca_LUR2[,models[[6]]$indexbestmodel]+ VGOB1_subsetI_meca_LUR2[,models[[7]]$indexbestmodel]+ VGOB1_subsetI_meca_LUR2[,models[[8]]$indexbestmodel]+ VGOB1_subsetI_meca_LUR2[,models[[9]]$indexbestmodel]) 

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[5]]$summarybestmodel
models[[6]]$summarybestmodel
models[[7]]$summarybestmodel
models[[8]]$summarybestmodel
models[[9]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[5]]$namesbestmodel
models[[6]]$namesbestmodel
models[[7]]$namesbestmodel
models[[8]]$namesbestmodel
models[[9]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel
models[[5]]$R2bestmodel
models[[6]]$R2bestmodel
models[[7]]$R2bestmodel
models[[8]]$R2bestmodel
models[[9]]$R2bestmodel


# 10 #
#  add tenth variable (the only difference of the above part is that now model n=10 the model statement more variables)
#  and the call for the list of variable names in the model changed slightly

modeln<-10

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_2 :nlastvar_LUR_2){if (is.numeric(VGOB1_subsetI_meca_LUR2[,i])==TRUE){ modeltry<-lm(VGOB1_subsetI_meca_LUR2$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetI_meca_LUR2[,models[[1]]$indexbestmodel]+VGOB1_subsetI_meca_LUR2[,models[[2]]$indexbestmodel]+ VGOB1_subsetI_meca_LUR2[,models[[3]]$indexbestmodel]+VGOB1_subsetI_meca_LUR2[,models[[4]]$indexbestmodel]+ VGOB1_subsetI_meca_LUR2[,models[[5]]$indexbestmodel]+ VGOB1_subsetI_meca_LUR2[,models[[6]]$indexbestmodel]+ VGOB1_subsetI_meca_LUR2[,models[[7]]$indexbestmodel]+ VGOB1_subsetI_meca_LUR2[,models[[8]]$indexbestmodel]+ VGOB1_subsetI_meca_LUR2[,models[[9]]$indexbestmodel]+ VGOB1_subsetI_meca_LUR2[,i])

R2<-rbind(R2,summary(modeltry)$adj.r.squared)
# the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])#
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # Measurements_livestockpreds_LUR2[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR2)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetI_meca_LUR2)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

# this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

# here are the names
models[[modeln]]$namesbestmodel<-c( names(VGOB1_subsetI_meca_LUR2)[models[[1]]$indexbestmodel],                   names(VGOB1_subsetI_meca_LUR2)[models[[2]]$indexbestmodel] , names(VGOB1_subsetI_meca_LUR2)[models[[3]]$indexbestmodel], names(VGOB1_subsetI_meca_LUR2)[models[[4]]$indexbestmodel], names(VGOB1_subsetI_meca_LUR2)[models[[5]]$indexbestmodel], names(VGOB1_subsetI_meca_LUR2)[models[[6]]$indexbestmodel], names(VGOB1_subsetI_meca_LUR2)[models[[7]]$indexbestmodel], names(VGOB1_subsetI_meca_LUR2)[models[[8]]$indexbestmodel], names(VGOB1_subsetI_meca_LUR2)[models[[9]]$indexbestmodel], names(VGOB1_subsetI_meca_LUR2)[models[[10]]$indexbestmodel])

#  this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetI_meca_LUR2$meca_copiespm3.ln.diffmeth.mean~                                VGOB1_subsetI_meca_LUR2[,models[[1]]$indexbestmodel]+ VGOB1_subsetI_meca_LUR2[,models[[2]]$indexbestmodel]+                           VGOB1_subsetI_meca_LUR2[,models[[3]]$indexbestmodel]+ VGOB1_subsetI_meca_LUR2[,models[[4]]$indexbestmodel]+ VGOB1_subsetI_meca_LUR2[,models[[5]]$indexbestmodel]+ VGOB1_subsetI_meca_LUR2[,models[[6]]$indexbestmodel]+ VGOB1_subsetI_meca_LUR2[,models[[7]]$indexbestmodel]+ VGOB1_subsetI_meca_LUR2[,models[[8]]$indexbestmodel]+ VGOB1_subsetI_meca_LUR2[,models[[9]]$indexbestmodel]+ VGOB1_subsetI_meca_LUR2[,models[[10]]$indexbestmodel])

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[5]]$summarybestmodel
models[[6]]$summarybestmodel
models[[7]]$summarybestmodel
models[[8]]$summarybestmodel
models[[9]]$summarybestmodel
models[[10]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[5]]$namesbestmodel
models[[6]]$namesbestmodel
models[[7]]$namesbestmodel
models[[8]]$namesbestmodel
models[[9]]$namesbestmodel
models[[10]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel
models[[5]]$R2bestmodel
models[[6]]$R2bestmodel
models[[7]]$R2bestmodel
models[[8]]$R2bestmodel
models[[9]]$R2bestmodel
models[[10]]$R2bestmodel

#   CODE FOR PICKING OUT THE BEST MODEL #   
temp <- 0
besti <- 0
for (i in 1:10){ #  think this runs the loop 10 times - not fully sure thought - but not to do with the number of models I don't think - as when I change to 3, I still get the model with 4 variables as best model
  print(models[[i]]$R2bestmodel)
  #       print(models[[i]]$summarybestmodel$coefficients=-1,4])
  #       if((models[[i]]$R2bestmodel-temp > 0.0) && (all(models[[i]]$summarybestmodel$coefficients[-1,4]<0.1))){
  #         temp <- models[[i]]$R2bestmodel
  #         besti <- i
  #         }
  if((models[[i]]$R2bestmodel-temp > 0.0) && (all(models[[i]]$summarybestmodel$coefficients[-1,4]<0.1))){
    temp <- models[[i]]$R2bestmodel
    besti <- i
  }else{
    finalBestModel_meca_LUR2_subsetI <- models[[besti]]$bestmodel
    finalBestModelNames_meca_subsetI <- models[[besti]]$namesbestmodel
    Sites <- 1:dim(VGOB1_subsetI_meca_LUR2)[1] # full original model
    #  CVaR2<-escCV_meca_LUR2(Sites)[2] # Cross Validation
    maxCD<-max(cooks.distance(finalBestModel_meca_LUR2_subsetI))
    if(length(finalBestModelNames_meca_subsetI)<2){ # vif fn doesnot work when only 1 variable...       # 
      maxVIF<-"NA"
    }else{
      maxVIF<-max(vif(finalBestModel_meca_LUR2_subsetI))
    }
    print(paste("This is the best meca model for subset I: ",besti,
                "(AdjR2: ",format(models[[besti]]$R2bestmodel,digits=3), "; MaxCD: ",format(maxCD,digits=3),"; MaxVIF: ",
                format(maxVIF,digits=3),")", sep=''))
    print(finalBestModelNames_meca_subsetI)
    break
  }
}

#  Overview of the final best model using the algorithm selection process (taking into account VIF, R^2, and p-values)
finalBestModel_meca_LUR2_subsetI
finalBestModelNames_meca_subsetI
models[[besti]]$summarybestmodel
models[[besti]]$R2bestmodel

#### J ####
# LUR model building process for subset J
#  This is the dataframe with the relevant predictor vars for LUR2 models for subset J (55 sites)
VGOB1_subsetJ_meca_LUR2 # n.b. this dataframe only includes microbial marker concentrations for meca unlike the dataframe Measurements_livestockpreds_LUR2 as previously used for the model building. 

#  Now set the values of some variables that will be needed
nfirstvar_LUR_2 <- 3  
nlastvar_LUR_2 <- 71

# Function building to run the models 
# 1 #  

models<-list()
modeln<-1
models[[modeln]]<-list()

R2<-1
betaaddedvar<-1
addedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_2:nlastvar_LUR_2){
  if (is.numeric(VGOB1_subsetJ_meca_LUR2[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetJ_meca_LUR2$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetJ_meca_LUR2[,i])                            
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    #  Measurements_livestockpreds_LUR2[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR2)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetJ_meca_LUR2)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)
models[[modeln]]$results

#  this are the candidates models with the highest R2, not a negative beta for the new, nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)
models[[modeln]]$resultspos

#  rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))
models[[modeln]]$resultspos

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j
models[[modeln]]$indexbestmodel

subset(models[[modeln]]$resultspos, rank==1)
subset(models[[modeln]]$resultspos)

#  this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]
models[[modeln]]$summarybestmodel

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetJ_meca_LUR2)[models[[1]]$indexbestmodel])
models[[modeln]]$namesbestmodel

#  this is the r2 of that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2
models[[modeln]]$R2bestmodel

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetJ_meca_LUR2$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetJ_meca_LUR2[,models[[1]]$indexbestmodel]) 
models[[modeln]]$bestmodel

summary(models[[modeln]]$bestmodel)

#  The first model includes the predictor: nPigMultipFarmWghtDist.3000m.sum.Tr.1P9 - meaning the number of multiplier pig farms weighted to distance in a 3000m buffer

# 2 #  
# Add 2nd variable (the only difference of the above part is that now modeln=2 the model statement has 2 variables)
# and the call for the list of variable names in the model changed slightly

modeln<-2

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_2:nlastvar_LUR_2){
  if (is.numeric(VGOB1_subsetJ_meca_LUR2[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetJ_meca_LUR2$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetJ_meca_LUR2[,models[[1]]$indexbestmodel]+ VGOB1_subsetJ_meca_LUR2[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # Measurements_livestockpreds_LUR2[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR2)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetJ_meca_LUR2)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  these are the candidate models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)
models[[modeln]]$resultspos

#  rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))
models[[modeln]]$resultspos

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j
models[[modeln]]$indexbestmodel

subset(models[[modeln]]$resultspos, rank==1)

# this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]
models[[modeln]]$summarybestmodel

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetJ_meca_LUR2)[models[[1]]$indexbestmodel], names(VGOB1_subsetJ_meca_LUR2)[models[[2]]$indexbestmodel] )
models[[modeln]]$namesbestmodel

# this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2
models[[modeln]]$R2bestmodel

# this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetJ_meca_LUR2$meca_copiespm3.ln.diffmeth.mean~                               VGOB1_subsetJ_meca_LUR2[,models[[1]]$indexbestmodel]+                           VGOB1_subsetJ_meca_LUR2[,models[[2]]$indexbestmodel]) 

models[[modeln]]$bestmodel

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel


# 3 #  
# add third variable (the only difference of the above part is that now modeln=3 the model statement has 3 variables)
# and the call for the list of variable names in the model changed slightly

modeln<-3

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_2:nlastvar_LUR_2){
  if (is.numeric(VGOB1_subsetJ_meca_LUR2[,i])==TRUE){  
    modeltry<-lm(VGOB1_subsetJ_meca_LUR2$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetJ_meca_LUR2[,models[[1]]$indexbestmodel]+VGOB1_subsetJ_meca_LUR2[,models[[2]]$indexbestmodel]+ VGOB1_subsetJ_meca_LUR2[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # All[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR2)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetJ_meca_LUR2)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

#  rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

#  this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

#  here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetJ_meca_LUR2)[models[[1]]$indexbestmodel], names(VGOB1_subsetJ_meca_LUR2)[models[[2]]$indexbestmodel], names(VGOB1_subsetJ_meca_LUR2)[models[[3]]$indexbestmodel])

#  this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetJ_meca_LUR2$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetJ_meca_LUR2[,models[[1]]$indexbestmodel]+ VGOB1_subsetJ_meca_LUR2[,models[[2]]$indexbestmodel]+ VGOB1_subsetJ_meca_LUR2[,models[[3]]$indexbestmodel]) 

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel


# 4 #  
#  add forth variable (the only difference of the above part is that now model n=4 the model statement more variables)
#  and the call for the list of variable names in the model changed slightly
modeln<-4

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1


for (i in nfirstvar_LUR_2:nlastvar_LUR_2){
  if (is.numeric(VGOB1_subsetJ_meca_LUR2[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetJ_meca_LUR2$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetJ_meca_LUR2[,models[[1]]$indexbestmodel]+VGOB1_subsetJ_meca_LUR2[,models[[2]]$indexbestmodel]+VGOB1_subsetJ_meca_LUR2[,models[[3]]$indexbestmodel]+VGOB1_subsetJ_meca_LUR2[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    #  the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    #  All[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR2)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetJ_meca_LUR2)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

#  this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

#  here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetJ_meca_LUR2)[models[[1]]$indexbestmodel], names(VGOB1_subsetJ_meca_LUR2)[models[[2]]$indexbestmodel], names(VGOB1_subsetJ_meca_LUR2)[models[[3]]$indexbestmodel], names(VGOB1_subsetJ_meca_LUR2)[models[[4]]$indexbestmodel])

#  this is the r2 of that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetJ_meca_LUR2$meca_copiespm3.ln.diffmeth.mean~ VGOB1_subsetJ_meca_LUR2[,models[[1]]$indexbestmodel]+ VGOB1_subsetJ_meca_LUR2[,models[[2]]$indexbestmodel]+VGOB1_subsetJ_meca_LUR2[,models[[3]]$indexbestmodel]+ VGOB1_subsetJ_meca_LUR2[,models[[4]]$indexbestmodel]) 


models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel


# 5 #  
# add fifth variable (the only difference of the above part is that now modeln=5 the model statement more variables)
# and the call for the list of variable names in the model changed slightly
modeln<-5

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_2:nlastvar_LUR_2){
  if (is.numeric(VGOB1_subsetJ_meca_LUR2[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetJ_meca_LUR2$meca_copiespm3.ln.diffmeth.mean~ VGOB1_subsetJ_meca_LUR2[,models[[1]]$indexbestmodel]+ VGOB1_subsetJ_meca_LUR2[,models[[2]]$indexbestmodel]+ VGOB1_subsetJ_meca_LUR2[,models[[3]]$indexbestmodel]+ VGOB1_subsetJ_meca_LUR2[,models[[4]]$indexbestmodel]+ VGOB1_subsetJ_meca_LUR2[,i]) 
  
R2<-rbind(R2,summary(modeltry)$adj.r.squared)
# the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # All[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR2)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetJ_meca_LUR2)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

#  this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetJ_meca_LUR2)[models[[1]]$indexbestmodel], names(VGOB1_subsetJ_meca_LUR2)[models[[2]]$indexbestmodel], names(VGOB1_subsetJ_meca_LUR2)[models[[3]]$indexbestmodel], names(VGOB1_subsetJ_meca_LUR2)[models[[4]]$indexbestmodel], names(VGOB1_subsetJ_meca_LUR2)[models[[5]]$indexbestmodel])

#  this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetJ_meca_LUR2$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetJ_meca_LUR2[,models[[1]]$indexbestmodel]+VGOB1_subsetJ_meca_LUR2[,models[[2]]$indexbestmodel]+VGOB1_subsetJ_meca_LUR2[,models[[3]]$indexbestmodel]+ VGOB1_subsetJ_meca_LUR2[,models[[4]]$indexbestmodel]+ VGOB1_subsetJ_meca_LUR2[,models[[5]]$indexbestmodel]) 
models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[5]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[5]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel
models[[5]]$R2bestmodel

# 6 #  
# add sixth variable (the only difference of the above part is that now model n=6 the model statement more variables)
#  and the call for the list of variable names in the model changed slightly

modeln<-6

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_2 :nlastvar_LUR_2){
  if (is.numeric(VGOB1_subsetJ_meca_LUR2[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetJ_meca_LUR2$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetJ_meca_LUR2[,models[[1]]$indexbestmodel]+VGOB1_subsetJ_meca_LUR2[,models[[2]]$indexbestmodel]+VGOB1_subsetJ_meca_LUR2[,models[[3]]$indexbestmodel]+VGOB1_subsetJ_meca_LUR2[,models[[4]]$indexbestmodel]+VGOB1_subsetJ_meca_LUR2[,models[[5]]$indexbestmodel]+ VGOB1_subsetJ_meca_LUR2[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # All[,i] is the row that's being tried out now. the name of that row can be found in  names(All)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetJ_meca_LUR2)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

# this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetJ_meca_LUR2)[models[[1]]$indexbestmodel], names(VGOB1_subsetJ_meca_LUR2)[models[[2]]$indexbestmodel] , names(VGOB1_subsetJ_meca_LUR2)[models[[3]]$indexbestmodel], names(VGOB1_subsetJ_meca_LUR2)[models[[4]]$indexbestmodel], names(VGOB1_subsetJ_meca_LUR2)[models[[5]]$indexbestmodel], names(VGOB1_subsetJ_meca_LUR2)[models[[6]]$indexbestmodel])

#  this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetJ_meca_LUR2$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetJ_meca_LUR2[,models[[1]]$indexbestmodel]+VGOB1_subsetJ_meca_LUR2[,models[[2]]$indexbestmodel]+VGOB1_subsetJ_meca_LUR2[,models[[3]]$indexbestmodel]+ VGOB1_subsetJ_meca_LUR2[,models[[4]]$indexbestmodel]+ VGOB1_subsetJ_meca_LUR2[,models[[5]]$indexbestmodel]+ VGOB1_subsetJ_meca_LUR2[,models[[6]]$indexbestmodel]) 

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[5]]$summarybestmodel
models[[6]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[5]]$namesbestmodel
models[[6]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel
models[[5]]$R2bestmodel
models[[6]]$R2bestmodel


# 7 #  
# add seventh variable (the only difference of the above part is that now model n=7 the model statement more variables)
#  and the call for the list of variable names in the model changed slightly

modeln<-7

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_2 :nlastvar_LUR_2){
  if (is.numeric(VGOB1_subsetJ_meca_LUR2[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetJ_meca_LUR2$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetJ_meca_LUR2[,models[[1]]$indexbestmodel]+VGOB1_subsetJ_meca_LUR2[,models[[2]]$indexbestmodel]+VGOB1_subsetJ_meca_LUR2[,models[[3]]$indexbestmodel]+VGOB1_subsetJ_meca_LUR2[,models[[4]]$indexbestmodel]+VGOB1_subsetJ_meca_LUR2[,models[[5]]$indexbestmodel]+VGOB1_subsetJ_meca_LUR2[,models[[6]]$indexbestmodel]+ VGOB1_subsetJ_meca_LUR2[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # Measurements_livestockpreds_LUR2[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR2)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetJ_meca_LUR2)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

# this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetJ_meca_LUR2)[models[[1]]$indexbestmodel], names(VGOB1_subsetJ_meca_LUR2)[models[[2]]$indexbestmodel] , names(VGOB1_subsetJ_meca_LUR2)[models[[3]]$indexbestmodel], names(VGOB1_subsetJ_meca_LUR2)[models[[4]]$indexbestmodel], names(VGOB1_subsetJ_meca_LUR2)[models[[5]]$indexbestmodel], names(VGOB1_subsetJ_meca_LUR2)[models[[6]]$indexbestmodel], names(VGOB1_subsetJ_meca_LUR2)[models[[7]]$indexbestmodel])

#  this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetJ_meca_LUR2$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetJ_meca_LUR2[,models[[1]]$indexbestmodel]+VGOB1_subsetJ_meca_LUR2[,models[[2]]$indexbestmodel]+VGOB1_subsetJ_meca_LUR2[,models[[3]]$indexbestmodel]+ VGOB1_subsetJ_meca_LUR2[,models[[4]]$indexbestmodel]+ VGOB1_subsetJ_meca_LUR2[,models[[5]]$indexbestmodel]+ VGOB1_subsetJ_meca_LUR2[,models[[6]]$indexbestmodel]+ VGOB1_subsetJ_meca_LUR2[,models[[7]]$indexbestmodel]) 

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[5]]$summarybestmodel
models[[6]]$summarybestmodel
models[[7]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[5]]$namesbestmodel
models[[6]]$namesbestmodel
models[[7]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel
models[[5]]$R2bestmodel
models[[6]]$R2bestmodel
models[[7]]$R2bestmodel

# 8 #  
# add eighth variable (the only difference of the above part is that now modeln=7 the model statement more variables)
# and the call for the list of variable names in the model changed slightly

modeln<-8

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_2 :nlastvar_LUR_2){
  if (is.numeric(VGOB1_subsetJ_meca_LUR2[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetJ_meca_LUR2$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetJ_meca_LUR2[,models[[1]]$indexbestmodel]+VGOB1_subsetJ_meca_LUR2[,models[[2]]$indexbestmodel]+VGOB1_subsetJ_meca_LUR2[,models[[3]]$indexbestmodel]+VGOB1_subsetJ_meca_LUR2[,models[[4]]$indexbestmodel]+VGOB1_subsetJ_meca_LUR2[,models[[5]]$indexbestmodel]+VGOB1_subsetJ_meca_LUR2[,models[[6]]$indexbestmodel]+ VGOB1_subsetJ_meca_LUR2[,models[[7]]$indexbestmodel]+ VGOB1_subsetJ_meca_LUR2[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # Measurements_livestockpreds_LUR2[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR2)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetJ_meca_LUR2)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

# this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetJ_meca_LUR2)[models[[1]]$indexbestmodel], names(VGOB1_subsetJ_meca_LUR2)[models[[2]]$indexbestmodel] , names(VGOB1_subsetJ_meca_LUR2)[models[[3]]$indexbestmodel], names(VGOB1_subsetJ_meca_LUR2)[models[[4]]$indexbestmodel], names(VGOB1_subsetJ_meca_LUR2)[models[[5]]$indexbestmodel], names(VGOB1_subsetJ_meca_LUR2)[models[[6]]$indexbestmodel], names(VGOB1_subsetJ_meca_LUR2)[models[[7]]$indexbestmodel], names(VGOB1_subsetJ_meca_LUR2)[models[[8]]$indexbestmodel])

#  this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetJ_meca_LUR2$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetJ_meca_LUR2[,models[[1]]$indexbestmodel]+VGOB1_subsetJ_meca_LUR2[,models[[2]]$indexbestmodel]+VGOB1_subsetJ_meca_LUR2[,models[[3]]$indexbestmodel]+ VGOB1_subsetJ_meca_LUR2[,models[[4]]$indexbestmodel]+ VGOB1_subsetJ_meca_LUR2[,models[[5]]$indexbestmodel]+ VGOB1_subsetJ_meca_LUR2[,models[[6]]$indexbestmodel]+ VGOB1_subsetJ_meca_LUR2[,models[[7]]$indexbestmodel]+ VGOB1_subsetJ_meca_LUR2[,models[[8]]$indexbestmodel]) 

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[5]]$summarybestmodel
models[[6]]$summarybestmodel
models[[7]]$summarybestmodel
models[[8]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[5]]$namesbestmodel
models[[6]]$namesbestmodel
models[[7]]$namesbestmodel
models[[8]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel
models[[5]]$R2bestmodel
models[[6]]$R2bestmodel
models[[7]]$R2bestmodel
models[[8]]$R2bestmodel

# 9 #  
# add ninth variable (the only difference of the above part is that now modeln=9 the model statement more variables)
# and the call for the list of variable names in the model changed slightly

modeln<-9

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_2 :nlastvar_LUR_2){
  if (is.numeric(VGOB1_subsetJ_meca_LUR2[,i])==TRUE){
      modeltry<-lm(VGOB1_subsetJ_meca_LUR2$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetJ_meca_LUR2[,models[[1]]$indexbestmodel]+VGOB1_subsetJ_meca_LUR2[,models[[2]]$indexbestmodel]+VGOB1_subsetJ_meca_LUR2[,models[[3]]$indexbestmodel]+VGOB1_subsetJ_meca_LUR2[,models[[4]]$indexbestmodel]+VGOB1_subsetJ_meca_LUR2[,models[[5]]$indexbestmodel]+VGOB1_subsetJ_meca_LUR2[,models[[6]]$indexbestmodel]+ VGOB1_subsetJ_meca_LUR2[,models[[7]]$indexbestmodel]+ VGOB1_subsetJ_meca_LUR2[,models[[8]]$indexbestmodel]+ VGOB1_subsetJ_meca_LUR2[,i]) 
        R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # Measurements_livestockpreds_LUR2[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR2)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetJ_meca_LUR2)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

# this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetJ_meca_LUR2)[models[[1]]$indexbestmodel], names(VGOB1_subsetJ_meca_LUR2)[models[[2]]$indexbestmodel] , names(VGOB1_subsetJ_meca_LUR2)[models[[3]]$indexbestmodel], names(VGOB1_subsetJ_meca_LUR2)[models[[4]]$indexbestmodel], names(VGOB1_subsetJ_meca_LUR2)[models[[5]]$indexbestmodel], names(VGOB1_subsetJ_meca_LUR2)[models[[6]]$indexbestmodel], names(VGOB1_subsetJ_meca_LUR2)[models[[7]]$indexbestmodel], names(VGOB1_subsetJ_meca_LUR2)[models[[8]]$indexbestmodel],  names(VGOB1_subsetJ_meca_LUR2)[models[[9]]$indexbestmodel])

#  this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetJ_meca_LUR2$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetJ_meca_LUR2[,models[[1]]$indexbestmodel]+VGOB1_subsetJ_meca_LUR2[,models[[2]]$indexbestmodel]+VGOB1_subsetJ_meca_LUR2[,models[[3]]$indexbestmodel]+ VGOB1_subsetJ_meca_LUR2[,models[[4]]$indexbestmodel]+ VGOB1_subsetJ_meca_LUR2[,models[[5]]$indexbestmodel]+ VGOB1_subsetJ_meca_LUR2[,models[[6]]$indexbestmodel]+ VGOB1_subsetJ_meca_LUR2[,models[[7]]$indexbestmodel]+ VGOB1_subsetJ_meca_LUR2[,models[[8]]$indexbestmodel]+ VGOB1_subsetJ_meca_LUR2[,models[[9]]$indexbestmodel]) 

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[5]]$summarybestmodel
models[[6]]$summarybestmodel
models[[7]]$summarybestmodel
models[[8]]$summarybestmodel
models[[9]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[5]]$namesbestmodel
models[[6]]$namesbestmodel
models[[7]]$namesbestmodel
models[[8]]$namesbestmodel
models[[9]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel
models[[5]]$R2bestmodel
models[[6]]$R2bestmodel
models[[7]]$R2bestmodel
models[[8]]$R2bestmodel
models[[9]]$R2bestmodel

# 10 #  
#  add tenth variable (the only difference of the above part is that now model n=10 the model statement more variables)
#  and the call for the list of variable names in the model changed slightly

modeln<-10

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_2 :nlastvar_LUR_2){if (is.numeric(VGOB1_subsetJ_meca_LUR2[,i])==TRUE){ modeltry<-lm(VGOB1_subsetJ_meca_LUR2$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetJ_meca_LUR2[,models[[1]]$indexbestmodel]+VGOB1_subsetJ_meca_LUR2[,models[[2]]$indexbestmodel]+ VGOB1_subsetJ_meca_LUR2[,models[[3]]$indexbestmodel]+VGOB1_subsetJ_meca_LUR2[,models[[4]]$indexbestmodel]+ VGOB1_subsetJ_meca_LUR2[,models[[5]]$indexbestmodel]+ VGOB1_subsetJ_meca_LUR2[,models[[6]]$indexbestmodel]+ VGOB1_subsetJ_meca_LUR2[,models[[7]]$indexbestmodel]+ VGOB1_subsetJ_meca_LUR2[,models[[8]]$indexbestmodel]+ VGOB1_subsetJ_meca_LUR2[,models[[9]]$indexbestmodel]+ VGOB1_subsetJ_meca_LUR2[,i]) 

R2<-rbind(R2,summary(modeltry)$adj.r.squared)
# the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # Measurements_livestockpreds_LUR2[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR2)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetJ_meca_LUR2)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

# this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

# here are the names
models[[modeln]]$namesbestmodel<-c( names(VGOB1_subsetJ_meca_LUR2)[models[[1]]$indexbestmodel],                   names(VGOB1_subsetJ_meca_LUR2)[models[[2]]$indexbestmodel] , names(VGOB1_subsetJ_meca_LUR2)[models[[3]]$indexbestmodel], names(VGOB1_subsetJ_meca_LUR2)[models[[4]]$indexbestmodel], names(VGOB1_subsetJ_meca_LUR2)[models[[5]]$indexbestmodel], names(VGOB1_subsetJ_meca_LUR2)[models[[6]]$indexbestmodel], names(VGOB1_subsetJ_meca_LUR2)[models[[7]]$indexbestmodel], names(VGOB1_subsetJ_meca_LUR2)[models[[8]]$indexbestmodel], names(VGOB1_subsetJ_meca_LUR2)[models[[9]]$indexbestmodel], names(VGOB1_subsetJ_meca_LUR2)[models[[10]]$indexbestmodel])

#  this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetJ_meca_LUR2$meca_copiespm3.ln.diffmeth.mean~                                VGOB1_subsetJ_meca_LUR2[,models[[1]]$indexbestmodel]+ VGOB1_subsetJ_meca_LUR2[,models[[2]]$indexbestmodel]+                           VGOB1_subsetJ_meca_LUR2[,models[[3]]$indexbestmodel]+ VGOB1_subsetJ_meca_LUR2[,models[[4]]$indexbestmodel]+ VGOB1_subsetJ_meca_LUR2[,models[[5]]$indexbestmodel]+ VGOB1_subsetJ_meca_LUR2[,models[[6]]$indexbestmodel]+ VGOB1_subsetJ_meca_LUR2[,models[[7]]$indexbestmodel]+ VGOB1_subsetJ_meca_LUR2[,models[[8]]$indexbestmodel]+ VGOB1_subsetJ_meca_LUR2[,models[[9]]$indexbestmodel]+ VGOB1_subsetJ_meca_LUR2[,models[[10]]$indexbestmodel]) 

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[5]]$summarybestmodel
models[[6]]$summarybestmodel
models[[7]]$summarybestmodel
models[[8]]$summarybestmodel
models[[9]]$summarybestmodel
models[[10]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[5]]$namesbestmodel
models[[6]]$namesbestmodel
models[[7]]$namesbestmodel
models[[8]]$namesbestmodel
models[[9]]$namesbestmodel
models[[10]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel
models[[5]]$R2bestmodel
models[[6]]$R2bestmodel
models[[7]]$R2bestmodel
models[[8]]$R2bestmodel
models[[9]]$R2bestmodel
models[[10]]$R2bestmodel

#   CODE FOR PICKING OUT THE BEST MODEL #   
temp <- 0
besti <- 0
for (i in 1:10){ #  think this runs the loop 10 times - not fully sure thought - but not to do with the number of models I don't think - as when I change to 3, I still get the model with 4 variables as best model
  print(models[[i]]$R2bestmodel)
  #       print(models[[i]]$summarybestmodel$coefficients=-1,4])
  #       if((models[[i]]$R2bestmodel-temp > 0.0) && (all(models[[i]]$summarybestmodel$coefficients[-1,4]<0.1))){
  #         temp <- models[[i]]$R2bestmodel
  #         besti <- i
  #         }
  if((models[[i]]$R2bestmodel-temp > 0.0) && (all(models[[i]]$summarybestmodel$coefficients[-1,4]<0.1))){
    temp <- models[[i]]$R2bestmodel
    besti <- i
  }else{
    finalBestModel_meca_LUR2_subsetJ <- models[[besti]]$bestmodel
    finalBestModelNames_meca_subsetJ <- models[[besti]]$namesbestmodel
    Sites <- 1:dim(VGOB1_subsetJ_meca_LUR2)[1] # full original model
    #  CVaR2<-escCV_meca_LUR2(Sites)[2] # Cross Validation
    maxCD<-max(cooks.distance(finalBestModel_meca_LUR2_subsetJ))
    if(length(finalBestModelNames_meca_subsetJ)<2){ # vif fn doesnot work when only 1 variable...       # 
      maxVIF<-"NA"
    }else{
      maxVIF<-max(vif(finalBestModel_meca_LUR2_subsetJ))
    }
    print(paste("This is the best meca model for subset J: ",besti,
                "(AdjR2: ",format(models[[besti]]$R2bestmodel,digits=3), "; MaxCD: ",format(maxCD,digits=3),"; MaxVIF: ",
                format(maxVIF,digits=3),")", sep=''))
    print(finalBestModelNames_meca_subsetJ)
    break
  }
}

#  Overview of the final best model using the algorithm selection process (taking into account VIF, R^2, and p-values)
finalBestModel_meca_LUR2_subsetJ
finalBestModelNames_meca_subsetJ
models[[besti]]$summarybestmodel
models[[besti]]$R2bestmodel

#### Predicting hold out sites ####
# These are the models from the 10 subsets: 
finalBestModel_meca_LUR2_subsetA
finalBestModel_meca_LUR2_subsetB
finalBestModel_meca_LUR2_subsetC
finalBestModel_meca_LUR2_subsetD
finalBestModel_meca_LUR2_subsetE
finalBestModel_meca_LUR2_subsetF
finalBestModel_meca_LUR2_subsetG
finalBestModel_meca_LUR2_subsetH
finalBestModel_meca_LUR2_subsetI
finalBestModel_meca_LUR2_subsetJ

#  Selecting of test sets
#  valID 1 to 10
VGOB1_subsetvalID1_meca_LUR2 <- subset(VGOB1_FINAL_meca_LUR2, valID == 1)
VGOB1_subsetvalID2_meca_LUR2 <- subset(VGOB1_FINAL_meca_LUR2, valID == 2)
VGOB1_subsetvalID3_meca_LUR2 <- subset(VGOB1_FINAL_meca_LUR2, valID == 3)
VGOB1_subsetvalID4_meca_LUR2 <- subset(VGOB1_FINAL_meca_LUR2, valID == 4)
VGOB1_subsetvalID5_meca_LUR2 <- subset(VGOB1_FINAL_meca_LUR2, valID == 5)
VGOB1_subsetvalID6_meca_LUR2 <- subset(VGOB1_FINAL_meca_LUR2, valID == 6)
VGOB1_subsetvalID7_meca_LUR2 <- subset(VGOB1_FINAL_meca_LUR2, valID == 7)
VGOB1_subsetvalID8_meca_LUR2 <- subset(VGOB1_FINAL_meca_LUR2, valID == 8)
VGOB1_subsetvalID9_meca_LUR2 <- subset(VGOB1_FINAL_meca_LUR2, valID == 9)
VGOB1_subsetvalID10_meca_LUR2 <- subset(VGOB1_FINAL_meca_LUR2, valID == 10)

#  For every subset predict (based on LUR model for that subset, so the training sites) the concentrations at the sites left out (test sites) to enable comparisons observed vs predicted 

#  Set 1
finalBestModel_meca_LUR2_subsetA
finalBestModelNames_meca_subsetA
summary(finalBestModel_meca_LUR2_subsetA)
# write the model out
finalBestModel_meca_LUR2_subsetA_lm <- lm(meca_copiespm3.ln.diffmeth.mean~ npoultryWghtDist.3000m.sum.95Win.10to90scaled + AllFarm.3000m.95Win.10to90scaled, data = VGOB1_subsetA_meca_LUR2)
VGOB1_subsetvalID1_meca_LUR2$meca_PRED_HV <- predict(finalBestModel_meca_LUR2_subsetA_lm,VGOB1_subsetvalID1_meca_LUR2)
summary(VGOB1_subsetvalID1_meca_LUR2$meca_PRED_HV)
plot(VGOB1_subsetvalID1_meca_LUR2$meca_PRED_HV, VGOB1_subsetvalID1_meca_LUR2$meca_copiespm3.ln.diffmeth.mean, xlab="meca predicted (HV)", ylab="meca concentration observed")
VGOB1_subsetvalID1_meca_LUR2_lm <- lm(meca_copiespm3.ln.diffmeth.mean~meca_PRED_HV, data=VGOB1_subsetvalID1_meca_LUR2 )
summary(VGOB1_subsetvalID1_meca_LUR2_lm)

#  Set 2
finalBestModel_meca_LUR2_subsetB
finalBestModelNames_meca_subsetB
summary(finalBestModel_meca_LUR2_subsetB)
# write the model out
finalBestModel_meca_LUR2_subsetB_lm <- lm(meca_copiespm3.ln.diffmeth.mean~ PoultryFarm.3000m.95Win.10to90scaled + npoultry.1000m.95Win.10to90scaled + HorseFarm.3000m.95Win.10to90scaled + PigFarm.3000m.95Win.10to90scaled, data = VGOB1_subsetB_meca_LUR2)
VGOB1_subsetvalID2_meca_LUR2$meca_PRED_HV <- predict(finalBestModel_meca_LUR2_subsetB_lm,VGOB1_subsetvalID2_meca_LUR2)
summary(VGOB1_subsetvalID2_meca_LUR2$meca_PRED_HV)
plot(VGOB1_subsetvalID2_meca_LUR2$meca_PRED_HV, VGOB1_subsetvalID2_meca_LUR2$meca_copiespm3.ln.diffmeth.mean, xlab="meca predicted (HV)", ylab="meca concentration observed")
VGOB1_subsetvalID2_meca_LUR2_lm <- lm(meca_copiespm3.ln.diffmeth.mean~meca_PRED_HV, data=VGOB1_subsetvalID2_meca_LUR2)
summary(VGOB1_subsetvalID2_meca_LUR2_lm)

#  Set 3
finalBestModel_meca_LUR2_subsetC
finalBestModelNames_meca_subsetC
summary(finalBestModel_meca_LUR2_subsetC)
# write the model out
finalBestModel_meca_LUR2_subsetC_lm <- lm(meca_copiespm3.ln.diffmeth.mean~ npoultryWghtDist.3000m.sum.95Win.10to90scaled + HorseFarm.3000m.95Win.10to90scaled, data = VGOB1_subsetC_meca_LUR2)
VGOB1_subsetvalID3_meca_LUR2$meca_PRED_HV <- predict(finalBestModel_meca_LUR2_subsetC_lm,VGOB1_subsetvalID3_meca_LUR2)
summary(VGOB1_subsetvalID3_meca_LUR2$meca_PRED_HV)
plot(VGOB1_subsetvalID3_meca_LUR2$meca_PRED_HV, VGOB1_subsetvalID3_meca_LUR2$meca_copiespm3.ln.diffmeth.mean, xlab="meca predicted (HV)", ylab="meca concentration observed")
VGOB1_subsetvalID3_meca_LUR2_lm <- lm(meca_copiespm3.ln.diffmeth.mean~meca_PRED_HV, data=VGOB1_subsetvalID3_meca_LUR2 )
summary(VGOB1_subsetvalID3_meca_LUR2_lm)

#  Set 4
finalBestModel_meca_LUR2_subsetD
finalBestModelNames_meca_subsetD
summary(finalBestModel_meca_LUR2_subsetD)
# write the model out
finalBestModel_meca_LUR2_subsetD_lm <- lm(meca_copiespm3.ln.diffmeth.mean~ npoultry.3000m.95Win.10to90scaled + AllFarm.3000m.95Win.10to90scaled + npoultry.500m.95Win.10to90scaled, data = VGOB1_subsetD_meca_LUR2)
VGOB1_subsetvalID4_meca_LUR2$meca_PRED_HV <- predict(finalBestModel_meca_LUR2_subsetD_lm,VGOB1_subsetvalID4_meca_LUR2)
summary(VGOB1_subsetvalID4_meca_LUR2$meca_PRED_HV)
plot(VGOB1_subsetvalID4_meca_LUR2$meca_PRED_HV, VGOB1_subsetvalID4_meca_LUR2$meca_copiespm3.ln.diffmeth.mean, xlab="meca predicted (HV)", ylab="meca concentration observed")
VGOB1_subsetvalID4_meca_LUR2_lm <- lm(meca_copiespm3.ln.diffmeth.mean~meca_PRED_HV, data=VGOB1_subsetvalID4_meca_LUR2 )
summary(VGOB1_subsetvalID4_meca_LUR2_lm)

#  Set 5
finalBestModel_meca_LUR2_subsetE
finalBestModelNames_meca_subsetE
summary(finalBestModel_meca_LUR2_subsetE)
# write the model out
finalBestModel_meca_LUR2_subsetE_lm <- lm(meca_copiespm3.ln.diffmeth.mean~ npoultry.3000m.95Win.10to90scaled + npigs.500m.95Win.10to90scaled + HorseFarm.3000m.95Win.10to90scaled + npoultry.1000m.95Win.10to90scaled, data = VGOB1_subsetE_meca_LUR2)
VGOB1_subsetvalID5_meca_LUR2$meca_PRED_HV <- predict(finalBestModel_meca_LUR2_subsetE_lm,VGOB1_subsetvalID5_meca_LUR2)
summary(VGOB1_subsetvalID5_meca_LUR2$meca_PRED_HV)
plot(VGOB1_subsetvalID5_meca_LUR2$meca_PRED_HV, VGOB1_subsetvalID5_meca_LUR2$meca_copiespm3.ln.diffmeth.mean, xlab="meca predicted (HV)", ylab="meca concentration observed")
VGOB1_subsetvalID5_meca_LUR2_lm <- lm(meca_copiespm3.ln.diffmeth.mean~meca_PRED_HV, data=VGOB1_subsetvalID5_meca_LUR2)
summary(VGOB1_subsetvalID5_meca_LUR2_lm)

#  Set 6
finalBestModel_meca_LUR2_subsetF
finalBestModelNames_meca_subsetF
summary(finalBestModel_meca_LUR2_subsetF)
# write the model out
finalBestModel_meca_LUR2_subsetF_lm <- lm(meca_copiespm3.ln.diffmeth.mean~npoultry.3000m.95Win.10to90scaled + npigs.500m.95Win.10to90scaled + HorseFarm.3000m.95Win.10to90scaled + npoultry.1000m.95Win.10to90scaled, data = VGOB1_subsetF_meca_LUR2)
VGOB1_subsetvalID6_meca_LUR2$meca_PRED_HV <- predict(finalBestModel_meca_LUR2_subsetF_lm,VGOB1_subsetvalID1_meca_LUR2)
summary(VGOB1_subsetvalID6_meca_LUR2$meca_PRED_HV)
plot(VGOB1_subsetvalID6_meca_LUR2$meca_PRED_HV, VGOB1_subsetvalID6_meca_LUR2$meca_copiespm3.ln.diffmeth.mean, xlab="meca predicted (HV)", ylab="meca concentration observed")
VGOB1_subsetvalID6_meca_LUR2_lm <- lm(meca_copiespm3.ln.diffmeth.mean~meca_PRED_HV, data=VGOB1_subsetvalID6_meca_LUR2 )
summary(VGOB1_subsetvalID6_meca_LUR2_lm)

#  Set 7
finalBestModel_meca_LUR2_subsetG
finalBestModelNames_meca_subsetG
summary(finalBestModel_meca_LUR2_subsetG)
# write the model out
finalBestModel_meca_LUR2_subsetG_lm <- lm(meca_copiespm3.ln.diffmeth.mean~ npoultryWghtDist.3000m.sum.95Win.10to90scaled + npigs.500m.95Win.10to90scaled + HorseFarm.3000m.95Win.10to90scaled, data = VGOB1_subsetG_meca_LUR2)
VGOB1_subsetvalID7_meca_LUR2$meca_PRED_HV <- predict(finalBestModel_meca_LUR2_subsetG_lm,VGOB1_subsetvalID7_meca_LUR2)
summary(VGOB1_subsetvalID7_meca_LUR2$meca_PRED_HV)
plot(VGOB1_subsetvalID7_meca_LUR2$meca_PRED_HV, VGOB1_subsetvalID7_meca_LUR2$meca_copiespm3.ln.diffmeth.mean, xlab="meca predicted (HV)", ylab="meca concentration observed")
VGOB1_subsetvalID7_meca_LUR2_lm <- lm(meca_copiespm3.ln.diffmeth.mean~meca_PRED_HV, data=VGOB1_subsetvalID7_meca_LUR2)
summary(VGOB1_subsetvalID7_meca_LUR2_lm)

#  Set 8
finalBestModel_meca_LUR2_subsetH
finalBestModelNames_meca_subsetH
summary(finalBestModel_meca_LUR2_subsetH)
# write the model out
finalBestModel_meca_LUR2_subsetH_lm <- lm(meca_copiespm3.ln.diffmeth.mean~ npoultry.3000m.95Win.10to90scaled + npigs.500m.95Win.10to90scaled + HorseFarm.3000m.95Win.10to90scaled, data = VGOB1_subsetH_meca_LUR2)
VGOB1_subsetvalID8_meca_LUR2$meca_PRED_HV <- predict(finalBestModel_meca_LUR2_subsetH_lm,VGOB1_subsetvalID8_meca_LUR2)
summary(VGOB1_subsetvalID8_meca_LUR2$meca_PRED_HV)
plot(VGOB1_subsetvalID8_meca_LUR2$meca_PRED_HV, VGOB1_subsetvalID8_meca_LUR2$meca_copiespm3.ln.diffmeth.mean, xlab="meca predicted (HV)", ylab="meca concentration observed")
VGOB1_subsetvalID8_meca_LUR2_lm <- lm(meca_copiespm3.ln.diffmeth.mean~meca_PRED_HV, data=VGOB1_subsetvalID8_meca_LUR2)
summary(VGOB1_subsetvalID8_meca_LUR2_lm)

#  Set 9
finalBestModel_meca_LUR2_subsetI
finalBestModelNames_meca_subsetI
summary(finalBestModel_meca_LUR2_subsetI)
# write the model out
finalBestModel_meca_LUR2_subsetI_lm <- lm(meca_copiespm3.ln.diffmeth.mean~ npoultryWghtDist.3000m.sum.95Win.10to90scaled + HorseFarm.3000m.95Win.10to90scaled + npoultry.1000m.95Win.10to90scaled, data = VGOB1_subsetI_meca_LUR2)
VGOB1_subsetvalID9_meca_LUR2$meca_PRED_HV <- predict(finalBestModel_meca_LUR2_subsetI_lm,VGOB1_subsetvalID9_meca_LUR2)
summary(VGOB1_subsetvalID9_meca_LUR2$meca_PRED_HV)
plot(VGOB1_subsetvalID9_meca_LUR2$meca_PRED_HV, VGOB1_subsetvalID9_meca_LUR2$meca_copiespm3.ln.diffmeth.mean, xlab="meca predicted (HV)", ylab="meca concentration observed")
VGOB1_subsetvalID9_meca_LUR2_lm <- lm(meca_copiespm3.ln.diffmeth.mean~meca_PRED_HV, data=VGOB1_subsetvalID9_meca_LUR2 )
summary(VGOB1_subsetvalID9_meca_LUR2_lm)

#  Set 10
finalBestModel_meca_LUR2_subsetJ
finalBestModelNames_meca_subsetJ
summary(finalBestModel_meca_LUR2_subsetJ)
# write the model out
finalBestModel_meca_LUR2_subsetJ_lm <- lm(meca_copiespm3.ln.diffmeth.mean~ npoultryWghtDist.3000m.sum.95Win.10to90scaled+HorseFarm.3000m.95Win.10to90scaled+PigFarm.3000m.95Win.10to90scaled, data = VGOB1_subsetJ_meca_LUR2)
VGOB1_subsetvalID10_meca_LUR2$meca_PRED_HV <- predict(finalBestModel_meca_LUR2_subsetJ_lm,VGOB1_subsetvalID10_meca_LUR2)
summary(VGOB1_subsetvalID10_meca_LUR2$meca_PRED_HV)
plot(VGOB1_subsetvalID10_meca_LUR2$meca_PRED_HV, VGOB1_subsetvalID10_meca_LUR2$meca_copiespm3.ln.diffmeth.mean, xlab="meca predicted (HV)", ylab="meca concentration observed")
VGOB1_subsetvalID10_meca_LUR2_lm <- lm(meca_copiespm3.ln.diffmeth.mean~meca_PRED_HV, data=VGOB1_subsetvalID10_meca_LUR2)
summary(VGOB1_subsetvalID10_meca_LUR2_lm)

# Calculate max VIF and cook's distnace of each subset (each fold of the 10-fold CV)
# Since all models only include 1 variable, VIF is not possible to calculate
maxVIF_meca_LUR2_subsetA <- max(vif(finalBestModel_meca_LUR2_subsetA))
maxVIF_meca_LUR2_subsetB <- max(vif(finalBestModel_meca_LUR2_subsetB))
maxVIF_meca_LUR2_subsetC <- max(vif(finalBestModel_meca_LUR2_subsetC))
maxVIF_meca_LUR2_subsetD <- max(vif(finalBestModel_meca_LUR2_subsetD))
maxVIF_meca_LUR2_subsetE <- max(vif(finalBestModel_meca_LUR2_subsetE))
maxVIF_meca_LUR2_subsetF <- max(vif(finalBestModel_meca_LUR2_subsetF))
maxVIF_meca_LUR2_subsetG <- max(vif(finalBestModel_meca_LUR2_subsetG))
maxVIF_meca_LUR2_subsetH <- max(vif(finalBestModel_meca_LUR2_subsetH))
maxVIF_meca_LUR2_subsetI <- max(vif(finalBestModel_meca_LUR2_subsetI))
maxVIF_meca_LUR2_subsetJ <- max(vif(finalBestModel_meca_LUR2_subsetJ))

maxCD_meca_LUR2_subsetA <- max(cooks.distance(finalBestModel_meca_LUR2_subsetA))
maxCD_meca_LUR2_subsetB <- max(cooks.distance(finalBestModel_meca_LUR2_subsetB))
maxCD_meca_LUR2_subsetC <- max(cooks.distance(finalBestModel_meca_LUR2_subsetC))
maxCD_meca_LUR2_subsetD <- max(cooks.distance(finalBestModel_meca_LUR2_subsetD))
maxCD_meca_LUR2_subsetE <- max(cooks.distance(finalBestModel_meca_LUR2_subsetE))
maxCD_meca_LUR2_subsetF <- max(cooks.distance(finalBestModel_meca_LUR2_subsetF))
maxCD_meca_LUR2_subsetG <- max(cooks.distance(finalBestModel_meca_LUR2_subsetG))
maxCD_meca_LUR2_subsetH <- max(cooks.distance(finalBestModel_meca_LUR2_subsetH))
maxCD_meca_LUR2_subsetI <- max(cooks.distance(finalBestModel_meca_LUR2_subsetI))
maxCD_meca_LUR2_subsetJ <- max(cooks.distance(finalBestModel_meca_LUR2_subsetJ))

# Write out the max VIF and cook's distance figures for each of the 10 folds, and create a dataframe 

meca_LUR2_maxVIF_subsetvalID1to10 <- c(maxVIF_meca_LUR2_subsetA, maxVIF_meca_LUR2_subsetB, maxVIF_meca_LUR2_subsetC, maxVIF_meca_LUR2_subsetD, maxVIF_meca_LUR2_subsetE, maxVIF_meca_LUR2_subsetF, maxVIF_meca_LUR2_subsetG, maxVIF_meca_LUR2_subsetH, maxVIF_meca_LUR2_subsetI, maxVIF_meca_LUR2_subsetJ)

meca_LUR2_maxCD_maxCD_subsetvalID1to10 <- c(maxCD_meca_LUR2_subsetA, maxCD_meca_LUR2_subsetB, maxCD_meca_LUR2_subsetC, maxCD_meca_LUR2_subsetD, maxCD_meca_LUR2_subsetE, maxCD_meca_LUR2_subsetF, maxCD_meca_LUR2_subsetG, maxCD_meca_LUR2_subsetH, maxCD_meca_LUR2_subsetI, maxCD_meca_LUR2_subsetJ)

meca_LUR2_maxVIF_maxCD_matrix <- cbind(meca_LUR2_maxVIF_subsetvalID1to10, meca_LUR2_maxCD_maxCD_subsetvalID1to10)
meca_LUR2_maxVIF_maxCD_df <- as.data.frame(meca_LUR2_maxVIF_maxCD_matrix)

row.names(meca_LUR2_maxVIF_maxCD_df) <- c("SubsetA", "SubsetB", "SubsetC", "SubsetD", "SubsetE", "SubsetF", "SubsetG", "SubsetH", "SubsetI", "SubsetJ")

write_xlsx(meca_LUR2_maxVIF_maxCD_df,"Output_files\\meca_LUR2_maxVIF_maxCD_df.xlsx")

#  Merging of all test sets to make overall comparisons of predicted vs observed
VGOB1_subsetvalID1to10_meca_LUR2_10foldCV <- rbind(VGOB1_subsetvalID1_meca_LUR2, VGOB1_subsetvalID2_meca_LUR2, VGOB1_subsetvalID3_meca_LUR2, VGOB1_subsetvalID4_meca_LUR2, VGOB1_subsetvalID5_meca_LUR2, VGOB1_subsetvalID6_meca_LUR2, VGOB1_subsetvalID7_meca_LUR2, VGOB1_subsetvalID8_meca_LUR2, VGOB1_subsetvalID9_meca_LUR2, VGOB1_subsetvalID10_meca_LUR2)

#  Overall comparison of predicted vs observed
plot(VGOB1_subsetvalID1to10_meca_LUR2_10foldCV$meca_PRED_HV, VGOB1_subsetvalID1to10_meca_LUR2_10foldCV$meca_copiespm3.ln.diffmeth.mean, xlab="LUR2-predicted meca DNA concentration (ln copies/m^3)", ylab="Observed meca DNA concentration (ln copies/m^3)", cex.lab=0.85)
abline(lm(VGOB1_subsetvalID1to10_meca_LUR2_10foldCV$meca_copiespm3.ln.diffmeth.mean ~ VGOB1_subsetvalID1to10_meca_LUR2_10foldCV$meca_PRED_HV))

VGOB1_subsetvalID1to10_meca_LUR2_10foldCV_lm <- lm(meca_copiespm3.ln.diffmeth.mean ~ meca_PRED_HV, data=VGOB1_subsetvalID1to10_meca_LUR2_10foldCV)
summary(VGOB1_subsetvalID1to10_meca_LUR2_10foldCV_lm)

# 10-fold CV multiple R2 for meca LUR2 = 0.1669

#  Calculate RMSE
RMSE_meca_LUR2_10foldCV <- sqrt(mean((VGOB1_subsetvalID1to10_meca_LUR2_10foldCV$meca_copiespm3.ln.diffmeth.mean - VGOB1_subsetvalID1to10_meca_LUR2_10foldCV$meca_PRED_HV)^2))
RMSE_meca_LUR2_10foldCV

# 10-fold CV RMSE = 0.8981917

#  Save these predicted concentrations as an excel file along with the actual measured concentrations of meca at each of the measurement sites 
#  These are the predicted concentrations for the sites that were left out of the model training procedure in 10-fold cross validation 
meca_LUR2_10foldCV_preds <- VGOB1_subsetvalID1to10_meca_LUR2_10foldCV$meca_PRED_HV 
#  These are the actual measured concentrations at the 61 measurement sites - these are in the same order as the above sites in order to match the predicted concentrations (i.e. not in order 1-61)
VGOB1_subsetvalID1to10_meca_LUR2_10foldCV$meca_copiespm3.ln.diffmeth.mean

VGOB1_subsetvalID1to10_meca_LUR2_10foldCV$Loc_ID

#  Create a dataframe 
meca_SLR_10foldCVpreds_observed <- data.frame(VGOB1_subsetvalID1to10_meca_LUR2_10foldCV$Loc_ID,VGOB1_subsetvalID1to10_meca_LUR2_10foldCV$meca_copiespm3.ln.diffmeth.mean, VGOB1_subsetvalID1to10_meca_LUR2_10foldCV$meca_PRED_HV)
print(meca_SLR_10foldCVpreds_observed)

#  Save as xls file 
write_xlsx(meca_SLR_10foldCVpreds_observed,"Output_files//meca_LUR2_10foldCV_observed_predicted.xlsx")
```
#  meca LUR3 - training model
```{r}
#  Function building to run the models 
models<-list()
# 
modeln<-1
models[[modeln]]<-list()

R2<-1
betaaddedvar<-1
addedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR3:nlastvar_LUR3){
  if (is.numeric(Measurements_livestockpreds_LUR3[,i])==TRUE){
    modeltry<-lm(meca~Measurements_livestockpreds_LUR3[,i])                            
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    # find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # Measurements_livestockpreds_LUR3[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR3)[i]
    addedvar<-rbind(addedvar,names(Measurements_livestockpreds_LUR3)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)
models[[modeln]]$results

#  this are the candidates models with the highest R2, not a negative beta for the new, nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)
models[[modeln]]$resultspos

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))
models[[modeln]]$resultspos

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j
models[[modeln]]$indexbestmodel

subset(models[[modeln]]$resultspos, rank==1)
subset(models[[modeln]]$resultspos)

#  this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]
models[[modeln]]$summarybestmodel

# here are the names
models[[modeln]]$namesbestmodel<-c(names(Measurements_livestockpreds_LUR3)[models[[1]]$indexbestmodel])
models[[modeln]]$namesbestmodel

# this is the r2 of that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2
models[[modeln]]$R2bestmodel

# this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(meca~Measurements_livestockpreds_LUR3[,models[[1]]$indexbestmodel]) 
models[[modeln]]$bestmodel

summary(models[[modeln]]$bestmodel)


#  2 # 

#  Add 2nd variable (the only difference of the above part is that now modeln=2 the model statement has 2 variables)
#  and the cAll for the list of variable names in the model changed slightly

modeln<-2

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR3:nlastvar_LUR3){
  if (is.numeric(Measurements_livestockpreds_LUR3[,i])==TRUE){
    modeltry<-lm(meca~Measurements_livestockpreds_LUR3[,models[[1]]$indexbestmodel]+ Measurements_livestockpreds_LUR3[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    # find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # Measurements_livestockpreds_LUR3[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR3)[i]
    addedvar<-rbind(addedvar,names(Measurements_livestockpreds_LUR3)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  these are the candidate models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)
models[[modeln]]$resultspos

#  rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))
models[[modeln]]$resultspos

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j
models[[modeln]]$indexbestmodel

subset(models[[modeln]]$resultspos, rank==1)

# this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]
models[[modeln]]$summarybestmodel

# here are the names
models[[modeln]]$namesbestmodel<-c(names(Measurements_livestockpreds_LUR3)[models[[1]]$indexbestmodel], names(Measurements_livestockpreds_LUR3)[models[[2]]$indexbestmodel] )
models[[modeln]]$namesbestmodel

# this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2
models[[modeln]]$R2bestmodel

# this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(meca~Measurements_livestockpreds_LUR3[,models[[1]]$indexbestmodel]+Measurements_livestockpreds_LUR3[,models[[2]]$indexbestmodel]) 
models[[modeln]]$bestmodel

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel

models[[1]]$namesbestmodel
models[[2]]$namesbestmodel

models[[1]]$R2bestmodel
models[[2]]$R2bestmodel

#  at this point I always check whether the next model (with 2 variables) is more than 1% better than the one before and if not I end here
#  R2 of the second model is higher than the 1st model, so 2nd is better  
#  Also check vif and cook's distance 
vif(models[[2]]$bestmodel) #  no VIF values are > 1
ols_plot_cooksd_bar(models[[2]]$bestmodel, print_plot = TRUE) #  no cook's distances are >1 
#  3 # 

#  add third variable (the only difference of the above part is that now modeln=3 the model statement has 3 variables)
#  and the cAll for the list of variable names in the model changed slightly

modeln<-3

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR3:nlastvar_LUR3){
  if (is.numeric(Measurements_livestockpreds_LUR3[,i])==TRUE){  
    modeltry<-lm(meca~Measurements_livestockpreds_LUR3[,models[[1]]$indexbestmodel]+Measurements_livestockpreds_LUR3[,models[[2]]$indexbestmodel]+ Measurements_livestockpreds_LUR3[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    # find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # All[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR3)[i]
    addedvar<-rbind(addedvar,names(Measurements_livestockpreds_LUR3)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))


#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

# this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

# here are the names
models[[modeln]]$namesbestmodel<-c(names(Measurements_livestockpreds_LUR3)[models[[1]]$indexbestmodel], names(Measurements_livestockpreds_LUR3)[models[[2]]$indexbestmodel] , names(Measurements_livestockpreds_LUR3)[models[[3]]$indexbestmodel])

# this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

# this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(meca~Measurements_livestockpreds_LUR3[,models[[1]]$indexbestmodel]+Measurements_livestockpreds_LUR3[,models[[2]]$indexbestmodel]+Measurements_livestockpreds_LUR3[,models[[3]]$indexbestmodel]) 

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel

models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel

models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel

#  Yes R^2 increases >1% 
#  Also check vif and cook's distance 
vif(models[[3]]$bestmodel) #  no VIF values are > 1
ols_plot_cooksd_bar(models[[2]]$bestmodel, print_plot = TRUE) #  no cook's distances are >1 


#  4 # 

#  add forth variable (the only difference of the above part is that now model n=4 the model statement more variables)
#  and the cAll for the list of variable names in the model changed slightly
modeln<-4

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1


for (i in nfirstvar_LUR3:nlastvar_LUR3){
  if (is.numeric(Measurements_livestockpreds_LUR3[,i])==TRUE){
    modeltry<-lm(meca~Measurements_livestockpreds_LUR3[,models[[1]]$indexbestmodel]+Measurements_livestockpreds_LUR3[,models[[2]]$indexbestmodel]+Measurements_livestockpreds_LUR3[,models[[3]]$indexbestmodel]+Measurements_livestockpreds_LUR3[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    # find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # All[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR3)[i]
    addedvar<-rbind(addedvar,names(Measurements_livestockpreds_LUR3)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

# this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

# here are the names
models[[modeln]]$namesbestmodel<-c(names(Measurements_livestockpreds_LUR3)[models[[1]]$indexbestmodel], names(Measurements_livestockpreds_LUR3)[models[[2]]$indexbestmodel] , names(Measurements_livestockpreds_LUR3)[models[[3]]$indexbestmodel], names(Measurements_livestockpreds_LUR3)[models[[4]]$indexbestmodel])

# this is the r2 of that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

# this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(meca~Measurements_livestockpreds_LUR3[,models[[1]]$indexbestmodel]+Measurements_livestockpreds_LUR3[,models[[2]]$indexbestmodel]+Measurements_livestockpreds_LUR3[,models[[3]]$indexbestmodel]+ Measurements_livestockpreds_LUR3[,models[[4]]$indexbestmodel]) 


models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel

#  R^2 increasese by > 1% 
#  Also check vif and cook's distance 
vif(models[[4]]$bestmodel) #  no VIF values are > 1 - approaching 3 (highest is 2.43)
ols_plot_cooksd_bar(models[[4]]$bestmodel, print_plot = TRUE) #  no cook's distances are >1 

#  5 # 
#  add fifth variable (the only difference of the above part is that now modeln=5 the model statement more variables)
#  and the cAll for the list of variable names in the model changed slightly
modeln<-5

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR3:nlastvar_LUR3){
  if (is.numeric(Measurements_livestockpreds_LUR3[,i])==TRUE){
    modeltry<-lm(meca~Measurements_livestockpreds_LUR3[,models[[1]]$indexbestmodel]+Measurements_livestockpreds_LUR3[,models[[2]]$indexbestmodel]+Measurements_livestockpreds_LUR3[,models[[3]]$indexbestmodel]+Measurements_livestockpreds_LUR3[,models[[4]]$indexbestmodel]+ Measurements_livestockpreds_LUR3[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    # find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # All[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR3)[i]
    addedvar<-rbind(addedvar,names(Measurements_livestockpreds_LUR3)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

#  this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

# here are the names
models[[modeln]]$namesbestmodel<-c(names(Measurements_livestockpreds_LUR3)[models[[1]]$indexbestmodel], names(Measurements_livestockpreds_LUR3)[models[[2]]$indexbestmodel] , names(Measurements_livestockpreds_LUR3)[models[[3]]$indexbestmodel], names(Measurements_livestockpreds_LUR3)[models[[4]]$indexbestmodel], names(Measurements_livestockpreds_LUR3)[models[[5]]$indexbestmodel])


# this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

# this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(meca~Measurements_livestockpreds_LUR3[,models[[1]]$indexbestmodel]+Measurements_livestockpreds_LUR3[,models[[2]]$indexbestmodel]+Measurements_livestockpreds_LUR3[,models[[3]]$indexbestmodel]+ Measurements_livestockpreds_LUR3[,models[[4]]$indexbestmodel]+ Measurements_livestockpreds_LUR3[,models[[5]]$indexbestmodel]) 


models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[5]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[5]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel
models[[5]]$R2bestmodel

#  at this point I always check whether the next model is more than 1% better than the one before and if not I end here
#  Yes model 5 is 1.41754% better than model 4 therefore I continue
#  Also check vif and cook's distance 
vif(models[[5]]$bestmodel) #  I have some values approaching 3 but not yet 3 (highest is 2.69)
ols_plot_cooksd_bar(models[[5]]$bestmodel, print_plot = TRUE) #  no cook's distances are >1 

#  6 # 
#  add sixth variable (the only difference of the above part is that now modeln=6 the modelstatement more variables)
#  and the cAll for the list of variable names in the model changed slightly

modeln<-6

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR3 :nlastvar_LUR3){
  if (is.numeric(Measurements_livestockpreds_LUR3[,i])==TRUE){
    modeltry<-lm(meca~Measurements_livestockpreds_LUR3[,models[[1]]$indexbestmodel]+Measurements_livestockpreds_LUR3[,models[[2]]$indexbestmodel]+Measurements_livestockpreds_LUR3[,models[[3]]$indexbestmodel]+Measurements_livestockpreds_LUR3[,models[[4]]$indexbestmodel]+Measurements_livestockpreds_LUR3[,models[[5]]$indexbestmodel]+ Measurements_livestockpreds_LUR3[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    # find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # All[,i] is the row that's being tried out now. the name of that row can be found in  names(All)[i]
    addedvar<-rbind(addedvar,names(Measurements_livestockpreds_LUR3)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

# this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

# here are the names
models[[modeln]]$namesbestmodel<-c(names(Measurements_livestockpreds_LUR3)[models[[1]]$indexbestmodel], names(Measurements_livestockpreds_LUR3)[models[[2]]$indexbestmodel] , names(Measurements_livestockpreds_LUR3)[models[[3]]$indexbestmodel], names(Measurements_livestockpreds_LUR3)[models[[4]]$indexbestmodel], names(Measurements_livestockpreds_LUR3)[models[[5]]$indexbestmodel], names(Measurements_livestockpreds_LUR3)[models[[6]]$indexbestmodel])

# this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

# this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(meca~Measurements_livestockpreds_LUR3[,models[[1]]$indexbestmodel]+Measurements_livestockpreds_LUR3[,models[[2]]$indexbestmodel]+Measurements_livestockpreds_LUR3[,models[[3]]$indexbestmodel]+ Measurements_livestockpreds_LUR3[,models[[4]]$indexbestmodel]+ Measurements_livestockpreds_LUR3[,models[[5]]$indexbestmodel]+ Measurements_livestockpreds_LUR3[,models[[6]]$indexbestmodel]) 

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[5]]$summarybestmodel
models[[6]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[5]]$namesbestmodel
models[[6]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel
models[[5]]$R2bestmodel
models[[6]]$R2bestmodel

#  7 # 
#  add seventh variable (the only difference of the above part is that now modeln=7 the modelstatement more variables)
#  and the cAll for the list of variable names in the model changed slightly

modeln<-7

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR3 :nlastvar_LUR3){
  if (is.numeric(Measurements_livestockpreds_LUR3[,i])==TRUE){
    modeltry<-lm(meca~Measurements_livestockpreds_LUR3[,models[[1]]$indexbestmodel]+Measurements_livestockpreds_LUR3[,models[[2]]$indexbestmodel]+Measurements_livestockpreds_LUR3[,models[[3]]$indexbestmodel]+Measurements_livestockpreds_LUR3[,models[[4]]$indexbestmodel]+Measurements_livestockpreds_LUR3[,models[[5]]$indexbestmodel]+Measurements_livestockpreds_LUR3[,models[[6]]$indexbestmodel]+ Measurements_livestockpreds_LUR3[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    # find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # Measurements_livestockpreds_LUR3[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR3)[i]
    addedvar<-rbind(addedvar,names(Measurements_livestockpreds_LUR3)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

# this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

# here are the names
models[[modeln]]$namesbestmodel<-c(names(Measurements_livestockpreds_LUR3)[models[[1]]$indexbestmodel], names(Measurements_livestockpreds_LUR3)[models[[2]]$indexbestmodel] , names(Measurements_livestockpreds_LUR3)[models[[3]]$indexbestmodel], names(Measurements_livestockpreds_LUR3)[models[[4]]$indexbestmodel], names(Measurements_livestockpreds_LUR3)[models[[5]]$indexbestmodel], names(Measurements_livestockpreds_LUR3)[models[[6]]$indexbestmodel],
names(Measurements_livestockpreds_LUR3)[models[[7]]$indexbestmodel])

# this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

# this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(meca~Measurements_livestockpreds_LUR3[,models[[1]]$indexbestmodel]+Measurements_livestockpreds_LUR3[,models[[2]]$indexbestmodel]+Measurements_livestockpreds_LUR3[,models[[3]]$indexbestmodel]+ Measurements_livestockpreds_LUR3[,models[[4]]$indexbestmodel]+ Measurements_livestockpreds_LUR3[,models[[5]]$indexbestmodel]+ Measurements_livestockpreds_LUR3[,models[[6]]$indexbestmodel]+
Measurements_livestockpreds_LUR3[,models[[7]]$indexbestmodel]) 

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[5]]$summarybestmodel
models[[6]]$summarybestmodel
models[[7]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[5]]$namesbestmodel
models[[6]]$namesbestmodel
models[[7]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel
models[[5]]$R2bestmodel
models[[6]]$R2bestmodel
models[[7]]$R2bestmodel

# R^2 decreases from model 6 to 7 
#  I continue with the model building for the algorithm but unlikely to be >6 vars in best model

#  8 # 
#  add eighth variable (the only difference of the above part is that now modeln=8 the modelstatement more variables)
#  and the cAll for the list of variable names in the model changed slightly

modeln<-8

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR3 :nlastvar_LUR3){
  if (is.numeric(Measurements_livestockpreds_LUR3[,i])==TRUE){
    modeltry<-lm(meca~Measurements_livestockpreds_LUR3[,models[[1]]$indexbestmodel]+Measurements_livestockpreds_LUR3[,models[[2]]$indexbestmodel]+Measurements_livestockpreds_LUR3[,models[[3]]$indexbestmodel]+Measurements_livestockpreds_LUR3[,models[[4]]$indexbestmodel]+Measurements_livestockpreds_LUR3[,models[[5]]$indexbestmodel]+Measurements_livestockpreds_LUR3[,models[[6]]$indexbestmodel]+ Measurements_livestockpreds_LUR3[,models[[7]]$indexbestmodel]+ Measurements_livestockpreds_LUR3[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    # find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # Measurements_livestockpreds_LUR3[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR3)[i]
    addedvar<-rbind(addedvar,names(Measurements_livestockpreds_LUR3)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

# this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

# here are the names
models[[modeln]]$namesbestmodel<-c(names(Measurements_livestockpreds_LUR3)[models[[1]]$indexbestmodel], names(Measurements_livestockpreds_LUR3)[models[[2]]$indexbestmodel] , names(Measurements_livestockpreds_LUR3)[models[[3]]$indexbestmodel], names(Measurements_livestockpreds_LUR3)[models[[4]]$indexbestmodel], names(Measurements_livestockpreds_LUR3)[models[[5]]$indexbestmodel], names(Measurements_livestockpreds_LUR3)[models[[6]]$indexbestmodel],
names(Measurements_livestockpreds_LUR3)[models[[7]]$indexbestmodel],
names(Measurements_livestockpreds_LUR3)[models[[8]]$indexbestmodel] )

# this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

# this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(meca~Measurements_livestockpreds_LUR3[,models[[1]]$indexbestmodel]+Measurements_livestockpreds_LUR3[,models[[2]]$indexbestmodel]+Measurements_livestockpreds_LUR3[,models[[3]]$indexbestmodel]+ Measurements_livestockpreds_LUR3[,models[[4]]$indexbestmodel]+ Measurements_livestockpreds_LUR3[,models[[5]]$indexbestmodel]+ Measurements_livestockpreds_LUR3[,models[[6]]$indexbestmodel]+
Measurements_livestockpreds_LUR3[,models[[7]]$indexbestmodel] +Measurements_livestockpreds_LUR3[,models[[8]]$indexbestmodel]) 

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[5]]$summarybestmodel
models[[6]]$summarybestmodel
models[[7]]$summarybestmodel
models[[8]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[5]]$namesbestmodel
models[[6]]$namesbestmodel
models[[7]]$namesbestmodel
models[[8]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel
models[[5]]$R2bestmodel
models[[6]]$R2bestmodel
models[[7]]$R2bestmodel
models[[8]]$R2bestmodel

#  R^2 decreases from model 7 to 8 now 
#  I will try a few more models for the algorithm

#  9 # 

modeln<-9

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR3 :nlastvar_LUR3){
  if (is.numeric(Measurements_livestockpreds_LUR3[,i])==TRUE){
    modeltry<-lm(meca~Measurements_livestockpreds_LUR3[,models[[1]]$indexbestmodel]+Measurements_livestockpreds_LUR3[,models[[2]]$indexbestmodel]+Measurements_livestockpreds_LUR3[,models[[3]]$indexbestmodel]+Measurements_livestockpreds_LUR3[,models[[4]]$indexbestmodel]+Measurements_livestockpreds_LUR3[,models[[5]]$indexbestmodel]+ Measurements_livestockpreds_LUR3[,models[[6]]$indexbestmodel]+ Measurements_livestockpreds_LUR3[,models[[7]]$indexbestmodel]+ Measurements_livestockpreds_LUR3[,models[[8]]$indexbestmodel]+ Measurements_livestockpreds_LUR3[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    # find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # Measurements_livestockpreds_LUR3[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR3)[i]
    addedvar<-rbind(addedvar,names(Measurements_livestockpreds_LUR3)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

# this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

# here are the names
models[[modeln]]$namesbestmodel<-c(names(Measurements_livestockpreds_LUR3)[models[[1]]$indexbestmodel], names(Measurements_livestockpreds_LUR3)[models[[2]]$indexbestmodel] , names(Measurements_livestockpreds_LUR3)[models[[3]]$indexbestmodel], names(Measurements_livestockpreds_LUR3)[models[[4]]$indexbestmodel], names(Measurements_livestockpreds_LUR3)[models[[5]]$indexbestmodel], names(Measurements_livestockpreds_LUR3)[models[[6]]$indexbestmodel], names(Measurements_livestockpreds_LUR3)[models[[7]]$indexbestmodel], names(Measurements_livestockpreds_LUR3)[models[[8]]$indexbestmodel], names(Measurements_livestockpreds_LUR3)[models[[9]]$indexbestmodel])

# this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

# this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(meca~Measurements_livestockpreds_LUR3[,models[[1]]$indexbestmodel]+Measurements_livestockpreds_LUR3[,models[[2]]$indexbestmodel]+Measurements_livestockpreds_LUR3[,models[[3]]$indexbestmodel]+ Measurements_livestockpreds_LUR3[,models[[4]]$indexbestmodel]+ Measurements_livestockpreds_LUR3[,models[[5]]$indexbestmodel]+ Measurements_livestockpreds_LUR3[,models[[6]]$indexbestmodel]+ Measurements_livestockpreds_LUR3[,models[[7]]$indexbestmodel]+ Measurements_livestockpreds_LUR3[,models[[8]]$indexbestmodel]+ Measurements_livestockpreds_LUR3[,models[[9]]$indexbestmodel]) 

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[5]]$summarybestmodel
models[[6]]$summarybestmodel
models[[7]]$summarybestmodel
models[[8]]$summarybestmodel
models[[9]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[5]]$namesbestmodel
models[[6]]$namesbestmodel
models[[7]]$namesbestmodel
models[[8]]$namesbestmodel
models[[9]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel
models[[5]]$R2bestmodel
models[[6]]$R2bestmodel
models[[7]]$R2bestmodel
models[[8]]$R2bestmodel
models[[9]]$R2bestmodel

#  at this point I always check whether the next model is more than 1%better than the one before and if not I end here
#  last step is to exclude All var with p>0.1 one by one with the lowest p first, until All <0.1.

#  10 # 
modeln<-10

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR3 :nlastvar_LUR3){
  if (is.numeric(Measurements_livestockpreds_LUR3[,i])==TRUE){
    modeltry<-lm(meca~Measurements_livestockpreds_LUR3[,models[[1]]$indexbestmodel]+Measurements_livestockpreds_LUR3[,models[[2]]$indexbestmodel]+Measurements_livestockpreds_LUR3[,models[[3]]$indexbestmodel]+Measurements_livestockpreds_LUR3[,models[[4]]$indexbestmodel]+Measurements_livestockpreds_LUR3[,models[[5]]$indexbestmodel]+ Measurements_livestockpreds_LUR3[,models[[6]]$indexbestmodel]+ Measurements_livestockpreds_LUR3[,models[[7]]$indexbestmodel]+ Measurements_livestockpreds_LUR3[,models[[8]]$indexbestmodel]+ Measurements_livestockpreds_LUR3[,models[[9]]$indexbestmodel]+ Measurements_livestockpreds_LUR3[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    # find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # Measurements_livestockpreds_LUR3[,i] is the row that's being tried out now. the name of that row can be found in  names(All)[i]
    addedvar<-rbind(addedvar,names(Measurements_livestockpreds_LUR3)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

# this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

# here are the names
models[[modeln]]$namesbestmodel<-c(names(Measurements_livestockpreds_LUR3)[models[[1]]$indexbestmodel], names(Measurements_livestockpreds_LUR3)[models[[2]]$indexbestmodel] , names(Measurements_livestockpreds_LUR3)[models[[3]]$indexbestmodel], names(Measurements_livestockpreds_LUR3)[models[[4]]$indexbestmodel], names(Measurements_livestockpreds_LUR3)[models[[5]]$indexbestmodel], names(Measurements_livestockpreds_LUR3)[models[[6]]$indexbestmodel], names(Measurements_livestockpreds_LUR3)[models[[7]]$indexbestmodel], names(Measurements_livestockpreds_LUR3)[models[[8]]$indexbestmodel], names(Measurements_livestockpreds_LUR3)[models[[9]]$indexbestmodel], names(Measurements_livestockpreds_LUR3)[models[[10]]$indexbestmodel])

# this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

# this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(meca~Measurements_livestockpreds_LUR3[,models[[1]]$indexbestmodel]+Measurements_livestockpreds_LUR3[,models[[2]]$indexbestmodel]+Measurements_livestockpreds_LUR3[,models[[3]]$indexbestmodel]+ Measurements_livestockpreds_LUR3[,models[[4]]$indexbestmodel]+ Measurements_livestockpreds_LUR3[,models[[5]]$indexbestmodel]+ Measurements_livestockpreds_LUR3[,models[[6]]$indexbestmodel]+ Measurements_livestockpreds_LUR3[,models[[7]]$indexbestmodel]+ Measurements_livestockpreds_LUR3[,models[[8]]$indexbestmodel]+ Measurements_livestockpreds_LUR3[,models[[9]]$indexbestmodel]+ Measurements_livestockpreds_LUR3[,models[[10]]$indexbestmodel]) 

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[5]]$summarybestmodel
models[[6]]$summarybestmodel
models[[7]]$summarybestmodel
models[[8]]$summarybestmodel
models[[9]]$summarybestmodel
models[[10]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[5]]$namesbestmodel
models[[6]]$namesbestmodel
models[[7]]$namesbestmodel
models[[8]]$namesbestmodel
models[[9]]$namesbestmodel
models[[10]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel
models[[5]]$R2bestmodel
models[[6]]$R2bestmodel
models[[7]]$R2bestmodel
models[[8]]$R2bestmodel
models[[9]]$R2bestmodel
models[[10]]$R2bestmodel

#  CODE FOR PICKING OUT THE BEST MODEL #  
temp <- 0
besti <- 0
for (i in 1:10){ #  think this runs the loop 10 times - not fully sure thought - but not to do with the number of models I don't think - as when I change to 3, I still get the model with 4 variables as best model
  print(models[[i]]$R2bestmodel)
  #       print(models[[i]]$summarybestmodel$coefficients=-1,4])
  #       if((models[[i]]$R2bestmodel-temp > 0.0) && (all(models[[i]]$summarybestmodel$coefficients[-1,4]<0.1))){
  #         temp <- models[[i]]$R2bestmodel
  #         besti <- i
  #         }
  if((models[[i]]$R2bestmodel-temp > 0.0) && (all(models[[i]]$summarybestmodel$coefficients[-1,4]<0.1))){
    temp <- models[[i]]$R2bestmodel
    besti <- i
  }else{
    finalBestModel <- models[[besti]]$bestmodel
    finalBestModelNames <- models[[besti]]$namesbestmodel
    Sites <- 1:dim(Measurements_livestockpreds_LUR3)[1] # full original model
    #  CVaR2<-escCV_ecoli_LUR3(Sites)[2] # Cross Validation
    maxCD<-max(cooks.distance(finalBestModel))
    if(length(finalBestModelNames)<2){ # vif fn doesnot work when only 1 variable...       # 
      maxVIF<-"NA"
    }else{
      maxVIF<-max(vif(finalBestModel))
    }
    print(paste("This is the best meca LUR model 3: ",besti,
                "(AdjR2: ",format(models[[besti]]$R2bestmodel,digits=3), "; MaxCD: ",format(maxCD,digits=3),"; MaxVIF: ",
                format(maxVIF,digits=3),")", sep=''))
    print(finalBestModelNames)
    break
  }
}

#  the final best model includes the predictors: npoultryWghtDist.3000m.sum.95Win.10to90scaled+ nPigMultipFarmWghtDist.3000m.sum.95Win.10to90scaled+ nhorses.3000m.95Win.10to90scaled
meca_LUR3_algorithmmethod <- lm(meca_copiespm3.ln.diffmeth.mean ~ npoultryWghtDist.3000m.sum.95Win.10to90scaled+ nPigMultipFarmWghtDist.3000m.sum.95Win.10to90scaled+ nhorses.3000m.95Win.10to90scaled, data = Measurements_livestockpreds_LUR3)
summary(meca_LUR3_algorithmmethod)

# Calculate RMSE
predicted_meca_LUR3 <- predict(meca_LUR3_algorithmmethod, Measurements_livestockpreds_LUR3)
RMSE_meca_LUR3 <- sqrt(mean((Measurements_livestockpreds_LUR3$meca_copiespm3.ln.diffmeth.mean - predicted_meca_LUR3)^2))
RMSE_meca_LUR3

#  Save these predicted concentrations along with the measured concentrations as an excel file 
#  Create a dataframe 
meca_LUR3_preds_observed <- data.frame(Measurements_livestockpreds_LUR3$Loc_ID,Measurements_livestockpreds_LUR3$meca_copiespm3.ln.diffmeth.mean, predicted_meca_LUR3)
print(meca_LUR3_preds_observed)

#  Save as xls file 
write_xlsx(meca_LUR3_preds_observed,"Output_files//meca_LUR3_preds_observed.xlsx")

#  MODEL CHECKING # 
#  1)Check normality of residuals 
#  2)Check residuals for linearity, independence and homoscedasticity
#  3)Check multicollinearity (VIF)
#  4)Check influential points (Cook's Distance)

#  1) Normality of residuals
boxplot(residuals(meca_LUR3_algorithmmethod),main="boxplot of residuals - meca LUR model 2",xlab="LUR2 model residuals")
qqnorm(residuals(meca_LUR3_algorithmmethod),main="QQ-plot of residuals - meca LUR model 2",xlab="LUR2 model residuals")

#  2)Check residuals for linearity, independence and homoscedasticity
plot(fitted(meca_LUR3_algorithmmethod),residuals(meca_LUR3_algorithmmethod))

#  3)Check multicollinearity (VIF)
maxvif_meca_LUR3 <- max(vif(meca_LUR3_algorithmmethod))
maxvif_meca_LUR3

#  4)Check influential points (Cook's Distance)
ols_plot_cooksd_bar(meca_LUR3_algorithmmethod, print_plot = TRUE)
maxCD_meca_LUR3<-max(cooks.distance(meca_LUR3_algorithmmethod))
maxCD_meca_LUR3
#  won't remove any outliers - none with cook's d > 1 


#  Make a scatterplot of predicted vs observed values
#  Use training model to predict E. coli concentrations
meca_trainmodel_preds <- predict(meca_LUR3_algorithmmethod,newdata=Measurements_livestockpreds_LUR3)

#  Overall comparison of predicted vs observed
plot(meca_trainmodel_preds, Measurements_livestockpreds_LUR3$meca_copiespm3.ln.diffmeth.mean, xlab="Training model LUR3-predicted meca DNA concentration (ln copies/m^3)", ylab="Observed meca DNA concentration (ln copies/m^3)", cex.lab=0.85)
abline(lm(Measurements_livestockpreds_LUR3$meca_copiespm3.ln.diffmeth.mean ~ meca_trainmodel_preds))
```
# meca LUR3 model - LOOCV
```{r}
#  LOOCV - LUR model 3 for meca (using model with outlier 54 removed)
#  Leave one out cross validation - the goal of cross validation is to get a generalized score of the model. The reason for this generalization is to, hopefully, improve the model’s effectiveness in predicting on future data inputs.
#  It is a type of 'internal' cross validation
Measurements_livestockpreds_LUR3_LOOCV <- Measurements_livestockpreds_LUR3
set.seed(123)
Measurements_livestockpreds_LUR3_LOOCV$meca_LUR3_LOOCV_PRED <- unlist(lapply(1:nrow(Measurements_livestockpreds_LUR3_LOOCV),function(inx){
  train <- Measurements_livestockpreds_LUR3_LOOCV[-inx,,drop=FALSE]
  test <- Measurements_livestockpreds_LUR3_LOOCV[inx,,drop=FALSE] 
  cvm <- lm(meca_copiespm3.ln.diffmeth.mean ~ npoultryWghtDist.3000m.sum.95Win.10to90scaled+ nPigMultipFarmWghtDist.3000m.sum.95Win.10to90scaled+ nhorses.3000m.95Win.10to90scaled, data=train)
  pred <- predict(cvm,newdata=test)
  return(pred)
}))

predicted_meca_LUR3_LOOCV <- Measurements_livestockpreds_LUR3_LOOCV$meca_LUR3_LOOCV_PRED

#  Save these predicted concentrations along with the measured concentrations as an excel file 
#  Create a dataframe 
meca_LUR3_LOOCV_preds_observed <- data.frame(Measurements_livestockpreds_LUR3_LOOCV$Loc_ID, Measurements_livestockpreds_LUR3_LOOCV$meca_copiespm3.ln.diffmeth.mean, Measurements_livestockpreds_LUR3_LOOCV$meca_LUR3_LOOCV_PRED)
print(meca_LUR3_LOOCV_preds_observed)

#  Save as xls file 
write_xlsx(meca_LUR3_LOOCV_preds_observed,"Output_files//meca_LUR3_LOOCV_preds_observed.xlsx")

# Compute the LOOCV model R2
meca_LUR3_LOOCV_lm <- lm(meca_copiespm3.ln.diffmeth.mean ~ meca_LUR3_LOOCV_PRED, data=Measurements_livestockpreds_LUR3_LOOCV)
summary(meca_LUR3_LOOCV_lm)
#  meca LUR3 model LOOCV multiple R^2 = 0.4017

# Calculate RMSE
preds_meca_LUR3_LOOCV <- predict(meca_LUR3_LOOCV_lm, Measurements_livestockpreds_LUR3_LOOCV)
RMSE_meca_LUR3_LOOCV <- sqrt(mean((Measurements_livestockpreds_LUR3_LOOCV$meca_copiespm3.ln.diffmeth.mean - preds_meca_LUR3_LOOCV)^2))
RMSE_meca_LUR3_LOOCV

#  Plot LOOCV estimations vs. observed concentrations
plot(Measurements_livestockpreds_LUR3_LOOCV$meca_LUR3_LOOCV_PRED, Measurements_livestockpreds_LUR3_LOOCV$meca_copiespm3.ln.diffmeth.mean)
abline(lm(Measurements_livestockpreds_LUR3_LOOCV$meca_copiespm3.ln.diffmeth.mean ~ Measurements_livestockpreds_LUR3_LOOCV$meca_LUR3_LOOCV_PRED))
```
#  mecA LUR3 - 10-fold CV 
```{r}

options(stringsAsFactors = FALSE) # so that dataframes are not opened in new tabs

# This is the required dataset  
Measurements_livestockpreds_LUR3

#  10-fold hold-out validation is done to assess model robustness. This is done using a random selection of 90% of the measurement sites. 
#  Part 1. Each measurement site gets randomly allocated number out of range 1-10
#  Completely randomly pulling sites
mecA_HV_LUR3_df <- Measurements_livestockpreds_LUR3[c(1,5,6:138)] #  new df created with only mecA values 
#  Create valID variable 
mecA_HV_LUR3_df$valID <- 0
#  Draw 10 samples, thus on average 6 sites per test set (i.e 6 sites are removed from each model and then the model is tested on these 6 sites )
set.seed(123)
VGOB1_FINAL_mecA <- c()
for (s in 1:1){
  if (s==1) set <- mecA_HV_LUR3_df
  draws <- c(1:nrow(set))
  chosen <- c()
  tempdraws <- draws
  for (d in 1:10){
    list <- sample(tempdraws, length(tempdraws)/(11-d), FALSE)
    set[list,]$valID <- d
    chosen <- c(chosen, list)
    tempdraws <- draws[-chosen]
  }

#  Combine datasets to 1
VGOB1_FINAL_mecA <- set
}

summary(set)
rm(set)

#  View the df created
str(VGOB1_FINAL_mecA, list.len=ncol(VGOB1_FINAL_mecA))
names(VGOB1_FINAL_mecA)
summary(VGOB1_FINAL_mecA)

#  Part 2: Make 10 subsets of dataset based on randomly allocated number (so these are the training datasets) 
#  Then create 10 subsets, each excluding 1 set of 10 sites
VGOB1_subsetA_mecA_LUR3 <- subset(VGOB1_FINAL_mecA, valID != 1)
VGOB1_subsetB_mecA_LUR3 <- subset(VGOB1_FINAL_mecA, valID != 2)  
VGOB1_subsetC_mecA_LUR3 <- subset(VGOB1_FINAL_mecA, valID != 3)
VGOB1_subsetD_mecA_LUR3 <- subset(VGOB1_FINAL_mecA, valID != 4)
VGOB1_subsetE_mecA_LUR3 <- subset(VGOB1_FINAL_mecA, valID != 5)
VGOB1_subsetF_mecA_LUR3 <- subset(VGOB1_FINAL_mecA, valID != 6)
VGOB1_subsetG_mecA_LUR3 <- subset(VGOB1_FINAL_mecA, valID != 7)
VGOB1_subsetH_mecA_LUR3 <- subset(VGOB1_FINAL_mecA, valID != 8)
VGOB1_subsetI_mecA_LUR3 <- subset(VGOB1_FINAL_mecA, valID != 9)
VGOB1_subsetJ_mecA_LUR3 <- subset(VGOB1_FINAL_mecA, valID != 10)


#  Part 3: Build for each subset a LUR model (i.e. go through the whole LUR model script for each subset (so each training set). Start with subset A, until final LUR model. Then subset B, until final LUR model etc.) 

#### A ####
# LUR model building process for subset A
#  This is the dataframe with the relevant predictor vars for LUR3 models for subset A (55 sites)
VGOB1_subsetA_mecA_LUR3 # n.b. this dataframe only includes microbial marker concentrations for mecA unlike the dataframe Measurements_livestockpreds_LUR3 as previously used for the model building. 

#  Now set the values of some variables that will be needed
nfirstvar_LUR_3 <- 3  
nlastvar_LUR_3 <- 135

# Function building to run the models 
# 1 #  

models<-list()
modeln<-1
models[[modeln]]<-list()

R2<-1
betaaddedvar<-1
addedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_3:nlastvar_LUR_3){
  if (is.numeric(VGOB1_subsetA_mecA_LUR3[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetA_mecA_LUR3$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetA_mecA_LUR3[,i])                            
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    #  Measurements_livestockpreds_LUR3[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR3)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetA_mecA_LUR3)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)
models[[modeln]]$results

#  this are the candidates models with the highest R2, not a negative beta for the new, nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)
models[[modeln]]$resultspos

#  rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))
models[[modeln]]$resultspos

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j
models[[modeln]]$indexbestmodel

subset(models[[modeln]]$resultspos, rank==1)
subset(models[[modeln]]$resultspos)

#  this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]
models[[modeln]]$summarybestmodel

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetA_mecA_LUR3)[models[[1]]$indexbestmodel])
models[[modeln]]$namesbestmodel

#  this is the r2 of that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2
models[[modeln]]$R2bestmodel

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetA_mecA_LUR3$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetA_mecA_LUR3[,models[[1]]$indexbestmodel]) 
models[[modeln]]$bestmodel

summary(models[[modeln]]$bestmodel)

#  The first model includes the predictor: nPigMultipFarmWghtDist.3000m.sum.Tr.1P9 - meaning the number of multiplier pig farms weighted to distance in a 3000m buffer

# 2 #  
# Add 2nd variable (the only difference of the above part is that now modeln=2 the model statement has 2 variables)
# and the call for the list of variable names in the model changed slightly

modeln<-2

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_3:nlastvar_LUR_3){
  if (is.numeric(VGOB1_subsetA_mecA_LUR3[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetA_mecA_LUR3$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetA_mecA_LUR3[,models[[1]]$indexbestmodel]+ VGOB1_subsetA_mecA_LUR3[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # Measurements_livestockpreds_LUR3[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR3)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetA_mecA_LUR3)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  these are the candidate models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)
models[[modeln]]$resultspos

#  rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))
models[[modeln]]$resultspos

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j
models[[modeln]]$indexbestmodel

subset(models[[modeln]]$resultspos, rank==1)

# this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]
models[[modeln]]$summarybestmodel

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetA_mecA_LUR3)[models[[1]]$indexbestmodel], names(VGOB1_subsetA_mecA_LUR3)[models[[2]]$indexbestmodel] )
models[[modeln]]$namesbestmodel

# this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2
models[[modeln]]$R2bestmodel

# this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetA_mecA_LUR3$meca_copiespm3.ln.diffmeth.mean~                               VGOB1_subsetA_mecA_LUR3[,models[[1]]$indexbestmodel]+                           VGOB1_subsetA_mecA_LUR3[,models[[2]]$indexbestmodel]) 

models[[modeln]]$bestmodel

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel


# 3 #  
# add third variable (the only difference of the above part is that now modeln=3 the model statement has 3 variables)
# and the call for the list of variable names in the model changed slightly

modeln<-3

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_3:nlastvar_LUR_3){
  if (is.numeric(VGOB1_subsetA_mecA_LUR3[,i])==TRUE){  
    modeltry<-lm(VGOB1_subsetA_mecA_LUR3$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetA_mecA_LUR3[,models[[1]]$indexbestmodel]+VGOB1_subsetA_mecA_LUR3[,models[[2]]$indexbestmodel]+ VGOB1_subsetA_mecA_LUR3[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # All[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR3)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetA_mecA_LUR3)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

#  rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

#  this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

#  here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetA_mecA_LUR3)[models[[1]]$indexbestmodel], names(VGOB1_subsetA_mecA_LUR3)[models[[2]]$indexbestmodel], names(VGOB1_subsetA_mecA_LUR3)[models[[3]]$indexbestmodel])

#  this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetA_mecA_LUR3$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetA_mecA_LUR3[,models[[1]]$indexbestmodel]+ VGOB1_subsetA_mecA_LUR3[,models[[2]]$indexbestmodel]+ VGOB1_subsetA_mecA_LUR3[,models[[3]]$indexbestmodel]) 

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel


# 4 #  
#  add forth variable (the only difference of the above part is that now model n=4 the model statement more variables)
#  and the call for the list of variable names in the model changed slightly
modeln<-4

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1


for (i in nfirstvar_LUR_3:nlastvar_LUR_3){
  if (is.numeric(VGOB1_subsetA_mecA_LUR3[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetA_mecA_LUR3$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetA_mecA_LUR3[,models[[1]]$indexbestmodel]+VGOB1_subsetA_mecA_LUR3[,models[[2]]$indexbestmodel]+VGOB1_subsetA_mecA_LUR3[,models[[3]]$indexbestmodel]+VGOB1_subsetA_mecA_LUR3[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    #  the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    #  All[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR3)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetA_mecA_LUR3)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

#  this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

#  here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetA_mecA_LUR3)[models[[1]]$indexbestmodel], names(VGOB1_subsetA_mecA_LUR3)[models[[2]]$indexbestmodel], names(VGOB1_subsetA_mecA_LUR3)[models[[3]]$indexbestmodel], names(VGOB1_subsetA_mecA_LUR3)[models[[4]]$indexbestmodel])

#  this is the r2 of that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetA_mecA_LUR3$meca_copiespm3.ln.diffmeth.mean~ VGOB1_subsetA_mecA_LUR3[,models[[1]]$indexbestmodel]+ VGOB1_subsetA_mecA_LUR3[,models[[2]]$indexbestmodel]+VGOB1_subsetA_mecA_LUR3[,models[[3]]$indexbestmodel]+ VGOB1_subsetA_mecA_LUR3[,models[[4]]$indexbestmodel]) 


models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel


# 5 #  
# add fifth variable (the only difference of the above part is that now modeln=5 the model statement more variables)
# and the call for the list of variable names in the model changed slightly
modeln<-5

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_3:nlastvar_LUR_3){
  if (is.numeric(VGOB1_subsetA_mecA_LUR3[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetA_mecA_LUR3$meca_copiespm3.ln.diffmeth.mean~ VGOB1_subsetA_mecA_LUR3[,models[[1]]$indexbestmodel]+ VGOB1_subsetA_mecA_LUR3[,models[[2]]$indexbestmodel]+ VGOB1_subsetA_mecA_LUR3[,models[[3]]$indexbestmodel]+ VGOB1_subsetA_mecA_LUR3[,models[[4]]$indexbestmodel]+ VGOB1_subsetA_mecA_LUR3[,i]) 
  
R2<-rbind(R2,summary(modeltry)$adj.r.squared)
# the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # All[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR3)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetA_mecA_LUR3)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

#  this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetA_mecA_LUR3)[models[[1]]$indexbestmodel], names(VGOB1_subsetA_mecA_LUR3)[models[[2]]$indexbestmodel], names(VGOB1_subsetA_mecA_LUR3)[models[[3]]$indexbestmodel], names(VGOB1_subsetA_mecA_LUR3)[models[[4]]$indexbestmodel], names(VGOB1_subsetA_mecA_LUR3)[models[[5]]$indexbestmodel])

#  this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetA_mecA_LUR3$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetA_mecA_LUR3[,models[[1]]$indexbestmodel]+VGOB1_subsetA_mecA_LUR3[,models[[2]]$indexbestmodel]+VGOB1_subsetA_mecA_LUR3[,models[[3]]$indexbestmodel]+ VGOB1_subsetA_mecA_LUR3[,models[[4]]$indexbestmodel]+ VGOB1_subsetA_mecA_LUR3[,models[[5]]$indexbestmodel]) 
models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[5]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[5]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel
models[[5]]$R2bestmodel

# 6 #  
# add sixth variable (the only difference of the above part is that now model n=6 the model statement more variables)
#  and the call for the list of variable names in the model changed slightly

modeln<-6

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_3 :nlastvar_LUR_3){
  if (is.numeric(VGOB1_subsetA_mecA_LUR3[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetA_mecA_LUR3$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetA_mecA_LUR3[,models[[1]]$indexbestmodel]+VGOB1_subsetA_mecA_LUR3[,models[[2]]$indexbestmodel]+VGOB1_subsetA_mecA_LUR3[,models[[3]]$indexbestmodel]+VGOB1_subsetA_mecA_LUR3[,models[[4]]$indexbestmodel]+VGOB1_subsetA_mecA_LUR3[,models[[5]]$indexbestmodel]+ VGOB1_subsetA_mecA_LUR3[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # All[,i] is the row that's being tried out now. the name of that row can be found in  names(All)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetA_mecA_LUR3)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

# this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetA_mecA_LUR3)[models[[1]]$indexbestmodel], names(VGOB1_subsetA_mecA_LUR3)[models[[2]]$indexbestmodel] , names(VGOB1_subsetA_mecA_LUR3)[models[[3]]$indexbestmodel], names(VGOB1_subsetA_mecA_LUR3)[models[[4]]$indexbestmodel], names(VGOB1_subsetA_mecA_LUR3)[models[[5]]$indexbestmodel], names(VGOB1_subsetA_mecA_LUR3)[models[[6]]$indexbestmodel])

#  this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetA_mecA_LUR3$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetA_mecA_LUR3[,models[[1]]$indexbestmodel]+VGOB1_subsetA_mecA_LUR3[,models[[2]]$indexbestmodel]+VGOB1_subsetA_mecA_LUR3[,models[[3]]$indexbestmodel]+ VGOB1_subsetA_mecA_LUR3[,models[[4]]$indexbestmodel]+ VGOB1_subsetA_mecA_LUR3[,models[[5]]$indexbestmodel]+ VGOB1_subsetA_mecA_LUR3[,models[[6]]$indexbestmodel]) 

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[5]]$summarybestmodel
models[[6]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[5]]$namesbestmodel
models[[6]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel
models[[5]]$R2bestmodel
models[[6]]$R2bestmodel


# 7 #  
# add seventh variable (the only difference of the above part is that now model n=7 the model statement more variables)
#  and the call for the list of variable names in the model changed slightly

modeln<-7

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_3 :nlastvar_LUR_3){
  if (is.numeric(VGOB1_subsetA_mecA_LUR3[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetA_mecA_LUR3$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetA_mecA_LUR3[,models[[1]]$indexbestmodel]+VGOB1_subsetA_mecA_LUR3[,models[[2]]$indexbestmodel]+VGOB1_subsetA_mecA_LUR3[,models[[3]]$indexbestmodel]+VGOB1_subsetA_mecA_LUR3[,models[[4]]$indexbestmodel]+VGOB1_subsetA_mecA_LUR3[,models[[5]]$indexbestmodel]+VGOB1_subsetA_mecA_LUR3[,models[[6]]$indexbestmodel]+ VGOB1_subsetA_mecA_LUR3[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # Measurements_livestockpreds_LUR3[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR3)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetA_mecA_LUR3)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

# this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetA_mecA_LUR3)[models[[1]]$indexbestmodel], names(VGOB1_subsetA_mecA_LUR3)[models[[2]]$indexbestmodel] , names(VGOB1_subsetA_mecA_LUR3)[models[[3]]$indexbestmodel], names(VGOB1_subsetA_mecA_LUR3)[models[[4]]$indexbestmodel], names(VGOB1_subsetA_mecA_LUR3)[models[[5]]$indexbestmodel], names(VGOB1_subsetA_mecA_LUR3)[models[[6]]$indexbestmodel], names(VGOB1_subsetA_mecA_LUR3)[models[[7]]$indexbestmodel])

#  this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetA_mecA_LUR3$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetA_mecA_LUR3[,models[[1]]$indexbestmodel]+VGOB1_subsetA_mecA_LUR3[,models[[2]]$indexbestmodel]+VGOB1_subsetA_mecA_LUR3[,models[[3]]$indexbestmodel]+ VGOB1_subsetA_mecA_LUR3[,models[[4]]$indexbestmodel]+ VGOB1_subsetA_mecA_LUR3[,models[[5]]$indexbestmodel]+ VGOB1_subsetA_mecA_LUR3[,models[[6]]$indexbestmodel]+ VGOB1_subsetA_mecA_LUR3[,models[[7]]$indexbestmodel]) 

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[5]]$summarybestmodel
models[[6]]$summarybestmodel
models[[7]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[5]]$namesbestmodel
models[[6]]$namesbestmodel
models[[7]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel
models[[5]]$R2bestmodel
models[[6]]$R2bestmodel
models[[7]]$R2bestmodel

# 8 #  
# add eighth variable (the only difference of the above part is that now modeln=7 the model statement more variables)
# and the call for the list of variable names in the model changed slightly

modeln<-8

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_3 :nlastvar_LUR_3){
  if (is.numeric(VGOB1_subsetA_mecA_LUR3[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetA_mecA_LUR3$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetA_mecA_LUR3[,models[[1]]$indexbestmodel]+VGOB1_subsetA_mecA_LUR3[,models[[2]]$indexbestmodel]+VGOB1_subsetA_mecA_LUR3[,models[[3]]$indexbestmodel]+VGOB1_subsetA_mecA_LUR3[,models[[4]]$indexbestmodel]+VGOB1_subsetA_mecA_LUR3[,models[[5]]$indexbestmodel]+VGOB1_subsetA_mecA_LUR3[,models[[6]]$indexbestmodel]+ VGOB1_subsetA_mecA_LUR3[,models[[7]]$indexbestmodel]+ VGOB1_subsetA_mecA_LUR3[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # Measurements_livestockpreds_LUR3[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR3)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetA_mecA_LUR3)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

# this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetA_mecA_LUR3)[models[[1]]$indexbestmodel], names(VGOB1_subsetA_mecA_LUR3)[models[[2]]$indexbestmodel] , names(VGOB1_subsetA_mecA_LUR3)[models[[3]]$indexbestmodel], names(VGOB1_subsetA_mecA_LUR3)[models[[4]]$indexbestmodel], names(VGOB1_subsetA_mecA_LUR3)[models[[5]]$indexbestmodel], names(VGOB1_subsetA_mecA_LUR3)[models[[6]]$indexbestmodel], names(VGOB1_subsetA_mecA_LUR3)[models[[7]]$indexbestmodel], names(VGOB1_subsetA_mecA_LUR3)[models[[8]]$indexbestmodel])

#  this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetA_mecA_LUR3$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetA_mecA_LUR3[,models[[1]]$indexbestmodel]+VGOB1_subsetA_mecA_LUR3[,models[[2]]$indexbestmodel]+VGOB1_subsetA_mecA_LUR3[,models[[3]]$indexbestmodel]+ VGOB1_subsetA_mecA_LUR3[,models[[4]]$indexbestmodel]+ VGOB1_subsetA_mecA_LUR3[,models[[5]]$indexbestmodel]+ VGOB1_subsetA_mecA_LUR3[,models[[6]]$indexbestmodel]+ VGOB1_subsetA_mecA_LUR3[,models[[7]]$indexbestmodel]+ VGOB1_subsetA_mecA_LUR3[,models[[8]]$indexbestmodel]) 

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[5]]$summarybestmodel
models[[6]]$summarybestmodel
models[[7]]$summarybestmodel
models[[8]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[5]]$namesbestmodel
models[[6]]$namesbestmodel
models[[7]]$namesbestmodel
models[[8]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel
models[[5]]$R2bestmodel
models[[6]]$R2bestmodel
models[[7]]$R2bestmodel
models[[8]]$R2bestmodel

# 9 #  
# add ninth variable (the only difference of the above part is that now modeln=9 the model statement more variables)
# and the call for the list of variable names in the model changed slightly

modeln<-9

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_3 :nlastvar_LUR_3){
  if (is.numeric(VGOB1_subsetA_mecA_LUR3[,i])==TRUE){
      modeltry<-lm(VGOB1_subsetA_mecA_LUR3$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetA_mecA_LUR3[,models[[1]]$indexbestmodel]+VGOB1_subsetA_mecA_LUR3[,models[[2]]$indexbestmodel]+VGOB1_subsetA_mecA_LUR3[,models[[3]]$indexbestmodel]+VGOB1_subsetA_mecA_LUR3[,models[[4]]$indexbestmodel]+VGOB1_subsetA_mecA_LUR3[,models[[5]]$indexbestmodel]+VGOB1_subsetA_mecA_LUR3[,models[[6]]$indexbestmodel]+ VGOB1_subsetA_mecA_LUR3[,models[[7]]$indexbestmodel]+ VGOB1_subsetA_mecA_LUR3[,models[[8]]$indexbestmodel]+ VGOB1_subsetA_mecA_LUR3[,i]) 
        R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # Measurements_livestockpreds_LUR3[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR3)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetA_mecA_LUR3)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

# this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetA_mecA_LUR3)[models[[1]]$indexbestmodel], names(VGOB1_subsetA_mecA_LUR3)[models[[2]]$indexbestmodel] , names(VGOB1_subsetA_mecA_LUR3)[models[[3]]$indexbestmodel], names(VGOB1_subsetA_mecA_LUR3)[models[[4]]$indexbestmodel], names(VGOB1_subsetA_mecA_LUR3)[models[[5]]$indexbestmodel], names(VGOB1_subsetA_mecA_LUR3)[models[[6]]$indexbestmodel], names(VGOB1_subsetA_mecA_LUR3)[models[[7]]$indexbestmodel], names(VGOB1_subsetA_mecA_LUR3)[models[[8]]$indexbestmodel],  names(VGOB1_subsetA_mecA_LUR3)[models[[9]]$indexbestmodel])

#  this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetA_mecA_LUR3$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetA_mecA_LUR3[,models[[1]]$indexbestmodel]+VGOB1_subsetA_mecA_LUR3[,models[[2]]$indexbestmodel]+VGOB1_subsetA_mecA_LUR3[,models[[3]]$indexbestmodel]+ VGOB1_subsetA_mecA_LUR3[,models[[4]]$indexbestmodel]+ VGOB1_subsetA_mecA_LUR3[,models[[5]]$indexbestmodel]+ VGOB1_subsetA_mecA_LUR3[,models[[6]]$indexbestmodel]+ VGOB1_subsetA_mecA_LUR3[,models[[7]]$indexbestmodel]+ VGOB1_subsetA_mecA_LUR3[,models[[8]]$indexbestmodel]+ VGOB1_subsetA_mecA_LUR3[,models[[9]]$indexbestmodel]) 

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[5]]$summarybestmodel
models[[6]]$summarybestmodel
models[[7]]$summarybestmodel
models[[8]]$summarybestmodel
models[[9]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[5]]$namesbestmodel
models[[6]]$namesbestmodel
models[[7]]$namesbestmodel
models[[8]]$namesbestmodel
models[[9]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel
models[[5]]$R2bestmodel
models[[6]]$R2bestmodel
models[[7]]$R2bestmodel
models[[8]]$R2bestmodel
models[[9]]$R2bestmodel

# 10 #  
#  add tenth variable (the only difference of the above part is that now model n=10 the model statement more variables)
#  and the call for the list of variable names in the model changed slightly

modeln<-10

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_3 :nlastvar_LUR_3){if (is.numeric(VGOB1_subsetA_mecA_LUR3[,i])==TRUE){ modeltry<-lm(VGOB1_subsetA_mecA_LUR3$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetA_mecA_LUR3[,models[[1]]$indexbestmodel]+VGOB1_subsetA_mecA_LUR3[,models[[2]]$indexbestmodel]+ VGOB1_subsetA_mecA_LUR3[,models[[3]]$indexbestmodel]+VGOB1_subsetA_mecA_LUR3[,models[[4]]$indexbestmodel]+ VGOB1_subsetA_mecA_LUR3[,models[[5]]$indexbestmodel]+ VGOB1_subsetA_mecA_LUR3[,models[[6]]$indexbestmodel]+ VGOB1_subsetA_mecA_LUR3[,models[[7]]$indexbestmodel]+ VGOB1_subsetA_mecA_LUR3[,models[[8]]$indexbestmodel]+ VGOB1_subsetA_mecA_LUR3[,models[[9]]$indexbestmodel]+ VGOB1_subsetA_mecA_LUR3[,i]) 

R2<-rbind(R2,summary(modeltry)$adj.r.squared)
# the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # Measurements_livestockpreds_LUR3[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR3)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetA_mecA_LUR3)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

# this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

# here are the names
models[[modeln]]$namesbestmodel<-c( names(VGOB1_subsetA_mecA_LUR3)[models[[1]]$indexbestmodel],                   names(VGOB1_subsetA_mecA_LUR3)[models[[2]]$indexbestmodel] , names(VGOB1_subsetA_mecA_LUR3)[models[[3]]$indexbestmodel], names(VGOB1_subsetA_mecA_LUR3)[models[[4]]$indexbestmodel], names(VGOB1_subsetA_mecA_LUR3)[models[[5]]$indexbestmodel], names(VGOB1_subsetA_mecA_LUR3)[models[[6]]$indexbestmodel], names(VGOB1_subsetA_mecA_LUR3)[models[[7]]$indexbestmodel], names(VGOB1_subsetA_mecA_LUR3)[models[[8]]$indexbestmodel], names(VGOB1_subsetA_mecA_LUR3)[models[[9]]$indexbestmodel], names(VGOB1_subsetA_mecA_LUR3)[models[[10]]$indexbestmodel])

#  this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetA_mecA_LUR3$meca_copiespm3.ln.diffmeth.mean~                                VGOB1_subsetA_mecA_LUR3[,models[[1]]$indexbestmodel]+ VGOB1_subsetA_mecA_LUR3[,models[[2]]$indexbestmodel]+                           VGOB1_subsetA_mecA_LUR3[,models[[3]]$indexbestmodel]+ VGOB1_subsetA_mecA_LUR3[,models[[4]]$indexbestmodel]+ VGOB1_subsetA_mecA_LUR3[,models[[5]]$indexbestmodel]+ VGOB1_subsetA_mecA_LUR3[,models[[6]]$indexbestmodel]+ VGOB1_subsetA_mecA_LUR3[,models[[7]]$indexbestmodel]+ VGOB1_subsetA_mecA_LUR3[,models[[8]]$indexbestmodel]+ VGOB1_subsetA_mecA_LUR3[,models[[9]]$indexbestmodel]+ VGOB1_subsetA_mecA_LUR3[,models[[10]]$indexbestmodel]) 

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[5]]$summarybestmodel
models[[6]]$summarybestmodel
models[[7]]$summarybestmodel
models[[8]]$summarybestmodel
models[[9]]$summarybestmodel
models[[10]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[5]]$namesbestmodel
models[[6]]$namesbestmodel
models[[7]]$namesbestmodel
models[[8]]$namesbestmodel
models[[9]]$namesbestmodel
models[[10]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel
models[[5]]$R2bestmodel
models[[6]]$R2bestmodel
models[[7]]$R2bestmodel
models[[8]]$R2bestmodel
models[[9]]$R2bestmodel
models[[10]]$R2bestmodel

#  at this point I always check whether the next model is more than 1% better than the one before and if not I end here

#   CODE FOR PICKING OUT THE BEST MODEL #   
temp <- 0
besti <- 0
for (i in 1:10){ #  think this runs the loop 10 times - not fully sure thought - but not to do with the number of models I don't think - as when I change to 3, I still get the model with 4 variables as best model
  print(models[[i]]$R2bestmodel)
  #       print(models[[i]]$summarybestmodel$coefficients=-1,4])
  #       if((models[[i]]$R2bestmodel-temp > 0.0) && (all(models[[i]]$summarybestmodel$coefficients[-1,4]<0.1))){
  #         temp <- models[[i]]$R2bestmodel
  #         besti <- i
  #         }
  if((models[[i]]$R2bestmodel-temp > 0.0) && (all(models[[i]]$summarybestmodel$coefficients[-1,4]<0.1))){
    temp <- models[[i]]$R2bestmodel
    besti <- i
  }else{
    finalBestModel_mecA_subsetA <- models[[besti]]$bestmodel
    finalBestModelNames_mecA_subsetA <- models[[besti]]$namesbestmodel
    Sites <- 1:dim(VGOB1_subsetA_mecA_LUR3)[1] # full original model
    #  CVaR2<-escCV_mecA_LUR3(Sites)[2] # Cross Validation
    maxCD<-max(cooks.distance(finalBestModel_mecA_subsetA))
    if(length(finalBestModelNames_mecA_subsetA)<2){ # vif fn doesnot work when only 1 variable...       # 
      maxVIF<-"NA"
    }else{
      maxVIF<-max(vif(finalBestModel_mecA_subsetA))
    }
    print(paste("This is the best mecA model for subset A: ",besti,
                "(AdjR2: ",format(models[[besti]]$R2bestmodel,digits=3), "; MaxCD: ",format(maxCD,digits=3),"; MaxVIF: ",
                format(maxVIF,digits=3),")", sep=''))
    print(finalBestModelNames_mecA_subsetA)
    break
  }
}

#  Overview of the final best model using the algorithm selection process (taking into account VIF, R^2, and p-values)
finalBestModel_mecA_subsetA 
finalBestModelNames_mecA_subsetA
models[[besti]]$summarybestmodel
models[[besti]]$R2bestmodel

#### B ####
# LUR model building process for subset B
# This is the dataframe with the relevant predictor vars for LUR3 models for subset B (55 sites)
VGOB1_subsetB_mecA_LUR3 # n.b. this dataframe only includes microbial marker concentrations for mecA unlike the dataframe Measurements_livestockpreds_LUR3 as previously used for the model building. 

#  Now set the values of some variables that will be needed
nfirstvar_LUR_3 <- 3  
nlastvar_LUR_3 <- 135

# Function building to run the models 
# 1 #  

models<-list()
modeln<-1
models[[modeln]]<-list()

R2<-1
betaaddedvar<-1
addedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_3:nlastvar_LUR_3){
  if (is.numeric(VGOB1_subsetB_mecA_LUR3[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetB_mecA_LUR3$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetB_mecA_LUR3[,i])                            
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    #  Measurements_livestockpreds_LUR3[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR3)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetB_mecA_LUR3)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)
models[[modeln]]$results

#  this are the candidates models with the highest R2, not a negative beta for the new, nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)
models[[modeln]]$resultspos

#  rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))
models[[modeln]]$resultspos

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j
models[[modeln]]$indexbestmodel

subset(models[[modeln]]$resultspos, rank==1)
subset(models[[modeln]]$resultspos)

#  this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]
models[[modeln]]$summarybestmodel

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetB_mecA_LUR3)[models[[1]]$indexbestmodel])
models[[modeln]]$namesbestmodel

#  this is the r2 of that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2
models[[modeln]]$R2bestmodel

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetB_mecA_LUR3$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetB_mecA_LUR3[,models[[1]]$indexbestmodel]) 
models[[modeln]]$bestmodel

summary(models[[modeln]]$bestmodel)

#  The first model includes the predictor: nPigMultipFarmWghtDist.3000m.sum.Tr.1P9 - meaning the number of multiplier pig farms weighted to distance in a 3000m buffer

# 2 #  
# Add 2nd variable (the only difference of the above part is that now modeln=2 the model statement has 2 variables)
# and the call for the list of variable names in the model changed slightly

modeln<-2

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_3:nlastvar_LUR_3){
  if (is.numeric(VGOB1_subsetB_mecA_LUR3[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetB_mecA_LUR3$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetB_mecA_LUR3[,models[[1]]$indexbestmodel]+ VGOB1_subsetB_mecA_LUR3[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # Measurements_livestockpreds_LUR3[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR3)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetB_mecA_LUR3)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  these are the candidate models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)
models[[modeln]]$resultspos

#  rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))
models[[modeln]]$resultspos

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j
models[[modeln]]$indexbestmodel

subset(models[[modeln]]$resultspos, rank==1)

# this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]
models[[modeln]]$summarybestmodel

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetB_mecA_LUR3)[models[[1]]$indexbestmodel], names(VGOB1_subsetB_mecA_LUR3)[models[[2]]$indexbestmodel] )
models[[modeln]]$namesbestmodel

# this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2
models[[modeln]]$R2bestmodel

# this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetB_mecA_LUR3$meca_copiespm3.ln.diffmeth.mean~                               VGOB1_subsetB_mecA_LUR3[,models[[1]]$indexbestmodel]+                           VGOB1_subsetB_mecA_LUR3[,models[[2]]$indexbestmodel]) 

models[[modeln]]$bestmodel

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel


# 3 #  
# add third variable (the only difference of the above part is that now modeln=3 the model statement has 3 variables)
# and the call for the list of variable names in the model changed slightly

modeln<-3

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_3:nlastvar_LUR_3){
  if (is.numeric(VGOB1_subsetB_mecA_LUR3[,i])==TRUE){  
    modeltry<-lm(VGOB1_subsetB_mecA_LUR3$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetB_mecA_LUR3[,models[[1]]$indexbestmodel]+VGOB1_subsetB_mecA_LUR3[,models[[2]]$indexbestmodel]+ VGOB1_subsetB_mecA_LUR3[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # All[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR3)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetB_mecA_LUR3)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

#  rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

#  this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

#  here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetB_mecA_LUR3)[models[[1]]$indexbestmodel], names(VGOB1_subsetB_mecA_LUR3)[models[[2]]$indexbestmodel], names(VGOB1_subsetB_mecA_LUR3)[models[[3]]$indexbestmodel])

#  this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetB_mecA_LUR3$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetB_mecA_LUR3[,models[[1]]$indexbestmodel]+ VGOB1_subsetB_mecA_LUR3[,models[[2]]$indexbestmodel]+ VGOB1_subsetB_mecA_LUR3[,models[[3]]$indexbestmodel]) 

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel


# 4 #  
#  add forth variable (the only difference of the above part is that now model n=4 the model statement more variables)
#  and the call for the list of variable names in the model changed slightly
modeln<-4

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1


for (i in nfirstvar_LUR_3:nlastvar_LUR_3){
  if (is.numeric(VGOB1_subsetB_mecA_LUR3[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetB_mecA_LUR3$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetB_mecA_LUR3[,models[[1]]$indexbestmodel]+VGOB1_subsetB_mecA_LUR3[,models[[2]]$indexbestmodel]+VGOB1_subsetB_mecA_LUR3[,models[[3]]$indexbestmodel]+VGOB1_subsetB_mecA_LUR3[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    #  the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    #  All[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR3)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetB_mecA_LUR3)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

#  this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

#  here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetB_mecA_LUR3)[models[[1]]$indexbestmodel], names(VGOB1_subsetB_mecA_LUR3)[models[[2]]$indexbestmodel], names(VGOB1_subsetB_mecA_LUR3)[models[[3]]$indexbestmodel], names(VGOB1_subsetB_mecA_LUR3)[models[[4]]$indexbestmodel])

#  this is the r2 of that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetB_mecA_LUR3$meca_copiespm3.ln.diffmeth.mean~ VGOB1_subsetB_mecA_LUR3[,models[[1]]$indexbestmodel]+ VGOB1_subsetB_mecA_LUR3[,models[[2]]$indexbestmodel]+ VGOB1_subsetB_mecA_LUR3[,models[[3]]$indexbestmodel]+ VGOB1_subsetB_mecA_LUR3[,models[[4]]$indexbestmodel]) 


models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel


# 5 #  
# add fifth variable (the only difference of the above part is that now modeln=5 the model statement more variables)
# and the call for the list of variable names in the model changed slightly
modeln<-5

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_3:nlastvar_LUR_3){
  if (is.numeric(VGOB1_subsetB_mecA_LUR3[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetB_mecA_LUR3$meca_copiespm3.ln.diffmeth.mean~ VGOB1_subsetB_mecA_LUR3[,models[[1]]$indexbestmodel]+ VGOB1_subsetB_mecA_LUR3[,models[[2]]$indexbestmodel]+ VGOB1_subsetB_mecA_LUR3[,models[[3]]$indexbestmodel]+ VGOB1_subsetB_mecA_LUR3[,models[[4]]$indexbestmodel]+ VGOB1_subsetB_mecA_LUR3[,i]) 
  
R2<-rbind(R2,summary(modeltry)$adj.r.squared)
# the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # All[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR3)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetB_mecA_LUR3)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

#  this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetB_mecA_LUR3)[models[[1]]$indexbestmodel], names(VGOB1_subsetB_mecA_LUR3)[models[[2]]$indexbestmodel], names(VGOB1_subsetB_mecA_LUR3)[models[[3]]$indexbestmodel], names(VGOB1_subsetB_mecA_LUR3)[models[[4]]$indexbestmodel], names(VGOB1_subsetB_mecA_LUR3)[models[[5]]$indexbestmodel])

#  this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetB_mecA_LUR3$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetB_mecA_LUR3[,models[[1]]$indexbestmodel]+VGOB1_subsetB_mecA_LUR3[,models[[2]]$indexbestmodel]+VGOB1_subsetB_mecA_LUR3[,models[[3]]$indexbestmodel]+ VGOB1_subsetB_mecA_LUR3[,models[[4]]$indexbestmodel]+ VGOB1_subsetB_mecA_LUR3[,models[[5]]$indexbestmodel]) 
models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[5]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[5]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel
models[[5]]$R2bestmodel

# 6 #  
# add sixth variable (the only difference of the above part is that now model n=6 the model statement more variables)
#  and the call for the list of variable names in the model changed slightly

modeln<-6

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_3 :nlastvar_LUR_3){
  if (is.numeric(VGOB1_subsetB_mecA_LUR3[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetB_mecA_LUR3$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetB_mecA_LUR3[,models[[1]]$indexbestmodel]+VGOB1_subsetB_mecA_LUR3[,models[[2]]$indexbestmodel]+VGOB1_subsetB_mecA_LUR3[,models[[3]]$indexbestmodel]+VGOB1_subsetB_mecA_LUR3[,models[[4]]$indexbestmodel]+VGOB1_subsetB_mecA_LUR3[,models[[5]]$indexbestmodel]+ VGOB1_subsetB_mecA_LUR3[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # All[,i] is the row that's being tried out now. the name of that row can be found in  names(All)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetB_mecA_LUR3)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

# this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetB_mecA_LUR3)[models[[1]]$indexbestmodel], names(VGOB1_subsetB_mecA_LUR3)[models[[2]]$indexbestmodel] , names(VGOB1_subsetB_mecA_LUR3)[models[[3]]$indexbestmodel], names(VGOB1_subsetB_mecA_LUR3)[models[[4]]$indexbestmodel], names(VGOB1_subsetB_mecA_LUR3)[models[[5]]$indexbestmodel], names(VGOB1_subsetB_mecA_LUR3)[models[[6]]$indexbestmodel])

#  this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetB_mecA_LUR3$meca_copiespm3.ln.diffmeth.mean~ VGOB1_subsetB_mecA_LUR3[,models[[1]]$indexbestmodel]+ VGOB1_subsetB_mecA_LUR3[,models[[2]]$indexbestmodel]+ VGOB1_subsetB_mecA_LUR3[,models[[3]]$indexbestmodel]+ VGOB1_subsetB_mecA_LUR3[,models[[4]]$indexbestmodel]+ VGOB1_subsetB_mecA_LUR3[,models[[5]]$indexbestmodel]+ VGOB1_subsetB_mecA_LUR3[,models[[6]]$indexbestmodel]) 

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[5]]$summarybestmodel
models[[6]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[5]]$namesbestmodel
models[[6]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel
models[[5]]$R2bestmodel
models[[6]]$R2bestmodel


# 7 #  
# add seventh variable (the only difference of the above part is that now model n=7 the model statement more variables)
#  and the call for the list of variable names in the model changed slightly

modeln<-7

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_3 :nlastvar_LUR_3){
  if (is.numeric(VGOB1_subsetB_mecA_LUR3[,i])==TRUE){
    modeltry<- lm(VGOB1_subsetB_mecA_LUR3$meca_copiespm3.ln.diffmeth.mean~ VGOB1_subsetB_mecA_LUR3[,models[[1]]$indexbestmodel]+ VGOB1_subsetB_mecA_LUR3[,models[[2]]$indexbestmodel]+ VGOB1_subsetB_mecA_LUR3[,models[[3]]$indexbestmodel]+ VGOB1_subsetB_mecA_LUR3[,models[[4]]$indexbestmodel]+ VGOB1_subsetB_mecA_LUR3[,models[[5]]$indexbestmodel]+ VGOB1_subsetB_mecA_LUR3[,models[[6]]$indexbestmodel]+ VGOB1_subsetB_mecA_LUR3[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # Measurements_livestockpreds_LUR3[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR3)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetB_mecA_LUR3)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

# this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetB_mecA_LUR3)[models[[1]]$indexbestmodel], names(VGOB1_subsetB_mecA_LUR3)[models[[2]]$indexbestmodel] , names(VGOB1_subsetB_mecA_LUR3)[models[[3]]$indexbestmodel], names(VGOB1_subsetB_mecA_LUR3)[models[[4]]$indexbestmodel], names(VGOB1_subsetB_mecA_LUR3)[models[[5]]$indexbestmodel], names(VGOB1_subsetB_mecA_LUR3)[models[[6]]$indexbestmodel], names(VGOB1_subsetB_mecA_LUR3)[models[[7]]$indexbestmodel])

#  this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetB_mecA_LUR3$meca_copiespm3.ln.diffmeth.mean~ VGOB1_subsetB_mecA_LUR3[,models[[1]]$indexbestmodel]+ VGOB1_subsetB_mecA_LUR3[,models[[2]]$indexbestmodel]+ VGOB1_subsetB_mecA_LUR3[,models[[3]]$indexbestmodel]+ VGOB1_subsetB_mecA_LUR3[,models[[4]]$indexbestmodel]+ VGOB1_subsetB_mecA_LUR3[,models[[5]]$indexbestmodel]+ VGOB1_subsetB_mecA_LUR3[,models[[6]]$indexbestmodel]+ VGOB1_subsetB_mecA_LUR3[,models[[7]]$indexbestmodel]) 

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[5]]$summarybestmodel
models[[6]]$summarybestmodel
models[[7]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[5]]$namesbestmodel
models[[6]]$namesbestmodel
models[[7]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel
models[[5]]$R2bestmodel
models[[6]]$R2bestmodel
models[[7]]$R2bestmodel

# 8 #  
# add eighth variable (the only difference of the above part is that now modeln=7 the model statement more variables)
# and the call for the list of variable names in the model changed slightly

modeln<-8

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_3 :nlastvar_LUR_3){
  if (is.numeric(VGOB1_subsetB_mecA_LUR3[,i])==TRUE){
    modeltry<- lm(VGOB1_subsetB_mecA_LUR3$meca_copiespm3.ln.diffmeth.mean~ VGOB1_subsetB_mecA_LUR3[,models[[1]]$indexbestmodel]+ VGOB1_subsetB_mecA_LUR3[,models[[2]]$indexbestmodel]+ VGOB1_subsetB_mecA_LUR3[,models[[3]]$indexbestmodel]+ VGOB1_subsetB_mecA_LUR3[,models[[4]]$indexbestmodel]+ VGOB1_subsetB_mecA_LUR3[,models[[5]]$indexbestmodel]+ VGOB1_subsetB_mecA_LUR3[,models[[6]]$indexbestmodel]+ VGOB1_subsetB_mecA_LUR3[,models[[7]]$indexbestmodel]+ VGOB1_subsetB_mecA_LUR3[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # Measurements_livestockpreds_LUR3[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR3)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetB_mecA_LUR3)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

# this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetB_mecA_LUR3)[models[[1]]$indexbestmodel], names(VGOB1_subsetB_mecA_LUR3)[models[[2]]$indexbestmodel] , names(VGOB1_subsetB_mecA_LUR3)[models[[3]]$indexbestmodel], names(VGOB1_subsetB_mecA_LUR3)[models[[4]]$indexbestmodel], names(VGOB1_subsetB_mecA_LUR3)[models[[5]]$indexbestmodel], names(VGOB1_subsetB_mecA_LUR3)[models[[6]]$indexbestmodel], names(VGOB1_subsetB_mecA_LUR3)[models[[7]]$indexbestmodel], names(VGOB1_subsetB_mecA_LUR3)[models[[8]]$indexbestmodel])

#  this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetB_mecA_LUR3$meca_copiespm3.ln.diffmeth.mean~ VGOB1_subsetB_mecA_LUR3[,models[[1]]$indexbestmodel]+ VGOB1_subsetB_mecA_LUR3[,models[[2]]$indexbestmodel]+ VGOB1_subsetB_mecA_LUR3[,models[[3]]$indexbestmodel]+ VGOB1_subsetB_mecA_LUR3[,models[[4]]$indexbestmodel]+ VGOB1_subsetB_mecA_LUR3[,models[[5]]$indexbestmodel]+ VGOB1_subsetB_mecA_LUR3[,models[[6]]$indexbestmodel]+ VGOB1_subsetB_mecA_LUR3[,models[[7]]$indexbestmodel]+ VGOB1_subsetB_mecA_LUR3[,models[[8]]$indexbestmodel]) 

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[5]]$summarybestmodel
models[[6]]$summarybestmodel
models[[7]]$summarybestmodel
models[[8]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[5]]$namesbestmodel
models[[6]]$namesbestmodel
models[[7]]$namesbestmodel
models[[8]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel
models[[5]]$R2bestmodel
models[[6]]$R2bestmodel
models[[7]]$R2bestmodel
models[[8]]$R2bestmodel

# 9 #  
# add ninth variable (the only difference of the above part is that now modeln=9 the model statement more variables)
# and the call for the list of variable names in the model changed slightly

modeln<-9

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_3 :nlastvar_LUR_3){
  if (is.numeric(VGOB1_subsetB_mecA_LUR3[,i])==TRUE){
      modeltry<-lm(VGOB1_subsetB_mecA_LUR3$meca_copiespm3.ln.diffmeth.mean~ VGOB1_subsetB_mecA_LUR3[,models[[1]]$indexbestmodel]+ VGOB1_subsetB_mecA_LUR3[,models[[2]]$indexbestmodel]+ VGOB1_subsetB_mecA_LUR3[,models[[3]]$indexbestmodel]+ VGOB1_subsetB_mecA_LUR3[,models[[4]]$indexbestmodel]+ VGOB1_subsetB_mecA_LUR3[,models[[5]]$indexbestmodel]+ VGOB1_subsetB_mecA_LUR3[,models[[6]]$indexbestmodel]+ VGOB1_subsetB_mecA_LUR3[,models[[7]]$indexbestmodel]+ VGOB1_subsetB_mecA_LUR3[,models[[8]]$indexbestmodel]+ VGOB1_subsetB_mecA_LUR3[,i]) 
        R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # Measurements_livestockpreds_LUR3[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR3)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetB_mecA_LUR3)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

# this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetB_mecA_LUR3)[models[[1]]$indexbestmodel], names(VGOB1_subsetB_mecA_LUR3)[models[[2]]$indexbestmodel] , names(VGOB1_subsetB_mecA_LUR3)[models[[3]]$indexbestmodel], names(VGOB1_subsetB_mecA_LUR3)[models[[4]]$indexbestmodel], names(VGOB1_subsetB_mecA_LUR3)[models[[5]]$indexbestmodel], names(VGOB1_subsetB_mecA_LUR3)[models[[6]]$indexbestmodel], names(VGOB1_subsetB_mecA_LUR3)[models[[7]]$indexbestmodel], names(VGOB1_subsetB_mecA_LUR3)[models[[8]]$indexbestmodel],  names(VGOB1_subsetB_mecA_LUR3)[models[[9]]$indexbestmodel])

#  this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetB_mecA_LUR3$meca_copiespm3.ln.diffmeth.mean~ VGOB1_subsetB_mecA_LUR3[,models[[1]]$indexbestmodel]+ VGOB1_subsetB_mecA_LUR3[,models[[2]]$indexbestmodel]+ VGOB1_subsetB_mecA_LUR3[,models[[3]]$indexbestmodel]+ VGOB1_subsetB_mecA_LUR3[,models[[4]]$indexbestmodel]+ VGOB1_subsetB_mecA_LUR3[,models[[5]]$indexbestmodel]+ VGOB1_subsetB_mecA_LUR3[,models[[6]]$indexbestmodel]+ VGOB1_subsetB_mecA_LUR3[,models[[7]]$indexbestmodel]+ VGOB1_subsetB_mecA_LUR3[,models[[8]]$indexbestmodel]+ VGOB1_subsetB_mecA_LUR3[,models[[9]]$indexbestmodel]) 

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[5]]$summarybestmodel
models[[6]]$summarybestmodel
models[[7]]$summarybestmodel
models[[8]]$summarybestmodel
models[[9]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[5]]$namesbestmodel
models[[6]]$namesbestmodel
models[[7]]$namesbestmodel
models[[8]]$namesbestmodel
models[[9]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel
models[[5]]$R2bestmodel
models[[6]]$R2bestmodel
models[[7]]$R2bestmodel
models[[8]]$R2bestmodel
models[[9]]$R2bestmodel

# 10 #  
#  add tenth variable (the only difference of the above part is that now model n=10 the model statement more variables)
#  and the call for the list of variable names in the model changed slightly

modeln<-10

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_3 :nlastvar_LUR_3){if (is.numeric(VGOB1_subsetB_mecA_LUR3[,i])==TRUE){ modeltry<-lm(VGOB1_subsetB_mecA_LUR3$meca_copiespm3.ln.diffmeth.mean~ VGOB1_subsetB_mecA_LUR3[,models[[1]]$indexbestmodel]+ VGOB1_subsetB_mecA_LUR3[,models[[2]]$indexbestmodel]+ VGOB1_subsetB_mecA_LUR3[,models[[3]]$indexbestmodel]+ VGOB1_subsetB_mecA_LUR3[,models[[4]]$indexbestmodel]+ VGOB1_subsetB_mecA_LUR3[,models[[5]]$indexbestmodel]+ VGOB1_subsetB_mecA_LUR3[,models[[6]]$indexbestmodel]+ VGOB1_subsetB_mecA_LUR3[,models[[7]]$indexbestmodel]+ VGOB1_subsetB_mecA_LUR3[,models[[8]]$indexbestmodel]+ VGOB1_subsetB_mecA_LUR3[,models[[9]]$indexbestmodel]+ VGOB1_subsetB_mecA_LUR3[,i]) 

R2<-rbind(R2,summary(modeltry)$adj.r.squared)
# the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # Measurements_livestockpreds_LUR3[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR3)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetB_mecA_LUR3)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

# this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetB_mecA_LUR3)[models[[1]]$indexbestmodel],    names(VGOB1_subsetB_mecA_LUR3)[models[[2]]$indexbestmodel], names(VGOB1_subsetB_mecA_LUR3)[models[[3]]$indexbestmodel], names(VGOB1_subsetB_mecA_LUR3)[models[[4]]$indexbestmodel], names(VGOB1_subsetB_mecA_LUR3)[models[[5]]$indexbestmodel], names(VGOB1_subsetB_mecA_LUR3)[models[[6]]$indexbestmodel], names(VGOB1_subsetB_mecA_LUR3)[models[[7]]$indexbestmodel], names(VGOB1_subsetB_mecA_LUR3)[models[[8]]$indexbestmodel], names(VGOB1_subsetB_mecA_LUR3)[models[[9]]$indexbestmodel], names(VGOB1_subsetB_mecA_LUR3)[models[[10]]$indexbestmodel])

#  this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetB_mecA_LUR3$meca_copiespm3.ln.diffmeth.mean~        VGOB1_subsetB_mecA_LUR3[,models[[1]]$indexbestmodel]+ VGOB1_subsetB_mecA_LUR3[,models[[2]]$indexbestmodel]+  VGOB1_subsetB_mecA_LUR3[,models[[3]]$indexbestmodel]+ VGOB1_subsetB_mecA_LUR3[,models[[4]]$indexbestmodel]+ VGOB1_subsetB_mecA_LUR3[,models[[5]]$indexbestmodel]+ VGOB1_subsetB_mecA_LUR3[,models[[6]]$indexbestmodel]+ VGOB1_subsetB_mecA_LUR3[,models[[7]]$indexbestmodel]+ VGOB1_subsetB_mecA_LUR3[,models[[8]]$indexbestmodel]+ VGOB1_subsetB_mecA_LUR3[,models[[9]]$indexbestmodel]+ VGOB1_subsetB_mecA_LUR3[,models[[10]]$indexbestmodel]) 

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[5]]$summarybestmodel
models[[6]]$summarybestmodel
models[[7]]$summarybestmodel
models[[8]]$summarybestmodel
models[[9]]$summarybestmodel
models[[10]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[5]]$namesbestmodel
models[[6]]$namesbestmodel
models[[7]]$namesbestmodel
models[[8]]$namesbestmodel
models[[9]]$namesbestmodel
models[[10]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel
models[[5]]$R2bestmodel
models[[6]]$R2bestmodel
models[[7]]$R2bestmodel
models[[8]]$R2bestmodel
models[[9]]$R2bestmodel
models[[10]]$R2bestmodel

#  at this point I always check whether the next model is more than 1% better than the one before and if not I end here

#   CODE FOR PICKING OUT THE BEST MODEL #   
temp <- 0
besti <- 0
for (i in 1:10){ #  think this runs the loop 10 times - not fully sure thought - but not to do with the number of models I don't think - as when I change to 3, I still get the model with 4 variables as best model
  print(models[[i]]$R2bestmodel)
  #       print(models[[i]]$summarybestmodel$coefficients=-1,4])
  #       if((models[[i]]$R2bestmodel-temp > 0.0) && (all(models[[i]]$summarybestmodel$coefficients[-1,4]<0.1))){
  #         temp <- models[[i]]$R2bestmodel
  #         besti <- i
  #         }
  if((models[[i]]$R2bestmodel-temp > 0.0) && (all(models[[i]]$summarybestmodel$coefficients[-1,4]<0.1))){
    temp <- models[[i]]$R2bestmodel
    besti <- i
  }else{
    finalBestModel_mecA_subsetB <- models[[besti]]$bestmodel
    finalBestModelNames_mecA_subsetB <- models[[besti]]$namesbestmodel
    Sites <- 1:dim(VGOB1_subsetB_mecA_LUR3)[1] # full original model
    #  CVaR2<-escCV_mecA_LUR3(Sites)[2] # Cross Validation
    maxCD<-max(cooks.distance(finalBestModel_mecA_subsetB))
    if(length(finalBestModelNames_mecA_subsetB)<2){ # vif fn doesnot work when only 1 variable...       # 
      maxVIF<-"NA"
    }else{
      maxVIF<-max(vif(finalBestModel_mecA_subsetB))
    }
    print(paste("This is the best mecA model for subset B of 10-fold CV: ",besti,
                "(AdjR2: ",format(models[[besti]]$R2bestmodel,digits=3), "; MaxCD: ",format(maxCD,digits=3),"; MaxVIF: ",
                format(maxVIF,digits=3),")", sep=''))
    print(finalBestModelNames_mecA_subsetB)
    break
  }
}

#  Overview of the final best model using the algorithm selection process (taking into account VIF, R^2, and p-values)
finalBestModel_mecA_subsetB 
finalBestModelNames_mecA_subsetB 
models[[besti]]$summarybestmodel
models[[besti]]$R2bestmodel

#### C ####
# LUR model building process for subset C
#  This is the dataframe with the relevant predictor vars for LUR3 models for subset C (55 sites)
VGOB1_subsetC_mecA_LUR3 # n.b. this dataframe only includes microbial marker concentrations for mecA unlike the dataframe Measurements_livestockpreds_LUR3 as previously used for the model building. 

#  Now set the values of some variables that will be needed
nfirstvar_LUR_3 <- 3  
nlastvar_LUR_3 <- 135

# Function building to run the models 
# 1 #  

models<-list()
modeln<-1
models[[modeln]]<-list()

R2<-1
betaaddedvar<-1
addedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_3:nlastvar_LUR_3){
  if (is.numeric(VGOB1_subsetC_mecA_LUR3[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetC_mecA_LUR3$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetC_mecA_LUR3[,i])                            
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    #  Measurements_livestockpreds_LUR3[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR3)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetC_mecA_LUR3)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)
models[[modeln]]$results

#  this are the candidates models with the highest R2, not a negative beta for the new, nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)
models[[modeln]]$resultspos

#  rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))
models[[modeln]]$resultspos

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j
models[[modeln]]$indexbestmodel

subset(models[[modeln]]$resultspos, rank==1)
subset(models[[modeln]]$resultspos)

#  this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]
models[[modeln]]$summarybestmodel

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetC_mecA_LUR3)[models[[1]]$indexbestmodel])
models[[modeln]]$namesbestmodel

#  this is the r2 of that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2
models[[modeln]]$R2bestmodel

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetC_mecA_LUR3$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetC_mecA_LUR3[,models[[1]]$indexbestmodel]) 
models[[modeln]]$bestmodel

summary(models[[modeln]]$bestmodel)

#  The first model includes the predictor: nPigMultipFarmWghtDist.3000m.sum.Tr.1P9 - meaning the number of multiplier pig farms weighted to distance in a 3000m buffer

# 2 #  
# Add 2nd variable (the only difference of the above part is that now modeln=2 the model statement has 2 variables)
# and the call for the list of variable names in the model changed slightly

modeln<-2

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_3:nlastvar_LUR_3){
  if (is.numeric(VGOB1_subsetC_mecA_LUR3[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetC_mecA_LUR3$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetC_mecA_LUR3[,models[[1]]$indexbestmodel]+ VGOB1_subsetC_mecA_LUR3[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # Measurements_livestockpreds_LUR3[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR3)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetC_mecA_LUR3)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  these are the candidate models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)
models[[modeln]]$resultspos

#  rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))
models[[modeln]]$resultspos

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j
models[[modeln]]$indexbestmodel

subset(models[[modeln]]$resultspos, rank==1)

# this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]
models[[modeln]]$summarybestmodel

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetC_mecA_LUR3)[models[[1]]$indexbestmodel], names(VGOB1_subsetC_mecA_LUR3)[models[[2]]$indexbestmodel] )
models[[modeln]]$namesbestmodel

# this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2
models[[modeln]]$R2bestmodel

# this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetC_mecA_LUR3$meca_copiespm3.ln.diffmeth.mean~                               VGOB1_subsetC_mecA_LUR3[,models[[1]]$indexbestmodel]+                           VGOB1_subsetC_mecA_LUR3[,models[[2]]$indexbestmodel]) 

models[[modeln]]$bestmodel

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel


# 3 #  
# add third variable (the only difference of the above part is that now modeln=3 the model statement has 3 variables)
# and the call for the list of variable names in the model changed slightly

modeln<-3

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_3:nlastvar_LUR_3){
  if (is.numeric(VGOB1_subsetC_mecA_LUR3[,i])==TRUE){  
    modeltry<-lm(VGOB1_subsetC_mecA_LUR3$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetC_mecA_LUR3[,models[[1]]$indexbestmodel]+VGOB1_subsetC_mecA_LUR3[,models[[2]]$indexbestmodel]+ VGOB1_subsetC_mecA_LUR3[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # All[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR3)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetC_mecA_LUR3)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

#  rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

#  this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

#  here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetC_mecA_LUR3)[models[[1]]$indexbestmodel], names(VGOB1_subsetC_mecA_LUR3)[models[[2]]$indexbestmodel], names(VGOB1_subsetC_mecA_LUR3)[models[[3]]$indexbestmodel])

#  this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetC_mecA_LUR3$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetC_mecA_LUR3[,models[[1]]$indexbestmodel]+ VGOB1_subsetC_mecA_LUR3[,models[[2]]$indexbestmodel]+ VGOB1_subsetC_mecA_LUR3[,models[[3]]$indexbestmodel]) 

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel


# 4 #  
#  add forth variable (the only difference of the above part is that now model n=4 the model statement more variables)
#  and the call for the list of variable names in the model changed slightly
modeln<-4

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1


for (i in nfirstvar_LUR_3:nlastvar_LUR_3){
  if (is.numeric(VGOB1_subsetC_mecA_LUR3[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetC_mecA_LUR3$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetC_mecA_LUR3[,models[[1]]$indexbestmodel]+VGOB1_subsetC_mecA_LUR3[,models[[2]]$indexbestmodel]+VGOB1_subsetC_mecA_LUR3[,models[[3]]$indexbestmodel]+VGOB1_subsetC_mecA_LUR3[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    #  the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    #  All[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR3)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetC_mecA_LUR3)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

#  this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

#  here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetC_mecA_LUR3)[models[[1]]$indexbestmodel], names(VGOB1_subsetC_mecA_LUR3)[models[[2]]$indexbestmodel], names(VGOB1_subsetC_mecA_LUR3)[models[[3]]$indexbestmodel], names(VGOB1_subsetC_mecA_LUR3)[models[[4]]$indexbestmodel])

#  this is the r2 of that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetC_mecA_LUR3$meca_copiespm3.ln.diffmeth.mean~ VGOB1_subsetC_mecA_LUR3[,models[[1]]$indexbestmodel]+ VGOB1_subsetC_mecA_LUR3[,models[[2]]$indexbestmodel]+VGOB1_subsetC_mecA_LUR3[,models[[3]]$indexbestmodel]+ VGOB1_subsetC_mecA_LUR3[,models[[4]]$indexbestmodel]) 


models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel


# 5 #  
# add fifth variable (the only difference of the above part is that now modeln=5 the model statement more variables)
# and the call for the list of variable names in the model changed slightly
modeln<-5

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_3:nlastvar_LUR_3){
  if (is.numeric(VGOB1_subsetC_mecA_LUR3[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetC_mecA_LUR3$meca_copiespm3.ln.diffmeth.mean~ VGOB1_subsetC_mecA_LUR3[,models[[1]]$indexbestmodel]+ VGOB1_subsetC_mecA_LUR3[,models[[2]]$indexbestmodel]+ VGOB1_subsetC_mecA_LUR3[,models[[3]]$indexbestmodel]+ VGOB1_subsetC_mecA_LUR3[,models[[4]]$indexbestmodel]+ VGOB1_subsetC_mecA_LUR3[,i]) 
  
R2<-rbind(R2,summary(modeltry)$adj.r.squared)
# the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # All[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR3)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetC_mecA_LUR3)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

#  this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetC_mecA_LUR3)[models[[1]]$indexbestmodel], names(VGOB1_subsetC_mecA_LUR3)[models[[2]]$indexbestmodel], names(VGOB1_subsetC_mecA_LUR3)[models[[3]]$indexbestmodel], names(VGOB1_subsetC_mecA_LUR3)[models[[4]]$indexbestmodel], names(VGOB1_subsetC_mecA_LUR3)[models[[5]]$indexbestmodel])

#  this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetC_mecA_LUR3$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetC_mecA_LUR3[,models[[1]]$indexbestmodel]+VGOB1_subsetC_mecA_LUR3[,models[[2]]$indexbestmodel]+VGOB1_subsetC_mecA_LUR3[,models[[3]]$indexbestmodel]+ VGOB1_subsetC_mecA_LUR3[,models[[4]]$indexbestmodel]+ VGOB1_subsetC_mecA_LUR3[,models[[5]]$indexbestmodel]) 
models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[5]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[5]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel
models[[5]]$R2bestmodel

# 6 #  
# add sixth variable (the only difference of the above part is that now model n=6 the model statement more variables)
#  and the call for the list of variable names in the model changed slightly

modeln<-6

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_3 :nlastvar_LUR_3){
  if (is.numeric(VGOB1_subsetC_mecA_LUR3[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetC_mecA_LUR3$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetC_mecA_LUR3[,models[[1]]$indexbestmodel]+VGOB1_subsetC_mecA_LUR3[,models[[2]]$indexbestmodel]+VGOB1_subsetC_mecA_LUR3[,models[[3]]$indexbestmodel]+VGOB1_subsetC_mecA_LUR3[,models[[4]]$indexbestmodel]+VGOB1_subsetC_mecA_LUR3[,models[[5]]$indexbestmodel]+ VGOB1_subsetC_mecA_LUR3[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # All[,i] is the row that's being tried out now. the name of that row can be found in  names(All)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetC_mecA_LUR3)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

# this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetC_mecA_LUR3)[models[[1]]$indexbestmodel], names(VGOB1_subsetC_mecA_LUR3)[models[[2]]$indexbestmodel] , names(VGOB1_subsetC_mecA_LUR3)[models[[3]]$indexbestmodel], names(VGOB1_subsetC_mecA_LUR3)[models[[4]]$indexbestmodel], names(VGOB1_subsetC_mecA_LUR3)[models[[5]]$indexbestmodel], names(VGOB1_subsetC_mecA_LUR3)[models[[6]]$indexbestmodel])

#  this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetC_mecA_LUR3$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetC_mecA_LUR3[,models[[1]]$indexbestmodel]+VGOB1_subsetC_mecA_LUR3[,models[[2]]$indexbestmodel]+VGOB1_subsetC_mecA_LUR3[,models[[3]]$indexbestmodel]+ VGOB1_subsetC_mecA_LUR3[,models[[4]]$indexbestmodel]+ VGOB1_subsetC_mecA_LUR3[,models[[5]]$indexbestmodel]+ VGOB1_subsetC_mecA_LUR3[,models[[6]]$indexbestmodel]) 

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[5]]$summarybestmodel
models[[6]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[5]]$namesbestmodel
models[[6]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel
models[[5]]$R2bestmodel
models[[6]]$R2bestmodel


# 7 #  
# add seventh variable (the only difference of the above part is that now model n=7 the model statement more variables)
#  and the call for the list of variable names in the model changed slightly

modeln<-7

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_3 :nlastvar_LUR_3){
  if (is.numeric(VGOB1_subsetC_mecA_LUR3[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetC_mecA_LUR3$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetC_mecA_LUR3[,models[[1]]$indexbestmodel]+VGOB1_subsetC_mecA_LUR3[,models[[2]]$indexbestmodel]+VGOB1_subsetC_mecA_LUR3[,models[[3]]$indexbestmodel]+VGOB1_subsetC_mecA_LUR3[,models[[4]]$indexbestmodel]+VGOB1_subsetC_mecA_LUR3[,models[[5]]$indexbestmodel]+VGOB1_subsetC_mecA_LUR3[,models[[6]]$indexbestmodel]+ VGOB1_subsetC_mecA_LUR3[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # Measurements_livestockpreds_LUR3[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR3)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetC_mecA_LUR3)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

# this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetC_mecA_LUR3)[models[[1]]$indexbestmodel], names(VGOB1_subsetC_mecA_LUR3)[models[[2]]$indexbestmodel] , names(VGOB1_subsetC_mecA_LUR3)[models[[3]]$indexbestmodel], names(VGOB1_subsetC_mecA_LUR3)[models[[4]]$indexbestmodel], names(VGOB1_subsetC_mecA_LUR3)[models[[5]]$indexbestmodel], names(VGOB1_subsetC_mecA_LUR3)[models[[6]]$indexbestmodel], names(VGOB1_subsetC_mecA_LUR3)[models[[7]]$indexbestmodel])

#  this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetC_mecA_LUR3$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetC_mecA_LUR3[,models[[1]]$indexbestmodel]+VGOB1_subsetC_mecA_LUR3[,models[[2]]$indexbestmodel]+VGOB1_subsetC_mecA_LUR3[,models[[3]]$indexbestmodel]+ VGOB1_subsetC_mecA_LUR3[,models[[4]]$indexbestmodel]+ VGOB1_subsetC_mecA_LUR3[,models[[5]]$indexbestmodel]+ VGOB1_subsetC_mecA_LUR3[,models[[6]]$indexbestmodel]+ VGOB1_subsetC_mecA_LUR3[,models[[7]]$indexbestmodel]) 

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[5]]$summarybestmodel
models[[6]]$summarybestmodel
models[[7]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[5]]$namesbestmodel
models[[6]]$namesbestmodel
models[[7]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel
models[[5]]$R2bestmodel
models[[6]]$R2bestmodel
models[[7]]$R2bestmodel

# 8 #  
# add eighth variable (the only difference of the above part is that now modeln=7 the model statement more variables)
# and the call for the list of variable names in the model changed slightly

modeln<-8

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_3 :nlastvar_LUR_3){
  if (is.numeric(VGOB1_subsetC_mecA_LUR3[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetC_mecA_LUR3$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetC_mecA_LUR3[,models[[1]]$indexbestmodel]+VGOB1_subsetC_mecA_LUR3[,models[[2]]$indexbestmodel]+VGOB1_subsetC_mecA_LUR3[,models[[3]]$indexbestmodel]+VGOB1_subsetC_mecA_LUR3[,models[[4]]$indexbestmodel]+VGOB1_subsetC_mecA_LUR3[,models[[5]]$indexbestmodel]+VGOB1_subsetC_mecA_LUR3[,models[[6]]$indexbestmodel]+ VGOB1_subsetC_mecA_LUR3[,models[[7]]$indexbestmodel]+ VGOB1_subsetC_mecA_LUR3[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # Measurements_livestockpreds_LUR3[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR3)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetC_mecA_LUR3)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

# this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetC_mecA_LUR3)[models[[1]]$indexbestmodel], names(VGOB1_subsetC_mecA_LUR3)[models[[2]]$indexbestmodel] , names(VGOB1_subsetC_mecA_LUR3)[models[[3]]$indexbestmodel], names(VGOB1_subsetC_mecA_LUR3)[models[[4]]$indexbestmodel], names(VGOB1_subsetC_mecA_LUR3)[models[[5]]$indexbestmodel], names(VGOB1_subsetC_mecA_LUR3)[models[[6]]$indexbestmodel], names(VGOB1_subsetC_mecA_LUR3)[models[[7]]$indexbestmodel], names(VGOB1_subsetC_mecA_LUR3)[models[[8]]$indexbestmodel])

#  this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetC_mecA_LUR3$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetC_mecA_LUR3[,models[[1]]$indexbestmodel]+VGOB1_subsetC_mecA_LUR3[,models[[2]]$indexbestmodel]+VGOB1_subsetC_mecA_LUR3[,models[[3]]$indexbestmodel]+ VGOB1_subsetC_mecA_LUR3[,models[[4]]$indexbestmodel]+ VGOB1_subsetC_mecA_LUR3[,models[[5]]$indexbestmodel]+ VGOB1_subsetC_mecA_LUR3[,models[[6]]$indexbestmodel]+ VGOB1_subsetC_mecA_LUR3[,models[[7]]$indexbestmodel]+ VGOB1_subsetC_mecA_LUR3[,models[[8]]$indexbestmodel]) 

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[5]]$summarybestmodel
models[[6]]$summarybestmodel
models[[7]]$summarybestmodel
models[[8]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[5]]$namesbestmodel
models[[6]]$namesbestmodel
models[[7]]$namesbestmodel
models[[8]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel
models[[5]]$R2bestmodel
models[[6]]$R2bestmodel
models[[7]]$R2bestmodel
models[[8]]$R2bestmodel

# 9 #  
# add ninth variable (the only difference of the above part is that now modeln=9 the model statement more variables)
# and the call for the list of variable names in the model changed slightly

modeln<-9

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_3 :nlastvar_LUR_3){
  if (is.numeric(VGOB1_subsetC_mecA_LUR3[,i])==TRUE){
      modeltry<-lm(VGOB1_subsetC_mecA_LUR3$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetC_mecA_LUR3[,models[[1]]$indexbestmodel]+VGOB1_subsetC_mecA_LUR3[,models[[2]]$indexbestmodel]+VGOB1_subsetC_mecA_LUR3[,models[[3]]$indexbestmodel]+VGOB1_subsetC_mecA_LUR3[,models[[4]]$indexbestmodel]+VGOB1_subsetC_mecA_LUR3[,models[[5]]$indexbestmodel]+VGOB1_subsetC_mecA_LUR3[,models[[6]]$indexbestmodel]+ VGOB1_subsetC_mecA_LUR3[,models[[7]]$indexbestmodel]+ VGOB1_subsetC_mecA_LUR3[,models[[8]]$indexbestmodel]+ VGOB1_subsetC_mecA_LUR3[,i]) 
        R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # Measurements_livestockpreds_LUR3[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR3)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetC_mecA_LUR3)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

# this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetC_mecA_LUR3)[models[[1]]$indexbestmodel], names(VGOB1_subsetC_mecA_LUR3)[models[[2]]$indexbestmodel] , names(VGOB1_subsetC_mecA_LUR3)[models[[3]]$indexbestmodel], names(VGOB1_subsetC_mecA_LUR3)[models[[4]]$indexbestmodel], names(VGOB1_subsetC_mecA_LUR3)[models[[5]]$indexbestmodel], names(VGOB1_subsetC_mecA_LUR3)[models[[6]]$indexbestmodel], names(VGOB1_subsetC_mecA_LUR3)[models[[7]]$indexbestmodel], names(VGOB1_subsetC_mecA_LUR3)[models[[8]]$indexbestmodel],  names(VGOB1_subsetC_mecA_LUR3)[models[[9]]$indexbestmodel])

#  this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetC_mecA_LUR3$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetC_mecA_LUR3[,models[[1]]$indexbestmodel]+VGOB1_subsetC_mecA_LUR3[,models[[2]]$indexbestmodel]+VGOB1_subsetC_mecA_LUR3[,models[[3]]$indexbestmodel]+ VGOB1_subsetC_mecA_LUR3[,models[[4]]$indexbestmodel]+ VGOB1_subsetC_mecA_LUR3[,models[[5]]$indexbestmodel]+ VGOB1_subsetC_mecA_LUR3[,models[[6]]$indexbestmodel]+ VGOB1_subsetC_mecA_LUR3[,models[[7]]$indexbestmodel]+ VGOB1_subsetC_mecA_LUR3[,models[[8]]$indexbestmodel]+ VGOB1_subsetC_mecA_LUR3[,models[[9]]$indexbestmodel]) 

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[5]]$summarybestmodel
models[[6]]$summarybestmodel
models[[7]]$summarybestmodel
models[[8]]$summarybestmodel
models[[9]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[5]]$namesbestmodel
models[[6]]$namesbestmodel
models[[7]]$namesbestmodel
models[[8]]$namesbestmodel
models[[9]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel
models[[5]]$R2bestmodel
models[[6]]$R2bestmodel
models[[7]]$R2bestmodel
models[[8]]$R2bestmodel
models[[9]]$R2bestmodel

# 10 #  
#  add tenth variable (the only difference of the above part is that now model n=10 the model statement more variables)
#  and the call for the list of variable names in the model changed slightly

modeln<-10

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_3 :nlastvar_LUR_3){if (is.numeric(VGOB1_subsetC_mecA_LUR3[,i])==TRUE){ modeltry<-lm(VGOB1_subsetC_mecA_LUR3$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetC_mecA_LUR3[,models[[1]]$indexbestmodel]+VGOB1_subsetC_mecA_LUR3[,models[[2]]$indexbestmodel]+ VGOB1_subsetC_mecA_LUR3[,models[[3]]$indexbestmodel]+VGOB1_subsetC_mecA_LUR3[,models[[4]]$indexbestmodel]+ VGOB1_subsetC_mecA_LUR3[,models[[5]]$indexbestmodel]+ VGOB1_subsetC_mecA_LUR3[,models[[6]]$indexbestmodel]+ VGOB1_subsetC_mecA_LUR3[,models[[7]]$indexbestmodel]+ VGOB1_subsetC_mecA_LUR3[,models[[8]]$indexbestmodel]+ VGOB1_subsetC_mecA_LUR3[,models[[9]]$indexbestmodel]+ VGOB1_subsetC_mecA_LUR3[,i]) 

R2<-rbind(R2,summary(modeltry)$adj.r.squared)
# the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # Measurements_livestockpreds_LUR3[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR3)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetC_mecA_LUR3)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

# this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

# here are the names
models[[modeln]]$namesbestmodel<-c( names(VGOB1_subsetC_mecA_LUR3)[models[[1]]$indexbestmodel],                   names(VGOB1_subsetC_mecA_LUR3)[models[[2]]$indexbestmodel] , names(VGOB1_subsetC_mecA_LUR3)[models[[3]]$indexbestmodel], names(VGOB1_subsetC_mecA_LUR3)[models[[4]]$indexbestmodel], names(VGOB1_subsetC_mecA_LUR3)[models[[5]]$indexbestmodel], names(VGOB1_subsetC_mecA_LUR3)[models[[6]]$indexbestmodel], names(VGOB1_subsetC_mecA_LUR3)[models[[7]]$indexbestmodel], names(VGOB1_subsetC_mecA_LUR3)[models[[8]]$indexbestmodel], names(VGOB1_subsetC_mecA_LUR3)[models[[9]]$indexbestmodel], names(VGOB1_subsetC_mecA_LUR3)[models[[10]]$indexbestmodel])

#  this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetC_mecA_LUR3$meca_copiespm3.ln.diffmeth.mean~                                VGOB1_subsetC_mecA_LUR3[,models[[1]]$indexbestmodel]+ VGOB1_subsetC_mecA_LUR3[,models[[2]]$indexbestmodel]+                           VGOB1_subsetC_mecA_LUR3[,models[[3]]$indexbestmodel]+ VGOB1_subsetC_mecA_LUR3[,models[[4]]$indexbestmodel]+ VGOB1_subsetC_mecA_LUR3[,models[[5]]$indexbestmodel]+ VGOB1_subsetC_mecA_LUR3[,models[[6]]$indexbestmodel]+ VGOB1_subsetC_mecA_LUR3[,models[[7]]$indexbestmodel]+ VGOB1_subsetC_mecA_LUR3[,models[[8]]$indexbestmodel]+ VGOB1_subsetC_mecA_LUR3[,models[[9]]$indexbestmodel]+ VGOB1_subsetC_mecA_LUR3[,models[[10]]$indexbestmodel]) 

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[5]]$summarybestmodel
models[[6]]$summarybestmodel
models[[7]]$summarybestmodel
models[[8]]$summarybestmodel
models[[9]]$summarybestmodel
models[[10]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[5]]$namesbestmodel
models[[6]]$namesbestmodel
models[[7]]$namesbestmodel
models[[8]]$namesbestmodel
models[[9]]$namesbestmodel
models[[10]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel
models[[5]]$R2bestmodel
models[[6]]$R2bestmodel
models[[7]]$R2bestmodel
models[[8]]$R2bestmodel
models[[9]]$R2bestmodel
models[[10]]$R2bestmodel

#  at this point I always check whether the next model is more than 1% better than the one before and if not I end here

#   CODE FOR PICKING OUT THE BEST MODEL #   
temp <- 0
besti <- 0
for (i in 1:10){ #  think this runs the loop 10 times - not fully sure thought - but not to do with the number of models I don't think - as when I change to 3, I still get the model with 4 variables as best model
  print(models[[i]]$R2bestmodel)
  #       print(models[[i]]$summarybestmodel$coefficients=-1,4])
  #       if((models[[i]]$R2bestmodel-temp > 0.0) && (all(models[[i]]$summarybestmodel$coefficients[-1,4]<0.1))){
  #         temp <- models[[i]]$R2bestmodel
  #         besti <- i
  #         }
  if((models[[i]]$R2bestmodel-temp > 0.0) && (all(models[[i]]$summarybestmodel$coefficients[-1,4]<0.1))){
    temp <- models[[i]]$R2bestmodel
    besti <- i
  }else{
    finalBestModel_mecA_subsetC <- models[[besti]]$bestmodel
    finalBestModelNames_mecA_subsetC <- models[[besti]]$namesbestmodel
    Sites <- 1:dim(VGOB1_subsetC_mecA_LUR3)[1] # full original model
    #  CVaR2<-escCV_mecA_LUR3(Sites)[2] # Cross Validation
    maxCD<-max(cooks.distance(finalBestModel_mecA_subsetC))
    if(length(finalBestModelNames_mecA_subsetC)<2){ # vif fn doesnot work when only 1 variable...       # 
      maxVIF<-"NA"
    }else{
      maxVIF<-max(vif(finalBestModel_mecA_subsetC))
    }
    print(paste("This is the best mecA model for subset C: ",besti,
                "(AdjR2: ",format(models[[besti]]$R2bestmodel,digits=3), "; MaxCD: ",format(maxCD,digits=3),"; MaxVIF: ",
                format(maxVIF,digits=3),")", sep=''))
    print(finalBestModelNames_mecA_subsetC)
    break
  }
}

#  Overview of the final best model using the algorithm selection process (taking into account VIF, R^2, and p-values)
finalBestModel_mecA_subsetC
finalBestModelNames_mecA_subsetC
models[[besti]]$summarybestmodel
models[[besti]]$R2bestmodel

#### D ####
# LUR model building process for subset D
#  This is the dataframe with the relevant predictor vars for LUR3 models for subset D (55 sites)
VGOB1_subsetD_mecA_LUR3 # n.b. this dataframe only includes microbial marker concentrations for mecA unlike the dataframe Measurements_livestockpreds_LUR3 as previously used for the model building. 

#  Now set the values of some variables that will be needed
nfirstvar_LUR_3 <- 3  
nlastvar_LUR_3 <- 135

# Function building to run the models 
# 1 #  

models<-list()
modeln<-1
models[[modeln]]<-list()

R2<-1
betaaddedvar<-1
addedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_3:nlastvar_LUR_3){
  if (is.numeric(VGOB1_subsetD_mecA_LUR3[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetD_mecA_LUR3$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetD_mecA_LUR3[,i])                            
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    #  Measurements_livestockpreds_LUR3[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR3)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetD_mecA_LUR3)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)
models[[modeln]]$results

#  this are the candidates models with the highest R2, not a negative beta for the new, nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)
models[[modeln]]$resultspos

#  rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))
models[[modeln]]$resultspos

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j
models[[modeln]]$indexbestmodel

subset(models[[modeln]]$resultspos, rank==1)
subset(models[[modeln]]$resultspos)

#  this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]
models[[modeln]]$summarybestmodel

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetD_mecA_LUR3)[models[[1]]$indexbestmodel])
models[[modeln]]$namesbestmodel

#  this is the r2 of that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2
models[[modeln]]$R2bestmodel

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetD_mecA_LUR3$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetD_mecA_LUR3[,models[[1]]$indexbestmodel]) 
models[[modeln]]$bestmodel

summary(models[[modeln]]$bestmodel)

#  The first model includes the predictor: nPigMultipFarmWghtDist.3000m.sum.Tr.1P9 - meaning the number of multiplier pig farms weighted to distance in a 3000m buffer

# 2 #  
# Add 2nd variable (the only difference of the above part is that now modeln=2 the model statement has 2 variables)
# and the call for the list of variable names in the model changed slightly

modeln<-2

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_3:nlastvar_LUR_3){
  if (is.numeric(VGOB1_subsetD_mecA_LUR3[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetD_mecA_LUR3$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetD_mecA_LUR3[,models[[1]]$indexbestmodel]+ VGOB1_subsetD_mecA_LUR3[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # Measurements_livestockpreds_LUR3[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR3)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetD_mecA_LUR3)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  these are the candidate models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)
models[[modeln]]$resultspos

#  rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))
models[[modeln]]$resultspos

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j
models[[modeln]]$indexbestmodel

subset(models[[modeln]]$resultspos, rank==1)

# this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]
models[[modeln]]$summarybestmodel

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetD_mecA_LUR3)[models[[1]]$indexbestmodel], names(VGOB1_subsetD_mecA_LUR3)[models[[2]]$indexbestmodel] )
models[[modeln]]$namesbestmodel

# this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2
models[[modeln]]$R2bestmodel

# this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetD_mecA_LUR3$meca_copiespm3.ln.diffmeth.mean~                               VGOB1_subsetD_mecA_LUR3[,models[[1]]$indexbestmodel]+                           VGOB1_subsetD_mecA_LUR3[,models[[2]]$indexbestmodel]) 

models[[modeln]]$bestmodel

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel


# 3 #  
# add third variable (the only difference of the above part is that now modeln=3 the model statement has 3 variables)
# and the call for the list of variable names in the model changed slightly

modeln<-3

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_3:nlastvar_LUR_3){
  if (is.numeric(VGOB1_subsetD_mecA_LUR3[,i])==TRUE){  
    modeltry<-lm(VGOB1_subsetD_mecA_LUR3$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetD_mecA_LUR3[,models[[1]]$indexbestmodel]+VGOB1_subsetD_mecA_LUR3[,models[[2]]$indexbestmodel]+ VGOB1_subsetD_mecA_LUR3[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # All[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR3)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetD_mecA_LUR3)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

#  rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

#  this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

#  here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetD_mecA_LUR3)[models[[1]]$indexbestmodel], names(VGOB1_subsetD_mecA_LUR3)[models[[2]]$indexbestmodel], names(VGOB1_subsetD_mecA_LUR3)[models[[3]]$indexbestmodel])

#  this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetD_mecA_LUR3$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetD_mecA_LUR3[,models[[1]]$indexbestmodel]+ VGOB1_subsetD_mecA_LUR3[,models[[2]]$indexbestmodel]+ VGOB1_subsetD_mecA_LUR3[,models[[3]]$indexbestmodel]) 

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel


# 4 #  
#  add forth variable (the only difference of the above part is that now model n=4 the model statement more variables)
#  and the call for the list of variable names in the model changed slightly
modeln<-4

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1


for (i in nfirstvar_LUR_3:nlastvar_LUR_3){
  if (is.numeric(VGOB1_subsetD_mecA_LUR3[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetD_mecA_LUR3$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetD_mecA_LUR3[,models[[1]]$indexbestmodel]+VGOB1_subsetD_mecA_LUR3[,models[[2]]$indexbestmodel]+VGOB1_subsetD_mecA_LUR3[,models[[3]]$indexbestmodel]+VGOB1_subsetD_mecA_LUR3[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    #  the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    #  All[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR3)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetD_mecA_LUR3)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

#  this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

#  here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetD_mecA_LUR3)[models[[1]]$indexbestmodel], names(VGOB1_subsetD_mecA_LUR3)[models[[2]]$indexbestmodel], names(VGOB1_subsetD_mecA_LUR3)[models[[3]]$indexbestmodel], names(VGOB1_subsetD_mecA_LUR3)[models[[4]]$indexbestmodel])

#  this is the r2 of that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetD_mecA_LUR3$meca_copiespm3.ln.diffmeth.mean~ VGOB1_subsetD_mecA_LUR3[,models[[1]]$indexbestmodel]+ VGOB1_subsetD_mecA_LUR3[,models[[2]]$indexbestmodel]+VGOB1_subsetD_mecA_LUR3[,models[[3]]$indexbestmodel]+ VGOB1_subsetD_mecA_LUR3[,models[[4]]$indexbestmodel]) 


models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel


# 5 #  
# add fifth variable (the only difference of the above part is that now modeln=5 the model statement more variables)
# and the call for the list of variable names in the model changed slightly
modeln<-5

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_3:nlastvar_LUR_3){
  if (is.numeric(VGOB1_subsetD_mecA_LUR3[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetD_mecA_LUR3$meca_copiespm3.ln.diffmeth.mean~ VGOB1_subsetD_mecA_LUR3[,models[[1]]$indexbestmodel]+ VGOB1_subsetD_mecA_LUR3[,models[[2]]$indexbestmodel]+ VGOB1_subsetD_mecA_LUR3[,models[[3]]$indexbestmodel]+ VGOB1_subsetD_mecA_LUR3[,models[[4]]$indexbestmodel]+ VGOB1_subsetD_mecA_LUR3[,i]) 
  
R2<-rbind(R2,summary(modeltry)$adj.r.squared)
# the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # All[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR3)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetD_mecA_LUR3)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

#  this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetD_mecA_LUR3)[models[[1]]$indexbestmodel], names(VGOB1_subsetD_mecA_LUR3)[models[[2]]$indexbestmodel], names(VGOB1_subsetD_mecA_LUR3)[models[[3]]$indexbestmodel], names(VGOB1_subsetD_mecA_LUR3)[models[[4]]$indexbestmodel], names(VGOB1_subsetD_mecA_LUR3)[models[[5]]$indexbestmodel])

#  this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetD_mecA_LUR3$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetD_mecA_LUR3[,models[[1]]$indexbestmodel]+VGOB1_subsetD_mecA_LUR3[,models[[2]]$indexbestmodel]+VGOB1_subsetD_mecA_LUR3[,models[[3]]$indexbestmodel]+ VGOB1_subsetD_mecA_LUR3[,models[[4]]$indexbestmodel]+ VGOB1_subsetD_mecA_LUR3[,models[[5]]$indexbestmodel]) 
models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[5]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[5]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel
models[[5]]$R2bestmodel

# 6 #  
# add sixth variable (the only difference of the above part is that now model n=6 the model statement more variables)
#  and the call for the list of variable names in the model changed slightly

modeln<-6

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_3 :nlastvar_LUR_3){
  if (is.numeric(VGOB1_subsetD_mecA_LUR3[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetD_mecA_LUR3$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetD_mecA_LUR3[,models[[1]]$indexbestmodel]+VGOB1_subsetD_mecA_LUR3[,models[[2]]$indexbestmodel]+VGOB1_subsetD_mecA_LUR3[,models[[3]]$indexbestmodel]+VGOB1_subsetD_mecA_LUR3[,models[[4]]$indexbestmodel]+VGOB1_subsetD_mecA_LUR3[,models[[5]]$indexbestmodel]+ VGOB1_subsetD_mecA_LUR3[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # All[,i] is the row that's being tried out now. the name of that row can be found in  names(All)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetD_mecA_LUR3)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

# this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetD_mecA_LUR3)[models[[1]]$indexbestmodel], names(VGOB1_subsetD_mecA_LUR3)[models[[2]]$indexbestmodel] , names(VGOB1_subsetD_mecA_LUR3)[models[[3]]$indexbestmodel], names(VGOB1_subsetD_mecA_LUR3)[models[[4]]$indexbestmodel], names(VGOB1_subsetD_mecA_LUR3)[models[[5]]$indexbestmodel], names(VGOB1_subsetD_mecA_LUR3)[models[[6]]$indexbestmodel])

#  this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetD_mecA_LUR3$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetD_mecA_LUR3[,models[[1]]$indexbestmodel]+VGOB1_subsetD_mecA_LUR3[,models[[2]]$indexbestmodel]+VGOB1_subsetD_mecA_LUR3[,models[[3]]$indexbestmodel]+ VGOB1_subsetD_mecA_LUR3[,models[[4]]$indexbestmodel]+ VGOB1_subsetD_mecA_LUR3[,models[[5]]$indexbestmodel]+ VGOB1_subsetD_mecA_LUR3[,models[[6]]$indexbestmodel]) 

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[5]]$summarybestmodel
models[[6]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[5]]$namesbestmodel
models[[6]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel
models[[5]]$R2bestmodel
models[[6]]$R2bestmodel


# 7 #  
# add seventh variable (the only difference of the above part is that now model n=7 the model statement more variables)
#  and the call for the list of variable names in the model changed slightly

modeln<-7

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_3 :nlastvar_LUR_3){
  if (is.numeric(VGOB1_subsetD_mecA_LUR3[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetD_mecA_LUR3$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetD_mecA_LUR3[,models[[1]]$indexbestmodel]+VGOB1_subsetD_mecA_LUR3[,models[[2]]$indexbestmodel]+VGOB1_subsetD_mecA_LUR3[,models[[3]]$indexbestmodel]+VGOB1_subsetD_mecA_LUR3[,models[[4]]$indexbestmodel]+VGOB1_subsetD_mecA_LUR3[,models[[5]]$indexbestmodel]+VGOB1_subsetD_mecA_LUR3[,models[[6]]$indexbestmodel]+ VGOB1_subsetD_mecA_LUR3[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # Measurements_livestockpreds_LUR3[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR3)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetD_mecA_LUR3)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

# this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetD_mecA_LUR3)[models[[1]]$indexbestmodel], names(VGOB1_subsetD_mecA_LUR3)[models[[2]]$indexbestmodel] , names(VGOB1_subsetD_mecA_LUR3)[models[[3]]$indexbestmodel], names(VGOB1_subsetD_mecA_LUR3)[models[[4]]$indexbestmodel], names(VGOB1_subsetD_mecA_LUR3)[models[[5]]$indexbestmodel], names(VGOB1_subsetD_mecA_LUR3)[models[[6]]$indexbestmodel], names(VGOB1_subsetD_mecA_LUR3)[models[[7]]$indexbestmodel])

#  this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetD_mecA_LUR3$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetD_mecA_LUR3[,models[[1]]$indexbestmodel]+VGOB1_subsetD_mecA_LUR3[,models[[2]]$indexbestmodel]+VGOB1_subsetD_mecA_LUR3[,models[[3]]$indexbestmodel]+ VGOB1_subsetD_mecA_LUR3[,models[[4]]$indexbestmodel]+ VGOB1_subsetD_mecA_LUR3[,models[[5]]$indexbestmodel]+ VGOB1_subsetD_mecA_LUR3[,models[[6]]$indexbestmodel]+ VGOB1_subsetD_mecA_LUR3[,models[[7]]$indexbestmodel]) 

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[5]]$summarybestmodel
models[[6]]$summarybestmodel
models[[7]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[5]]$namesbestmodel
models[[6]]$namesbestmodel
models[[7]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel
models[[5]]$R2bestmodel
models[[6]]$R2bestmodel
models[[7]]$R2bestmodel

# 8 #  
# add eighth variable (the only difference of the above part is that now modeln=7 the model statement more variables)
# and the call for the list of variable names in the model changed slightly

modeln<-8

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_3 :nlastvar_LUR_3){
  if (is.numeric(VGOB1_subsetD_mecA_LUR3[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetD_mecA_LUR3$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetD_mecA_LUR3[,models[[1]]$indexbestmodel]+VGOB1_subsetD_mecA_LUR3[,models[[2]]$indexbestmodel]+VGOB1_subsetD_mecA_LUR3[,models[[3]]$indexbestmodel]+VGOB1_subsetD_mecA_LUR3[,models[[4]]$indexbestmodel]+VGOB1_subsetD_mecA_LUR3[,models[[5]]$indexbestmodel]+VGOB1_subsetD_mecA_LUR3[,models[[6]]$indexbestmodel]+ VGOB1_subsetD_mecA_LUR3[,models[[7]]$indexbestmodel]+ VGOB1_subsetD_mecA_LUR3[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # Measurements_livestockpreds_LUR3[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR3)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetD_mecA_LUR3)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

# this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetD_mecA_LUR3)[models[[1]]$indexbestmodel], names(VGOB1_subsetD_mecA_LUR3)[models[[2]]$indexbestmodel] , names(VGOB1_subsetD_mecA_LUR3)[models[[3]]$indexbestmodel], names(VGOB1_subsetD_mecA_LUR3)[models[[4]]$indexbestmodel], names(VGOB1_subsetD_mecA_LUR3)[models[[5]]$indexbestmodel], names(VGOB1_subsetD_mecA_LUR3)[models[[6]]$indexbestmodel], names(VGOB1_subsetD_mecA_LUR3)[models[[7]]$indexbestmodel], names(VGOB1_subsetD_mecA_LUR3)[models[[8]]$indexbestmodel])

#  this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetD_mecA_LUR3$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetD_mecA_LUR3[,models[[1]]$indexbestmodel]+VGOB1_subsetD_mecA_LUR3[,models[[2]]$indexbestmodel]+VGOB1_subsetD_mecA_LUR3[,models[[3]]$indexbestmodel]+ VGOB1_subsetD_mecA_LUR3[,models[[4]]$indexbestmodel]+ VGOB1_subsetD_mecA_LUR3[,models[[5]]$indexbestmodel]+ VGOB1_subsetD_mecA_LUR3[,models[[6]]$indexbestmodel]+ VGOB1_subsetD_mecA_LUR3[,models[[7]]$indexbestmodel]+ VGOB1_subsetD_mecA_LUR3[,models[[8]]$indexbestmodel]) 

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[5]]$summarybestmodel
models[[6]]$summarybestmodel
models[[7]]$summarybestmodel
models[[8]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[5]]$namesbestmodel
models[[6]]$namesbestmodel
models[[7]]$namesbestmodel
models[[8]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel
models[[5]]$R2bestmodel
models[[6]]$R2bestmodel
models[[7]]$R2bestmodel
models[[8]]$R2bestmodel

# 9 #  
# add ninth variable (the only difference of the above part is that now modeln=9 the model statement more variables)
# and the call for the list of variable names in the model changed slightly

modeln<-9

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_3 :nlastvar_LUR_3){
  if (is.numeric(VGOB1_subsetD_mecA_LUR3[,i])==TRUE){
      modeltry<-lm(VGOB1_subsetD_mecA_LUR3$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetD_mecA_LUR3[,models[[1]]$indexbestmodel]+VGOB1_subsetD_mecA_LUR3[,models[[2]]$indexbestmodel]+VGOB1_subsetD_mecA_LUR3[,models[[3]]$indexbestmodel]+VGOB1_subsetD_mecA_LUR3[,models[[4]]$indexbestmodel]+VGOB1_subsetD_mecA_LUR3[,models[[5]]$indexbestmodel]+VGOB1_subsetD_mecA_LUR3[,models[[6]]$indexbestmodel]+ VGOB1_subsetD_mecA_LUR3[,models[[7]]$indexbestmodel]+ VGOB1_subsetD_mecA_LUR3[,models[[8]]$indexbestmodel]+ VGOB1_subsetD_mecA_LUR3[,i]) 
        R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # Measurements_livestockpreds_LUR3[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR3)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetD_mecA_LUR3)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

# this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetD_mecA_LUR3)[models[[1]]$indexbestmodel], names(VGOB1_subsetD_mecA_LUR3)[models[[2]]$indexbestmodel] , names(VGOB1_subsetD_mecA_LUR3)[models[[3]]$indexbestmodel], names(VGOB1_subsetD_mecA_LUR3)[models[[4]]$indexbestmodel], names(VGOB1_subsetD_mecA_LUR3)[models[[5]]$indexbestmodel], names(VGOB1_subsetD_mecA_LUR3)[models[[6]]$indexbestmodel], names(VGOB1_subsetD_mecA_LUR3)[models[[7]]$indexbestmodel], names(VGOB1_subsetD_mecA_LUR3)[models[[8]]$indexbestmodel],  names(VGOB1_subsetD_mecA_LUR3)[models[[9]]$indexbestmodel])

#  this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetD_mecA_LUR3$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetD_mecA_LUR3[,models[[1]]$indexbestmodel]+VGOB1_subsetD_mecA_LUR3[,models[[2]]$indexbestmodel]+VGOB1_subsetD_mecA_LUR3[,models[[3]]$indexbestmodel]+ VGOB1_subsetD_mecA_LUR3[,models[[4]]$indexbestmodel]+ VGOB1_subsetD_mecA_LUR3[,models[[5]]$indexbestmodel]+ VGOB1_subsetD_mecA_LUR3[,models[[6]]$indexbestmodel]+ VGOB1_subsetD_mecA_LUR3[,models[[7]]$indexbestmodel]+ VGOB1_subsetD_mecA_LUR3[,models[[8]]$indexbestmodel]+ VGOB1_subsetD_mecA_LUR3[,models[[9]]$indexbestmodel]) 

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[5]]$summarybestmodel
models[[6]]$summarybestmodel
models[[7]]$summarybestmodel
models[[8]]$summarybestmodel
models[[9]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[5]]$namesbestmodel
models[[6]]$namesbestmodel
models[[7]]$namesbestmodel
models[[8]]$namesbestmodel
models[[9]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel
models[[5]]$R2bestmodel
models[[6]]$R2bestmodel
models[[7]]$R2bestmodel
models[[8]]$R2bestmodel
models[[9]]$R2bestmodel

# 10 #  
#  add tenth variable (the only difference of the above part is that now model n=10 the model statement more variables)
#  and the call for the list of variable names in the model changed slightly

modeln<-10

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_3 :nlastvar_LUR_3){if (is.numeric(VGOB1_subsetD_mecA_LUR3[,i])==TRUE){ modeltry<-lm(VGOB1_subsetD_mecA_LUR3$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetD_mecA_LUR3[,models[[1]]$indexbestmodel]+VGOB1_subsetD_mecA_LUR3[,models[[2]]$indexbestmodel]+ VGOB1_subsetD_mecA_LUR3[,models[[3]]$indexbestmodel]+VGOB1_subsetD_mecA_LUR3[,models[[4]]$indexbestmodel]+ VGOB1_subsetD_mecA_LUR3[,models[[5]]$indexbestmodel]+ VGOB1_subsetD_mecA_LUR3[,models[[6]]$indexbestmodel]+ VGOB1_subsetD_mecA_LUR3[,models[[7]]$indexbestmodel]+ VGOB1_subsetD_mecA_LUR3[,models[[8]]$indexbestmodel]+ VGOB1_subsetD_mecA_LUR3[,models[[9]]$indexbestmodel]+ VGOB1_subsetD_mecA_LUR3[,i]) 

R2<-rbind(R2,summary(modeltry)$adj.r.squared)
# the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # Measurements_livestockpreds_LUR3[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR3)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetD_mecA_LUR3)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

# this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

# here are the names
models[[modeln]]$namesbestmodel<-c( names(VGOB1_subsetD_mecA_LUR3)[models[[1]]$indexbestmodel],                   names(VGOB1_subsetD_mecA_LUR3)[models[[2]]$indexbestmodel] , names(VGOB1_subsetD_mecA_LUR3)[models[[3]]$indexbestmodel], names(VGOB1_subsetD_mecA_LUR3)[models[[4]]$indexbestmodel], names(VGOB1_subsetD_mecA_LUR3)[models[[5]]$indexbestmodel], names(VGOB1_subsetD_mecA_LUR3)[models[[6]]$indexbestmodel], names(VGOB1_subsetD_mecA_LUR3)[models[[7]]$indexbestmodel], names(VGOB1_subsetD_mecA_LUR3)[models[[8]]$indexbestmodel], names(VGOB1_subsetD_mecA_LUR3)[models[[9]]$indexbestmodel], names(VGOB1_subsetD_mecA_LUR3)[models[[10]]$indexbestmodel])

#  this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetD_mecA_LUR3$meca_copiespm3.ln.diffmeth.mean~                                VGOB1_subsetD_mecA_LUR3[,models[[1]]$indexbestmodel]+ VGOB1_subsetD_mecA_LUR3[,models[[2]]$indexbestmodel]+                           VGOB1_subsetD_mecA_LUR3[,models[[3]]$indexbestmodel]+ VGOB1_subsetD_mecA_LUR3[,models[[4]]$indexbestmodel]+ VGOB1_subsetD_mecA_LUR3[,models[[5]]$indexbestmodel]+ VGOB1_subsetD_mecA_LUR3[,models[[6]]$indexbestmodel]+ VGOB1_subsetD_mecA_LUR3[,models[[7]]$indexbestmodel]+ VGOB1_subsetD_mecA_LUR3[,models[[8]]$indexbestmodel]+ VGOB1_subsetD_mecA_LUR3[,models[[9]]$indexbestmodel]+ VGOB1_subsetD_mecA_LUR3[,models[[10]]$indexbestmodel]) 

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[5]]$summarybestmodel
models[[6]]$summarybestmodel
models[[7]]$summarybestmodel
models[[8]]$summarybestmodel
models[[9]]$summarybestmodel
models[[10]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[5]]$namesbestmodel
models[[6]]$namesbestmodel
models[[7]]$namesbestmodel
models[[8]]$namesbestmodel
models[[9]]$namesbestmodel
models[[10]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel
models[[5]]$R2bestmodel
models[[6]]$R2bestmodel
models[[7]]$R2bestmodel
models[[8]]$R2bestmodel
models[[9]]$R2bestmodel
models[[10]]$R2bestmodel

#  at this point I always check whether the next model is more than 1% better than the one before and if not I end here

#   CODE FOR PICKING OUT THE BEST MODEL #   
temp <- 0
besti <- 0
for (i in 1:10){ #  think this runs the loop 10 times - not fully sure thought - but not to do with the number of models I don't think - as when I change to 3, I still get the model with 4 variables as best model
  print(models[[i]]$R2bestmodel)
  #       print(models[[i]]$summarybestmodel$coefficients=-1,4])
  #       if((models[[i]]$R2bestmodel-temp > 0.0) && (all(models[[i]]$summarybestmodel$coefficients[-1,4]<0.1))){
  #         temp <- models[[i]]$R2bestmodel
  #         besti <- i
  #         }
  if((models[[i]]$R2bestmodel-temp > 0.0) && (all(models[[i]]$summarybestmodel$coefficients[-1,4]<0.1))){
    temp <- models[[i]]$R2bestmodel
    besti <- i
  }else{
    finalBestModel_mecA_subsetD <- models[[besti]]$bestmodel
    finalBestModelNames_mecA_subsetD <- models[[besti]]$namesbestmodel
    Sites <- 1:dim(VGOB1_subsetD_mecA_LUR3)[1] # full original model
    #  CVaR2<-escCV_mecA_LUR3(Sites)[2] # Cross Validation
    maxCD<-max(cooks.distance(finalBestModel_mecA_subsetD))
    if(length(finalBestModelNames_mecA_subsetD)<2){ # vif fn doesnot work when only 1 variable...       # 
      maxVIF<-"NA"
    }else{
      maxVIF<-max(vif(finalBestModel_mecA_subsetD))
    }
    print(paste("This is the best mecA model for subset D: ",besti,
                "(AdjR2: ",format(models[[besti]]$R2bestmodel,digits=3), "; MaxCD: ",format(maxCD,digits=3),"; MaxVIF: ",
                format(maxVIF,digits=3),")", sep=''))
    print(finalBestModelNames_mecA_subsetD)
    break
  }
}

#  Overview of the final best model using the algorithm selection process (taking into account VIF, R^2, and p-values)
finalBestModel_mecA_subsetD
finalBestModelNames_mecA_subsetD
models[[besti]]$summarybestmodel
models[[besti]]$R2bestmodel


#### E ####
# LUR model building process for subset E
#  This is the dataframe with the relevant predictor vars for LUR3 models for subset E (55 sites)
VGOB1_subsetE_mecA_LUR3 # n.b. this dataframe only includes microbial marker concentrations for mecA unlike the dataframe Measurements_livestockpreds_LUR3 as previously used for the model building. 

#  Now set the values of some variables that will be needed
nfirstvar_LUR_3 <- 3  
nlastvar_LUR_3 <- 135

# Function building to run the models 
# 1 #  

models<-list()
modeln<-1
models[[modeln]]<-list()

R2<-1
betaaddedvar<-1
addedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_3:nlastvar_LUR_3){
  if (is.numeric(VGOB1_subsetE_mecA_LUR3[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetE_mecA_LUR3$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetE_mecA_LUR3[,i])                            
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    #  Measurements_livestockpreds_LUR3[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR3)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetE_mecA_LUR3)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)
models[[modeln]]$results

#  this are the candidates models with the highest R2, not a negative beta for the new, nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)
models[[modeln]]$resultspos

#  rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))
models[[modeln]]$resultspos

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j
models[[modeln]]$indexbestmodel

subset(models[[modeln]]$resultspos, rank==1)
subset(models[[modeln]]$resultspos)

#  this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]
models[[modeln]]$summarybestmodel

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetE_mecA_LUR3)[models[[1]]$indexbestmodel])
models[[modeln]]$namesbestmodel

#  this is the r2 of that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2
models[[modeln]]$R2bestmodel

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetE_mecA_LUR3$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetE_mecA_LUR3[,models[[1]]$indexbestmodel]) 
models[[modeln]]$bestmodel

summary(models[[modeln]]$bestmodel)

#  The first model includes the predictor: nPigMultipFarmWghtDist.3000m.sum.Tr.1P9 - meaning the number of multiplier pig farms weighted to distance in a 3000m buffer

# 2 #  
# Add 2nd variable (the only difference of the above part is that now modeln=2 the model statement has 2 variables)
# and the call for the list of variable names in the model changed slightly

modeln<-2

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_3:nlastvar_LUR_3){
  if (is.numeric(VGOB1_subsetE_mecA_LUR3[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetE_mecA_LUR3$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetE_mecA_LUR3[,models[[1]]$indexbestmodel]+ VGOB1_subsetE_mecA_LUR3[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # Measurements_livestockpreds_LUR3[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR3)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetE_mecA_LUR3)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  these are the candidate models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)
models[[modeln]]$resultspos

#  rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))
models[[modeln]]$resultspos

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j
models[[modeln]]$indexbestmodel

subset(models[[modeln]]$resultspos, rank==1)

# this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]
models[[modeln]]$summarybestmodel

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetE_mecA_LUR3)[models[[1]]$indexbestmodel], names(VGOB1_subsetE_mecA_LUR3)[models[[2]]$indexbestmodel] )
models[[modeln]]$namesbestmodel

# this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2
models[[modeln]]$R2bestmodel

# this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetE_mecA_LUR3$meca_copiespm3.ln.diffmeth.mean~                               VGOB1_subsetE_mecA_LUR3[,models[[1]]$indexbestmodel]+                           VGOB1_subsetE_mecA_LUR3[,models[[2]]$indexbestmodel]) 

models[[modeln]]$bestmodel

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel


# 3 #  
# add third variable (the only difference of the above part is that now modeln=3 the model statement has 3 variables)
# and the call for the list of variable names in the model changed slightly

modeln<-3

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_3:nlastvar_LUR_3){
  if (is.numeric(VGOB1_subsetE_mecA_LUR3[,i])==TRUE){  
    modeltry<-lm(VGOB1_subsetE_mecA_LUR3$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetE_mecA_LUR3[,models[[1]]$indexbestmodel]+VGOB1_subsetE_mecA_LUR3[,models[[2]]$indexbestmodel]+ VGOB1_subsetE_mecA_LUR3[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # All[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR3)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetE_mecA_LUR3)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

#  rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

#  this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

#  here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetE_mecA_LUR3)[models[[1]]$indexbestmodel], names(VGOB1_subsetE_mecA_LUR3)[models[[2]]$indexbestmodel], names(VGOB1_subsetE_mecA_LUR3)[models[[3]]$indexbestmodel])

#  this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetE_mecA_LUR3$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetE_mecA_LUR3[,models[[1]]$indexbestmodel]+ VGOB1_subsetE_mecA_LUR3[,models[[2]]$indexbestmodel]+ VGOB1_subsetE_mecA_LUR3[,models[[3]]$indexbestmodel]) 

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel


# 4 #  
#  add forth variable (the only difference of the above part is that now model n=4 the model statement more variables)
#  and the call for the list of variable names in the model changed slightly
modeln<-4

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1


for (i in nfirstvar_LUR_3:nlastvar_LUR_3){
  if (is.numeric(VGOB1_subsetE_mecA_LUR3[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetE_mecA_LUR3$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetE_mecA_LUR3[,models[[1]]$indexbestmodel]+VGOB1_subsetE_mecA_LUR3[,models[[2]]$indexbestmodel]+VGOB1_subsetE_mecA_LUR3[,models[[3]]$indexbestmodel]+VGOB1_subsetE_mecA_LUR3[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    #  the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    #  All[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR3)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetE_mecA_LUR3)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

#  this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

#  here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetE_mecA_LUR3)[models[[1]]$indexbestmodel], names(VGOB1_subsetE_mecA_LUR3)[models[[2]]$indexbestmodel], names(VGOB1_subsetE_mecA_LUR3)[models[[3]]$indexbestmodel], names(VGOB1_subsetE_mecA_LUR3)[models[[4]]$indexbestmodel])

#  this is the r2 of that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetE_mecA_LUR3$meca_copiespm3.ln.diffmeth.mean~ VGOB1_subsetE_mecA_LUR3[,models[[1]]$indexbestmodel]+ VGOB1_subsetE_mecA_LUR3[,models[[2]]$indexbestmodel]+VGOB1_subsetE_mecA_LUR3[,models[[3]]$indexbestmodel]+ VGOB1_subsetE_mecA_LUR3[,models[[4]]$indexbestmodel]) 


models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel


# 5 #  
# add fifth variable (the only difference of the above part is that now modeln=5 the model statement more variables)
# and the call for the list of variable names in the model changed slightly
modeln<-5

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_3:nlastvar_LUR_3){
  if (is.numeric(VGOB1_subsetE_mecA_LUR3[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetE_mecA_LUR3$meca_copiespm3.ln.diffmeth.mean~ VGOB1_subsetE_mecA_LUR3[,models[[1]]$indexbestmodel]+ VGOB1_subsetE_mecA_LUR3[,models[[2]]$indexbestmodel]+ VGOB1_subsetE_mecA_LUR3[,models[[3]]$indexbestmodel]+ VGOB1_subsetE_mecA_LUR3[,models[[4]]$indexbestmodel]+ VGOB1_subsetE_mecA_LUR3[,i]) 
  
R2<-rbind(R2,summary(modeltry)$adj.r.squared)
# the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # All[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR3)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetE_mecA_LUR3)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

#  this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetE_mecA_LUR3)[models[[1]]$indexbestmodel], names(VGOB1_subsetE_mecA_LUR3)[models[[2]]$indexbestmodel], names(VGOB1_subsetE_mecA_LUR3)[models[[3]]$indexbestmodel], names(VGOB1_subsetE_mecA_LUR3)[models[[4]]$indexbestmodel], names(VGOB1_subsetE_mecA_LUR3)[models[[5]]$indexbestmodel])

#  this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetE_mecA_LUR3$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetE_mecA_LUR3[,models[[1]]$indexbestmodel]+VGOB1_subsetE_mecA_LUR3[,models[[2]]$indexbestmodel]+VGOB1_subsetE_mecA_LUR3[,models[[3]]$indexbestmodel]+ VGOB1_subsetE_mecA_LUR3[,models[[4]]$indexbestmodel]+ VGOB1_subsetE_mecA_LUR3[,models[[5]]$indexbestmodel]) 
models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[5]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[5]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel
models[[5]]$R2bestmodel

# 6 #  
# add sixth variable (the only difference of the above part is that now model n=6 the model statement more variables)
#  and the call for the list of variable names in the model changed slightly

modeln<-6

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_3 :nlastvar_LUR_3){
  if (is.numeric(VGOB1_subsetE_mecA_LUR3[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetE_mecA_LUR3$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetE_mecA_LUR3[,models[[1]]$indexbestmodel]+VGOB1_subsetE_mecA_LUR3[,models[[2]]$indexbestmodel]+VGOB1_subsetE_mecA_LUR3[,models[[3]]$indexbestmodel]+VGOB1_subsetE_mecA_LUR3[,models[[4]]$indexbestmodel]+VGOB1_subsetE_mecA_LUR3[,models[[5]]$indexbestmodel]+ VGOB1_subsetE_mecA_LUR3[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # All[,i] is the row that's being tried out now. the name of that row can be found in  names(All)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetE_mecA_LUR3)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

# this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetE_mecA_LUR3)[models[[1]]$indexbestmodel], names(VGOB1_subsetE_mecA_LUR3)[models[[2]]$indexbestmodel] , names(VGOB1_subsetE_mecA_LUR3)[models[[3]]$indexbestmodel], names(VGOB1_subsetE_mecA_LUR3)[models[[4]]$indexbestmodel], names(VGOB1_subsetE_mecA_LUR3)[models[[5]]$indexbestmodel], names(VGOB1_subsetE_mecA_LUR3)[models[[6]]$indexbestmodel])

#  this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetE_mecA_LUR3$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetE_mecA_LUR3[,models[[1]]$indexbestmodel]+VGOB1_subsetE_mecA_LUR3[,models[[2]]$indexbestmodel]+VGOB1_subsetE_mecA_LUR3[,models[[3]]$indexbestmodel]+ VGOB1_subsetE_mecA_LUR3[,models[[4]]$indexbestmodel]+ VGOB1_subsetE_mecA_LUR3[,models[[5]]$indexbestmodel]+ VGOB1_subsetE_mecA_LUR3[,models[[6]]$indexbestmodel]) 

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[5]]$summarybestmodel
models[[6]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[5]]$namesbestmodel
models[[6]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel
models[[5]]$R2bestmodel
models[[6]]$R2bestmodel


# 7 #  
# add seventh variable (the only difference of the above part is that now model n=7 the model statement more variables)
#  and the call for the list of variable names in the model changed slightly

modeln<-7

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_3 :nlastvar_LUR_3){
  if (is.numeric(VGOB1_subsetE_mecA_LUR3[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetE_mecA_LUR3$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetE_mecA_LUR3[,models[[1]]$indexbestmodel]+VGOB1_subsetE_mecA_LUR3[,models[[2]]$indexbestmodel]+VGOB1_subsetE_mecA_LUR3[,models[[3]]$indexbestmodel]+VGOB1_subsetE_mecA_LUR3[,models[[4]]$indexbestmodel]+VGOB1_subsetE_mecA_LUR3[,models[[5]]$indexbestmodel]+VGOB1_subsetE_mecA_LUR3[,models[[6]]$indexbestmodel]+ VGOB1_subsetE_mecA_LUR3[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # Measurements_livestockpreds_LUR3[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR3)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetE_mecA_LUR3)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

# this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetE_mecA_LUR3)[models[[1]]$indexbestmodel], names(VGOB1_subsetE_mecA_LUR3)[models[[2]]$indexbestmodel] , names(VGOB1_subsetE_mecA_LUR3)[models[[3]]$indexbestmodel], names(VGOB1_subsetE_mecA_LUR3)[models[[4]]$indexbestmodel], names(VGOB1_subsetE_mecA_LUR3)[models[[5]]$indexbestmodel], names(VGOB1_subsetE_mecA_LUR3)[models[[6]]$indexbestmodel], names(VGOB1_subsetE_mecA_LUR3)[models[[7]]$indexbestmodel])

#  this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetE_mecA_LUR3$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetE_mecA_LUR3[,models[[1]]$indexbestmodel]+VGOB1_subsetE_mecA_LUR3[,models[[2]]$indexbestmodel]+VGOB1_subsetE_mecA_LUR3[,models[[3]]$indexbestmodel]+ VGOB1_subsetE_mecA_LUR3[,models[[4]]$indexbestmodel]+ VGOB1_subsetE_mecA_LUR3[,models[[5]]$indexbestmodel]+ VGOB1_subsetE_mecA_LUR3[,models[[6]]$indexbestmodel]+ VGOB1_subsetE_mecA_LUR3[,models[[7]]$indexbestmodel]) 

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[5]]$summarybestmodel
models[[6]]$summarybestmodel
models[[7]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[5]]$namesbestmodel
models[[6]]$namesbestmodel
models[[7]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel
models[[5]]$R2bestmodel
models[[6]]$R2bestmodel
models[[7]]$R2bestmodel

# 8 #  
# add eighth variable (the only difference of the above part is that now modeln=7 the model statement more variables)
# and the call for the list of variable names in the model changed slightly

modeln<-8

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_3 :nlastvar_LUR_3){
  if (is.numeric(VGOB1_subsetE_mecA_LUR3[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetE_mecA_LUR3$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetE_mecA_LUR3[,models[[1]]$indexbestmodel]+VGOB1_subsetE_mecA_LUR3[,models[[2]]$indexbestmodel]+VGOB1_subsetE_mecA_LUR3[,models[[3]]$indexbestmodel]+VGOB1_subsetE_mecA_LUR3[,models[[4]]$indexbestmodel]+VGOB1_subsetE_mecA_LUR3[,models[[5]]$indexbestmodel]+VGOB1_subsetE_mecA_LUR3[,models[[6]]$indexbestmodel]+ VGOB1_subsetE_mecA_LUR3[,models[[7]]$indexbestmodel]+ VGOB1_subsetE_mecA_LUR3[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # Measurements_livestockpreds_LUR3[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR3)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetE_mecA_LUR3)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

# this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetE_mecA_LUR3)[models[[1]]$indexbestmodel], names(VGOB1_subsetE_mecA_LUR3)[models[[2]]$indexbestmodel] , names(VGOB1_subsetE_mecA_LUR3)[models[[3]]$indexbestmodel], names(VGOB1_subsetE_mecA_LUR3)[models[[4]]$indexbestmodel], names(VGOB1_subsetE_mecA_LUR3)[models[[5]]$indexbestmodel], names(VGOB1_subsetE_mecA_LUR3)[models[[6]]$indexbestmodel], names(VGOB1_subsetE_mecA_LUR3)[models[[7]]$indexbestmodel], names(VGOB1_subsetE_mecA_LUR3)[models[[8]]$indexbestmodel])

#  this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetE_mecA_LUR3$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetE_mecA_LUR3[,models[[1]]$indexbestmodel]+VGOB1_subsetE_mecA_LUR3[,models[[2]]$indexbestmodel]+VGOB1_subsetE_mecA_LUR3[,models[[3]]$indexbestmodel]+ VGOB1_subsetE_mecA_LUR3[,models[[4]]$indexbestmodel]+ VGOB1_subsetE_mecA_LUR3[,models[[5]]$indexbestmodel]+ VGOB1_subsetE_mecA_LUR3[,models[[6]]$indexbestmodel]+ VGOB1_subsetE_mecA_LUR3[,models[[7]]$indexbestmodel]+ VGOB1_subsetE_mecA_LUR3[,models[[8]]$indexbestmodel]) 

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[5]]$summarybestmodel
models[[6]]$summarybestmodel
models[[7]]$summarybestmodel
models[[8]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[5]]$namesbestmodel
models[[6]]$namesbestmodel
models[[7]]$namesbestmodel
models[[8]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel
models[[5]]$R2bestmodel
models[[6]]$R2bestmodel
models[[7]]$R2bestmodel
models[[8]]$R2bestmodel

# 9 #  
# add ninth variable (the only difference of the above part is that now modeln=9 the model statement more variables)
# and the call for the list of variable names in the model changed slightly

modeln<-9

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_3 :nlastvar_LUR_3){
  if (is.numeric(VGOB1_subsetE_mecA_LUR3[,i])==TRUE){
      modeltry<-lm(VGOB1_subsetE_mecA_LUR3$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetE_mecA_LUR3[,models[[1]]$indexbestmodel]+VGOB1_subsetE_mecA_LUR3[,models[[2]]$indexbestmodel]+VGOB1_subsetE_mecA_LUR3[,models[[3]]$indexbestmodel]+VGOB1_subsetE_mecA_LUR3[,models[[4]]$indexbestmodel]+VGOB1_subsetE_mecA_LUR3[,models[[5]]$indexbestmodel]+VGOB1_subsetE_mecA_LUR3[,models[[6]]$indexbestmodel]+ VGOB1_subsetE_mecA_LUR3[,models[[7]]$indexbestmodel]+ VGOB1_subsetE_mecA_LUR3[,models[[8]]$indexbestmodel]+ VGOB1_subsetE_mecA_LUR3[,i]) 
        R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # Measurements_livestockpreds_LUR3[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR3)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetE_mecA_LUR3)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

# this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetE_mecA_LUR3)[models[[1]]$indexbestmodel], names(VGOB1_subsetE_mecA_LUR3)[models[[2]]$indexbestmodel] , names(VGOB1_subsetE_mecA_LUR3)[models[[3]]$indexbestmodel], names(VGOB1_subsetE_mecA_LUR3)[models[[4]]$indexbestmodel], names(VGOB1_subsetE_mecA_LUR3)[models[[5]]$indexbestmodel], names(VGOB1_subsetE_mecA_LUR3)[models[[6]]$indexbestmodel], names(VGOB1_subsetE_mecA_LUR3)[models[[7]]$indexbestmodel], names(VGOB1_subsetE_mecA_LUR3)[models[[8]]$indexbestmodel],  names(VGOB1_subsetE_mecA_LUR3)[models[[9]]$indexbestmodel])

#  this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetE_mecA_LUR3$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetE_mecA_LUR3[,models[[1]]$indexbestmodel]+VGOB1_subsetE_mecA_LUR3[,models[[2]]$indexbestmodel]+VGOB1_subsetE_mecA_LUR3[,models[[3]]$indexbestmodel]+ VGOB1_subsetE_mecA_LUR3[,models[[4]]$indexbestmodel]+ VGOB1_subsetE_mecA_LUR3[,models[[5]]$indexbestmodel]+ VGOB1_subsetE_mecA_LUR3[,models[[6]]$indexbestmodel]+ VGOB1_subsetE_mecA_LUR3[,models[[7]]$indexbestmodel]+ VGOB1_subsetE_mecA_LUR3[,models[[8]]$indexbestmodel]+ VGOB1_subsetE_mecA_LUR3[,models[[9]]$indexbestmodel]) 

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[5]]$summarybestmodel
models[[6]]$summarybestmodel
models[[7]]$summarybestmodel
models[[8]]$summarybestmodel
models[[9]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[5]]$namesbestmodel
models[[6]]$namesbestmodel
models[[7]]$namesbestmodel
models[[8]]$namesbestmodel
models[[9]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel
models[[5]]$R2bestmodel
models[[6]]$R2bestmodel
models[[7]]$R2bestmodel
models[[8]]$R2bestmodel
models[[9]]$R2bestmodel

# 10 #  
#  add tenth variable (the only difference of the above part is that now model n=10 the model statement more variables)
#  and the call for the list of variable names in the model changed slightly

modeln<-10

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_3 :nlastvar_LUR_3){if (is.numeric(VGOB1_subsetE_mecA_LUR3[,i])==TRUE){ modeltry<-lm(VGOB1_subsetE_mecA_LUR3$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetE_mecA_LUR3[,models[[1]]$indexbestmodel]+VGOB1_subsetE_mecA_LUR3[,models[[2]]$indexbestmodel]+ VGOB1_subsetE_mecA_LUR3[,models[[3]]$indexbestmodel]+VGOB1_subsetE_mecA_LUR3[,models[[4]]$indexbestmodel]+ VGOB1_subsetE_mecA_LUR3[,models[[5]]$indexbestmodel]+ VGOB1_subsetE_mecA_LUR3[,models[[6]]$indexbestmodel]+ VGOB1_subsetE_mecA_LUR3[,models[[7]]$indexbestmodel]+ VGOB1_subsetE_mecA_LUR3[,models[[8]]$indexbestmodel]+ VGOB1_subsetE_mecA_LUR3[,models[[9]]$indexbestmodel]+ VGOB1_subsetE_mecA_LUR3[,i]) 

R2<-rbind(R2,summary(modeltry)$adj.r.squared)
# the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # Measurements_livestockpreds_LUR3[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR3)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetE_mecA_LUR3)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

# this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

# here are the names
models[[modeln]]$namesbestmodel<-c( names(VGOB1_subsetE_mecA_LUR3)[models[[1]]$indexbestmodel],                   names(VGOB1_subsetE_mecA_LUR3)[models[[2]]$indexbestmodel] , names(VGOB1_subsetE_mecA_LUR3)[models[[3]]$indexbestmodel], names(VGOB1_subsetE_mecA_LUR3)[models[[4]]$indexbestmodel], names(VGOB1_subsetE_mecA_LUR3)[models[[5]]$indexbestmodel], names(VGOB1_subsetE_mecA_LUR3)[models[[6]]$indexbestmodel], names(VGOB1_subsetE_mecA_LUR3)[models[[7]]$indexbestmodel], names(VGOB1_subsetE_mecA_LUR3)[models[[8]]$indexbestmodel], names(VGOB1_subsetE_mecA_LUR3)[models[[9]]$indexbestmodel], names(VGOB1_subsetE_mecA_LUR3)[models[[10]]$indexbestmodel])

#  this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetE_mecA_LUR3$meca_copiespm3.ln.diffmeth.mean~                                VGOB1_subsetE_mecA_LUR3[,models[[1]]$indexbestmodel]+ VGOB1_subsetE_mecA_LUR3[,models[[2]]$indexbestmodel]+                           VGOB1_subsetE_mecA_LUR3[,models[[3]]$indexbestmodel]+ VGOB1_subsetE_mecA_LUR3[,models[[4]]$indexbestmodel]+ VGOB1_subsetE_mecA_LUR3[,models[[5]]$indexbestmodel]+ VGOB1_subsetE_mecA_LUR3[,models[[6]]$indexbestmodel]+ VGOB1_subsetE_mecA_LUR3[,models[[7]]$indexbestmodel]+ VGOB1_subsetE_mecA_LUR3[,models[[8]]$indexbestmodel]+ VGOB1_subsetE_mecA_LUR3[,models[[9]]$indexbestmodel]+ VGOB1_subsetE_mecA_LUR3[,models[[10]]$indexbestmodel]) 

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[5]]$summarybestmodel
models[[6]]$summarybestmodel
models[[7]]$summarybestmodel
models[[8]]$summarybestmodel
models[[9]]$summarybestmodel
models[[10]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[5]]$namesbestmodel
models[[6]]$namesbestmodel
models[[7]]$namesbestmodel
models[[8]]$namesbestmodel
models[[9]]$namesbestmodel
models[[10]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel
models[[5]]$R2bestmodel
models[[6]]$R2bestmodel
models[[7]]$R2bestmodel
models[[8]]$R2bestmodel
models[[9]]$R2bestmodel
models[[10]]$R2bestmodel

#  at this point I always check whether the next model is more than 1% better than the one before and if not I end here

#   CODE FOR PICKING OUT THE BEST MODEL #   
temp <- 0
besti <- 0
for (i in 1:10){ #  think this runs the loop 10 times - not fully sure thought - but not to do with the number of models I don't think - as when I change to 3, I still get the model with 4 variables as best model
  print(models[[i]]$R2bestmodel)
  #       print(models[[i]]$summarybestmodel$coefficients=-1,4])
  #       if((models[[i]]$R2bestmodel-temp > 0.0) && (all(models[[i]]$summarybestmodel$coefficients[-1,4]<0.1))){
  #         temp <- models[[i]]$R2bestmodel
  #         besti <- i
  #         }
  if((models[[i]]$R2bestmodel-temp > 0.0) && (all(models[[i]]$summarybestmodel$coefficients[-1,4]<0.1))){
    temp <- models[[i]]$R2bestmodel
    besti <- i
  }else{
    finalBestModel_mecA_subsetE <- models[[besti]]$bestmodel
    finalBestModelNames_mecA_subsetE <- models[[besti]]$namesbestmodel
    Sites <- 1:dim(VGOB1_subsetE_mecA_LUR3)[1] # full original model
    #  CVaR2<-escCV_mecA_LUR3(Sites)[2] # Cross Validation
    maxCD<-max(cooks.distance(finalBestModel_mecA_subsetE))
    if(length(finalBestModelNames_mecA_subsetE)<2){ # vif fn doesnot work when only 1 variable...       # 
      maxVIF<-"NA"
    }else{
      maxVIF<-max(vif(finalBestModel_mecA_subsetE))
    }
    print(paste("This is the best mecA model for subset E: ",besti,
                "(AdjR2: ",format(models[[besti]]$R2bestmodel,digits=3), "; MaxCD: ",format(maxCD,digits=3),"; MaxVIF: ",
                format(maxVIF,digits=3),")", sep=''))
    print(finalBestModelNames_mecA_subsetE)
    break
  }
}

#  Overview of the final best model using the algorithm selection process (taking into account VIF, R^2, and p-values)
finalBestModel_mecA_subsetE
finalBestModelNames_mecA_subsetE
models[[besti]]$summarybestmodel
models[[besti]]$R2bestmodel

#### F ####
# LUR model building process for subset F
#  This is the dataframe with the relevant predictor vars for LUR3 models for subset F (55 sites)
VGOB1_subsetF_mecA_LUR3 # n.b. this dataframe only includes microbial marker concentrations for mecA unlike the dataframe Measurements_livestockpreds_LUR3 as previously used for the model building. 

#  Now set the values of some variables that will be needed
nfirstvar_LUR_3 <- 3  
nlastvar_LUR_3 <- 135

# Function building to run the models 
# 1 #  

models<-list()
modeln<-1
models[[modeln]]<-list()

R2<-1
betaaddedvar<-1
addedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_3:nlastvar_LUR_3){
  if (is.numeric(VGOB1_subsetF_mecA_LUR3[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetF_mecA_LUR3$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetF_mecA_LUR3[,i])                            
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    #  Measurements_livestockpreds_LUR3[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR3)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetF_mecA_LUR3)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)
models[[modeln]]$results

#  this are the candidates models with the highest R2, not a negative beta for the new, nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)
models[[modeln]]$resultspos

#  rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))
models[[modeln]]$resultspos

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j
models[[modeln]]$indexbestmodel

subset(models[[modeln]]$resultspos, rank==1)
subset(models[[modeln]]$resultspos)

#  this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]
models[[modeln]]$summarybestmodel

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetF_mecA_LUR3)[models[[1]]$indexbestmodel])
models[[modeln]]$namesbestmodel

#  this is the r2 of that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2
models[[modeln]]$R2bestmodel

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetF_mecA_LUR3$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetF_mecA_LUR3[,models[[1]]$indexbestmodel]) 
models[[modeln]]$bestmodel

summary(models[[modeln]]$bestmodel)

#  The first model includes the predictor: nPigMultipFarmWghtDist.3000m.sum.Tr.1P9 - meaning the number of multiplier pig farms weighted to distance in a 3000m buffer

# 2 #  
# Add 2nd variable (the only difference of the above part is that now modeln=2 the model statement has 2 variables)
# and the call for the list of variable names in the model changed slightly

modeln<-2

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_3:nlastvar_LUR_3){
  if (is.numeric(VGOB1_subsetF_mecA_LUR3[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetF_mecA_LUR3$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetF_mecA_LUR3[,models[[1]]$indexbestmodel]+ VGOB1_subsetF_mecA_LUR3[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # Measurements_livestockpreds_LUR3[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR3)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetF_mecA_LUR3)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  these are the candidate models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)
models[[modeln]]$resultspos

#  rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))
models[[modeln]]$resultspos

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j
models[[modeln]]$indexbestmodel

subset(models[[modeln]]$resultspos, rank==1)

# this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]
models[[modeln]]$summarybestmodel

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetF_mecA_LUR3)[models[[1]]$indexbestmodel], names(VGOB1_subsetF_mecA_LUR3)[models[[2]]$indexbestmodel] )
models[[modeln]]$namesbestmodel

# this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2
models[[modeln]]$R2bestmodel

# this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetF_mecA_LUR3$meca_copiespm3.ln.diffmeth.mean~                               VGOB1_subsetF_mecA_LUR3[,models[[1]]$indexbestmodel]+                           VGOB1_subsetF_mecA_LUR3[,models[[2]]$indexbestmodel]) 

models[[modeln]]$bestmodel

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel


# 3 #  
# add third variable (the only difference of the above part is that now modeln=3 the model statement has 3 variables)
# and the call for the list of variable names in the model changed slightly

modeln<-3

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_3:nlastvar_LUR_3){
  if (is.numeric(VGOB1_subsetF_mecA_LUR3[,i])==TRUE){  
    modeltry<-lm(VGOB1_subsetF_mecA_LUR3$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetF_mecA_LUR3[,models[[1]]$indexbestmodel]+VGOB1_subsetF_mecA_LUR3[,models[[2]]$indexbestmodel]+ VGOB1_subsetF_mecA_LUR3[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # All[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR3)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetF_mecA_LUR3)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

#  rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

#  this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

#  here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetF_mecA_LUR3)[models[[1]]$indexbestmodel], names(VGOB1_subsetF_mecA_LUR3)[models[[2]]$indexbestmodel], names(VGOB1_subsetF_mecA_LUR3)[models[[3]]$indexbestmodel])

#  this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetF_mecA_LUR3$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetF_mecA_LUR3[,models[[1]]$indexbestmodel]+ VGOB1_subsetF_mecA_LUR3[,models[[2]]$indexbestmodel]+ VGOB1_subsetF_mecA_LUR3[,models[[3]]$indexbestmodel]) 

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel


# 4 #  
#  add forth variable (the only difference of the above part is that now model n=4 the model statement more variables)
#  and the call for the list of variable names in the model changed slightly
modeln<-4

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1


for (i in nfirstvar_LUR_3:nlastvar_LUR_3){
  if (is.numeric(VGOB1_subsetF_mecA_LUR3[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetF_mecA_LUR3$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetF_mecA_LUR3[,models[[1]]$indexbestmodel]+VGOB1_subsetF_mecA_LUR3[,models[[2]]$indexbestmodel]+VGOB1_subsetF_mecA_LUR3[,models[[3]]$indexbestmodel]+VGOB1_subsetF_mecA_LUR3[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    #  the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    #  All[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR3)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetF_mecA_LUR3)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

#  this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

#  here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetF_mecA_LUR3)[models[[1]]$indexbestmodel], names(VGOB1_subsetF_mecA_LUR3)[models[[2]]$indexbestmodel], names(VGOB1_subsetF_mecA_LUR3)[models[[3]]$indexbestmodel], names(VGOB1_subsetF_mecA_LUR3)[models[[4]]$indexbestmodel])

#  this is the r2 of that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetF_mecA_LUR3$meca_copiespm3.ln.diffmeth.mean~ VGOB1_subsetF_mecA_LUR3[,models[[1]]$indexbestmodel]+ VGOB1_subsetF_mecA_LUR3[,models[[2]]$indexbestmodel]+VGOB1_subsetF_mecA_LUR3[,models[[3]]$indexbestmodel]+ VGOB1_subsetF_mecA_LUR3[,models[[4]]$indexbestmodel]) 


models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel


# 5 #  
# add fifth variable (the only difference of the above part is that now modeln=5 the model statement more variables)
# and the call for the list of variable names in the model changed slightly
modeln<-5

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_3:nlastvar_LUR_3){
  if (is.numeric(VGOB1_subsetF_mecA_LUR3[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetF_mecA_LUR3$meca_copiespm3.ln.diffmeth.mean~ VGOB1_subsetF_mecA_LUR3[,models[[1]]$indexbestmodel]+ VGOB1_subsetF_mecA_LUR3[,models[[2]]$indexbestmodel]+ VGOB1_subsetF_mecA_LUR3[,models[[3]]$indexbestmodel]+ VGOB1_subsetF_mecA_LUR3[,models[[4]]$indexbestmodel]+ VGOB1_subsetF_mecA_LUR3[,i]) 
  
R2<-rbind(R2,summary(modeltry)$adj.r.squared)
# the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # All[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR3)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetF_mecA_LUR3)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

#  this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetF_mecA_LUR3)[models[[1]]$indexbestmodel], names(VGOB1_subsetF_mecA_LUR3)[models[[2]]$indexbestmodel], names(VGOB1_subsetF_mecA_LUR3)[models[[3]]$indexbestmodel], names(VGOB1_subsetF_mecA_LUR3)[models[[4]]$indexbestmodel], names(VGOB1_subsetF_mecA_LUR3)[models[[5]]$indexbestmodel])

#  this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetF_mecA_LUR3$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetF_mecA_LUR3[,models[[1]]$indexbestmodel]+VGOB1_subsetF_mecA_LUR3[,models[[2]]$indexbestmodel]+VGOB1_subsetF_mecA_LUR3[,models[[3]]$indexbestmodel]+ VGOB1_subsetF_mecA_LUR3[,models[[4]]$indexbestmodel]+ VGOB1_subsetF_mecA_LUR3[,models[[5]]$indexbestmodel]) 
models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[5]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[5]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel
models[[5]]$R2bestmodel

# 6 #  
# add sixth variable (the only difference of the above part is that now model n=6 the model statement more variables)
#  and the call for the list of variable names in the model changed slightly

modeln<-6

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_3 :nlastvar_LUR_3){
  if (is.numeric(VGOB1_subsetF_mecA_LUR3[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetF_mecA_LUR3$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetF_mecA_LUR3[,models[[1]]$indexbestmodel]+VGOB1_subsetF_mecA_LUR3[,models[[2]]$indexbestmodel]+VGOB1_subsetF_mecA_LUR3[,models[[3]]$indexbestmodel]+VGOB1_subsetF_mecA_LUR3[,models[[4]]$indexbestmodel]+VGOB1_subsetF_mecA_LUR3[,models[[5]]$indexbestmodel]+ VGOB1_subsetF_mecA_LUR3[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # All[,i] is the row that's being tried out now. the name of that row can be found in  names(All)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetF_mecA_LUR3)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

# this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetF_mecA_LUR3)[models[[1]]$indexbestmodel], names(VGOB1_subsetF_mecA_LUR3)[models[[2]]$indexbestmodel] , names(VGOB1_subsetF_mecA_LUR3)[models[[3]]$indexbestmodel], names(VGOB1_subsetF_mecA_LUR3)[models[[4]]$indexbestmodel], names(VGOB1_subsetF_mecA_LUR3)[models[[5]]$indexbestmodel], names(VGOB1_subsetF_mecA_LUR3)[models[[6]]$indexbestmodel])

#  this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetF_mecA_LUR3$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetF_mecA_LUR3[,models[[1]]$indexbestmodel]+VGOB1_subsetF_mecA_LUR3[,models[[2]]$indexbestmodel]+VGOB1_subsetF_mecA_LUR3[,models[[3]]$indexbestmodel]+ VGOB1_subsetF_mecA_LUR3[,models[[4]]$indexbestmodel]+ VGOB1_subsetF_mecA_LUR3[,models[[5]]$indexbestmodel]+ VGOB1_subsetF_mecA_LUR3[,models[[6]]$indexbestmodel]) 

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[5]]$summarybestmodel
models[[6]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[5]]$namesbestmodel
models[[6]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel
models[[5]]$R2bestmodel
models[[6]]$R2bestmodel


# 7 #  
# add seventh variable (the only difference of the above part is that now model n=7 the model statement more variables)
#  and the call for the list of variable names in the model changed slightly

modeln<-7

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_3 :nlastvar_LUR_3){
  if (is.numeric(VGOB1_subsetF_mecA_LUR3[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetF_mecA_LUR3$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetF_mecA_LUR3[,models[[1]]$indexbestmodel]+VGOB1_subsetF_mecA_LUR3[,models[[2]]$indexbestmodel]+VGOB1_subsetF_mecA_LUR3[,models[[3]]$indexbestmodel]+VGOB1_subsetF_mecA_LUR3[,models[[4]]$indexbestmodel]+VGOB1_subsetF_mecA_LUR3[,models[[5]]$indexbestmodel]+VGOB1_subsetF_mecA_LUR3[,models[[6]]$indexbestmodel]+ VGOB1_subsetF_mecA_LUR3[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # Measurements_livestockpreds_LUR3[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR3)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetF_mecA_LUR3)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

# this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetF_mecA_LUR3)[models[[1]]$indexbestmodel], names(VGOB1_subsetF_mecA_LUR3)[models[[2]]$indexbestmodel] , names(VGOB1_subsetF_mecA_LUR3)[models[[3]]$indexbestmodel], names(VGOB1_subsetF_mecA_LUR3)[models[[4]]$indexbestmodel], names(VGOB1_subsetF_mecA_LUR3)[models[[5]]$indexbestmodel], names(VGOB1_subsetF_mecA_LUR3)[models[[6]]$indexbestmodel], names(VGOB1_subsetF_mecA_LUR3)[models[[7]]$indexbestmodel])

#  this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetF_mecA_LUR3$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetF_mecA_LUR3[,models[[1]]$indexbestmodel]+VGOB1_subsetF_mecA_LUR3[,models[[2]]$indexbestmodel]+VGOB1_subsetF_mecA_LUR3[,models[[3]]$indexbestmodel]+ VGOB1_subsetF_mecA_LUR3[,models[[4]]$indexbestmodel]+ VGOB1_subsetF_mecA_LUR3[,models[[5]]$indexbestmodel]+ VGOB1_subsetF_mecA_LUR3[,models[[6]]$indexbestmodel]+ VGOB1_subsetF_mecA_LUR3[,models[[7]]$indexbestmodel]) 

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[5]]$summarybestmodel
models[[6]]$summarybestmodel
models[[7]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[5]]$namesbestmodel
models[[6]]$namesbestmodel
models[[7]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel
models[[5]]$R2bestmodel
models[[6]]$R2bestmodel
models[[7]]$R2bestmodel

# 8 #  
# add eighth variable (the only difference of the above part is that now modeln=7 the model statement more variables)
# and the call for the list of variable names in the model changed slightly

modeln<-8

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_3 :nlastvar_LUR_3){
  if (is.numeric(VGOB1_subsetF_mecA_LUR3[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetF_mecA_LUR3$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetF_mecA_LUR3[,models[[1]]$indexbestmodel]+VGOB1_subsetF_mecA_LUR3[,models[[2]]$indexbestmodel]+VGOB1_subsetF_mecA_LUR3[,models[[3]]$indexbestmodel]+VGOB1_subsetF_mecA_LUR3[,models[[4]]$indexbestmodel]+VGOB1_subsetF_mecA_LUR3[,models[[5]]$indexbestmodel]+VGOB1_subsetF_mecA_LUR3[,models[[6]]$indexbestmodel]+ VGOB1_subsetF_mecA_LUR3[,models[[7]]$indexbestmodel]+ VGOB1_subsetF_mecA_LUR3[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # Measurements_livestockpreds_LUR3[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR3)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetF_mecA_LUR3)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

# this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetF_mecA_LUR3)[models[[1]]$indexbestmodel], names(VGOB1_subsetF_mecA_LUR3)[models[[2]]$indexbestmodel] , names(VGOB1_subsetF_mecA_LUR3)[models[[3]]$indexbestmodel], names(VGOB1_subsetF_mecA_LUR3)[models[[4]]$indexbestmodel], names(VGOB1_subsetF_mecA_LUR3)[models[[5]]$indexbestmodel], names(VGOB1_subsetF_mecA_LUR3)[models[[6]]$indexbestmodel], names(VGOB1_subsetF_mecA_LUR3)[models[[7]]$indexbestmodel], names(VGOB1_subsetF_mecA_LUR3)[models[[8]]$indexbestmodel])

#  this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetF_mecA_LUR3$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetF_mecA_LUR3[,models[[1]]$indexbestmodel]+VGOB1_subsetF_mecA_LUR3[,models[[2]]$indexbestmodel]+VGOB1_subsetF_mecA_LUR3[,models[[3]]$indexbestmodel]+ VGOB1_subsetF_mecA_LUR3[,models[[4]]$indexbestmodel]+ VGOB1_subsetF_mecA_LUR3[,models[[5]]$indexbestmodel]+ VGOB1_subsetF_mecA_LUR3[,models[[6]]$indexbestmodel]+ VGOB1_subsetF_mecA_LUR3[,models[[7]]$indexbestmodel]+ VGOB1_subsetF_mecA_LUR3[,models[[8]]$indexbestmodel]) 

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[5]]$summarybestmodel
models[[6]]$summarybestmodel
models[[7]]$summarybestmodel
models[[8]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[5]]$namesbestmodel
models[[6]]$namesbestmodel
models[[7]]$namesbestmodel
models[[8]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel
models[[5]]$R2bestmodel
models[[6]]$R2bestmodel
models[[7]]$R2bestmodel
models[[8]]$R2bestmodel

# 9 #  
# add ninth variable (the only difference of the above part is that now modeln=9 the model statement more variables)
# and the call for the list of variable names in the model changed slightly

modeln<-9

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_3 :nlastvar_LUR_3){
  if (is.numeric(VGOB1_subsetF_mecA_LUR3[,i])==TRUE){
      modeltry<-lm(VGOB1_subsetF_mecA_LUR3$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetF_mecA_LUR3[,models[[1]]$indexbestmodel]+VGOB1_subsetF_mecA_LUR3[,models[[2]]$indexbestmodel]+VGOB1_subsetF_mecA_LUR3[,models[[3]]$indexbestmodel]+VGOB1_subsetF_mecA_LUR3[,models[[4]]$indexbestmodel]+VGOB1_subsetF_mecA_LUR3[,models[[5]]$indexbestmodel]+VGOB1_subsetF_mecA_LUR3[,models[[6]]$indexbestmodel]+ VGOB1_subsetF_mecA_LUR3[,models[[7]]$indexbestmodel]+ VGOB1_subsetF_mecA_LUR3[,models[[8]]$indexbestmodel]+ VGOB1_subsetF_mecA_LUR3[,i]) 
        R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # Measurements_livestockpreds_LUR3[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR3)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetF_mecA_LUR3)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

# this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetF_mecA_LUR3)[models[[1]]$indexbestmodel], names(VGOB1_subsetF_mecA_LUR3)[models[[2]]$indexbestmodel] , names(VGOB1_subsetF_mecA_LUR3)[models[[3]]$indexbestmodel], names(VGOB1_subsetF_mecA_LUR3)[models[[4]]$indexbestmodel], names(VGOB1_subsetF_mecA_LUR3)[models[[5]]$indexbestmodel], names(VGOB1_subsetF_mecA_LUR3)[models[[6]]$indexbestmodel], names(VGOB1_subsetF_mecA_LUR3)[models[[7]]$indexbestmodel], names(VGOB1_subsetF_mecA_LUR3)[models[[8]]$indexbestmodel],  names(VGOB1_subsetF_mecA_LUR3)[models[[9]]$indexbestmodel])

#  this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetF_mecA_LUR3$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetF_mecA_LUR3[,models[[1]]$indexbestmodel]+VGOB1_subsetF_mecA_LUR3[,models[[2]]$indexbestmodel]+VGOB1_subsetF_mecA_LUR3[,models[[3]]$indexbestmodel]+ VGOB1_subsetF_mecA_LUR3[,models[[4]]$indexbestmodel]+ VGOB1_subsetF_mecA_LUR3[,models[[5]]$indexbestmodel]+ VGOB1_subsetF_mecA_LUR3[,models[[6]]$indexbestmodel]+ VGOB1_subsetF_mecA_LUR3[,models[[7]]$indexbestmodel]+ VGOB1_subsetF_mecA_LUR3[,models[[8]]$indexbestmodel]+ VGOB1_subsetF_mecA_LUR3[,models[[9]]$indexbestmodel]) 

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[5]]$summarybestmodel
models[[6]]$summarybestmodel
models[[7]]$summarybestmodel
models[[8]]$summarybestmodel
models[[9]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[5]]$namesbestmodel
models[[6]]$namesbestmodel
models[[7]]$namesbestmodel
models[[8]]$namesbestmodel
models[[9]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel
models[[5]]$R2bestmodel
models[[6]]$R2bestmodel
models[[7]]$R2bestmodel
models[[8]]$R2bestmodel
models[[9]]$R2bestmodel

# 10 #  
#  add tenth variable (the only difference of the above part is that now model n=10 the model statement more variables)
#  and the call for the list of variable names in the model changed slightly

modeln<-10

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_3 :nlastvar_LUR_3){if (is.numeric(VGOB1_subsetF_mecA_LUR3[,i])==TRUE){ modeltry<-lm(VGOB1_subsetF_mecA_LUR3$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetF_mecA_LUR3[,models[[1]]$indexbestmodel]+VGOB1_subsetF_mecA_LUR3[,models[[2]]$indexbestmodel]+ VGOB1_subsetF_mecA_LUR3[,models[[3]]$indexbestmodel]+VGOB1_subsetF_mecA_LUR3[,models[[4]]$indexbestmodel]+ VGOB1_subsetF_mecA_LUR3[,models[[5]]$indexbestmodel]+ VGOB1_subsetF_mecA_LUR3[,models[[6]]$indexbestmodel]+ VGOB1_subsetF_mecA_LUR3[,models[[7]]$indexbestmodel]+ VGOB1_subsetF_mecA_LUR3[,models[[8]]$indexbestmodel]+ VGOB1_subsetF_mecA_LUR3[,models[[9]]$indexbestmodel]+ VGOB1_subsetF_mecA_LUR3[,i]) 

R2<-rbind(R2,summary(modeltry)$adj.r.squared)
# the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # Measurements_livestockpreds_LUR3[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR3)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetF_mecA_LUR3)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

# this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

# here are the names
models[[modeln]]$namesbestmodel<-c( names(VGOB1_subsetF_mecA_LUR3)[models[[1]]$indexbestmodel],                   names(VGOB1_subsetF_mecA_LUR3)[models[[2]]$indexbestmodel] , names(VGOB1_subsetF_mecA_LUR3)[models[[3]]$indexbestmodel], names(VGOB1_subsetF_mecA_LUR3)[models[[4]]$indexbestmodel], names(VGOB1_subsetF_mecA_LUR3)[models[[5]]$indexbestmodel], names(VGOB1_subsetF_mecA_LUR3)[models[[6]]$indexbestmodel], names(VGOB1_subsetF_mecA_LUR3)[models[[7]]$indexbestmodel], names(VGOB1_subsetF_mecA_LUR3)[models[[8]]$indexbestmodel], names(VGOB1_subsetF_mecA_LUR3)[models[[9]]$indexbestmodel], names(VGOB1_subsetF_mecA_LUR3)[models[[10]]$indexbestmodel])

#  this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetF_mecA_LUR3$meca_copiespm3.ln.diffmeth.mean~                                VGOB1_subsetF_mecA_LUR3[,models[[1]]$indexbestmodel]+ VGOB1_subsetF_mecA_LUR3[,models[[2]]$indexbestmodel]+                           VGOB1_subsetF_mecA_LUR3[,models[[3]]$indexbestmodel]+ VGOB1_subsetF_mecA_LUR3[,models[[4]]$indexbestmodel]+ VGOB1_subsetF_mecA_LUR3[,models[[5]]$indexbestmodel]+ VGOB1_subsetF_mecA_LUR3[,models[[6]]$indexbestmodel]+ VGOB1_subsetF_mecA_LUR3[,models[[7]]$indexbestmodel]+ VGOB1_subsetF_mecA_LUR3[,models[[8]]$indexbestmodel]+ VGOB1_subsetF_mecA_LUR3[,models[[9]]$indexbestmodel]+ VGOB1_subsetF_mecA_LUR3[,models[[10]]$indexbestmodel]) 

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[5]]$summarybestmodel
models[[6]]$summarybestmodel
models[[7]]$summarybestmodel
models[[8]]$summarybestmodel
models[[9]]$summarybestmodel
models[[10]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[5]]$namesbestmodel
models[[6]]$namesbestmodel
models[[7]]$namesbestmodel
models[[8]]$namesbestmodel
models[[9]]$namesbestmodel
models[[10]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel
models[[5]]$R2bestmodel
models[[6]]$R2bestmodel
models[[7]]$R2bestmodel
models[[8]]$R2bestmodel
models[[9]]$R2bestmodel
models[[10]]$R2bestmodel

#  at this point I always check whether the next model is more than 1% better than the one before and if not I end here

#   CODE FOR PICKING OUT THE BEST MODEL #   
temp <- 0
besti <- 0
for (i in 1:10){ #  think this runs the loop 10 times - not fully sure thought - but not to do with the number of models I don't think - as when I change to 3, I still get the model with 4 variables as best model
  print(models[[i]]$R2bestmodel)
  #       print(models[[i]]$summarybestmodel$coefficients=-1,4])
  #       if((models[[i]]$R2bestmodel-temp > 0.0) && (all(models[[i]]$summarybestmodel$coefficients[-1,4]<0.1))){
  #         temp <- models[[i]]$R2bestmodel
  #         besti <- i
  #         }
  if((models[[i]]$R2bestmodel-temp > 0.0) && (all(models[[i]]$summarybestmodel$coefficients[-1,4]<0.1))){
    temp <- models[[i]]$R2bestmodel
    besti <- i
  }else{
    finalBestModel_mecA_subsetF <- models[[besti]]$bestmodel
    finalBestModelNames_mecA_subsetF <- models[[besti]]$namesbestmodel
    Sites <- 1:dim(VGOB1_subsetF_mecA_LUR3)[1] # full original model
    #  CVaR2<-escCV_mecA_LUR3(Sites)[2] # Cross Validation
    maxCD<-max(cooks.distance(finalBestModel_mecA_subsetF))
    if(length(finalBestModelNames_mecA_subsetF)<2){ # vif fn doesnot work when only 1 variable...       # 
      maxVIF<-"NA"
    }else{
      maxVIF<-max(vif(finalBestModel_mecA_subsetF))
    }
    print(paste("This is the best mecA model for subset F: ",besti,
                "(AdjR2: ",format(models[[besti]]$R2bestmodel,digits=3), "; MaxCD: ",format(maxCD,digits=3),"; MaxVIF: ",
                format(maxVIF,digits=3),")", sep=''))
    print(finalBestModelNames_mecA_subsetF)
    break
  }
}

#  Overview of the final best model using the algorithm selection process (taking into account VIF, R^2, and p-values)
finalBestModel_mecA_subsetF
finalBestModelNames_mecA_subsetF
models[[besti]]$summarybestmodel
models[[besti]]$R2bestmodel

#### G ####
# LUR model building process for subset G
#  This is the dataframe with the relevant predictor vars for LUR3 models for subset G (55 sites)
VGOB1_subsetG_mecA_LUR3 # n.b. this dataframe only includes microbial marker concentrations for mecA unlike the dataframe Measurements_livestockpreds_LUR3 as previously used for the model building. 

#  Now set the values of some variables that will be needed
nfirstvar_LUR_3 <- 3  
nlastvar_LUR_3 <- 135

# Function building to run the models 
# 1 #  

models<-list()
modeln<-1
models[[modeln]]<-list()

R2<-1
betaaddedvar<-1
addedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_3:nlastvar_LUR_3){
  if (is.numeric(VGOB1_subsetG_mecA_LUR3[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetG_mecA_LUR3$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetG_mecA_LUR3[,i])                            
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    #  Measurements_livestockpreds_LUR3[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR3)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetG_mecA_LUR3)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)
models[[modeln]]$results

#  this are the candidates models with the highest R2, not a negative beta for the new, nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)
models[[modeln]]$resultspos

#  rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))
models[[modeln]]$resultspos

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j
models[[modeln]]$indexbestmodel

subset(models[[modeln]]$resultspos, rank==1)
subset(models[[modeln]]$resultspos)

#  this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]
models[[modeln]]$summarybestmodel

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetG_mecA_LUR3)[models[[1]]$indexbestmodel])
models[[modeln]]$namesbestmodel

#  this is the r2 of that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2
models[[modeln]]$R2bestmodel

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetG_mecA_LUR3$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetG_mecA_LUR3[,models[[1]]$indexbestmodel]) 
models[[modeln]]$bestmodel

summary(models[[modeln]]$bestmodel)

#  The first model includes the predictor: nPigMultipFarmWghtDist.3000m.sum.Tr.1P9 - meaning the number of multiplier pig farms weighted to distance in a 3000m buffer

# 2 #  
# Add 2nd variable (the only difference of the above part is that now modeln=2 the model statement has 2 variables)
# and the call for the list of variable names in the model changed slightly

modeln<-2

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_3:nlastvar_LUR_3){
  if (is.numeric(VGOB1_subsetG_mecA_LUR3[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetG_mecA_LUR3$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetG_mecA_LUR3[,models[[1]]$indexbestmodel]+ VGOB1_subsetG_mecA_LUR3[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # Measurements_livestockpreds_LUR3[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR3)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetG_mecA_LUR3)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  these are the candidate models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)
models[[modeln]]$resultspos

#  rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))
models[[modeln]]$resultspos

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j
models[[modeln]]$indexbestmodel

subset(models[[modeln]]$resultspos, rank==1)

# this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]
models[[modeln]]$summarybestmodel

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetG_mecA_LUR3)[models[[1]]$indexbestmodel], names(VGOB1_subsetG_mecA_LUR3)[models[[2]]$indexbestmodel] )
models[[modeln]]$namesbestmodel

# this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2
models[[modeln]]$R2bestmodel

# this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetG_mecA_LUR3$meca_copiespm3.ln.diffmeth.mean~                               VGOB1_subsetG_mecA_LUR3[,models[[1]]$indexbestmodel]+                           VGOB1_subsetG_mecA_LUR3[,models[[2]]$indexbestmodel]) 

models[[modeln]]$bestmodel

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel


# 3 #  
# add third variable (the only difference of the above part is that now modeln=3 the model statement has 3 variables)
# and the call for the list of variable names in the model changed slightly

modeln<-3

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_3:nlastvar_LUR_3){
  if (is.numeric(VGOB1_subsetG_mecA_LUR3[,i])==TRUE){  
    modeltry<-lm(VGOB1_subsetG_mecA_LUR3$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetG_mecA_LUR3[,models[[1]]$indexbestmodel]+VGOB1_subsetG_mecA_LUR3[,models[[2]]$indexbestmodel]+ VGOB1_subsetG_mecA_LUR3[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # All[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR3)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetG_mecA_LUR3)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

#  rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

#  this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

#  here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetG_mecA_LUR3)[models[[1]]$indexbestmodel], names(VGOB1_subsetG_mecA_LUR3)[models[[2]]$indexbestmodel], names(VGOB1_subsetG_mecA_LUR3)[models[[3]]$indexbestmodel])

#  this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetG_mecA_LUR3$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetG_mecA_LUR3[,models[[1]]$indexbestmodel]+ VGOB1_subsetG_mecA_LUR3[,models[[2]]$indexbestmodel]+ VGOB1_subsetG_mecA_LUR3[,models[[3]]$indexbestmodel]) 

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel


# 4 #  
#  add forth variable (the only difference of the above part is that now model n=4 the model statement more variables)
#  and the call for the list of variable names in the model changed slightly
modeln<-4

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1


for (i in nfirstvar_LUR_3:nlastvar_LUR_3){
  if (is.numeric(VGOB1_subsetG_mecA_LUR3[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetG_mecA_LUR3$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetG_mecA_LUR3[,models[[1]]$indexbestmodel]+VGOB1_subsetG_mecA_LUR3[,models[[2]]$indexbestmodel]+VGOB1_subsetG_mecA_LUR3[,models[[3]]$indexbestmodel]+VGOB1_subsetG_mecA_LUR3[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    #  the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    #  All[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR3)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetG_mecA_LUR3)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

#  this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

#  here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetG_mecA_LUR3)[models[[1]]$indexbestmodel], names(VGOB1_subsetG_mecA_LUR3)[models[[2]]$indexbestmodel], names(VGOB1_subsetG_mecA_LUR3)[models[[3]]$indexbestmodel], names(VGOB1_subsetG_mecA_LUR3)[models[[4]]$indexbestmodel])

#  this is the r2 of that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetG_mecA_LUR3$meca_copiespm3.ln.diffmeth.mean~ VGOB1_subsetG_mecA_LUR3[,models[[1]]$indexbestmodel]+ VGOB1_subsetG_mecA_LUR3[,models[[2]]$indexbestmodel]+VGOB1_subsetG_mecA_LUR3[,models[[3]]$indexbestmodel]+ VGOB1_subsetG_mecA_LUR3[,models[[4]]$indexbestmodel]) 


models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel


# 5 #  
# add fifth variable (the only difference of the above part is that now modeln=5 the model statement more variables)
# and the call for the list of variable names in the model changed slightly
modeln<-5

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_3:nlastvar_LUR_3){
  if (is.numeric(VGOB1_subsetG_mecA_LUR3[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetG_mecA_LUR3$meca_copiespm3.ln.diffmeth.mean~ VGOB1_subsetG_mecA_LUR3[,models[[1]]$indexbestmodel]+ VGOB1_subsetG_mecA_LUR3[,models[[2]]$indexbestmodel]+ VGOB1_subsetG_mecA_LUR3[,models[[3]]$indexbestmodel]+ VGOB1_subsetG_mecA_LUR3[,models[[4]]$indexbestmodel]+ VGOB1_subsetG_mecA_LUR3[,i]) 
  
R2<-rbind(R2,summary(modeltry)$adj.r.squared)
# the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # All[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR3)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetG_mecA_LUR3)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

#  this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetG_mecA_LUR3)[models[[1]]$indexbestmodel], names(VGOB1_subsetG_mecA_LUR3)[models[[2]]$indexbestmodel], names(VGOB1_subsetG_mecA_LUR3)[models[[3]]$indexbestmodel], names(VGOB1_subsetG_mecA_LUR3)[models[[4]]$indexbestmodel], names(VGOB1_subsetG_mecA_LUR3)[models[[5]]$indexbestmodel])

#  this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetG_mecA_LUR3$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetG_mecA_LUR3[,models[[1]]$indexbestmodel]+VGOB1_subsetG_mecA_LUR3[,models[[2]]$indexbestmodel]+VGOB1_subsetG_mecA_LUR3[,models[[3]]$indexbestmodel]+ VGOB1_subsetG_mecA_LUR3[,models[[4]]$indexbestmodel]+ VGOB1_subsetG_mecA_LUR3[,models[[5]]$indexbestmodel]) 
models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[5]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[5]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel
models[[5]]$R2bestmodel

# 6 #  
# add sixth variable (the only difference of the above part is that now model n=6 the model statement more variables)
#  and the call for the list of variable names in the model changed slightly

modeln<-6

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_3 :nlastvar_LUR_3){
  if (is.numeric(VGOB1_subsetG_mecA_LUR3[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetG_mecA_LUR3$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetG_mecA_LUR3[,models[[1]]$indexbestmodel]+VGOB1_subsetG_mecA_LUR3[,models[[2]]$indexbestmodel]+VGOB1_subsetG_mecA_LUR3[,models[[3]]$indexbestmodel]+VGOB1_subsetG_mecA_LUR3[,models[[4]]$indexbestmodel]+VGOB1_subsetG_mecA_LUR3[,models[[5]]$indexbestmodel]+ VGOB1_subsetG_mecA_LUR3[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # All[,i] is the row that's being tried out now. the name of that row can be found in  names(All)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetG_mecA_LUR3)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

# this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetG_mecA_LUR3)[models[[1]]$indexbestmodel], names(VGOB1_subsetG_mecA_LUR3)[models[[2]]$indexbestmodel] , names(VGOB1_subsetG_mecA_LUR3)[models[[3]]$indexbestmodel], names(VGOB1_subsetG_mecA_LUR3)[models[[4]]$indexbestmodel], names(VGOB1_subsetG_mecA_LUR3)[models[[5]]$indexbestmodel], names(VGOB1_subsetG_mecA_LUR3)[models[[6]]$indexbestmodel])

#  this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetG_mecA_LUR3$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetG_mecA_LUR3[,models[[1]]$indexbestmodel]+VGOB1_subsetG_mecA_LUR3[,models[[2]]$indexbestmodel]+VGOB1_subsetG_mecA_LUR3[,models[[3]]$indexbestmodel]+ VGOB1_subsetG_mecA_LUR3[,models[[4]]$indexbestmodel]+ VGOB1_subsetG_mecA_LUR3[,models[[5]]$indexbestmodel]+ VGOB1_subsetG_mecA_LUR3[,models[[6]]$indexbestmodel]) 

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[5]]$summarybestmodel
models[[6]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[5]]$namesbestmodel
models[[6]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel
models[[5]]$R2bestmodel
models[[6]]$R2bestmodel


# 7 #  
# add seventh variable (the only difference of the above part is that now model n=7 the model statement more variables)
#  and the call for the list of variable names in the model changed slightly

modeln<-7

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_3 :nlastvar_LUR_3){
  if (is.numeric(VGOB1_subsetG_mecA_LUR3[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetG_mecA_LUR3$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetG_mecA_LUR3[,models[[1]]$indexbestmodel]+VGOB1_subsetG_mecA_LUR3[,models[[2]]$indexbestmodel]+VGOB1_subsetG_mecA_LUR3[,models[[3]]$indexbestmodel]+VGOB1_subsetG_mecA_LUR3[,models[[4]]$indexbestmodel]+VGOB1_subsetG_mecA_LUR3[,models[[5]]$indexbestmodel]+VGOB1_subsetG_mecA_LUR3[,models[[6]]$indexbestmodel]+ VGOB1_subsetG_mecA_LUR3[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # Measurements_livestockpreds_LUR3[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR3)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetG_mecA_LUR3)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

# this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetG_mecA_LUR3)[models[[1]]$indexbestmodel], names(VGOB1_subsetG_mecA_LUR3)[models[[2]]$indexbestmodel] , names(VGOB1_subsetG_mecA_LUR3)[models[[3]]$indexbestmodel], names(VGOB1_subsetG_mecA_LUR3)[models[[4]]$indexbestmodel], names(VGOB1_subsetG_mecA_LUR3)[models[[5]]$indexbestmodel], names(VGOB1_subsetG_mecA_LUR3)[models[[6]]$indexbestmodel], names(VGOB1_subsetG_mecA_LUR3)[models[[7]]$indexbestmodel])

#  this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetG_mecA_LUR3$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetG_mecA_LUR3[,models[[1]]$indexbestmodel]+VGOB1_subsetG_mecA_LUR3[,models[[2]]$indexbestmodel]+VGOB1_subsetG_mecA_LUR3[,models[[3]]$indexbestmodel]+ VGOB1_subsetG_mecA_LUR3[,models[[4]]$indexbestmodel]+ VGOB1_subsetG_mecA_LUR3[,models[[5]]$indexbestmodel]+ VGOB1_subsetG_mecA_LUR3[,models[[6]]$indexbestmodel]+ VGOB1_subsetG_mecA_LUR3[,models[[7]]$indexbestmodel]) 

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[5]]$summarybestmodel
models[[6]]$summarybestmodel
models[[7]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[5]]$namesbestmodel
models[[6]]$namesbestmodel
models[[7]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel
models[[5]]$R2bestmodel
models[[6]]$R2bestmodel
models[[7]]$R2bestmodel

# 8 #  
# add eighth variable (the only difference of the above part is that now modeln=7 the model statement more variables)
# and the call for the list of variable names in the model changed slightly

modeln<-8

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_3 :nlastvar_LUR_3){
  if (is.numeric(VGOB1_subsetG_mecA_LUR3[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetG_mecA_LUR3$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetG_mecA_LUR3[,models[[1]]$indexbestmodel]+VGOB1_subsetG_mecA_LUR3[,models[[2]]$indexbestmodel]+VGOB1_subsetG_mecA_LUR3[,models[[3]]$indexbestmodel]+VGOB1_subsetG_mecA_LUR3[,models[[4]]$indexbestmodel]+VGOB1_subsetG_mecA_LUR3[,models[[5]]$indexbestmodel]+VGOB1_subsetG_mecA_LUR3[,models[[6]]$indexbestmodel]+ VGOB1_subsetG_mecA_LUR3[,models[[7]]$indexbestmodel]+ VGOB1_subsetG_mecA_LUR3[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # Measurements_livestockpreds_LUR3[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR3)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetG_mecA_LUR3)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

# this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetG_mecA_LUR3)[models[[1]]$indexbestmodel], names(VGOB1_subsetG_mecA_LUR3)[models[[2]]$indexbestmodel] , names(VGOB1_subsetG_mecA_LUR3)[models[[3]]$indexbestmodel], names(VGOB1_subsetG_mecA_LUR3)[models[[4]]$indexbestmodel], names(VGOB1_subsetG_mecA_LUR3)[models[[5]]$indexbestmodel], names(VGOB1_subsetG_mecA_LUR3)[models[[6]]$indexbestmodel], names(VGOB1_subsetG_mecA_LUR3)[models[[7]]$indexbestmodel], names(VGOB1_subsetG_mecA_LUR3)[models[[8]]$indexbestmodel])

#  this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetG_mecA_LUR3$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetG_mecA_LUR3[,models[[1]]$indexbestmodel]+VGOB1_subsetG_mecA_LUR3[,models[[2]]$indexbestmodel]+VGOB1_subsetG_mecA_LUR3[,models[[3]]$indexbestmodel]+ VGOB1_subsetG_mecA_LUR3[,models[[4]]$indexbestmodel]+ VGOB1_subsetG_mecA_LUR3[,models[[5]]$indexbestmodel]+ VGOB1_subsetG_mecA_LUR3[,models[[6]]$indexbestmodel]+ VGOB1_subsetG_mecA_LUR3[,models[[7]]$indexbestmodel]+ VGOB1_subsetG_mecA_LUR3[,models[[8]]$indexbestmodel]) 

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[5]]$summarybestmodel
models[[6]]$summarybestmodel
models[[7]]$summarybestmodel
models[[8]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[5]]$namesbestmodel
models[[6]]$namesbestmodel
models[[7]]$namesbestmodel
models[[8]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel
models[[5]]$R2bestmodel
models[[6]]$R2bestmodel
models[[7]]$R2bestmodel
models[[8]]$R2bestmodel

# 9 #  
# add ninth variable (the only difference of the above part is that now modeln=9 the model statement more variables)
# and the call for the list of variable names in the model changed slightly

modeln<-9

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_3 :nlastvar_LUR_3){
  if (is.numeric(VGOB1_subsetG_mecA_LUR3[,i])==TRUE){
      modeltry<-lm(VGOB1_subsetG_mecA_LUR3$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetG_mecA_LUR3[,models[[1]]$indexbestmodel]+VGOB1_subsetG_mecA_LUR3[,models[[2]]$indexbestmodel]+VGOB1_subsetG_mecA_LUR3[,models[[3]]$indexbestmodel]+VGOB1_subsetG_mecA_LUR3[,models[[4]]$indexbestmodel]+VGOB1_subsetG_mecA_LUR3[,models[[5]]$indexbestmodel]+VGOB1_subsetG_mecA_LUR3[,models[[6]]$indexbestmodel]+ VGOB1_subsetG_mecA_LUR3[,models[[7]]$indexbestmodel]+ VGOB1_subsetG_mecA_LUR3[,models[[8]]$indexbestmodel]+ VGOB1_subsetG_mecA_LUR3[,i]) 
        R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # Measurements_livestockpreds_LUR3[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR3)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetG_mecA_LUR3)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

# this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetG_mecA_LUR3)[models[[1]]$indexbestmodel], names(VGOB1_subsetG_mecA_LUR3)[models[[2]]$indexbestmodel] , names(VGOB1_subsetG_mecA_LUR3)[models[[3]]$indexbestmodel], names(VGOB1_subsetG_mecA_LUR3)[models[[4]]$indexbestmodel], names(VGOB1_subsetG_mecA_LUR3)[models[[5]]$indexbestmodel], names(VGOB1_subsetG_mecA_LUR3)[models[[6]]$indexbestmodel], names(VGOB1_subsetG_mecA_LUR3)[models[[7]]$indexbestmodel], names(VGOB1_subsetG_mecA_LUR3)[models[[8]]$indexbestmodel],  names(VGOB1_subsetG_mecA_LUR3)[models[[9]]$indexbestmodel])

#  this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetG_mecA_LUR3$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetG_mecA_LUR3[,models[[1]]$indexbestmodel]+VGOB1_subsetG_mecA_LUR3[,models[[2]]$indexbestmodel]+VGOB1_subsetG_mecA_LUR3[,models[[3]]$indexbestmodel]+ VGOB1_subsetG_mecA_LUR3[,models[[4]]$indexbestmodel]+ VGOB1_subsetG_mecA_LUR3[,models[[5]]$indexbestmodel]+ VGOB1_subsetG_mecA_LUR3[,models[[6]]$indexbestmodel]+ VGOB1_subsetG_mecA_LUR3[,models[[7]]$indexbestmodel]+ VGOB1_subsetG_mecA_LUR3[,models[[8]]$indexbestmodel]+ VGOB1_subsetG_mecA_LUR3[,models[[9]]$indexbestmodel]) 

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[5]]$summarybestmodel
models[[6]]$summarybestmodel
models[[7]]$summarybestmodel
models[[8]]$summarybestmodel
models[[9]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[5]]$namesbestmodel
models[[6]]$namesbestmodel
models[[7]]$namesbestmodel
models[[8]]$namesbestmodel
models[[9]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel
models[[5]]$R2bestmodel
models[[6]]$R2bestmodel
models[[7]]$R2bestmodel
models[[8]]$R2bestmodel
models[[9]]$R2bestmodel

# 10 #  
#  add tenth variable (the only difference of the above part is that now model n=10 the model statement more variables)
#  and the call for the list of variable names in the model changed slightly

modeln<-10

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_3 :nlastvar_LUR_3){if (is.numeric(VGOB1_subsetG_mecA_LUR3[,i])==TRUE){ modeltry<-lm(VGOB1_subsetG_mecA_LUR3$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetG_mecA_LUR3[,models[[1]]$indexbestmodel]+VGOB1_subsetG_mecA_LUR3[,models[[2]]$indexbestmodel]+ VGOB1_subsetG_mecA_LUR3[,models[[3]]$indexbestmodel]+VGOB1_subsetG_mecA_LUR3[,models[[4]]$indexbestmodel]+ VGOB1_subsetG_mecA_LUR3[,models[[5]]$indexbestmodel]+ VGOB1_subsetG_mecA_LUR3[,models[[6]]$indexbestmodel]+ VGOB1_subsetG_mecA_LUR3[,models[[7]]$indexbestmodel]+ VGOB1_subsetG_mecA_LUR3[,models[[8]]$indexbestmodel]+ VGOB1_subsetG_mecA_LUR3[,models[[9]]$indexbestmodel]+ VGOB1_subsetG_mecA_LUR3[,i]) 

R2<-rbind(R2,summary(modeltry)$adj.r.squared)
# the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # Measurements_livestockpreds_LUR3[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR3)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetG_mecA_LUR3)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

# this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

# here are the names
models[[modeln]]$namesbestmodel<-c( names(VGOB1_subsetG_mecA_LUR3)[models[[1]]$indexbestmodel],                   names(VGOB1_subsetG_mecA_LUR3)[models[[2]]$indexbestmodel] , names(VGOB1_subsetG_mecA_LUR3)[models[[3]]$indexbestmodel], names(VGOB1_subsetG_mecA_LUR3)[models[[4]]$indexbestmodel], names(VGOB1_subsetG_mecA_LUR3)[models[[5]]$indexbestmodel], names(VGOB1_subsetG_mecA_LUR3)[models[[6]]$indexbestmodel], names(VGOB1_subsetG_mecA_LUR3)[models[[7]]$indexbestmodel], names(VGOB1_subsetG_mecA_LUR3)[models[[8]]$indexbestmodel], names(VGOB1_subsetG_mecA_LUR3)[models[[9]]$indexbestmodel], names(VGOB1_subsetG_mecA_LUR3)[models[[10]]$indexbestmodel])

#  this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetG_mecA_LUR3$meca_copiespm3.ln.diffmeth.mean~                                VGOB1_subsetG_mecA_LUR3[,models[[1]]$indexbestmodel]+ VGOB1_subsetG_mecA_LUR3[,models[[2]]$indexbestmodel]+                           VGOB1_subsetG_mecA_LUR3[,models[[3]]$indexbestmodel]+ VGOB1_subsetG_mecA_LUR3[,models[[4]]$indexbestmodel]+ VGOB1_subsetG_mecA_LUR3[,models[[5]]$indexbestmodel]+ VGOB1_subsetG_mecA_LUR3[,models[[6]]$indexbestmodel]+ VGOB1_subsetG_mecA_LUR3[,models[[7]]$indexbestmodel]+ VGOB1_subsetG_mecA_LUR3[,models[[8]]$indexbestmodel]+ VGOB1_subsetG_mecA_LUR3[,models[[9]]$indexbestmodel]+ VGOB1_subsetG_mecA_LUR3[,models[[10]]$indexbestmodel]) 

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[5]]$summarybestmodel
models[[6]]$summarybestmodel
models[[7]]$summarybestmodel
models[[8]]$summarybestmodel
models[[9]]$summarybestmodel
models[[10]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[5]]$namesbestmodel
models[[6]]$namesbestmodel
models[[7]]$namesbestmodel
models[[8]]$namesbestmodel
models[[9]]$namesbestmodel
models[[10]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel
models[[5]]$R2bestmodel
models[[6]]$R2bestmodel
models[[7]]$R2bestmodel
models[[8]]$R2bestmodel
models[[9]]$R2bestmodel
models[[10]]$R2bestmodel

#  at this point I always check whether the next model is more than 1% better than the one before and if not I end here

#   CODE FOR PICKING OUT THE BEST MODEL #   
temp <- 0
besti <- 0
for (i in 1:10){ #  think this runs the loop 10 times - not fully sure thought - but not to do with the number of models I don't think - as when I change to 3, I still get the model with 4 variables as best model
  print(models[[i]]$R2bestmodel)
  #       print(models[[i]]$summarybestmodel$coefficients=-1,4])
  #       if((models[[i]]$R2bestmodel-temp > 0.0) && (all(models[[i]]$summarybestmodel$coefficients[-1,4]<0.1))){
  #         temp <- models[[i]]$R2bestmodel
  #         besti <- i
  #         }
  if((models[[i]]$R2bestmodel-temp > 0.0) && (all(models[[i]]$summarybestmodel$coefficients[-1,4]<0.1))){
    temp <- models[[i]]$R2bestmodel
    besti <- i
  }else{
    finalBestModel_mecA_subsetG <- models[[besti]]$bestmodel
    finalBestModelNames_mecA_subsetG <- models[[besti]]$namesbestmodel
    Sites <- 1:dim(VGOB1_subsetG_mecA_LUR3)[1] # full original model
    #  CVaR2<-escCV_mecA_LUR3(Sites)[2] # Cross Validation
    maxCD<-max(cooks.distance(finalBestModel_mecA_subsetG))
    if(length(finalBestModelNames_mecA_subsetG)<2){ # vif fn doesnot work when only 1 variable...       # 
      maxVIF<-"NA"
    }else{
      maxVIF<-max(vif(finalBestModel_mecA_subsetG))
    }
    print(paste("This is the best mecA model for subset G: ",besti,
                "(AdjR2: ",format(models[[besti]]$R2bestmodel,digits=3), "; MaxCD: ",format(maxCD,digits=3),"; MaxVIF: ",
                format(maxVIF,digits=3),")", sep=''))
    print(finalBestModelNames_mecA_subsetG)
    break
  }
}

#  Overview of the final best model using the algorithm selection process (taking into account VIF, R^2, and p-values)
finalBestModel_mecA_subsetG
finalBestModelNames_mecA_subsetG
models[[besti]]$summarybestmodel
models[[besti]]$R2bestmodel

#### H ####
# LUR model building process for subset H
#  This is the dataframe with the relevant predictor vars for LUR3 models for subset H (55 sites)
VGOB1_subsetH_mecA_LUR3 # n.b. this dataframe only includes microbial marker concentrations for mecA unlike the dataframe Measurements_livestockpreds_LUR3 as previously used for the model building. 

#  Now set the values of some variables that will be needed
nfirstvar_LUR_3 <- 3  
nlastvar_LUR_3 <- 135

# Function building to run the models 
# 1 #  

models<-list()
modeln<-1
models[[modeln]]<-list()

R2<-1
betaaddedvar<-1
addedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_3:nlastvar_LUR_3){
  if (is.numeric(VGOB1_subsetH_mecA_LUR3[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetH_mecA_LUR3$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetH_mecA_LUR3[,i])                            
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    #  Measurements_livestockpreds_LUR3[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR3)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetH_mecA_LUR3)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)
models[[modeln]]$results

#  this are the candidates models with the highest R2, not a negative beta for the new, nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)
models[[modeln]]$resultspos

#  rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))
models[[modeln]]$resultspos

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j
models[[modeln]]$indexbestmodel

subset(models[[modeln]]$resultspos, rank==1)
subset(models[[modeln]]$resultspos)

#  this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]
models[[modeln]]$summarybestmodel

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetH_mecA_LUR3)[models[[1]]$indexbestmodel])
models[[modeln]]$namesbestmodel

#  this is the r2 of that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2
models[[modeln]]$R2bestmodel

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetH_mecA_LUR3$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetH_mecA_LUR3[,models[[1]]$indexbestmodel]) 
models[[modeln]]$bestmodel

summary(models[[modeln]]$bestmodel)

#  The first model includes the predictor: nPigMultipFarmWghtDist.3000m.sum.Tr.1P9 - meaning the number of multiplier pig farms weighted to distance in a 3000m buffer

# 2 #  
# Add 2nd variable (the only difference of the above part is that now modeln=2 the model statement has 2 variables)
# and the call for the list of variable names in the model changed slightly

modeln<-2

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_3:nlastvar_LUR_3){
  if (is.numeric(VGOB1_subsetH_mecA_LUR3[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetH_mecA_LUR3$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetH_mecA_LUR3[,models[[1]]$indexbestmodel]+ VGOB1_subsetH_mecA_LUR3[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # Measurements_livestockpreds_LUR3[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR3)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetH_mecA_LUR3)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  these are the candidate models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)
models[[modeln]]$resultspos

#  rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))
models[[modeln]]$resultspos

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j
models[[modeln]]$indexbestmodel

subset(models[[modeln]]$resultspos, rank==1)

# this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]
models[[modeln]]$summarybestmodel

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetH_mecA_LUR3)[models[[1]]$indexbestmodel], names(VGOB1_subsetH_mecA_LUR3)[models[[2]]$indexbestmodel] )
models[[modeln]]$namesbestmodel

# this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2
models[[modeln]]$R2bestmodel

# this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetH_mecA_LUR3$meca_copiespm3.ln.diffmeth.mean~                               VGOB1_subsetH_mecA_LUR3[,models[[1]]$indexbestmodel]+                           VGOB1_subsetH_mecA_LUR3[,models[[2]]$indexbestmodel]) 

models[[modeln]]$bestmodel

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel


# 3 #  
# add third variable (the only difference of the above part is that now modeln=3 the model statement has 3 variables)
# and the call for the list of variable names in the model changed slightly

modeln<-3

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_3:nlastvar_LUR_3){
  if (is.numeric(VGOB1_subsetH_mecA_LUR3[,i])==TRUE){  
    modeltry<-lm(VGOB1_subsetH_mecA_LUR3$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetH_mecA_LUR3[,models[[1]]$indexbestmodel]+VGOB1_subsetH_mecA_LUR3[,models[[2]]$indexbestmodel]+ VGOB1_subsetH_mecA_LUR3[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # All[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR3)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetH_mecA_LUR3)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

#  rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

#  this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

#  here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetH_mecA_LUR3)[models[[1]]$indexbestmodel], names(VGOB1_subsetH_mecA_LUR3)[models[[2]]$indexbestmodel], names(VGOB1_subsetH_mecA_LUR3)[models[[3]]$indexbestmodel])

#  this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetH_mecA_LUR3$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetH_mecA_LUR3[,models[[1]]$indexbestmodel]+ VGOB1_subsetH_mecA_LUR3[,models[[2]]$indexbestmodel]+ VGOB1_subsetH_mecA_LUR3[,models[[3]]$indexbestmodel]) 

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel


# 4 #  
#  add forth variable (the only difference of the above part is that now model n=4 the model statement more variables)
#  and the call for the list of variable names in the model changed slightly
modeln<-4

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1


for (i in nfirstvar_LUR_3:nlastvar_LUR_3){
  if (is.numeric(VGOB1_subsetH_mecA_LUR3[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetH_mecA_LUR3$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetH_mecA_LUR3[,models[[1]]$indexbestmodel]+VGOB1_subsetH_mecA_LUR3[,models[[2]]$indexbestmodel]+VGOB1_subsetH_mecA_LUR3[,models[[3]]$indexbestmodel]+VGOB1_subsetH_mecA_LUR3[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    #  the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    #  All[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR3)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetH_mecA_LUR3)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

#  this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

#  here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetH_mecA_LUR3)[models[[1]]$indexbestmodel], names(VGOB1_subsetH_mecA_LUR3)[models[[2]]$indexbestmodel], names(VGOB1_subsetH_mecA_LUR3)[models[[3]]$indexbestmodel], names(VGOB1_subsetH_mecA_LUR3)[models[[4]]$indexbestmodel])

#  this is the r2 of that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetH_mecA_LUR3$meca_copiespm3.ln.diffmeth.mean~ VGOB1_subsetH_mecA_LUR3[,models[[1]]$indexbestmodel]+ VGOB1_subsetH_mecA_LUR3[,models[[2]]$indexbestmodel]+VGOB1_subsetH_mecA_LUR3[,models[[3]]$indexbestmodel]+ VGOB1_subsetH_mecA_LUR3[,models[[4]]$indexbestmodel]) 


models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel


# 5 #  
# add fifth variable (the only difference of the above part is that now modeln=5 the model statement more variables)
# and the call for the list of variable names in the model changed slightly
modeln<-5

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_3:nlastvar_LUR_3){
  if (is.numeric(VGOB1_subsetH_mecA_LUR3[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetH_mecA_LUR3$meca_copiespm3.ln.diffmeth.mean~ VGOB1_subsetH_mecA_LUR3[,models[[1]]$indexbestmodel]+ VGOB1_subsetH_mecA_LUR3[,models[[2]]$indexbestmodel]+ VGOB1_subsetH_mecA_LUR3[,models[[3]]$indexbestmodel]+ VGOB1_subsetH_mecA_LUR3[,models[[4]]$indexbestmodel]+ VGOB1_subsetH_mecA_LUR3[,i]) 
  
R2<-rbind(R2,summary(modeltry)$adj.r.squared)
# the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # All[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR3)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetH_mecA_LUR3)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

#  this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetH_mecA_LUR3)[models[[1]]$indexbestmodel], names(VGOB1_subsetH_mecA_LUR3)[models[[2]]$indexbestmodel], names(VGOB1_subsetH_mecA_LUR3)[models[[3]]$indexbestmodel], names(VGOB1_subsetH_mecA_LUR3)[models[[4]]$indexbestmodel], names(VGOB1_subsetH_mecA_LUR3)[models[[5]]$indexbestmodel])

#  this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetH_mecA_LUR3$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetH_mecA_LUR3[,models[[1]]$indexbestmodel]+VGOB1_subsetH_mecA_LUR3[,models[[2]]$indexbestmodel]+VGOB1_subsetH_mecA_LUR3[,models[[3]]$indexbestmodel]+ VGOB1_subsetH_mecA_LUR3[,models[[4]]$indexbestmodel]+ VGOB1_subsetH_mecA_LUR3[,models[[5]]$indexbestmodel]) 
models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[5]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[5]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel
models[[5]]$R2bestmodel

# 6 #  
# add sixth variable (the only difference of the above part is that now model n=6 the model statement more variables)
#  and the call for the list of variable names in the model changed slightly

modeln<-6

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_3 :nlastvar_LUR_3){
  if (is.numeric(VGOB1_subsetH_mecA_LUR3[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetH_mecA_LUR3$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetH_mecA_LUR3[,models[[1]]$indexbestmodel]+VGOB1_subsetH_mecA_LUR3[,models[[2]]$indexbestmodel]+VGOB1_subsetH_mecA_LUR3[,models[[3]]$indexbestmodel]+VGOB1_subsetH_mecA_LUR3[,models[[4]]$indexbestmodel]+VGOB1_subsetH_mecA_LUR3[,models[[5]]$indexbestmodel]+ VGOB1_subsetH_mecA_LUR3[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # All[,i] is the row that's being tried out now. the name of that row can be found in  names(All)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetH_mecA_LUR3)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

# this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetH_mecA_LUR3)[models[[1]]$indexbestmodel], names(VGOB1_subsetH_mecA_LUR3)[models[[2]]$indexbestmodel] , names(VGOB1_subsetH_mecA_LUR3)[models[[3]]$indexbestmodel], names(VGOB1_subsetH_mecA_LUR3)[models[[4]]$indexbestmodel], names(VGOB1_subsetH_mecA_LUR3)[models[[5]]$indexbestmodel], names(VGOB1_subsetH_mecA_LUR3)[models[[6]]$indexbestmodel])

#  this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetH_mecA_LUR3$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetH_mecA_LUR3[,models[[1]]$indexbestmodel]+VGOB1_subsetH_mecA_LUR3[,models[[2]]$indexbestmodel]+VGOB1_subsetH_mecA_LUR3[,models[[3]]$indexbestmodel]+ VGOB1_subsetH_mecA_LUR3[,models[[4]]$indexbestmodel]+ VGOB1_subsetH_mecA_LUR3[,models[[5]]$indexbestmodel]+ VGOB1_subsetH_mecA_LUR3[,models[[6]]$indexbestmodel]) 

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[5]]$summarybestmodel
models[[6]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[5]]$namesbestmodel
models[[6]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel
models[[5]]$R2bestmodel
models[[6]]$R2bestmodel


# 7 #  
# add seventh variable (the only difference of the above part is that now model n=7 the model statement more variables)
#  and the call for the list of variable names in the model changed slightly

modeln<-7

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_3 :nlastvar_LUR_3){
  if (is.numeric(VGOB1_subsetH_mecA_LUR3[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetH_mecA_LUR3$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetH_mecA_LUR3[,models[[1]]$indexbestmodel]+VGOB1_subsetH_mecA_LUR3[,models[[2]]$indexbestmodel]+VGOB1_subsetH_mecA_LUR3[,models[[3]]$indexbestmodel]+VGOB1_subsetH_mecA_LUR3[,models[[4]]$indexbestmodel]+VGOB1_subsetH_mecA_LUR3[,models[[5]]$indexbestmodel]+VGOB1_subsetH_mecA_LUR3[,models[[6]]$indexbestmodel]+ VGOB1_subsetH_mecA_LUR3[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # Measurements_livestockpreds_LUR3[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR3)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetH_mecA_LUR3)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

# this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetH_mecA_LUR3)[models[[1]]$indexbestmodel], names(VGOB1_subsetH_mecA_LUR3)[models[[2]]$indexbestmodel] , names(VGOB1_subsetH_mecA_LUR3)[models[[3]]$indexbestmodel], names(VGOB1_subsetH_mecA_LUR3)[models[[4]]$indexbestmodel], names(VGOB1_subsetH_mecA_LUR3)[models[[5]]$indexbestmodel], names(VGOB1_subsetH_mecA_LUR3)[models[[6]]$indexbestmodel], names(VGOB1_subsetH_mecA_LUR3)[models[[7]]$indexbestmodel])

#  this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetH_mecA_LUR3$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetH_mecA_LUR3[,models[[1]]$indexbestmodel]+VGOB1_subsetH_mecA_LUR3[,models[[2]]$indexbestmodel]+VGOB1_subsetH_mecA_LUR3[,models[[3]]$indexbestmodel]+ VGOB1_subsetH_mecA_LUR3[,models[[4]]$indexbestmodel]+ VGOB1_subsetH_mecA_LUR3[,models[[5]]$indexbestmodel]+ VGOB1_subsetH_mecA_LUR3[,models[[6]]$indexbestmodel]+ VGOB1_subsetH_mecA_LUR3[,models[[7]]$indexbestmodel]) 

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[5]]$summarybestmodel
models[[6]]$summarybestmodel
models[[7]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[5]]$namesbestmodel
models[[6]]$namesbestmodel
models[[7]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel
models[[5]]$R2bestmodel
models[[6]]$R2bestmodel
models[[7]]$R2bestmodel

# 8 #  
# add eighth variable (the only difference of the above part is that now modeln=7 the model statement more variables)
# and the call for the list of variable names in the model changed slightly

modeln<-8

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_3 :nlastvar_LUR_3){
  if (is.numeric(VGOB1_subsetH_mecA_LUR3[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetH_mecA_LUR3$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetH_mecA_LUR3[,models[[1]]$indexbestmodel]+VGOB1_subsetH_mecA_LUR3[,models[[2]]$indexbestmodel]+VGOB1_subsetH_mecA_LUR3[,models[[3]]$indexbestmodel]+VGOB1_subsetH_mecA_LUR3[,models[[4]]$indexbestmodel]+VGOB1_subsetH_mecA_LUR3[,models[[5]]$indexbestmodel]+VGOB1_subsetH_mecA_LUR3[,models[[6]]$indexbestmodel]+ VGOB1_subsetH_mecA_LUR3[,models[[7]]$indexbestmodel]+ VGOB1_subsetH_mecA_LUR3[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # Measurements_livestockpreds_LUR3[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR3)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetH_mecA_LUR3)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

# this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetH_mecA_LUR3)[models[[1]]$indexbestmodel], names(VGOB1_subsetH_mecA_LUR3)[models[[2]]$indexbestmodel] , names(VGOB1_subsetH_mecA_LUR3)[models[[3]]$indexbestmodel], names(VGOB1_subsetH_mecA_LUR3)[models[[4]]$indexbestmodel], names(VGOB1_subsetH_mecA_LUR3)[models[[5]]$indexbestmodel], names(VGOB1_subsetH_mecA_LUR3)[models[[6]]$indexbestmodel], names(VGOB1_subsetH_mecA_LUR3)[models[[7]]$indexbestmodel], names(VGOB1_subsetH_mecA_LUR3)[models[[8]]$indexbestmodel])

#  this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetH_mecA_LUR3$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetH_mecA_LUR3[,models[[1]]$indexbestmodel]+VGOB1_subsetH_mecA_LUR3[,models[[2]]$indexbestmodel]+VGOB1_subsetH_mecA_LUR3[,models[[3]]$indexbestmodel]+ VGOB1_subsetH_mecA_LUR3[,models[[4]]$indexbestmodel]+ VGOB1_subsetH_mecA_LUR3[,models[[5]]$indexbestmodel]+ VGOB1_subsetH_mecA_LUR3[,models[[6]]$indexbestmodel]+ VGOB1_subsetH_mecA_LUR3[,models[[7]]$indexbestmodel]+ VGOB1_subsetH_mecA_LUR3[,models[[8]]$indexbestmodel]) 

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[5]]$summarybestmodel
models[[6]]$summarybestmodel
models[[7]]$summarybestmodel
models[[8]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[5]]$namesbestmodel
models[[6]]$namesbestmodel
models[[7]]$namesbestmodel
models[[8]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel
models[[5]]$R2bestmodel
models[[6]]$R2bestmodel
models[[7]]$R2bestmodel
models[[8]]$R2bestmodel

# 9 #  
# add ninth variable (the only difference of the above part is that now modeln=9 the model statement more variables)
# and the call for the list of variable names in the model changed slightly

modeln<-9

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_3 :nlastvar_LUR_3){
  if (is.numeric(VGOB1_subsetH_mecA_LUR3[,i])==TRUE){
      modeltry<-lm(VGOB1_subsetH_mecA_LUR3$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetH_mecA_LUR3[,models[[1]]$indexbestmodel]+VGOB1_subsetH_mecA_LUR3[,models[[2]]$indexbestmodel]+VGOB1_subsetH_mecA_LUR3[,models[[3]]$indexbestmodel]+VGOB1_subsetH_mecA_LUR3[,models[[4]]$indexbestmodel]+VGOB1_subsetH_mecA_LUR3[,models[[5]]$indexbestmodel]+VGOB1_subsetH_mecA_LUR3[,models[[6]]$indexbestmodel]+ VGOB1_subsetH_mecA_LUR3[,models[[7]]$indexbestmodel]+ VGOB1_subsetH_mecA_LUR3[,models[[8]]$indexbestmodel]+ VGOB1_subsetH_mecA_LUR3[,i]) 
        R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # Measurements_livestockpreds_LUR3[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR3)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetH_mecA_LUR3)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

# this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetH_mecA_LUR3)[models[[1]]$indexbestmodel], names(VGOB1_subsetH_mecA_LUR3)[models[[2]]$indexbestmodel] , names(VGOB1_subsetH_mecA_LUR3)[models[[3]]$indexbestmodel], names(VGOB1_subsetH_mecA_LUR3)[models[[4]]$indexbestmodel], names(VGOB1_subsetH_mecA_LUR3)[models[[5]]$indexbestmodel], names(VGOB1_subsetH_mecA_LUR3)[models[[6]]$indexbestmodel], names(VGOB1_subsetH_mecA_LUR3)[models[[7]]$indexbestmodel], names(VGOB1_subsetH_mecA_LUR3)[models[[8]]$indexbestmodel],  names(VGOB1_subsetH_mecA_LUR3)[models[[9]]$indexbestmodel])

#  this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetH_mecA_LUR3$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetH_mecA_LUR3[,models[[1]]$indexbestmodel]+VGOB1_subsetH_mecA_LUR3[,models[[2]]$indexbestmodel]+VGOB1_subsetH_mecA_LUR3[,models[[3]]$indexbestmodel]+ VGOB1_subsetH_mecA_LUR3[,models[[4]]$indexbestmodel]+ VGOB1_subsetH_mecA_LUR3[,models[[5]]$indexbestmodel]+ VGOB1_subsetH_mecA_LUR3[,models[[6]]$indexbestmodel]+ VGOB1_subsetH_mecA_LUR3[,models[[7]]$indexbestmodel]+ VGOB1_subsetH_mecA_LUR3[,models[[8]]$indexbestmodel]+ VGOB1_subsetH_mecA_LUR3[,models[[9]]$indexbestmodel]) 

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[5]]$summarybestmodel
models[[6]]$summarybestmodel
models[[7]]$summarybestmodel
models[[8]]$summarybestmodel
models[[9]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[5]]$namesbestmodel
models[[6]]$namesbestmodel
models[[7]]$namesbestmodel
models[[8]]$namesbestmodel
models[[9]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel
models[[5]]$R2bestmodel
models[[6]]$R2bestmodel
models[[7]]$R2bestmodel
models[[8]]$R2bestmodel
models[[9]]$R2bestmodel

# 10 #  
#  add tenth variable (the only difference of the above part is that now model n=10 the model statement more variables)
#  and the call for the list of variable names in the model changed slightly

modeln<-10

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_3 :nlastvar_LUR_3){if (is.numeric(VGOB1_subsetH_mecA_LUR3[,i])==TRUE){ modeltry<-lm(VGOB1_subsetH_mecA_LUR3$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetH_mecA_LUR3[,models[[1]]$indexbestmodel]+VGOB1_subsetH_mecA_LUR3[,models[[2]]$indexbestmodel]+ VGOB1_subsetH_mecA_LUR3[,models[[3]]$indexbestmodel]+VGOB1_subsetH_mecA_LUR3[,models[[4]]$indexbestmodel]+ VGOB1_subsetH_mecA_LUR3[,models[[5]]$indexbestmodel]+ VGOB1_subsetH_mecA_LUR3[,models[[6]]$indexbestmodel]+ VGOB1_subsetH_mecA_LUR3[,models[[7]]$indexbestmodel]+ VGOB1_subsetH_mecA_LUR3[,models[[8]]$indexbestmodel]+ VGOB1_subsetH_mecA_LUR3[,models[[9]]$indexbestmodel]+ VGOB1_subsetH_mecA_LUR3[,i]) 

R2<-rbind(R2,summary(modeltry)$adj.r.squared)
# the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # Measurements_livestockpreds_LUR3[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR3)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetH_mecA_LUR3)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

# this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

# here are the names
models[[modeln]]$namesbestmodel<-c( names(VGOB1_subsetH_mecA_LUR3)[models[[1]]$indexbestmodel],                   names(VGOB1_subsetH_mecA_LUR3)[models[[2]]$indexbestmodel] , names(VGOB1_subsetH_mecA_LUR3)[models[[3]]$indexbestmodel], names(VGOB1_subsetH_mecA_LUR3)[models[[4]]$indexbestmodel], names(VGOB1_subsetH_mecA_LUR3)[models[[5]]$indexbestmodel], names(VGOB1_subsetH_mecA_LUR3)[models[[6]]$indexbestmodel], names(VGOB1_subsetH_mecA_LUR3)[models[[7]]$indexbestmodel], names(VGOB1_subsetH_mecA_LUR3)[models[[8]]$indexbestmodel], names(VGOB1_subsetH_mecA_LUR3)[models[[9]]$indexbestmodel], names(VGOB1_subsetH_mecA_LUR3)[models[[10]]$indexbestmodel])

#  this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetH_mecA_LUR3$meca_copiespm3.ln.diffmeth.mean~                                VGOB1_subsetH_mecA_LUR3[,models[[1]]$indexbestmodel]+ VGOB1_subsetH_mecA_LUR3[,models[[2]]$indexbestmodel]+                           VGOB1_subsetH_mecA_LUR3[,models[[3]]$indexbestmodel]+ VGOB1_subsetH_mecA_LUR3[,models[[4]]$indexbestmodel]+ VGOB1_subsetH_mecA_LUR3[,models[[5]]$indexbestmodel]+ VGOB1_subsetH_mecA_LUR3[,models[[6]]$indexbestmodel]+ VGOB1_subsetH_mecA_LUR3[,models[[7]]$indexbestmodel]+ VGOB1_subsetH_mecA_LUR3[,models[[8]]$indexbestmodel]+ VGOB1_subsetH_mecA_LUR3[,models[[9]]$indexbestmodel]+ VGOB1_subsetH_mecA_LUR3[,models[[10]]$indexbestmodel]) 

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[5]]$summarybestmodel
models[[6]]$summarybestmodel
models[[7]]$summarybestmodel
models[[8]]$summarybestmodel
models[[9]]$summarybestmodel
models[[10]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[5]]$namesbestmodel
models[[6]]$namesbestmodel
models[[7]]$namesbestmodel
models[[8]]$namesbestmodel
models[[9]]$namesbestmodel
models[[10]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel
models[[5]]$R2bestmodel
models[[6]]$R2bestmodel
models[[7]]$R2bestmodel
models[[8]]$R2bestmodel
models[[9]]$R2bestmodel
models[[10]]$R2bestmodel

#  at this point I always check whether the next model is more than 1% better than the one before and if not I end here

#   CODE FOR PICKING OUT THE BEST MODEL #   
temp <- 0
besti <- 0
for (i in 1:10){ #  think this runs the loop 10 times - not fully sure thought - but not to do with the number of models I don't think - as when I change to 3, I still get the model with 4 variables as best model
  print(models[[i]]$R2bestmodel)
  #       print(models[[i]]$summarybestmodel$coefficients=-1,4])
  #       if((models[[i]]$R2bestmodel-temp > 0.0) && (all(models[[i]]$summarybestmodel$coefficients[-1,4]<0.1))){
  #         temp <- models[[i]]$R2bestmodel
  #         besti <- i
  #         }
  if((models[[i]]$R2bestmodel-temp > 0.0) && (all(models[[i]]$summarybestmodel$coefficients[-1,4]<0.1))){
    temp <- models[[i]]$R2bestmodel
    besti <- i
  }else{
    finalBestModel_mecA_subsetH <- models[[besti]]$bestmodel
    finalBestModelNames_mecA_subsetH <- models[[besti]]$namesbestmodel
    Sites <- 1:dim(VGOB1_subsetH_mecA_LUR3)[1] # full original model
    #  CVaR2<-escCV_mecA_LUR3(Sites)[2] # Cross Validation
    maxCD<-max(cooks.distance(finalBestModel_mecA_subsetH))
    if(length(finalBestModelNames_mecA_subsetH)<2){ # vif fn doesnot work when only 1 variable...       # 
      maxVIF<-"NA"
    }else{
      maxVIF<-max(vif(finalBestModel_mecA_subsetH))
    }
    print(paste("This is the best mecA model for subset H: ",besti,
                "(AdjR2: ",format(models[[besti]]$R2bestmodel,digits=3), "; MaxCD: ",format(maxCD,digits=3),"; MaxVIF: ",
                format(maxVIF,digits=3),")", sep=''))
    print(finalBestModelNames_mecA_subsetH)
    break
  }
}

#  Overview of the final best model using the algorithm selection process (taking into account VIF, R^2, and p-values)
finalBestModel_mecA_subsetH
finalBestModelNames_mecA_subsetH
models[[besti]]$summarybestmodel
models[[besti]]$R2bestmodel


#### I ####
# LUR model building process for subset I
#  This is the dataframe with the relevant predictor vars for LUR3 models for subset I (55 sites)
VGOB1_subsetI_mecA_LUR3 # n.b. this dataframe only includes microbial marker concentrations for mecA unlike the dataframe Measurements_livestockpreds_LUR3 as previously used for the model building. 

#  Now set the values of some variables that will be needed
nfirstvar_LUR_3 <- 3  
nlastvar_LUR_3 <- 135

# Function building to run the models 
# 1 #  

models<-list()
modeln<-1
models[[modeln]]<-list()

R2<-1
betaaddedvar<-1
addedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_3:nlastvar_LUR_3){
  if (is.numeric(VGOB1_subsetI_mecA_LUR3[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetI_mecA_LUR3$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetI_mecA_LUR3[,i])                            
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    #  Measurements_livestockpreds_LUR3[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR3)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetI_mecA_LUR3)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)
models[[modeln]]$results

#  this are the candidates models with the highest R2, not a negative beta for the new, nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)
models[[modeln]]$resultspos

#  rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))
models[[modeln]]$resultspos

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j
models[[modeln]]$indexbestmodel

subset(models[[modeln]]$resultspos, rank==1)
subset(models[[modeln]]$resultspos)

#  this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]
models[[modeln]]$summarybestmodel

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetI_mecA_LUR3)[models[[1]]$indexbestmodel])
models[[modeln]]$namesbestmodel

#  this is the r2 of that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2
models[[modeln]]$R2bestmodel

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetI_mecA_LUR3$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetI_mecA_LUR3[,models[[1]]$indexbestmodel]) 
models[[modeln]]$bestmodel

summary(models[[modeln]]$bestmodel)

#  The first model includes the predictor: nPigMultipFarmWghtDist.3000m.sum.Tr.1P9 - meaning the number of multiplier pig farms weighted to distance in a 3000m buffer

# 2 #  
# Add 2nd variable (the only difference of the above part is that now modeln=2 the model statement has 2 variables)
# and the call for the list of variable names in the model changed slightly

modeln<-2

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_3:nlastvar_LUR_3){
  if (is.numeric(VGOB1_subsetI_mecA_LUR3[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetI_mecA_LUR3$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetI_mecA_LUR3[,models[[1]]$indexbestmodel]+ VGOB1_subsetI_mecA_LUR3[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # Measurements_livestockpreds_LUR3[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR3)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetI_mecA_LUR3)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  these are the candidate models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)
models[[modeln]]$resultspos

#  rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))
models[[modeln]]$resultspos

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j
models[[modeln]]$indexbestmodel

subset(models[[modeln]]$resultspos, rank==1)

# this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]
models[[modeln]]$summarybestmodel

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetI_mecA_LUR3)[models[[1]]$indexbestmodel], names(VGOB1_subsetI_mecA_LUR3)[models[[2]]$indexbestmodel] )
models[[modeln]]$namesbestmodel

# this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2
models[[modeln]]$R2bestmodel

# this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetI_mecA_LUR3$meca_copiespm3.ln.diffmeth.mean~                               VGOB1_subsetI_mecA_LUR3[,models[[1]]$indexbestmodel]+                           VGOB1_subsetI_mecA_LUR3[,models[[2]]$indexbestmodel]) 

models[[modeln]]$bestmodel

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel


# 3 #  
# add third variable (the only difference of the above part is that now modeln=3 the model statement has 3 variables)
# and the call for the list of variable names in the model changed slightly

modeln<-3

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_3:nlastvar_LUR_3){
  if (is.numeric(VGOB1_subsetI_mecA_LUR3[,i])==TRUE){  
    modeltry<-lm(VGOB1_subsetI_mecA_LUR3$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetI_mecA_LUR3[,models[[1]]$indexbestmodel]+VGOB1_subsetI_mecA_LUR3[,models[[2]]$indexbestmodel]+ VGOB1_subsetI_mecA_LUR3[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # All[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR3)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetI_mecA_LUR3)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

#  rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

#  this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

#  here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetI_mecA_LUR3)[models[[1]]$indexbestmodel], names(VGOB1_subsetI_mecA_LUR3)[models[[2]]$indexbestmodel], names(VGOB1_subsetI_mecA_LUR3)[models[[3]]$indexbestmodel])

#  this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetI_mecA_LUR3$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetI_mecA_LUR3[,models[[1]]$indexbestmodel]+ VGOB1_subsetI_mecA_LUR3[,models[[2]]$indexbestmodel]+ VGOB1_subsetI_mecA_LUR3[,models[[3]]$indexbestmodel]) 

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel


# 4 #  
#  add forth variable (the only difference of the above part is that now model n=4 the model statement more variables)
#  and the call for the list of variable names in the model changed slightly
modeln<-4

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1


for (i in nfirstvar_LUR_3:nlastvar_LUR_3){
  if (is.numeric(VGOB1_subsetI_mecA_LUR3[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetI_mecA_LUR3$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetI_mecA_LUR3[,models[[1]]$indexbestmodel]+VGOB1_subsetI_mecA_LUR3[,models[[2]]$indexbestmodel]+VGOB1_subsetI_mecA_LUR3[,models[[3]]$indexbestmodel]+VGOB1_subsetI_mecA_LUR3[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    #  the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    #  All[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR3)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetI_mecA_LUR3)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

#  this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

#  here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetI_mecA_LUR3)[models[[1]]$indexbestmodel], names(VGOB1_subsetI_mecA_LUR3)[models[[2]]$indexbestmodel], names(VGOB1_subsetI_mecA_LUR3)[models[[3]]$indexbestmodel], names(VGOB1_subsetI_mecA_LUR3)[models[[4]]$indexbestmodel])

#  this is the r2 of that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetI_mecA_LUR3$meca_copiespm3.ln.diffmeth.mean~ VGOB1_subsetI_mecA_LUR3[,models[[1]]$indexbestmodel]+ VGOB1_subsetI_mecA_LUR3[,models[[2]]$indexbestmodel]+VGOB1_subsetI_mecA_LUR3[,models[[3]]$indexbestmodel]+ VGOB1_subsetI_mecA_LUR3[,models[[4]]$indexbestmodel]) 


models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel


# 5 #  
# add fifth variable (the only difference of the above part is that now modeln=5 the model statement more variables)
# and the call for the list of variable names in the model changed slightly
modeln<-5

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_3:nlastvar_LUR_3){
  if (is.numeric(VGOB1_subsetI_mecA_LUR3[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetI_mecA_LUR3$meca_copiespm3.ln.diffmeth.mean~ VGOB1_subsetI_mecA_LUR3[,models[[1]]$indexbestmodel]+ VGOB1_subsetI_mecA_LUR3[,models[[2]]$indexbestmodel]+ VGOB1_subsetI_mecA_LUR3[,models[[3]]$indexbestmodel]+ VGOB1_subsetI_mecA_LUR3[,models[[4]]$indexbestmodel]+ VGOB1_subsetI_mecA_LUR3[,i]) 
  
R2<-rbind(R2,summary(modeltry)$adj.r.squared)
# the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # All[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR3)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetI_mecA_LUR3)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

#  this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetI_mecA_LUR3)[models[[1]]$indexbestmodel], names(VGOB1_subsetI_mecA_LUR3)[models[[2]]$indexbestmodel], names(VGOB1_subsetI_mecA_LUR3)[models[[3]]$indexbestmodel], names(VGOB1_subsetI_mecA_LUR3)[models[[4]]$indexbestmodel], names(VGOB1_subsetI_mecA_LUR3)[models[[5]]$indexbestmodel])

#  this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetI_mecA_LUR3$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetI_mecA_LUR3[,models[[1]]$indexbestmodel]+VGOB1_subsetI_mecA_LUR3[,models[[2]]$indexbestmodel]+VGOB1_subsetI_mecA_LUR3[,models[[3]]$indexbestmodel]+ VGOB1_subsetI_mecA_LUR3[,models[[4]]$indexbestmodel]+ VGOB1_subsetI_mecA_LUR3[,models[[5]]$indexbestmodel]) 
models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[5]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[5]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel
models[[5]]$R2bestmodel

# 6 #  
# add sixth variable (the only difference of the above part is that now model n=6 the model statement more variables)
#  and the call for the list of variable names in the model changed slightly

modeln<-6

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_3 :nlastvar_LUR_3){
  if (is.numeric(VGOB1_subsetI_mecA_LUR3[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetI_mecA_LUR3$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetI_mecA_LUR3[,models[[1]]$indexbestmodel]+VGOB1_subsetI_mecA_LUR3[,models[[2]]$indexbestmodel]+VGOB1_subsetI_mecA_LUR3[,models[[3]]$indexbestmodel]+VGOB1_subsetI_mecA_LUR3[,models[[4]]$indexbestmodel]+VGOB1_subsetI_mecA_LUR3[,models[[5]]$indexbestmodel]+ VGOB1_subsetI_mecA_LUR3[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # All[,i] is the row that's being tried out now. the name of that row can be found in  names(All)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetI_mecA_LUR3)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

# this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetI_mecA_LUR3)[models[[1]]$indexbestmodel], names(VGOB1_subsetI_mecA_LUR3)[models[[2]]$indexbestmodel] , names(VGOB1_subsetI_mecA_LUR3)[models[[3]]$indexbestmodel], names(VGOB1_subsetI_mecA_LUR3)[models[[4]]$indexbestmodel], names(VGOB1_subsetI_mecA_LUR3)[models[[5]]$indexbestmodel], names(VGOB1_subsetI_mecA_LUR3)[models[[6]]$indexbestmodel])

#  this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetI_mecA_LUR3$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetI_mecA_LUR3[,models[[1]]$indexbestmodel]+VGOB1_subsetI_mecA_LUR3[,models[[2]]$indexbestmodel]+VGOB1_subsetI_mecA_LUR3[,models[[3]]$indexbestmodel]+ VGOB1_subsetI_mecA_LUR3[,models[[4]]$indexbestmodel]+ VGOB1_subsetI_mecA_LUR3[,models[[5]]$indexbestmodel]+ VGOB1_subsetI_mecA_LUR3[,models[[6]]$indexbestmodel]) 

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[5]]$summarybestmodel
models[[6]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[5]]$namesbestmodel
models[[6]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel
models[[5]]$R2bestmodel
models[[6]]$R2bestmodel


# 7 #  
# add seventh variable (the only difference of the above part is that now model n=7 the model statement more variables)
#  and the call for the list of variable names in the model changed slightly

modeln<-7

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_3 :nlastvar_LUR_3){
  if (is.numeric(VGOB1_subsetI_mecA_LUR3[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetI_mecA_LUR3$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetI_mecA_LUR3[,models[[1]]$indexbestmodel]+VGOB1_subsetI_mecA_LUR3[,models[[2]]$indexbestmodel]+VGOB1_subsetI_mecA_LUR3[,models[[3]]$indexbestmodel]+VGOB1_subsetI_mecA_LUR3[,models[[4]]$indexbestmodel]+VGOB1_subsetI_mecA_LUR3[,models[[5]]$indexbestmodel]+VGOB1_subsetI_mecA_LUR3[,models[[6]]$indexbestmodel]+ VGOB1_subsetI_mecA_LUR3[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # Measurements_livestockpreds_LUR3[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR3)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetI_mecA_LUR3)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

# this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetI_mecA_LUR3)[models[[1]]$indexbestmodel], names(VGOB1_subsetI_mecA_LUR3)[models[[2]]$indexbestmodel] , names(VGOB1_subsetI_mecA_LUR3)[models[[3]]$indexbestmodel], names(VGOB1_subsetI_mecA_LUR3)[models[[4]]$indexbestmodel], names(VGOB1_subsetI_mecA_LUR3)[models[[5]]$indexbestmodel], names(VGOB1_subsetI_mecA_LUR3)[models[[6]]$indexbestmodel], names(VGOB1_subsetI_mecA_LUR3)[models[[7]]$indexbestmodel])

#  this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetI_mecA_LUR3$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetI_mecA_LUR3[,models[[1]]$indexbestmodel]+VGOB1_subsetI_mecA_LUR3[,models[[2]]$indexbestmodel]+VGOB1_subsetI_mecA_LUR3[,models[[3]]$indexbestmodel]+ VGOB1_subsetI_mecA_LUR3[,models[[4]]$indexbestmodel]+ VGOB1_subsetI_mecA_LUR3[,models[[5]]$indexbestmodel]+ VGOB1_subsetI_mecA_LUR3[,models[[6]]$indexbestmodel]+ VGOB1_subsetI_mecA_LUR3[,models[[7]]$indexbestmodel]) 

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[5]]$summarybestmodel
models[[6]]$summarybestmodel
models[[7]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[5]]$namesbestmodel
models[[6]]$namesbestmodel
models[[7]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel
models[[5]]$R2bestmodel
models[[6]]$R2bestmodel
models[[7]]$R2bestmodel

# 8 #  
# add eighth variable (the only difference of the above part is that now modeln=7 the model statement more variables)
# and the call for the list of variable names in the model changed slightly

modeln<-8

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_3 :nlastvar_LUR_3){
  if (is.numeric(VGOB1_subsetI_mecA_LUR3[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetI_mecA_LUR3$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetI_mecA_LUR3[,models[[1]]$indexbestmodel]+VGOB1_subsetI_mecA_LUR3[,models[[2]]$indexbestmodel]+VGOB1_subsetI_mecA_LUR3[,models[[3]]$indexbestmodel]+VGOB1_subsetI_mecA_LUR3[,models[[4]]$indexbestmodel]+VGOB1_subsetI_mecA_LUR3[,models[[5]]$indexbestmodel]+VGOB1_subsetI_mecA_LUR3[,models[[6]]$indexbestmodel]+ VGOB1_subsetI_mecA_LUR3[,models[[7]]$indexbestmodel]+ VGOB1_subsetI_mecA_LUR3[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # Measurements_livestockpreds_LUR3[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR3)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetI_mecA_LUR3)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

# this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetI_mecA_LUR3)[models[[1]]$indexbestmodel], names(VGOB1_subsetI_mecA_LUR3)[models[[2]]$indexbestmodel] , names(VGOB1_subsetI_mecA_LUR3)[models[[3]]$indexbestmodel], names(VGOB1_subsetI_mecA_LUR3)[models[[4]]$indexbestmodel], names(VGOB1_subsetI_mecA_LUR3)[models[[5]]$indexbestmodel], names(VGOB1_subsetI_mecA_LUR3)[models[[6]]$indexbestmodel], names(VGOB1_subsetI_mecA_LUR3)[models[[7]]$indexbestmodel], names(VGOB1_subsetI_mecA_LUR3)[models[[8]]$indexbestmodel])

#  this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetI_mecA_LUR3$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetI_mecA_LUR3[,models[[1]]$indexbestmodel]+VGOB1_subsetI_mecA_LUR3[,models[[2]]$indexbestmodel]+VGOB1_subsetI_mecA_LUR3[,models[[3]]$indexbestmodel]+ VGOB1_subsetI_mecA_LUR3[,models[[4]]$indexbestmodel]+ VGOB1_subsetI_mecA_LUR3[,models[[5]]$indexbestmodel]+ VGOB1_subsetI_mecA_LUR3[,models[[6]]$indexbestmodel]+ VGOB1_subsetI_mecA_LUR3[,models[[7]]$indexbestmodel]+ VGOB1_subsetI_mecA_LUR3[,models[[8]]$indexbestmodel]) 

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[5]]$summarybestmodel
models[[6]]$summarybestmodel
models[[7]]$summarybestmodel
models[[8]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[5]]$namesbestmodel
models[[6]]$namesbestmodel
models[[7]]$namesbestmodel
models[[8]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel
models[[5]]$R2bestmodel
models[[6]]$R2bestmodel
models[[7]]$R2bestmodel
models[[8]]$R2bestmodel

# 9 #  
# add ninth variable (the only difference of the above part is that now modeln=9 the model statement more variables)
# and the call for the list of variable names in the model changed slightly

modeln<-9

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_3 :nlastvar_LUR_3){
  if (is.numeric(VGOB1_subsetI_mecA_LUR3[,i])==TRUE){
      modeltry<-lm(VGOB1_subsetI_mecA_LUR3$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetI_mecA_LUR3[,models[[1]]$indexbestmodel]+VGOB1_subsetI_mecA_LUR3[,models[[2]]$indexbestmodel]+VGOB1_subsetI_mecA_LUR3[,models[[3]]$indexbestmodel]+VGOB1_subsetI_mecA_LUR3[,models[[4]]$indexbestmodel]+VGOB1_subsetI_mecA_LUR3[,models[[5]]$indexbestmodel]+VGOB1_subsetI_mecA_LUR3[,models[[6]]$indexbestmodel]+ VGOB1_subsetI_mecA_LUR3[,models[[7]]$indexbestmodel]+ VGOB1_subsetI_mecA_LUR3[,models[[8]]$indexbestmodel]+ VGOB1_subsetI_mecA_LUR3[,i]) 
        R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # Measurements_livestockpreds_LUR3[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR3)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetI_mecA_LUR3)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

# this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetI_mecA_LUR3)[models[[1]]$indexbestmodel], names(VGOB1_subsetI_mecA_LUR3)[models[[2]]$indexbestmodel] , names(VGOB1_subsetI_mecA_LUR3)[models[[3]]$indexbestmodel], names(VGOB1_subsetI_mecA_LUR3)[models[[4]]$indexbestmodel], names(VGOB1_subsetI_mecA_LUR3)[models[[5]]$indexbestmodel], names(VGOB1_subsetI_mecA_LUR3)[models[[6]]$indexbestmodel], names(VGOB1_subsetI_mecA_LUR3)[models[[7]]$indexbestmodel], names(VGOB1_subsetI_mecA_LUR3)[models[[8]]$indexbestmodel],  names(VGOB1_subsetI_mecA_LUR3)[models[[9]]$indexbestmodel])

#  this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetI_mecA_LUR3$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetI_mecA_LUR3[,models[[1]]$indexbestmodel]+VGOB1_subsetI_mecA_LUR3[,models[[2]]$indexbestmodel]+VGOB1_subsetI_mecA_LUR3[,models[[3]]$indexbestmodel]+ VGOB1_subsetI_mecA_LUR3[,models[[4]]$indexbestmodel]+ VGOB1_subsetI_mecA_LUR3[,models[[5]]$indexbestmodel]+ VGOB1_subsetI_mecA_LUR3[,models[[6]]$indexbestmodel]+ VGOB1_subsetI_mecA_LUR3[,models[[7]]$indexbestmodel]+ VGOB1_subsetI_mecA_LUR3[,models[[8]]$indexbestmodel]+ VGOB1_subsetI_mecA_LUR3[,models[[9]]$indexbestmodel]) 

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[5]]$summarybestmodel
models[[6]]$summarybestmodel
models[[7]]$summarybestmodel
models[[8]]$summarybestmodel
models[[9]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[5]]$namesbestmodel
models[[6]]$namesbestmodel
models[[7]]$namesbestmodel
models[[8]]$namesbestmodel
models[[9]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel
models[[5]]$R2bestmodel
models[[6]]$R2bestmodel
models[[7]]$R2bestmodel
models[[8]]$R2bestmodel
models[[9]]$R2bestmodel

# 10 #  
#  add tenth variable (the only difference of the above part is that now model n=10 the model statement more variables)
#  and the call for the list of variable names in the model changed slightly

modeln<-10

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_3 :nlastvar_LUR_3){if (is.numeric(VGOB1_subsetI_mecA_LUR3[,i])==TRUE){ modeltry<-lm(VGOB1_subsetI_mecA_LUR3$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetI_mecA_LUR3[,models[[1]]$indexbestmodel]+VGOB1_subsetI_mecA_LUR3[,models[[2]]$indexbestmodel]+ VGOB1_subsetI_mecA_LUR3[,models[[3]]$indexbestmodel]+VGOB1_subsetI_mecA_LUR3[,models[[4]]$indexbestmodel]+ VGOB1_subsetI_mecA_LUR3[,models[[5]]$indexbestmodel]+ VGOB1_subsetI_mecA_LUR3[,models[[6]]$indexbestmodel]+ VGOB1_subsetI_mecA_LUR3[,models[[7]]$indexbestmodel]+ VGOB1_subsetI_mecA_LUR3[,models[[8]]$indexbestmodel]+ VGOB1_subsetI_mecA_LUR3[,models[[9]]$indexbestmodel]+ VGOB1_subsetI_mecA_LUR3[,i]) 

R2<-rbind(R2,summary(modeltry)$adj.r.squared)
# the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # Measurements_livestockpreds_LUR3[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR3)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetI_mecA_LUR3)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

# this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

# here are the names
models[[modeln]]$namesbestmodel<-c( names(VGOB1_subsetI_mecA_LUR3)[models[[1]]$indexbestmodel],                   names(VGOB1_subsetI_mecA_LUR3)[models[[2]]$indexbestmodel] , names(VGOB1_subsetI_mecA_LUR3)[models[[3]]$indexbestmodel], names(VGOB1_subsetI_mecA_LUR3)[models[[4]]$indexbestmodel], names(VGOB1_subsetI_mecA_LUR3)[models[[5]]$indexbestmodel], names(VGOB1_subsetI_mecA_LUR3)[models[[6]]$indexbestmodel], names(VGOB1_subsetI_mecA_LUR3)[models[[7]]$indexbestmodel], names(VGOB1_subsetI_mecA_LUR3)[models[[8]]$indexbestmodel], names(VGOB1_subsetI_mecA_LUR3)[models[[9]]$indexbestmodel], names(VGOB1_subsetI_mecA_LUR3)[models[[10]]$indexbestmodel])

#  this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetI_mecA_LUR3$meca_copiespm3.ln.diffmeth.mean~                                VGOB1_subsetI_mecA_LUR3[,models[[1]]$indexbestmodel]+ VGOB1_subsetI_mecA_LUR3[,models[[2]]$indexbestmodel]+                           VGOB1_subsetI_mecA_LUR3[,models[[3]]$indexbestmodel]+ VGOB1_subsetI_mecA_LUR3[,models[[4]]$indexbestmodel]+ VGOB1_subsetI_mecA_LUR3[,models[[5]]$indexbestmodel]+ VGOB1_subsetI_mecA_LUR3[,models[[6]]$indexbestmodel]+ VGOB1_subsetI_mecA_LUR3[,models[[7]]$indexbestmodel]+ VGOB1_subsetI_mecA_LUR3[,models[[8]]$indexbestmodel]+ VGOB1_subsetI_mecA_LUR3[,models[[9]]$indexbestmodel]+ VGOB1_subsetI_mecA_LUR3[,models[[10]]$indexbestmodel]) 

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[5]]$summarybestmodel
models[[6]]$summarybestmodel
models[[7]]$summarybestmodel
models[[8]]$summarybestmodel
models[[9]]$summarybestmodel
models[[10]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[5]]$namesbestmodel
models[[6]]$namesbestmodel
models[[7]]$namesbestmodel
models[[8]]$namesbestmodel
models[[9]]$namesbestmodel
models[[10]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel
models[[5]]$R2bestmodel
models[[6]]$R2bestmodel
models[[7]]$R2bestmodel
models[[8]]$R2bestmodel
models[[9]]$R2bestmodel
models[[10]]$R2bestmodel

#  at this point I always check whether the next model is more than 1% better than the one before and if not I end here

#   CODE FOR PICKING OUT THE BEST MODEL #   
temp <- 0
besti <- 0
for (i in 1:10){ #  think this runs the loop 10 times - not fully sure thought - but not to do with the number of models I don't think - as when I change to 3, I still get the model with 4 variables as best model
  print(models[[i]]$R2bestmodel)
  #       print(models[[i]]$summarybestmodel$coefficients=-1,4])
  #       if((models[[i]]$R2bestmodel-temp > 0.0) && (all(models[[i]]$summarybestmodel$coefficients[-1,4]<0.1))){
  #         temp <- models[[i]]$R2bestmodel
  #         besti <- i
  #         }
  if((models[[i]]$R2bestmodel-temp > 0.0) && (all(models[[i]]$summarybestmodel$coefficients[-1,4]<0.1))){
    temp <- models[[i]]$R2bestmodel
    besti <- i
  }else{
    finalBestModel_mecA_subsetI <- models[[besti]]$bestmodel
    finalBestModelNames_mecA_subsetI <- models[[besti]]$namesbestmodel
    Sites <- 1:dim(VGOB1_subsetI_mecA_LUR3)[1] # full original model
    #  CVaR2<-escCV_mecA_LUR3(Sites)[2] # Cross Validation
    maxCD<-max(cooks.distance(finalBestModel_mecA_subsetI))
    if(length(finalBestModelNames_mecA_subsetI)<2){ # vif fn doesnot work when only 1 variable...       # 
      maxVIF<-"NA"
    }else{
      maxVIF<-max(vif(finalBestModel_mecA_subsetI))
    }
    print(paste("This is the best mecA model for subset I: ",besti,
                "(AdjR2: ",format(models[[besti]]$R2bestmodel,digits=3), "; MaxCD: ",format(maxCD,digits=3),"; MaxVIF: ",
                format(maxVIF,digits=3),")", sep=''))
    print(finalBestModelNames_mecA_subsetI)
    break
  }
}

#  Overview of the final best model using the algorithm selection process (taking into account VIF, R^2, and p-values)
finalBestModel_mecA_subsetI
finalBestModelNames_mecA_subsetI
models[[besti]]$summarybestmodel
models[[besti]]$R2bestmodel

#### J ####
# LUR model building process for subset J
#  This is the dataframe with the relevant predictor vars for LUR3 models for subset J (55 sites)
VGOB1_subsetJ_mecA_LUR3 # n.b. this dataframe only includes microbial marker concentrations for mecA unlike the dataframe Measurements_livestockpreds_LUR3 as previously used for the model building. 

#  Now set the values of some variables that will be needed
nfirstvar_LUR_3 <- 3  
nlastvar_LUR_3 <- 135

# Function building to run the models 
# 1 #  

models<-list()
modeln<-1
models[[modeln]]<-list()

R2<-1
betaaddedvar<-1
addedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_3:nlastvar_LUR_3){
  if (is.numeric(VGOB1_subsetJ_mecA_LUR3[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetJ_mecA_LUR3$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetJ_mecA_LUR3[,i])                            
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    #  Measurements_livestockpreds_LUR3[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR3)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetJ_mecA_LUR3)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)
models[[modeln]]$results

#  this are the candidates models with the highest R2, not a negative beta for the new, nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)
models[[modeln]]$resultspos

#  rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))
models[[modeln]]$resultspos

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j
models[[modeln]]$indexbestmodel

subset(models[[modeln]]$resultspos, rank==1)
subset(models[[modeln]]$resultspos)

#  this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]
models[[modeln]]$summarybestmodel

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetJ_mecA_LUR3)[models[[1]]$indexbestmodel])
models[[modeln]]$namesbestmodel

#  this is the r2 of that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2
models[[modeln]]$R2bestmodel

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetJ_mecA_LUR3$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetJ_mecA_LUR3[,models[[1]]$indexbestmodel]) 
models[[modeln]]$bestmodel

summary(models[[modeln]]$bestmodel)

#  The first model includes the predictor: nPigMultipFarmWghtDist.3000m.sum.Tr.1P9 - meaning the number of multiplier pig farms weighted to distance in a 3000m buffer

# 2 #  
# Add 2nd variable (the only difference of the above part is that now modeln=2 the model statement has 2 variables)
# and the call for the list of variable names in the model changed slightly

modeln<-2

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_3:nlastvar_LUR_3){
  if (is.numeric(VGOB1_subsetJ_mecA_LUR3[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetJ_mecA_LUR3$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetJ_mecA_LUR3[,models[[1]]$indexbestmodel]+ VGOB1_subsetJ_mecA_LUR3[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # Measurements_livestockpreds_LUR3[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR3)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetJ_mecA_LUR3)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  these are the candidate models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)
models[[modeln]]$resultspos

#  rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))
models[[modeln]]$resultspos

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j
models[[modeln]]$indexbestmodel

subset(models[[modeln]]$resultspos, rank==1)

# this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]
models[[modeln]]$summarybestmodel

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetJ_mecA_LUR3)[models[[1]]$indexbestmodel], names(VGOB1_subsetJ_mecA_LUR3)[models[[2]]$indexbestmodel] )
models[[modeln]]$namesbestmodel

# this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2
models[[modeln]]$R2bestmodel

# this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetJ_mecA_LUR3$meca_copiespm3.ln.diffmeth.mean~                               VGOB1_subsetJ_mecA_LUR3[,models[[1]]$indexbestmodel]+                           VGOB1_subsetJ_mecA_LUR3[,models[[2]]$indexbestmodel]) 

models[[modeln]]$bestmodel

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel


# 3 #  
# add third variable (the only difference of the above part is that now modeln=3 the model statement has 3 variables)
# and the call for the list of variable names in the model changed slightly

modeln<-3

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_3:nlastvar_LUR_3){
  if (is.numeric(VGOB1_subsetJ_mecA_LUR3[,i])==TRUE){  
    modeltry<-lm(VGOB1_subsetJ_mecA_LUR3$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetJ_mecA_LUR3[,models[[1]]$indexbestmodel]+VGOB1_subsetJ_mecA_LUR3[,models[[2]]$indexbestmodel]+ VGOB1_subsetJ_mecA_LUR3[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # All[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR3)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetJ_mecA_LUR3)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

#  rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

#  this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

#  here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetJ_mecA_LUR3)[models[[1]]$indexbestmodel], names(VGOB1_subsetJ_mecA_LUR3)[models[[2]]$indexbestmodel], names(VGOB1_subsetJ_mecA_LUR3)[models[[3]]$indexbestmodel])

#  this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetJ_mecA_LUR3$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetJ_mecA_LUR3[,models[[1]]$indexbestmodel]+ VGOB1_subsetJ_mecA_LUR3[,models[[2]]$indexbestmodel]+ VGOB1_subsetJ_mecA_LUR3[,models[[3]]$indexbestmodel]) 

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel


# 4 #  
#  add forth variable (the only difference of the above part is that now model n=4 the model statement more variables)
#  and the call for the list of variable names in the model changed slightly
modeln<-4

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1


for (i in nfirstvar_LUR_3:nlastvar_LUR_3){
  if (is.numeric(VGOB1_subsetJ_mecA_LUR3[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetJ_mecA_LUR3$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetJ_mecA_LUR3[,models[[1]]$indexbestmodel]+VGOB1_subsetJ_mecA_LUR3[,models[[2]]$indexbestmodel]+VGOB1_subsetJ_mecA_LUR3[,models[[3]]$indexbestmodel]+VGOB1_subsetJ_mecA_LUR3[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    #  the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    #  All[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR3)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetJ_mecA_LUR3)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

#  this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

#  here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetJ_mecA_LUR3)[models[[1]]$indexbestmodel], names(VGOB1_subsetJ_mecA_LUR3)[models[[2]]$indexbestmodel], names(VGOB1_subsetJ_mecA_LUR3)[models[[3]]$indexbestmodel], names(VGOB1_subsetJ_mecA_LUR3)[models[[4]]$indexbestmodel])

#  this is the r2 of that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetJ_mecA_LUR3$meca_copiespm3.ln.diffmeth.mean~ VGOB1_subsetJ_mecA_LUR3[,models[[1]]$indexbestmodel]+ VGOB1_subsetJ_mecA_LUR3[,models[[2]]$indexbestmodel]+VGOB1_subsetJ_mecA_LUR3[,models[[3]]$indexbestmodel]+ VGOB1_subsetJ_mecA_LUR3[,models[[4]]$indexbestmodel]) 


models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel


# 5 #  
# add fifth variable (the only difference of the above part is that now modeln=5 the model statement more variables)
# and the call for the list of variable names in the model changed slightly
modeln<-5

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_3:nlastvar_LUR_3){
  if (is.numeric(VGOB1_subsetJ_mecA_LUR3[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetJ_mecA_LUR3$meca_copiespm3.ln.diffmeth.mean~ VGOB1_subsetJ_mecA_LUR3[,models[[1]]$indexbestmodel]+ VGOB1_subsetJ_mecA_LUR3[,models[[2]]$indexbestmodel]+ VGOB1_subsetJ_mecA_LUR3[,models[[3]]$indexbestmodel]+ VGOB1_subsetJ_mecA_LUR3[,models[[4]]$indexbestmodel]+ VGOB1_subsetJ_mecA_LUR3[,i]) 
  
R2<-rbind(R2,summary(modeltry)$adj.r.squared)
# the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # All[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR3)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetJ_mecA_LUR3)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

#  this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetJ_mecA_LUR3)[models[[1]]$indexbestmodel], names(VGOB1_subsetJ_mecA_LUR3)[models[[2]]$indexbestmodel], names(VGOB1_subsetJ_mecA_LUR3)[models[[3]]$indexbestmodel], names(VGOB1_subsetJ_mecA_LUR3)[models[[4]]$indexbestmodel], names(VGOB1_subsetJ_mecA_LUR3)[models[[5]]$indexbestmodel])

#  this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetJ_mecA_LUR3$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetJ_mecA_LUR3[,models[[1]]$indexbestmodel]+VGOB1_subsetJ_mecA_LUR3[,models[[2]]$indexbestmodel]+VGOB1_subsetJ_mecA_LUR3[,models[[3]]$indexbestmodel]+ VGOB1_subsetJ_mecA_LUR3[,models[[4]]$indexbestmodel]+ VGOB1_subsetJ_mecA_LUR3[,models[[5]]$indexbestmodel]) 
models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[5]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[5]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel
models[[5]]$R2bestmodel

# 6 #  
# add sixth variable (the only difference of the above part is that now model n=6 the model statement more variables)
#  and the call for the list of variable names in the model changed slightly

modeln<-6

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_3 :nlastvar_LUR_3){
  if (is.numeric(VGOB1_subsetJ_mecA_LUR3[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetJ_mecA_LUR3$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetJ_mecA_LUR3[,models[[1]]$indexbestmodel]+VGOB1_subsetJ_mecA_LUR3[,models[[2]]$indexbestmodel]+VGOB1_subsetJ_mecA_LUR3[,models[[3]]$indexbestmodel]+VGOB1_subsetJ_mecA_LUR3[,models[[4]]$indexbestmodel]+VGOB1_subsetJ_mecA_LUR3[,models[[5]]$indexbestmodel]+ VGOB1_subsetJ_mecA_LUR3[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # All[,i] is the row that's being tried out now. the name of that row can be found in  names(All)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetJ_mecA_LUR3)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

# this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetJ_mecA_LUR3)[models[[1]]$indexbestmodel], names(VGOB1_subsetJ_mecA_LUR3)[models[[2]]$indexbestmodel] , names(VGOB1_subsetJ_mecA_LUR3)[models[[3]]$indexbestmodel], names(VGOB1_subsetJ_mecA_LUR3)[models[[4]]$indexbestmodel], names(VGOB1_subsetJ_mecA_LUR3)[models[[5]]$indexbestmodel], names(VGOB1_subsetJ_mecA_LUR3)[models[[6]]$indexbestmodel])

#  this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetJ_mecA_LUR3$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetJ_mecA_LUR3[,models[[1]]$indexbestmodel]+VGOB1_subsetJ_mecA_LUR3[,models[[2]]$indexbestmodel]+VGOB1_subsetJ_mecA_LUR3[,models[[3]]$indexbestmodel]+ VGOB1_subsetJ_mecA_LUR3[,models[[4]]$indexbestmodel]+ VGOB1_subsetJ_mecA_LUR3[,models[[5]]$indexbestmodel]+ VGOB1_subsetJ_mecA_LUR3[,models[[6]]$indexbestmodel]) 

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[5]]$summarybestmodel
models[[6]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[5]]$namesbestmodel
models[[6]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel
models[[5]]$R2bestmodel
models[[6]]$R2bestmodel


# 7 #  
# add seventh variable (the only difference of the above part is that now model n=7 the model statement more variables)
#  and the call for the list of variable names in the model changed slightly

modeln<-7

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_3 :nlastvar_LUR_3){
  if (is.numeric(VGOB1_subsetJ_mecA_LUR3[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetJ_mecA_LUR3$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetJ_mecA_LUR3[,models[[1]]$indexbestmodel]+VGOB1_subsetJ_mecA_LUR3[,models[[2]]$indexbestmodel]+VGOB1_subsetJ_mecA_LUR3[,models[[3]]$indexbestmodel]+VGOB1_subsetJ_mecA_LUR3[,models[[4]]$indexbestmodel]+VGOB1_subsetJ_mecA_LUR3[,models[[5]]$indexbestmodel]+VGOB1_subsetJ_mecA_LUR3[,models[[6]]$indexbestmodel]+ VGOB1_subsetJ_mecA_LUR3[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # Measurements_livestockpreds_LUR3[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR3)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetJ_mecA_LUR3)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

# this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetJ_mecA_LUR3)[models[[1]]$indexbestmodel], names(VGOB1_subsetJ_mecA_LUR3)[models[[2]]$indexbestmodel] , names(VGOB1_subsetJ_mecA_LUR3)[models[[3]]$indexbestmodel], names(VGOB1_subsetJ_mecA_LUR3)[models[[4]]$indexbestmodel], names(VGOB1_subsetJ_mecA_LUR3)[models[[5]]$indexbestmodel], names(VGOB1_subsetJ_mecA_LUR3)[models[[6]]$indexbestmodel], names(VGOB1_subsetJ_mecA_LUR3)[models[[7]]$indexbestmodel])

#  this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetJ_mecA_LUR3$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetJ_mecA_LUR3[,models[[1]]$indexbestmodel]+VGOB1_subsetJ_mecA_LUR3[,models[[2]]$indexbestmodel]+VGOB1_subsetJ_mecA_LUR3[,models[[3]]$indexbestmodel]+ VGOB1_subsetJ_mecA_LUR3[,models[[4]]$indexbestmodel]+ VGOB1_subsetJ_mecA_LUR3[,models[[5]]$indexbestmodel]+ VGOB1_subsetJ_mecA_LUR3[,models[[6]]$indexbestmodel]+ VGOB1_subsetJ_mecA_LUR3[,models[[7]]$indexbestmodel]) 

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[5]]$summarybestmodel
models[[6]]$summarybestmodel
models[[7]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[5]]$namesbestmodel
models[[6]]$namesbestmodel
models[[7]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel
models[[5]]$R2bestmodel
models[[6]]$R2bestmodel
models[[7]]$R2bestmodel

# 8 #  
# add eighth variable (the only difference of the above part is that now modeln=7 the model statement more variables)
# and the call for the list of variable names in the model changed slightly

modeln<-8

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_3 :nlastvar_LUR_3){
  if (is.numeric(VGOB1_subsetJ_mecA_LUR3[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetJ_mecA_LUR3$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetJ_mecA_LUR3[,models[[1]]$indexbestmodel]+VGOB1_subsetJ_mecA_LUR3[,models[[2]]$indexbestmodel]+VGOB1_subsetJ_mecA_LUR3[,models[[3]]$indexbestmodel]+VGOB1_subsetJ_mecA_LUR3[,models[[4]]$indexbestmodel]+VGOB1_subsetJ_mecA_LUR3[,models[[5]]$indexbestmodel]+VGOB1_subsetJ_mecA_LUR3[,models[[6]]$indexbestmodel]+ VGOB1_subsetJ_mecA_LUR3[,models[[7]]$indexbestmodel]+ VGOB1_subsetJ_mecA_LUR3[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # Measurements_livestockpreds_LUR3[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR3)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetJ_mecA_LUR3)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

# this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetJ_mecA_LUR3)[models[[1]]$indexbestmodel], names(VGOB1_subsetJ_mecA_LUR3)[models[[2]]$indexbestmodel] , names(VGOB1_subsetJ_mecA_LUR3)[models[[3]]$indexbestmodel], names(VGOB1_subsetJ_mecA_LUR3)[models[[4]]$indexbestmodel], names(VGOB1_subsetJ_mecA_LUR3)[models[[5]]$indexbestmodel], names(VGOB1_subsetJ_mecA_LUR3)[models[[6]]$indexbestmodel], names(VGOB1_subsetJ_mecA_LUR3)[models[[7]]$indexbestmodel], names(VGOB1_subsetJ_mecA_LUR3)[models[[8]]$indexbestmodel])

#  this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetJ_mecA_LUR3$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetJ_mecA_LUR3[,models[[1]]$indexbestmodel]+VGOB1_subsetJ_mecA_LUR3[,models[[2]]$indexbestmodel]+VGOB1_subsetJ_mecA_LUR3[,models[[3]]$indexbestmodel]+ VGOB1_subsetJ_mecA_LUR3[,models[[4]]$indexbestmodel]+ VGOB1_subsetJ_mecA_LUR3[,models[[5]]$indexbestmodel]+ VGOB1_subsetJ_mecA_LUR3[,models[[6]]$indexbestmodel]+ VGOB1_subsetJ_mecA_LUR3[,models[[7]]$indexbestmodel]+ VGOB1_subsetJ_mecA_LUR3[,models[[8]]$indexbestmodel]) 

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[5]]$summarybestmodel
models[[6]]$summarybestmodel
models[[7]]$summarybestmodel
models[[8]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[5]]$namesbestmodel
models[[6]]$namesbestmodel
models[[7]]$namesbestmodel
models[[8]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel
models[[5]]$R2bestmodel
models[[6]]$R2bestmodel
models[[7]]$R2bestmodel
models[[8]]$R2bestmodel

# 9 #  
# add ninth variable (the only difference of the above part is that now modeln=9 the model statement more variables)
# and the call for the list of variable names in the model changed slightly

modeln<-9

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_3 :nlastvar_LUR_3){
  if (is.numeric(VGOB1_subsetJ_mecA_LUR3[,i])==TRUE){
      modeltry<-lm(VGOB1_subsetJ_mecA_LUR3$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetJ_mecA_LUR3[,models[[1]]$indexbestmodel]+VGOB1_subsetJ_mecA_LUR3[,models[[2]]$indexbestmodel]+VGOB1_subsetJ_mecA_LUR3[,models[[3]]$indexbestmodel]+VGOB1_subsetJ_mecA_LUR3[,models[[4]]$indexbestmodel]+VGOB1_subsetJ_mecA_LUR3[,models[[5]]$indexbestmodel]+VGOB1_subsetJ_mecA_LUR3[,models[[6]]$indexbestmodel]+ VGOB1_subsetJ_mecA_LUR3[,models[[7]]$indexbestmodel]+ VGOB1_subsetJ_mecA_LUR3[,models[[8]]$indexbestmodel]+ VGOB1_subsetJ_mecA_LUR3[,i]) 
        R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # Measurements_livestockpreds_LUR3[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR3)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetJ_mecA_LUR3)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

# this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetJ_mecA_LUR3)[models[[1]]$indexbestmodel], names(VGOB1_subsetJ_mecA_LUR3)[models[[2]]$indexbestmodel] , names(VGOB1_subsetJ_mecA_LUR3)[models[[3]]$indexbestmodel], names(VGOB1_subsetJ_mecA_LUR3)[models[[4]]$indexbestmodel], names(VGOB1_subsetJ_mecA_LUR3)[models[[5]]$indexbestmodel], names(VGOB1_subsetJ_mecA_LUR3)[models[[6]]$indexbestmodel], names(VGOB1_subsetJ_mecA_LUR3)[models[[7]]$indexbestmodel], names(VGOB1_subsetJ_mecA_LUR3)[models[[8]]$indexbestmodel],  names(VGOB1_subsetJ_mecA_LUR3)[models[[9]]$indexbestmodel])

#  this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetJ_mecA_LUR3$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetJ_mecA_LUR3[,models[[1]]$indexbestmodel]+VGOB1_subsetJ_mecA_LUR3[,models[[2]]$indexbestmodel]+VGOB1_subsetJ_mecA_LUR3[,models[[3]]$indexbestmodel]+ VGOB1_subsetJ_mecA_LUR3[,models[[4]]$indexbestmodel]+ VGOB1_subsetJ_mecA_LUR3[,models[[5]]$indexbestmodel]+ VGOB1_subsetJ_mecA_LUR3[,models[[6]]$indexbestmodel]+ VGOB1_subsetJ_mecA_LUR3[,models[[7]]$indexbestmodel]+ VGOB1_subsetJ_mecA_LUR3[,models[[8]]$indexbestmodel]+ VGOB1_subsetJ_mecA_LUR3[,models[[9]]$indexbestmodel]) 

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[5]]$summarybestmodel
models[[6]]$summarybestmodel
models[[7]]$summarybestmodel
models[[8]]$summarybestmodel
models[[9]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[5]]$namesbestmodel
models[[6]]$namesbestmodel
models[[7]]$namesbestmodel
models[[8]]$namesbestmodel
models[[9]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel
models[[5]]$R2bestmodel
models[[6]]$R2bestmodel
models[[7]]$R2bestmodel
models[[8]]$R2bestmodel
models[[9]]$R2bestmodel

# 10 #  
#  add tenth variable (the only difference of the above part is that now model n=10 the model statement more variables)
#  and the call for the list of variable names in the model changed slightly

modeln<-10

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_3 :nlastvar_LUR_3){if (is.numeric(VGOB1_subsetJ_mecA_LUR3[,i])==TRUE){ modeltry<-lm(VGOB1_subsetJ_mecA_LUR3$meca_copiespm3.ln.diffmeth.mean~VGOB1_subsetJ_mecA_LUR3[,models[[1]]$indexbestmodel]+VGOB1_subsetJ_mecA_LUR3[,models[[2]]$indexbestmodel]+ VGOB1_subsetJ_mecA_LUR3[,models[[3]]$indexbestmodel]+VGOB1_subsetJ_mecA_LUR3[,models[[4]]$indexbestmodel]+ VGOB1_subsetJ_mecA_LUR3[,models[[5]]$indexbestmodel]+ VGOB1_subsetJ_mecA_LUR3[,models[[6]]$indexbestmodel]+ VGOB1_subsetJ_mecA_LUR3[,models[[7]]$indexbestmodel]+ VGOB1_subsetJ_mecA_LUR3[,models[[8]]$indexbestmodel]+ VGOB1_subsetJ_mecA_LUR3[,models[[9]]$indexbestmodel]+ VGOB1_subsetJ_mecA_LUR3[,i]) 

R2<-rbind(R2,summary(modeltry)$adj.r.squared)
# the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # Measurements_livestockpreds_LUR3[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR3)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetJ_mecA_LUR3)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

# this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

# here are the names
models[[modeln]]$namesbestmodel<-c( names(VGOB1_subsetJ_mecA_LUR3)[models[[1]]$indexbestmodel],                   names(VGOB1_subsetJ_mecA_LUR3)[models[[2]]$indexbestmodel] , names(VGOB1_subsetJ_mecA_LUR3)[models[[3]]$indexbestmodel], names(VGOB1_subsetJ_mecA_LUR3)[models[[4]]$indexbestmodel], names(VGOB1_subsetJ_mecA_LUR3)[models[[5]]$indexbestmodel], names(VGOB1_subsetJ_mecA_LUR3)[models[[6]]$indexbestmodel], names(VGOB1_subsetJ_mecA_LUR3)[models[[7]]$indexbestmodel], names(VGOB1_subsetJ_mecA_LUR3)[models[[8]]$indexbestmodel], names(VGOB1_subsetJ_mecA_LUR3)[models[[9]]$indexbestmodel], names(VGOB1_subsetJ_mecA_LUR3)[models[[10]]$indexbestmodel])

#  this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetJ_mecA_LUR3$meca_copiespm3.ln.diffmeth.mean~                                VGOB1_subsetJ_mecA_LUR3[,models[[1]]$indexbestmodel]+ VGOB1_subsetJ_mecA_LUR3[,models[[2]]$indexbestmodel]+                           VGOB1_subsetJ_mecA_LUR3[,models[[3]]$indexbestmodel]+ VGOB1_subsetJ_mecA_LUR3[,models[[4]]$indexbestmodel]+ VGOB1_subsetJ_mecA_LUR3[,models[[5]]$indexbestmodel]+ VGOB1_subsetJ_mecA_LUR3[,models[[6]]$indexbestmodel]+ VGOB1_subsetJ_mecA_LUR3[,models[[7]]$indexbestmodel]+ VGOB1_subsetJ_mecA_LUR3[,models[[8]]$indexbestmodel]+ VGOB1_subsetJ_mecA_LUR3[,models[[9]]$indexbestmodel]+ VGOB1_subsetJ_mecA_LUR3[,models[[10]]$indexbestmodel]) 

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[5]]$summarybestmodel
models[[6]]$summarybestmodel
models[[7]]$summarybestmodel
models[[8]]$summarybestmodel
models[[9]]$summarybestmodel
models[[10]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[5]]$namesbestmodel
models[[6]]$namesbestmodel
models[[7]]$namesbestmodel
models[[8]]$namesbestmodel
models[[9]]$namesbestmodel
models[[10]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel
models[[5]]$R2bestmodel
models[[6]]$R2bestmodel
models[[7]]$R2bestmodel
models[[8]]$R2bestmodel
models[[9]]$R2bestmodel
models[[10]]$R2bestmodel

#  at this point I always check whether the next model is more than 1% better than the one before and if not I end here

#   CODE FOR PICKING OUT THE BEST MODEL #   
temp <- 0
besti <- 0
for (i in 1:10){ #  think this runs the loop 10 times - not fully sure thought - but not to do with the number of models I don't think - as when I change to 3, I still get the model with 4 variables as best model
  print(models[[i]]$R2bestmodel)
  #       print(models[[i]]$summarybestmodel$coefficients=-1,4])
  #       if((models[[i]]$R2bestmodel-temp > 0.0) && (all(models[[i]]$summarybestmodel$coefficients[-1,4]<0.1))){
  #         temp <- models[[i]]$R2bestmodel
  #         besti <- i
  #         }
  if((models[[i]]$R2bestmodel-temp > 0.0) && (all(models[[i]]$summarybestmodel$coefficients[-1,4]<0.1))){
    temp <- models[[i]]$R2bestmodel
    besti <- i
  }else{
    finalBestModel_mecA_subsetJ <- models[[besti]]$bestmodel
    finalBestModelNames_mecA_subsetJ <- models[[besti]]$namesbestmodel
    Sites <- 1:dim(VGOB1_subsetJ_mecA_LUR3)[1] # full original model
    #  CVaR2<-escCV_mecA_LUR3(Sites)[2] # Cross Validation
    maxCD<-max(cooks.distance(finalBestModel_mecA_subsetJ))
    if(length(finalBestModelNames_mecA_subsetJ)<2){ # vif fn doesnot work when only 1 variable...       # 
      maxVIF<-"NA"
    }else{
      maxVIF<-max(vif(finalBestModel_mecA_subsetJ))
    }
    print(paste("This is the best mecA model for subset J: ",besti,
                "(AdjR2: ",format(models[[besti]]$R2bestmodel,digits=3), "; MaxCD: ",format(maxCD,digits=3),"; MaxVIF: ",
                format(maxVIF,digits=3),")", sep=''))
    print(finalBestModelNames_mecA_subsetJ)
    break
  }
}

#  Overview of the final best model using the algorithm selection process (taking into account VIF, R^2, and p-values)
finalBestModel_mecA_subsetJ
finalBestModelNames_mecA_subsetJ
models[[besti]]$summarybestmodel
models[[besti]]$R2bestmodel

#### Predicting hold out sites ####
# These are the models from the 10 subsets: 
finalBestModel_mecA_subsetA
finalBestModel_mecA_subsetB
finalBestModel_mecA_subsetC
finalBestModel_mecA_subsetD
finalBestModel_mecA_subsetE
finalBestModel_mecA_subsetF
finalBestModel_mecA_subsetG
finalBestModel_mecA_subsetH
finalBestModel_mecA_subsetI
finalBestModel_mecA_subsetJ

#  Selecting of test sets
#  valID 1 to 10
VGOB1_subsetvalID1 <- subset(VGOB1_FINAL_mecA, valID == 1)
VGOB1_subsetvalID2 <- subset(VGOB1_FINAL_mecA, valID == 2)
VGOB1_subsetvalID3 <- subset(VGOB1_FINAL_mecA, valID == 3)
VGOB1_subsetvalID4 <- subset(VGOB1_FINAL_mecA, valID == 4)
VGOB1_subsetvalID5 <- subset(VGOB1_FINAL_mecA, valID == 5)
VGOB1_subsetvalID6 <- subset(VGOB1_FINAL_mecA, valID == 6)
VGOB1_subsetvalID7 <- subset(VGOB1_FINAL_mecA, valID == 7)
VGOB1_subsetvalID8 <- subset(VGOB1_FINAL_mecA, valID == 8)
VGOB1_subsetvalID9 <- subset(VGOB1_FINAL_mecA, valID == 9)
VGOB1_subsetvalID10 <- subset(VGOB1_FINAL_mecA, valID == 10)

#  For every subset predict (based on LUR model for that subset, so the training sites) the concentrations at the sites left out (test sites) to enable comparisons observed vs predicted 

#  Set 1
finalBestModel_mecA_subsetA
finalBestModelNames_mecA_subsetA
summary(finalBestModel_mecA_subsetA)
# write the model out
finalBestModel_mecA_subsetA_lm <- lm(meca_copiespm3.ln.diffmeth.mean~npoultryWghtDist.3000m.sum.95Win.10to90scaled + nPigMultipFarmWghtDist.3000m.sum.95Win.10to90scaled + PoultryFarm.1000m.95Win.10to90scaled, data = VGOB1_subsetA_mecA_LUR3)
VGOB1_subsetvalID1$mecA_PRED_HV <- predict(finalBestModel_mecA_subsetA_lm,VGOB1_subsetvalID1)
summary(VGOB1_subsetvalID1$mecA_PRED_HV)
plot(VGOB1_subsetvalID1$mecA_PRED_HV, VGOB1_subsetvalID1$meca_copiespm3.ln.diffmeth.mean, xlab="mecA predicted (HV)", ylab="mecA concentration observed")
VGOB1_subsetvalID1_Rsq <- lm(meca_copiespm3.ln.diffmeth.mean~mecA_PRED_HV, data=VGOB1_subsetvalID1 )
summary(VGOB1_subsetvalID1_Rsq)

#  Set 2
finalBestModel_mecA_subsetB
finalBestModelNames_mecA_subsetB
summary(finalBestModel_mecA_subsetB)
# write the model out
finalBestModel_mecA_subsetB_lm <- lm(meca_copiespm3.ln.diffmeth.mean~ PoultryFarm.3000m.95Win.10to90scaled+ nboarsWghtDist.3000m.sum.95Win.10to90scaled + npoultry.1000m.95Win.10to90scaled + HorseFarm.3000m.95Win.10to90scaled , data = VGOB1_subsetB_mecA_LUR3)
VGOB1_subsetvalID2$mecA_PRED_HV <- predict(finalBestModel_mecA_subsetB_lm,VGOB1_subsetvalID2)
summary(VGOB1_subsetvalID2$mecA_PRED_HV)
plot(VGOB1_subsetvalID2$mecA_PRED_HV, VGOB1_subsetvalID2$meca_copiespm3.ln.diffmeth.mean, xlab="mecA predicted (HV)", ylab="mecA concentration observed")
VGOB1_subsetvalID2_Rsq <- lm(meca_copiespm3.ln.diffmeth.mean~mecA_PRED_HV, data=VGOB1_subsetvalID2)
summary(VGOB1_subsetvalID2_Rsq)

#  Set 3
finalBestModel_mecA_subsetC
finalBestModelNames_mecA_subsetC
summary(finalBestModel_mecA_subsetC)
# write the model out
finalBestModel_mecA_subsetC_lm <- lm(meca_copiespm3.ln.diffmeth.mean~ nbroilerchicks.3000m.95Win.10to90scaled + npigletsWghtDist.1000m.sum.95Win.10to90scaled + npoultry.1000m.95Win.10to90scaled + MeatctlFarm.3000m.95Win.10to90scaled, data = VGOB1_subsetC_mecA_LUR3)
VGOB1_subsetvalID3$mecA_PRED_HV <- predict(finalBestModel_mecA_subsetC_lm,VGOB1_subsetvalID3)
summary(VGOB1_subsetvalID3$mecA_PRED_HV)
plot(VGOB1_subsetvalID3$mecA_PRED_HV, VGOB1_subsetvalID3$meca_copiespm3.ln.diffmeth.mean, xlab="mecA predicted (HV)", ylab="mecA concentration observed")
VGOB1_subsetvalID3_Rsq <- lm(meca_copiespm3.ln.diffmeth.mean~mecA_PRED_HV, data=VGOB1_subsetvalID3 )
summary(VGOB1_subsetvalID3_Rsq)

#  Set 4
finalBestModel_mecA_subsetD
finalBestModelNames_mecA_subsetD
summary(finalBestModel_mecA_subsetD)
# write the model out
finalBestModel_mecA_subsetD_lm <- lm(meca_copiespm3.ln.diffmeth.mean~ npoultry.3000m.95Win.10to90scaled + notherpoultryanimWghtDist.3000m.sum.95Win.10to90scaled + HorseFarm.3000m.95Win.10to90scaled + npoultry.1000m.95Win.10to90scaled + nsowsWghtDist.3000m.sum.95Win.10to90scaled, data = VGOB1_subsetD_mecA_LUR3)
VGOB1_subsetvalID4$mecA_PRED_HV <- predict(finalBestModel_mecA_subsetD_lm,VGOB1_subsetvalID4)
summary(VGOB1_subsetvalID4$mecA_PRED_HV)
plot(VGOB1_subsetvalID4$mecA_PRED_HV, VGOB1_subsetvalID4$meca_copiespm3.ln.diffmeth.mean, xlab="mecA predicted (HV)", ylab="mecA concentration observed")
VGOB1_subsetvalID4_Rsq <- lm(meca_copiespm3.ln.diffmeth.mean~mecA_PRED_HV, data=VGOB1_subsetvalID4 )
summary(VGOB1_subsetvalID4_Rsq)

#  Set 5
finalBestModel_mecA_subsetE
finalBestModelNames_mecA_subsetE
summary(finalBestModel_mecA_subsetE)
# write the model out
finalBestModel_mecA_subsetE_lm <- lm(meca_copiespm3.ln.diffmeth.mean~npoultry.3000m.95Win.10to90scaled + nboarsWghtDist.1000m.sum.95Win.10to90scaled + MeatctlFarm.3000m.95Win.10to90scaled + npoultry.500m.95Win.10to90scaled + HorseFarm.3000m.95Win.10to90scaled, data = VGOB1_subsetE_mecA_LUR3)
VGOB1_subsetvalID5$mecA_PRED_HV <- predict(finalBestModel_mecA_subsetE_lm,VGOB1_subsetvalID5)
summary(VGOB1_subsetvalID5$mecA_PRED_HV)
plot(VGOB1_subsetvalID5$mecA_PRED_HV, VGOB1_subsetvalID5$meca_copiespm3.ln.diffmeth.mean, xlab="mecA predicted (HV)", ylab="mecA concentration observed")
VGOB1_subsetvalID5_Rsq <- lm(meca_copiespm3.ln.diffmeth.mean~mecA_PRED_HV, data=VGOB1_subsetvalID5)
summary(VGOB1_subsetvalID5_Rsq)

#  Set 6
finalBestModel_mecA_subsetF
finalBestModelNames_mecA_subsetF
summary(finalBestModel_mecA_subsetF)
# write the model out
finalBestModel_mecA_subsetF_lm <- lm(meca_copiespm3.ln.diffmeth.mean~npoultry.3000m.95Win.10to90scaled + nPigMultipFarmWghtDist.3000m.sum.95Win.10to90scaled + npoultry.1000m.95Win.10to90scaled + HorseFarm.3000m.95Win.10to90scaled, data = VGOB1_subsetF_mecA_LUR3)
VGOB1_subsetvalID6$mecA_PRED_HV <- predict(finalBestModel_mecA_subsetF_lm,VGOB1_subsetvalID1)
summary(VGOB1_subsetvalID6$mecA_PRED_HV)
plot(VGOB1_subsetvalID6$mecA_PRED_HV, VGOB1_subsetvalID6$meca_copiespm3.ln.diffmeth.mean, xlab="mecA predicted (HV)", ylab="mecA concentration observed")
VGOB1_subsetvalID6_Rsq <- lm(meca_copiespm3.ln.diffmeth.mean~mecA_PRED_HV, data=VGOB1_subsetvalID6 )
summary(VGOB1_subsetvalID6_Rsq)

#  Set 7
finalBestModel_mecA_subsetG
finalBestModelNames_mecA_subsetG
summary(finalBestModel_mecA_subsetG)
# write the model out
finalBestModel_mecA_subsetG_lm <- lm(meca_copiespm3.ln.diffmeth.mean~npoultryWghtDist.3000m.sum.95Win.10to90scaled + nboarsWghtDist.1000m.sum.95Win.10to90scaled + HorseFarm.3000m.95Win.10to90scaled + MeatctlFarm.3000m.95Win.10to90scaled, data = VGOB1_subsetG_mecA_LUR3)
VGOB1_subsetvalID7$mecA_PRED_HV <- predict(finalBestModel_mecA_subsetG_lm,VGOB1_subsetvalID7)
summary(VGOB1_subsetvalID7$mecA_PRED_HV)
plot(VGOB1_subsetvalID7$mecA_PRED_HV, VGOB1_subsetvalID7$meca_copiespm3.ln.diffmeth.mean, xlab="mecA predicted (HV)", ylab="mecA concentration observed")
VGOB1_subsetvalID7_Rsq <- lm(meca_copiespm3.ln.diffmeth.mean~mecA_PRED_HV, data=VGOB1_subsetvalID7)
summary(VGOB1_subsetvalID1_Rsq)

#  Set 8
finalBestModel_mecA_subsetH
finalBestModelNames_mecA_subsetH
summary(finalBestModel_mecA_subsetH)
# write the model out
finalBestModel_mecA_subsetH_lm <- lm(meca_copiespm3.ln.diffmeth.mean~ npoultry.3000m.95Win.10to90scaled + nboarsWghtDist.1000m.sum.95Win.10to90scaled + BroilerFarm.1000m.95Win.10to90scaled + HorseFarm.3000m.95Win.10to90scaled, data = VGOB1_subsetH_mecA_LUR3)
VGOB1_subsetvalID8$mecA_PRED_HV <- predict(finalBestModel_mecA_subsetH_lm,VGOB1_subsetvalID8)
summary(VGOB1_subsetvalID8$mecA_PRED_HV)
plot(VGOB1_subsetvalID8$mecA_PRED_HV, VGOB1_subsetvalID8$meca_copiespm3.ln.diffmeth.mean, xlab="mecA predicted (HV)", ylab="mecA concentration observed")
VGOB1_subsetvalID8_Rsq <- lm(meca_copiespm3.ln.diffmeth.mean~mecA_PRED_HV, data=VGOB1_subsetvalID8)
summary(VGOB1_subsetvalID8_Rsq)

#  Set 9
finalBestModel_mecA_subsetI
finalBestModelNames_mecA_subsetI
summary(finalBestModel_mecA_subsetI)
# write the model out
finalBestModel_mecA_subsetI_lm <- lm(meca_copiespm3.ln.diffmeth.mean~npoultryWghtDist.3000m.sum.95Win.10to90scaled + nPigMultipFarmWghtDist.3000m.sum.95Win.10to90scaled , data = VGOB1_subsetI_mecA_LUR3)
VGOB1_subsetvalID9$mecA_PRED_HV <- predict(finalBestModel_mecA_subsetI_lm,VGOB1_subsetvalID9)
summary(VGOB1_subsetvalID9$mecA_PRED_HV)
plot(VGOB1_subsetvalID9$mecA_PRED_HV, VGOB1_subsetvalID9$meca_copiespm3.ln.diffmeth.mean, xlab="mecA predicted (HV)", ylab="mecA concentration observed")
VGOB1_subsetvalID9_Rsq <- lm(meca_copiespm3.ln.diffmeth.mean~mecA_PRED_HV, data=VGOB1_subsetvalID9 )
summary(VGOB1_subsetvalID9_Rsq)

#  Set 10
finalBestModel_mecA_subsetJ
finalBestModelNames_mecA_subsetJ
summary(finalBestModel_mecA_subsetJ)
# write the model out
finalBestModel_mecA_subsetJ_lm <- lm(meca_copiespm3.ln.diffmeth.mean~ npoultryWghtDist.3000m.sum.95Win.10to90scaled + PigMultipFarm.1000m.95Win.10to90scaled + nboars.3000m.95Win.10to90scaled + HorseFarm.3000m.95Win.10to90scaled , data = VGOB1_subsetJ_mecA_LUR3)
VGOB1_subsetvalID10$mecA_PRED_HV <- predict(finalBestModel_mecA_subsetJ_lm,VGOB1_subsetvalID10)
summary(VGOB1_subsetvalID10$mecA_PRED_HV)
plot(VGOB1_subsetvalID10$mecA_PRED_HV, VGOB1_subsetvalID10$meca_copiespm3.ln.diffmeth.mean, xlab="mecA predicted (HV)", ylab="mecA concentration observed")
VGOB1_subsetvalID10_Rsq <- lm(meca_copiespm3.ln.diffmeth.mean~mecA_PRED_HV, data=VGOB1_subsetvalID10)
summary(VGOB1_subsetvalID10_Rsq)

# Calculate max VIF and cook's distnace of each subset (each fold of the 10-fold CV)
# Since all models only include 1 variable, VIF is not possible to calculate
maxVIF_meca_LUR3_subsetA <- max(vif(finalBestModel_mecA_subsetA))
maxVIF_meca_LUR3_subsetB <- max(vif(finalBestModel_mecA_subsetB))
maxVIF_meca_LUR3_subsetC <- max(vif(finalBestModel_mecA_subsetC))
maxVIF_meca_LUR3_subsetD <- max(vif(finalBestModel_mecA_subsetD))
maxVIF_meca_LUR3_subsetE <- max(vif(finalBestModel_mecA_subsetE))
maxVIF_meca_LUR3_subsetF <- max(vif(finalBestModel_mecA_subsetF))
maxVIF_meca_LUR3_subsetG <- max(vif(finalBestModel_mecA_subsetG))
maxVIF_meca_LUR3_subsetH <- max(vif(finalBestModel_mecA_subsetH))
maxVIF_meca_LUR3_subsetI <- max(vif(finalBestModel_mecA_subsetI))
maxVIF_meca_LUR3_subsetJ <- max(vif(finalBestModel_mecA_subsetJ))

maxCD_meca_LUR3_subsetA <- max(cooks.distance(finalBestModel_mecA_subsetA))
maxCD_meca_LUR3_subsetB <- max(cooks.distance(finalBestModel_mecA_subsetB))
maxCD_meca_LUR3_subsetC <- max(cooks.distance(finalBestModel_mecA_subsetC))
maxCD_meca_LUR3_subsetD <- max(cooks.distance(finalBestModel_mecA_subsetD))
maxCD_meca_LUR3_subsetE <- max(cooks.distance(finalBestModel_mecA_subsetE))
maxCD_meca_LUR3_subsetF <- max(cooks.distance(finalBestModel_mecA_subsetF))
maxCD_meca_LUR3_subsetG <- max(cooks.distance(finalBestModel_mecA_subsetG))
maxCD_meca_LUR3_subsetH <- max(cooks.distance(finalBestModel_mecA_subsetH))
maxCD_meca_LUR3_subsetI <- max(cooks.distance(finalBestModel_mecA_subsetI))
maxCD_meca_LUR3_subsetJ <- max(cooks.distance(finalBestModel_mecA_subsetJ))

# Write out the max VIF and cook's distance figures for each of the 10 folds, and create a dataframe 

meca_LUR3_maxVIF_subsetvalID1to10 <- c(maxVIF_meca_LUR3_subsetA, maxVIF_meca_LUR3_subsetB, maxVIF_meca_LUR3_subsetC, maxVIF_meca_LUR3_subsetD, maxVIF_meca_LUR3_subsetE, maxVIF_meca_LUR3_subsetF, maxVIF_meca_LUR3_subsetG, maxVIF_meca_LUR3_subsetH, maxVIF_meca_LUR3_subsetI, maxVIF_meca_LUR3_subsetJ)

meca_LUR3_maxCD_maxCD_subsetvalID1to10 <- c(maxCD_meca_LUR3_subsetA, maxCD_meca_LUR3_subsetB, maxCD_meca_LUR3_subsetC, maxCD_meca_LUR3_subsetD, maxCD_meca_LUR3_subsetE, maxCD_meca_LUR3_subsetF, maxCD_meca_LUR3_subsetG, maxCD_meca_LUR3_subsetH, maxCD_meca_LUR3_subsetI, maxCD_meca_LUR3_subsetJ)

meca_LUR3_maxVIF_maxCD_matrix <- cbind(meca_LUR3_maxVIF_subsetvalID1to10, meca_LUR3_maxCD_maxCD_subsetvalID1to10)
meca_LUR3_maxVIF_maxCD_df <- as.data.frame(meca_LUR3_maxVIF_maxCD_matrix)

row.names(meca_LUR3_maxVIF_maxCD_df) <- c("SubsetA", "SubsetB", "SubsetC", "SubsetD", "SubsetE", "SubsetF", "SubsetG", "SubsetH", "SubsetI", "SubsetJ")

write_xlsx(meca_LUR3_maxVIF_maxCD_df,"Output_files\\meca_LUR3_maxVIF_maxCD_df.xlsx")

#  Merging of all test sets to make overall comparisons of predicted vs observed
VGOB1_subsetvalID1to10_mecA_10foldCV <- rbind(VGOB1_subsetvalID1, VGOB1_subsetvalID2, VGOB1_subsetvalID3, VGOB1_subsetvalID4, VGOB1_subsetvalID5, VGOB1_subsetvalID6, VGOB1_subsetvalID7, VGOB1_subsetvalID8, VGOB1_subsetvalID9, VGOB1_subsetvalID10)

#  Overall comparison of predicted vs observed
plot(VGOB1_subsetvalID1to10_mecA_10foldCV$mecA_PRED_HV, VGOB1_subsetvalID1to10_mecA_10foldCV$meca_copiespm3.ln.diffmeth.mean, xlab="LUR3-predicted mecA DNA concentration (ln copies/m^3)", ylab="Observed mecA DNA concentration (ln copies/m^3)", cex.lab=0.85)
abline(lm(VGOB1_subsetvalID1to10_mecA_10foldCV$meca_copiespm3.ln.diffmeth.mean ~ VGOB1_subsetvalID1to10_mecA_10foldCV$mecA_PRED_HV))

VGOB1_subsetvalID1to10_mecA_LUR3_10foldCV_lm <- lm(meca_copiespm3.ln.diffmeth.mean ~ mecA_PRED_HV, data=VGOB1_subsetvalID1to10_mecA_10foldCV)
summary(VGOB1_subsetvalID1to10_mecA_LUR3_10foldCV_lm)

#  10-fold HV R^2 (adjusted) for mecA LUR model 3 = 0.143

#  Calculate RMSE
RMSE_meca_LUR3_10foldCV <- sqrt(mean((VGOB1_subsetvalID1to10_mecA_10foldCV$meca_copiespm3.ln.diffmeth.mean - VGOB1_subsetvalID1to10_mecA_10foldCV$mecA_PRED_HV)^2))
RMSE_meca_LUR3_10foldCV

# RMSE = 0.9327878

#  Save these predicted concentrations as an excel file along with the actual measured concentrations of mecA at each of the measurement sites 
#  These are the predicted concentrations for the sites that were left out of the model training procedure in 10-fold cross validation 
mecA_LUR3_10foldCV_preds <- VGOB1_subsetvalID1to10_mecA_10foldCV$mecA_PRED_HV 
#  These are the actual measured concentrations at the 61 measurement sites - these are in the same order as the above sites in order to match the predicted concentrations (i.e. not in order 1-61)
VGOB1_subsetvalID1to10_mecA_10foldCV$meca_copiespm3.ln.diffmeth.mean

VGOB1_subsetvalID1to10_mecA_10foldCV$Loc_ID

#  Create a dataframe 
mecA_SLR_10foldCVpreds_observed <- data.frame(VGOB1_subsetvalID1to10_mecA_10foldCV$Loc_ID,VGOB1_subsetvalID1to10_mecA_10foldCV$meca_copiespm3.ln.diffmeth.mean, VGOB1_subsetvalID1to10_mecA_10foldCV$mecA_PRED_HV)
print(mecA_SLR_10foldCVpreds_observed)

#  Save as xls file 
library("writexl")
write_xlsx(mecA_SLR_10foldCVpreds_observed,"Output_files\\mecA_LUR3_10foldCV_observed_predicted.xlsx")
```
# Summarise performance (R2 and RMSE) of the meca models in a table 
```{r}
# meca 
# R-squared values
# Training models
meca_LUR1_trainingmodel_rsq <- summary(meca_LUR1_algorithmmethod)$r.squared
meca_LUR2_trainingmodel_rsq <- summary(meca_LUR2_algorithmmethod)$r.squared
meca_LUR3_trainingmodel_rsq <- summary(meca_LUR3_algorithmmethod)$r.squared

# LOOCV models 
meca_LUR1_LOOCVmodel_rsq <- summary(meca_LUR1_LOOCV_lm)$r.squared
meca_LUR2_LOOCVmodel_rsq <- summary(meca_LUR2_LOOCV_lm)$r.squared
meca_LUR3_LOOCVmodel_rsq <- summary(meca_LUR3_LOOCV_lm)$r.squared

# 10-fold CV models
meca_LUR1_10foldCVmodel_rsq <- summary(VGOB1_subsetvalID1to10_meca_LUR1_10foldCV_lm)$r.squared
meca_LUR2_10foldCVmodel_rsq <- summary(VGOB1_subsetvalID1to10_meca_LUR2_10foldCV_lm)$r.squared
meca_LUR3_10foldCVmodel_rsq <- summary(VGOB1_subsetvalID1to10_mecA_LUR3_10foldCV_lm)$r.squared

# RMSE
# Training models
RMSE_meca_LUR1
RMSE_meca_LUR2
RMSE_meca_LUR3
# LOOCV models
RMSE_meca_LUR1_LOOCV
RMSE_meca_LUR2_LOOCV
RMSE_meca_LUR3_LOOCV

# 10-fold CV models 
RMSE_meca_LUR1_10foldCV
RMSE_meca_LUR2_10foldCV
RMSE_meca_LUR3_10foldCV

# Create dataframes
# Training models 
meca_trainingmodels_rsq <- c(meca_LUR1_trainingmodel_rsq,meca_LUR2_trainingmodel_rsq, meca_LUR3_trainingmodel_rsq)

meca_trainingmodels_RMSE <- c(RMSE_meca_LUR1,RMSE_meca_LUR2, RMSE_meca_LUR3)

# LOOCV models 
meca_LOOCVmodels_rsq <- c(meca_LUR1_LOOCVmodel_rsq,meca_LUR2_LOOCVmodel_rsq, meca_LUR3_LOOCVmodel_rsq)

meca_LOOCVmodels_RMSE <- c(RMSE_meca_LUR1_LOOCV,RMSE_meca_LUR2_LOOCV, RMSE_meca_LUR3_LOOCV)

# 10-fold CV models 
meca_10foldCVmodels_rsq <- c(meca_LUR1_10foldCVmodel_rsq,meca_LUR2_10foldCVmodel_rsq, meca_LUR3_10foldCVmodel_rsq)

meca_10foldCVmodels_RMSE <- c(RMSE_meca_LUR1_10foldCV,RMSE_meca_LUR2_10foldCV, RMSE_meca_LUR3_10foldCV)

# dataframe of all rsq and RMSE values from the training, LOOCV and 10-folds models (LUR1,2,3)
meca_allmodels_Rsq_RMSE <- data.frame(meca_trainingmodels_rsq, meca_trainingmodels_RMSE, meca_LOOCVmodels_rsq, meca_LOOCVmodels_RMSE, meca_10foldCVmodels_rsq, meca_10foldCVmodels_RMSE)
row_names_mecamodels <- c("LUR1", "LUR2", "LUR3")
row.names(meca_allmodels_Rsq_RMSE) <- row_names_mecamodels

write.csv(meca_allmodels_Rsq_RMSE,"Output_files\\meca_allmodels_Rsq_RMSE.csv")
```