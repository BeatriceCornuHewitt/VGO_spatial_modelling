#  Staph 

I create 3 SLR LUR models for staph with differing levels of livestock exposure
In order to find the best model I firstly run at least 10 models with one more predictor added  
I then  use the (modified) selection code (see below) which was originally developed for the ESCAPE project
# Packages
```{r}
library(car)
library(writexl)
library(olsrr)
```
# Define the variables for LUR1, LUR2 and LUR3
```{r}
# Define the input variables
Measurements_livestockpreds_LUR1 <- read.csv("Input_files//Measurements_livestockpreds_LUR1.csv")
Measurements_livestockpreds_LUR2 <- read.csv("Input_files//Measurements_livestockpreds_LUR2.csv")
Measurements_livestockpreds_LUR3 <- read.csv("Input_files//Measurements_livestockpreds_LUR3.csv")

# Define the outcome variable
staph <- Measurements_livestockpreds_LUR1$staph_copiespm3.ln.diffmeth.mean

#  Now set the values of some variables that will be needed
# LUR1
nfirstvar_LUR1 <- 6 
nlastvar_LUR1 <- 13
# LUR2
nfirstvar_LUR_2 <- 6
nlastvar_LUR_2 <- 74
# LUR3 
nfirstvar_LUR_3 <- 6  
nlastvar_LUR_3 <- 138
```
#  Staph LUR1 model - training model
```{r}
#  This is the df with the predictors for LUR model 1 
Measurements_livestockpreds_LUR1 <- read.csv("Input_files//Measurements_livestockpreds_LUR1.csv")
Measurements_livestockpreds_LUR1 

staph <- Measurements_livestockpreds_LUR1$staph_copiespm3.ln.diffmeth.mean

#  Now set the values of some variables that will be needed
nfirstvar_LUR1_staph <- 6  #  given that the list of explanatory variables is at the end of the table: specify in which row the first explanatory variable is
nlastvar_LUR1_staph <- 13

#  Function building to run the models
#  1 #  
models<-list()

modeln<-1
models[[modeln]]<-list()


R2<-1
betaaddedvar<-1
addedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR1_staph:nlastvar_LUR1_staph){
  if (is.numeric(Measurements_livestockpreds_LUR1[,i])==TRUE){
    modeltry<-lm(staph~Measurements_livestockpreds_LUR1[,i])                            
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
   #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # Measurements_livestockpreds_LUR1[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR1)[i]
    addedvar<-rbind(addedvar,names(Measurements_livestockpreds_LUR1)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)
models[[modeln]]$results

#  this are the candidates models with the highest R2, not a negative beta for the new, nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)
models[[modeln]]$resultspos

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))
models[[modeln]]$resultspos

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j
models[[modeln]]$indexbestmodel

subset(models[[modeln]]$resultspos, rank==1)
subset(models[[modeln]]$resultspos)

#  this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]
models[[modeln]]$summarybestmodel

# here are the names
models[[modeln]]$namesbestmodel<-c(names(Measurements_livestockpreds_LUR1)[models[[1]]$indexbestmodel])
models[[modeln]]$namesbestmodel

# this is the r2 of that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2
models[[modeln]]$R2bestmodel

# this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(staph~Measurements_livestockpreds_LUR1[,models[[1]]$indexbestmodel]) 
models[[modeln]]$bestmodel

summary(models[[modeln]]$bestmodel)


#  2#  

#  Add 2nd variable (the only difference of the above part is that now modeln=2 the modelstatement has 2 variables)
#  and the cAll for the list of variable names in the model changed slightly

modeln<-2

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR1_staph:nlastvar_LUR1_staph){
  if (is.numeric(Measurements_livestockpreds_LUR1[,i])==TRUE){
    modeltry<-lm(staph~Measurements_livestockpreds_LUR1[,models[[1]]$indexbestmodel]+ Measurements_livestockpreds_LUR1[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
   #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # Measurements_livestockpreds_LUR1[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR1)[i]
    addedvar<-rbind(addedvar,names(Measurements_livestockpreds_LUR1)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  these are the candidate models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)
models[[modeln]]$resultspos

#  rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))
models[[modeln]]$resultspos

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j
models[[modeln]]$indexbestmodel

subset(models[[modeln]]$resultspos, rank==1)

# this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]
models[[modeln]]$summarybestmodel

# here are the names
models[[modeln]]$namesbestmodel<-c(names(Measurements_livestockpreds_LUR1)[models[[1]]$indexbestmodel], names(Measurements_livestockpreds_LUR1)[models[[2]]$indexbestmodel] )
models[[modeln]]$namesbestmodel

# this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2
models[[modeln]]$R2bestmodel

# this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(staph~Measurements_livestockpreds_LUR1[,models[[1]]$indexbestmodel]+Measurements_livestockpreds_LUR1[,models[[2]]$indexbestmodel]) 
models[[modeln]]$bestmodel

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel

models[[1]]$namesbestmodel
models[[2]]$namesbestmodel

models[[1]]$R2bestmodel
models[[2]]$R2bestmodel

#  3#  

#  add third variable (the only difference of the above part is that now modeln=3 the model statement has 3 variables)
#  and the cAll for the list of variable names in the model changed slightly

modeln<-3

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR1_staph:nlastvar_LUR1_staph){
  if (is.numeric(Measurements_livestockpreds_LUR1[,i])==TRUE){  
    modeltry<-lm(staph~Measurements_livestockpreds_LUR1[,models[[1]]$indexbestmodel]+Measurements_livestockpreds_LUR1[,models[[2]]$indexbestmodel]+ Measurements_livestockpreds_LUR1[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
   #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # All[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR2)[i]
    addedvar<-rbind(addedvar,names(Measurements_livestockpreds_LUR1)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))


#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

# this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

# here are the names
models[[modeln]]$namesbestmodel<-c(names(Measurements_livestockpreds_LUR1)[models[[1]]$indexbestmodel], names(Measurements_livestockpreds_LUR1)[models[[2]]$indexbestmodel] , names(Measurements_livestockpreds_LUR1)[models[[3]]$indexbestmodel])

# this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

# this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(staph~Measurements_livestockpreds_LUR1[,models[[1]]$indexbestmodel]+Measurements_livestockpreds_LUR1[,models[[2]]$indexbestmodel]+Measurements_livestockpreds_LUR1[,models[[3]]$indexbestmodel]) 

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel

models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel

models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel

#  CODE FOR PICKING OUT THE BEST MODEL #  
temp <- 0
besti <- 0
for (i in 1:10){ #  think this runs the loop 10 times - not fully sure thought - but not to do with the number of models I don't think - as when I change to 3, I still get the model with 4 variables as best model
  print(models[[i]]$R2bestmodel)
  #       print(models[[i]]$summarybestmodel$coefficients=-1,4])
  #       if((models[[i]]$R2bestmodel-temp > 0.0) && (all(models[[i]]$summarybestmodel$coefficients[-1,4]<0.1))){
  #         temp <- models[[i]]$R2bestmodel
  #         besti <- i
  #         }
  if((models[[i]]$R2bestmodel-temp > 0.0) && (all(models[[i]]$summarybestmodel$coefficients[-1,4]<0.1))){
    temp <- models[[i]]$R2bestmodel
    besti <- i
  }else{
    finalBestModel <- models[[besti]]$bestmodel
    finalBestModelNames <- models[[besti]]$namesbestmodel
    Sites <- 1:dim(Measurements_livestockpreds_LUR1)[1] # full original model
    #  CVaR2<-escCV(Sites)[2] # Cross Validation
    maxCD<-max(cooks.distance(finalBestModel))
    if(length(finalBestModelNames)<2){ # vif fn doesnot work when only 1 variable...       # 
      maxVIF<-"NA"
    }else{
      maxVIF<-max(vif(finalBestModel))
    }
    print(paste("This is the best staph model: ",besti,
                "(AdjR2: ",format(models[[besti]]$R2bestmodel,digits=3), "; MaxCD: ",format(maxCD,digits=3),"; MaxVIF: ",
                format(maxVIF,digits=3),")", sep=''))
    print(finalBestModelNames)
    break
  }
}

#  the final best model includes the predictors: nAnyFarmWghtDist.3000m.sum.95Win.10to90scaled
#  This is the same model as that I identified manually above! 

#  Best model is this: 
staph_LUR1_algorithmmethod <- lm(staph_copiespm3.ln.diffmeth.mean~ nAnyFarmWghtDist.3000m.sum.95Win.10to90scaled, data = Measurements_livestockpreds_LUR1)
summary(staph_LUR1_algorithmmethod)

# Calculate RMSE
predicted_staph_LUR1 <- predict(staph_LUR1_algorithmmethod, Measurements_livestockpreds_LUR1)
RMSE_staph_LUR1 <- sqrt(mean((Measurements_livestockpreds_LUR1$staph_copiespm3.ln.diffmeth.mean - predicted_staph_LUR1)^2))
RMSE_staph_LUR1

#  Save these predicted concentrations along with the measured concentrations as an excel file 
#  Create a dataframe 
staph_LUR1_preds_observed <- data.frame(Measurements_livestockpreds_LUR1$Loc_ID,Measurements_livestockpreds_LUR1$staph_copiespm3.ln.diffmeth.mean, predicted_staph_LUR1)
print(staph_LUR1_preds_observed)

#  Save as xls file 
write_xlsx(staph_LUR1_preds_observed,"Output_files//staph_LUR1_preds_observed.xlsx")

#  MODEL CHECKING:
#  1)Check normality of residuals 
#  2)Check residuals for linearity, independence and homoscedasticity
#  3)Check multicollinearity (VIF)
#  4)Check influential points (Cook's Distance)

#  1) Normality of residuals
boxplot(residuals(staph_LUR1_algorithmmethod),main="boxplot of residuals - staph LUR model 1",xlab="LUR model 1 residuals")
qqnorm(residuals(staph_LUR1_algorithmmethod),main="QQ-plot of residuals - staph LUR model 1",xlab="LUR model 1 residuals")

#  2)Check residuals for linearity, independence and homoscedasticity
plot(fitted(staph_LUR1_algorithmmethod),residuals(staph_LUR1_algorithmmethod))

#  3)Check multicollinearity (VIF)
#  NA for this model as there is only 1 predictor

#  4)Check influential points (Cook's Distance)
ols_plot_cooksd_bar(staph_LUR1_algorithmmethod, print_plot = TRUE)
maxCD_staph_LUR2<-max(cooks.distance(staph_LUR1_algorithmmethod))
maxCD_staph_LUR2
#  won't remove any outliers - none with cook's d > 1 
```

# Staph LUR1 model - LOOCV
```{r}
#  LOOCV - LUR model 1 for staph (using model with outlier 54 removed)
#  Leave one out cross validation - the goal of cross validation is to get a generalized score of the model. The reason for this generalization is to, hopefully, improve the model’s effectiveness in predicting on future data inputs.
#  It is a type of 'internal' cross validation
Measurements_livestockpreds_LUR1_LOOCV <- Measurements_livestockpreds_LUR1
set.seed(123)
Measurements_livestockpreds_LUR1_LOOCV$staph_LUR1_LOOCV_PRED <- unlist(lapply(1:nrow(Measurements_livestockpreds_LUR1_LOOCV),function(inx){
  train <- Measurements_livestockpreds_LUR1_LOOCV[-inx,,drop=FALSE]
  test <- Measurements_livestockpreds_LUR1_LOOCV[inx,,drop=FALSE]
  cvm <- lm(staph_copiespm3.ln.diffmeth.mean ~ nAnyFarmWghtDist.3000m.sum.95Win.10to90scaled, data=train)
  pred <- predict(cvm,newdata=test)
  return(pred)
}))

predicted_staph_LUR1_LOOCV <- Measurements_livestockpreds_LUR1_LOOCV$staph_LUR1_LOOCV_PRED

#  Save these predicted concentrations along with the measured concentrations as an excel file 
#  Create a dataframe 
staph_LUR1_LOOCV_preds_observed <- data.frame(Measurements_livestockpreds_LUR1_LOOCV$Loc_ID,Measurements_livestockpreds_LUR1_LOOCV$staph_copiespm3.ln.diffmeth.mean, Measurements_livestockpreds_LUR1_LOOCV$staph_LUR1_LOOCV_PRED)
print(staph_LUR1_LOOCV_preds_observed)

#  Save as xls file 
write_xlsx(staph_LUR1_LOOCV_preds_observed,"Output_files//staph_LUR1_LOOCV_preds_observed.xlsx")

# Compute the LOOCV model R2
staph_LUR1_LOOCV_lm <- lm(staph_copiespm3.ln.diffmeth.mean ~ staph_LUR1_LOOCV_PRED, data=Measurements_livestockpreds_LUR1_LOOCV)
summary(staph_LUR1_LOOCV_lm)
#  Staph LUR1 model LOOCV multiple R^2 = 0.173\

# Calculate RMSE
preds_staph_LUR1_LOOCV <- predict(staph_LUR1_LOOCV_lm, Measurements_livestockpreds_LUR1_LOOCV)
RMSE_staph_LUR1_LOOCV <- sqrt(mean((Measurements_livestockpreds_LUR1_LOOCV$staph_copiespm3.ln.diffmeth.mean - preds_staph_LUR1_LOOCV)^2))
RMSE_staph_LUR1_LOOCV

#  Plot LOOCV estimations vs. observed concentrations
plot(Measurements_livestockpreds_LUR1_LOOCV$staph_LUR1_LOOCV_PRED, Measurements_livestockpreds_LUR1_LOOCV$staph_copiespm3.ln.diffmeth.mean)
abline(lm(Measurements_livestockpreds_LUR1_LOOCV$staph_copiespm3.ln.diffmeth.mean ~ Measurements_livestockpreds_LUR1_LOOCV$staph_LUR1_LOOCV_PRED))
```
# Staph LUR1 - 10-fold CV
```{r}

options(stringsAsFactors = FALSE) # so that dataframes are not opened in new tabs
# This is the required dataset
Measurements_livestockpreds_LUR1 

#  10-fold hold-out validation is done to assess model robustness. This is done using a random selection of 90% of the measurement sites. 
#  Part 1. Each measurement site gets randomly allocated number out of range 1-10
#  Completely randomly pulling sites
staph_HV_LUR1_df <- Measurements_livestockpreds_LUR1[c(1,3,6:13)] #  new df created with only staph values 
#  Create valID variable 
staph_HV_LUR1_df$valID <- 0
#  Draw 10 samples, thus on average 6 sites per test set (i.e 6 sites are removed from each model and then the model is tested on these 6 sites )
set.seed(123)
VGOB1_FINAL_staph_LUR1 <- c()
for (s in 1:1){
  if (s==1) set <- staph_HV_LUR1_df
  draws <- c(1:nrow(set))
  chosen <- c()
  tempdraws <- draws
  for (d in 1:10){
    list <- sample(tempdraws, length(tempdraws)/(11-d), FALSE)
    set[list,]$valID <- d
    chosen <- c(chosen, list)
    tempdraws <- draws[-chosen]
  }

#  Combine datasets to 1
VGOB1_FINAL_staph_LUR1 <- set
}

summary(set)
rm(set)

#  View the df created
str(VGOB1_FINAL_staph_LUR1, list.len=ncol(VGOB1_FINAL_staph_LUR1))
names(VGOB1_FINAL_staph_LUR1)
summary(VGOB1_FINAL_staph_LUR1)

#  Part 2: Make 10 subsets of dataset based on randomly allocated number (so these are the training datasets) 
#  Then create 10 subsets, each excluding 1 set of 10 sites
VGOB1_subsetA_staph_LUR1 <- subset(VGOB1_FINAL_staph_LUR1, valID != 1)
VGOB1_subsetB_staph_LUR1 <- subset(VGOB1_FINAL_staph_LUR1, valID != 2)  
VGOB1_subsetC_staph_LUR1 <- subset(VGOB1_FINAL_staph_LUR1, valID != 3)
VGOB1_subsetD_staph_LUR1 <- subset(VGOB1_FINAL_staph_LUR1, valID != 4)
VGOB1_subsetE_staph_LUR1 <- subset(VGOB1_FINAL_staph_LUR1, valID != 5)
VGOB1_subsetF_staph_LUR1 <- subset(VGOB1_FINAL_staph_LUR1, valID != 6)
VGOB1_subsetG_staph_LUR1 <- subset(VGOB1_FINAL_staph_LUR1, valID != 7)
VGOB1_subsetH_staph_LUR1 <- subset(VGOB1_FINAL_staph_LUR1, valID != 8)
VGOB1_subsetI_staph_LUR1 <- subset(VGOB1_FINAL_staph_LUR1, valID != 9)
VGOB1_subsetJ_staph_LUR1 <- subset(VGOB1_FINAL_staph_LUR1, valID != 10)

#  Part 3: Build for each subset a LUR model (i.e. go through the whole LUR model script for each subset (so each training set). Start with subset A, until final LUR model. Then subset B, until final LUR model etc.) 

#### A ####
# LUR model building process for subset A
#  This is the dataframe with the relevant predictor vars for LUR1 models for subset A (55 sites)
VGOB1_subsetA_staph_LUR1 # n.b. this dataframe only includes microbial marker concentrations for staph unlike the dataframe Measurements_livestockpreds_LUR1 as previously used for the model building. 

#  Now set the values of some variables that will be needed
nfirstvar_LUR_1 <- 3  
nlastvar_LUR_1 <- 10

# Function building to run the models 
# 1 #  

models<-list()
modeln<-1
models[[modeln]]<-list()

R2<-1
betaaddedvar<-1
addedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_1:nlastvar_LUR_1){
  if (is.numeric(VGOB1_subsetA_staph_LUR1[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetA_staph_LUR1$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetA_staph_LUR1[,i])                            
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    #  Measurements_livestockpreds_LUR1[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR1)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetA_staph_LUR1)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)
models[[modeln]]$results

#  this are the candidates models with the highest R2, not a negative beta for the new, nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)
models[[modeln]]$resultspos

#  rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))
models[[modeln]]$resultspos

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j
models[[modeln]]$indexbestmodel

subset(models[[modeln]]$resultspos, rank==1)
subset(models[[modeln]]$resultspos)

#  this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]
models[[modeln]]$summarybestmodel

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetA_staph_LUR1)[models[[1]]$indexbestmodel])
models[[modeln]]$namesbestmodel

#  this is the r2 of that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2
models[[modeln]]$R2bestmodel

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetA_staph_LUR1$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetA_staph_LUR1[,models[[1]]$indexbestmodel]) 
models[[modeln]]$bestmodel

summary(models[[modeln]]$bestmodel)

#  The first model includes the predictor: nPigMultipFarmWghtDist.3000m.sum.Tr.1P9 - meaning the number of multiplier pig farms weighted to distance in a 3000m buffer

# 2 #  
# Add 2nd variable (the only difference of the above part is that now modeln=2 the model statement has 2 variables)
# and the call for the list of variable names in the model changed slightly

modeln<-2

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_1:nlastvar_LUR_1){
  if (is.numeric(VGOB1_subsetA_staph_LUR1[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetA_staph_LUR1$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetA_staph_LUR1[,models[[1]]$indexbestmodel]+ VGOB1_subsetA_staph_LUR1[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # Measurements_livestockpreds_LUR1[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR1)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetA_staph_LUR1)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  these are the candidate models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)
models[[modeln]]$resultspos

#  rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))
models[[modeln]]$resultspos

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j
models[[modeln]]$indexbestmodel

subset(models[[modeln]]$resultspos, rank==1)

# this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]
models[[modeln]]$summarybestmodel

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetA_staph_LUR1)[models[[1]]$indexbestmodel], names(VGOB1_subsetA_staph_LUR1)[models[[2]]$indexbestmodel] )
models[[modeln]]$namesbestmodel

# this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2
models[[modeln]]$R2bestmodel

# this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetA_staph_LUR1$staph_copiespm3.ln.diffmeth.mean~                               VGOB1_subsetA_staph_LUR1[,models[[1]]$indexbestmodel]+                           VGOB1_subsetA_staph_LUR1[,models[[2]]$indexbestmodel]) 

models[[modeln]]$bestmodel

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel


# 3 #  
# add third variable (the only difference of the above part is that now modeln=3 the model statement has 3 variables)
# and the call for the list of variable names in the model changed slightly

modeln<-3

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_1:nlastvar_LUR_1){
  if (is.numeric(VGOB1_subsetA_staph_LUR1[,i])==TRUE){  
    modeltry<-lm(VGOB1_subsetA_staph_LUR1$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetA_staph_LUR1[,models[[1]]$indexbestmodel]+VGOB1_subsetA_staph_LUR1[,models[[2]]$indexbestmodel]+ VGOB1_subsetA_staph_LUR1[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # All[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR1)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetA_staph_LUR1)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

#  rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

#  this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

#  here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetA_staph_LUR1)[models[[1]]$indexbestmodel], names(VGOB1_subsetA_staph_LUR1)[models[[2]]$indexbestmodel], names(VGOB1_subsetA_staph_LUR1)[models[[3]]$indexbestmodel])

#  this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetA_staph_LUR1$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetA_staph_LUR1[,models[[1]]$indexbestmodel]+ VGOB1_subsetA_staph_LUR1[,models[[2]]$indexbestmodel]+ VGOB1_subsetA_staph_LUR1[,models[[3]]$indexbestmodel]) 

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel

# The next part of the code (n=4-8) does not work
# This is because one of the coefficients included in the model with 6 variables is negative, the code does not allow for this. I can stop here. 

# # 4 #  
# #  add forth variable (the only difference of the above part is that now model n=4 the model statement more variables)
# #  and the call for the list of variable names in the model changed slightly
# modeln<-4
# 
# models[[modeln]]<-list()
# 
# R2<-1
# addedvar<-1
# betaaddedvar<-1
# minbetas<-1
# j<-1
# 
# 
# for (i in nfirstvar_LUR_1:nlastvar_LUR_1){
#   if (is.numeric(VGOB1_subsetA_staph_LUR1[,i])==TRUE){
#     modeltry<-lm(VGOB1_subsetA_staph_LUR1$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetA_staph_LUR1[,models[[1]]$indexbestmodel]+VGOB1_subsetA_staph_LUR1[,models[[2]]$indexbestmodel]+VGOB1_subsetA_staph_LUR1[,models[[3]]$indexbestmodel]+VGOB1_subsetA_staph_LUR1[,i]) 
#     R2<-rbind(R2,summary(modeltry)$adj.r.squared)
#     #  the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
#     betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])
#     #  find out if there is a negative beta at All. The intercept does not count [-1]!
#     minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
#     #  All[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR1)[i]
#     addedvar<-rbind(addedvar,names(VGOB1_subsetA_staph_LUR1)[i])
#     j<-rbind(j, i)
#     models[[modeln]][[i]]<-summary(modeltry)
#   }
# }
# 
# models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)
# 
# #  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
# models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)
# 
# # rank the R2's of these models
# models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))
# 
# #  this is the index of the row with the highest R2 and  no negative betas in this subset
# models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j
# 
# subset(models[[modeln]]$resultspos, rank==1)
# 
# #  this is the model
# models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]
# 
# #  here are the names
# models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetA_staph_LUR1)[models[[1]]$indexbestmodel], names(VGOB1_subsetA_staph_LUR1)[models[[2]]$indexbestmodel], names(VGOB1_subsetA_staph_LUR1)[models[[3]]$indexbestmodel], names(VGOB1_subsetA_staph_LUR1)[models[[4]]$indexbestmodel])
# 
# #  this is the r2 of that model
# models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2
# 
# #  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
# models[[modeln]]$bestmodel <- lm(VGOB1_subsetA_staph_LUR1$staph_copiespm3.ln.diffmeth.mean~ VGOB1_subsetA_staph_LUR1[,models[[1]]$indexbestmodel]+ VGOB1_subsetA_staph_LUR1[,models[[2]]$indexbestmodel]+VGOB1_subsetA_staph_LUR1[,models[[3]]$indexbestmodel]+ VGOB1_subsetA_staph_LUR1[,models[[4]]$indexbestmodel]) 
# 
# 
# models[[1]]$summarybestmodel
# models[[2]]$summarybestmodel
# models[[3]]$summarybestmodel
# models[[4]]$summarybestmodel
# models[[1]]$namesbestmodel
# models[[2]]$namesbestmodel
# models[[3]]$namesbestmodel
# models[[4]]$namesbestmodel
# models[[1]]$R2bestmodel
# models[[2]]$R2bestmodel
# models[[3]]$R2bestmodel
# models[[4]]$R2bestmodel
# 
# 
# # 5 #  
# # add fifth variable (the only difference of the above part is that now modeln=5 the model statement more variables)
# # and the call for the list of variable names in the model changed slightly
# modeln<-5
# 
# models[[modeln]]<-list()
# 
# R2<-1
# addedvar<-1
# betaaddedvar<-1
# minbetas<-1
# j<-1
# 
# for (i in nfirstvar_LUR_1:nlastvar_LUR_1){
#   if (is.numeric(VGOB1_subsetA_staph_LUR1[,i])==TRUE){
#     modeltry<-lm(VGOB1_subsetA_staph_LUR1$staph_copiespm3.ln.diffmeth.mean~ VGOB1_subsetA_staph_LUR1[,models[[1]]$indexbestmodel]+ VGOB1_subsetA_staph_LUR1[,models[[2]]$indexbestmodel]+ VGOB1_subsetA_staph_LUR1[,models[[3]]$indexbestmodel]+ VGOB1_subsetA_staph_LUR1[,models[[4]]$indexbestmodel]+ VGOB1_subsetA_staph_LUR1[,i]) 
#   
# R2<-rbind(R2,summary(modeltry)$adj.r.squared)
# # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
#     betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
#     #  find out if there is a negative beta at All. The intercept does not count [-1]!
#     minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
#     # All[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR1)[i]
#     addedvar<-rbind(addedvar,names(VGOB1_subsetA_staph_LUR1)[i])
#     j<-rbind(j, i)
#     models[[modeln]][[i]]<-summary(modeltry)
#   }
# }
# 
# models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)
# 
# #  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
# models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)
# 
# # rank the R2's of these models
# models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))
# 
# #  this is the index of the row with the highest R2 and  no negative betas in this subset
# models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j
# 
# subset(models[[modeln]]$resultspos, rank==1)
# 
# #  this is the model
# models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]
# 
# # here are the names
# models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetA_staph_LUR1)[models[[1]]$indexbestmodel], names(VGOB1_subsetA_staph_LUR1)[models[[2]]$indexbestmodel], names(VGOB1_subsetA_staph_LUR1)[models[[3]]$indexbestmodel], names(VGOB1_subsetA_staph_LUR1)[models[[4]]$indexbestmodel], names(VGOB1_subsetA_staph_LUR1)[models[[5]]$indexbestmodel])
# 
# #  this is the r2 or that model
# models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2
# 
# #  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
# models[[modeln]]$bestmodel <- lm(VGOB1_subsetA_staph_LUR1$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetA_staph_LUR1[,models[[1]]$indexbestmodel]+VGOB1_subsetA_staph_LUR1[,models[[2]]$indexbestmodel]+VGOB1_subsetA_staph_LUR1[,models[[3]]$indexbestmodel]+ VGOB1_subsetA_staph_LUR1[,models[[4]]$indexbestmodel]+ VGOB1_subsetA_staph_LUR1[,models[[5]]$indexbestmodel]) 
# models[[1]]$summarybestmodel
# models[[2]]$summarybestmodel
# models[[3]]$summarybestmodel
# models[[4]]$summarybestmodel
# models[[5]]$summarybestmodel
# models[[1]]$namesbestmodel
# models[[2]]$namesbestmodel
# models[[3]]$namesbestmodel
# models[[4]]$namesbestmodel
# models[[5]]$namesbestmodel
# models[[1]]$R2bestmodel
# models[[2]]$R2bestmodel
# models[[3]]$R2bestmodel
# models[[4]]$R2bestmodel
# models[[5]]$R2bestmodel
# 
# # 6 #  
# # add sixth variable (the only difference of the above part is that now model n=6 the model statement more variables)
# #  and the call for the list of variable names in the model changed slightly
# 
# modeln<-6
# 
# models[[modeln]]<-list()
# 
# R2<-1
# addedvar<-1
# betaaddedvar<-1
# minbetas<-1
# j<-1
# 
# for (i in nfirstvar_LUR_1 :nlastvar_LUR_1){
#   if (is.numeric(VGOB1_subsetA_staph_LUR1[,i])==TRUE){
#     modeltry<-lm(VGOB1_subsetA_staph_LUR1$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetA_staph_LUR1[,models[[1]]$indexbestmodel]+VGOB1_subsetA_staph_LUR1[,models[[2]]$indexbestmodel]+VGOB1_subsetA_staph_LUR1[,models[[3]]$indexbestmodel]+VGOB1_subsetA_staph_LUR1[,models[[4]]$indexbestmodel]+VGOB1_subsetA_staph_LUR1[,models[[5]]$indexbestmodel]+ VGOB1_subsetA_staph_LUR1[,i]) 
#     R2<-rbind(R2,summary(modeltry)$adj.r.squared)
#     # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
#     betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
#     #  find out if there is a negative beta at All. The intercept does not count [-1]!
#     minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
#     # All[,i] is the row that's being tried out now. the name of that row can be found in  names(All)[i]
#     addedvar<-rbind(addedvar,names(VGOB1_subsetA_staph_LUR1)[i])
#     j<-rbind(j, i)
#     models[[modeln]][[i]]<-summary(modeltry)
#   }
# }
# 
# models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)
# 
# #  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
# models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)
# 
# # rank the R2's of these models
# models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))
# 
# #  this is the index of the row with the highest R2 and  no negative betas in this subset
# models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j
# 
# subset(models[[modeln]]$resultspos, rank==1)
# 
# # this is the model
# models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]
# 
# # here are the names
# models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetA_staph_LUR1)[models[[1]]$indexbestmodel], names(VGOB1_subsetA_staph_LUR1)[models[[2]]$indexbestmodel] , names(VGOB1_subsetA_staph_LUR1)[models[[3]]$indexbestmodel], names(VGOB1_subsetA_staph_LUR1)[models[[4]]$indexbestmodel], names(VGOB1_subsetA_staph_LUR1)[models[[5]]$indexbestmodel], names(VGOB1_subsetA_staph_LUR1)[models[[6]]$indexbestmodel])
# 
# #  this is the r2 or that model
# models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2
# 
# #  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
# models[[modeln]]$bestmodel <- lm(VGOB1_subsetA_staph_LUR1$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetA_staph_LUR1[,models[[1]]$indexbestmodel]+VGOB1_subsetA_staph_LUR1[,models[[2]]$indexbestmodel]+VGOB1_subsetA_staph_LUR1[,models[[3]]$indexbestmodel]+ VGOB1_subsetA_staph_LUR1[,models[[4]]$indexbestmodel]+ VGOB1_subsetA_staph_LUR1[,models[[5]]$indexbestmodel]+ VGOB1_subsetA_staph_LUR1[,models[[6]]$indexbestmodel]) 
# 
# models[[1]]$summarybestmodel
# models[[2]]$summarybestmodel
# models[[3]]$summarybestmodel
# models[[4]]$summarybestmodel
# models[[5]]$summarybestmodel
# models[[6]]$summarybestmodel
# models[[1]]$namesbestmodel
# models[[2]]$namesbestmodel
# models[[3]]$namesbestmodel
# models[[4]]$namesbestmodel
# models[[5]]$namesbestmodel
# models[[6]]$namesbestmodel
# models[[1]]$R2bestmodel
# models[[2]]$R2bestmodel
# models[[3]]$R2bestmodel
# models[[4]]$R2bestmodel
# models[[5]]$R2bestmodel
# models[[6]]$R2bestmodel
# 
# 
# # 7 #  
# # add seventh variable (the only difference of the above part is that now model n=7 the model statement more variables)
# #  and the call for the list of variable names in the model changed slightly
# 
# modeln<-7
# 
# models[[modeln]]<-list()
# 
# R2<-1
# addedvar<-1
# betaaddedvar<-1
# minbetas<-1
# j<-1
# 
# for (i in nfirstvar_LUR_1 :nlastvar_LUR_1){
#   if (is.numeric(VGOB1_subsetA_staph_LUR1[,i])==TRUE){
#     modeltry<-lm(VGOB1_subsetA_staph_LUR1$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetA_staph_LUR1[,models[[1]]$indexbestmodel]+VGOB1_subsetA_staph_LUR1[,models[[2]]$indexbestmodel]+VGOB1_subsetA_staph_LUR1[,models[[3]]$indexbestmodel]+VGOB1_subsetA_staph_LUR1[,models[[4]]$indexbestmodel]+VGOB1_subsetA_staph_LUR1[,models[[5]]$indexbestmodel]+VGOB1_subsetA_staph_LUR1[,models[[6]]$indexbestmodel]+ VGOB1_subsetA_staph_LUR1[,i]) 
#     R2<-rbind(R2,summary(modeltry)$adj.r.squared)
#     # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
#     betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
#     #  find out if there is a negative beta at All. The intercept does not count [-1]!
#     minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
#     # Measurements_livestockpreds_LUR1[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR1)[i]
#     addedvar<-rbind(addedvar,names(VGOB1_subsetA_staph_LUR1)[i])
#     j<-rbind(j, i)
#     models[[modeln]][[i]]<-summary(modeltry)
#   }
# }
# 
# models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)
# 
# #  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
# models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)
# 
# # rank the R2's of these models
# models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))
# 
# #  this is the index of the row with the highest R2 and  no negative betas in this subset
# models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j
# 
# subset(models[[modeln]]$resultspos, rank==1)
# 
# # this is the model
# models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]
# 
# # here are the names
# models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetA_staph_LUR1)[models[[1]]$indexbestmodel], names(VGOB1_subsetA_staph_LUR1)[models[[2]]$indexbestmodel] , names(VGOB1_subsetA_staph_LUR1)[models[[3]]$indexbestmodel], names(VGOB1_subsetA_staph_LUR1)[models[[4]]$indexbestmodel], names(VGOB1_subsetA_staph_LUR1)[models[[5]]$indexbestmodel], names(VGOB1_subsetA_staph_LUR1)[models[[6]]$indexbestmodel], names(VGOB1_subsetA_staph_LUR1)[models[[7]]$indexbestmodel])
# 
# #  this is the r2 or that model
# models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2
# 
# #  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
# models[[modeln]]$bestmodel <- lm(VGOB1_subsetA_staph_LUR1$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetA_staph_LUR1[,models[[1]]$indexbestmodel]+VGOB1_subsetA_staph_LUR1[,models[[2]]$indexbestmodel]+VGOB1_subsetA_staph_LUR1[,models[[3]]$indexbestmodel]+ VGOB1_subsetA_staph_LUR1[,models[[4]]$indexbestmodel]+ VGOB1_subsetA_staph_LUR1[,models[[5]]$indexbestmodel]+ VGOB1_subsetA_staph_LUR1[,models[[6]]$indexbestmodel]+ VGOB1_subsetA_staph_LUR1[,models[[7]]$indexbestmodel]) 
# 
# models[[1]]$summarybestmodel
# models[[2]]$summarybestmodel
# models[[3]]$summarybestmodel
# models[[4]]$summarybestmodel
# models[[5]]$summarybestmodel
# models[[6]]$summarybestmodel
# models[[7]]$summarybestmodel
# models[[1]]$namesbestmodel
# models[[2]]$namesbestmodel
# models[[3]]$namesbestmodel
# models[[4]]$namesbestmodel
# models[[5]]$namesbestmodel
# models[[6]]$namesbestmodel
# models[[7]]$namesbestmodel
# models[[1]]$R2bestmodel
# models[[2]]$R2bestmodel
# models[[3]]$R2bestmodel
# models[[4]]$R2bestmodel
# models[[5]]$R2bestmodel
# models[[6]]$R2bestmodel
# models[[7]]$R2bestmodel
# 
# # 8 #  
# # add eighth variable (the only difference of the above part is that now modeln=7 the model statement more variables)
# # and the call for the list of variable names in the model changed slightly
# 
# modeln<-8
# 
# models[[modeln]]<-list()
# 
# R2<-1
# addedvar<-1
# betaaddedvar<-1
# minbetas<-1
# j<-1
# 
# for (i in nfirstvar_LUR_1 :nlastvar_LUR_1){
#   if (is.numeric(VGOB1_subsetA_staph_LUR1[,i])==TRUE){
#     modeltry<-lm(VGOB1_subsetA_staph_LUR1$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetA_staph_LUR1[,models[[1]]$indexbestmodel]+VGOB1_subsetA_staph_LUR1[,models[[2]]$indexbestmodel]+VGOB1_subsetA_staph_LUR1[,models[[3]]$indexbestmodel]+VGOB1_subsetA_staph_LUR1[,models[[4]]$indexbestmodel]+VGOB1_subsetA_staph_LUR1[,models[[5]]$indexbestmodel]+VGOB1_subsetA_staph_LUR1[,models[[6]]$indexbestmodel]+ VGOB1_subsetA_staph_LUR1[,models[[7]]$indexbestmodel]+ VGOB1_subsetA_staph_LUR1[,i]) 
#     R2<-rbind(R2,summary(modeltry)$adj.r.squared)
#     # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
#     betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
#     #  find out if there is a negative beta at All. The intercept does not count [-1]!
#     minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
#     # Measurements_livestockpreds_LUR1[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR1)[i]
#     addedvar<-rbind(addedvar,names(VGOB1_subsetA_staph_LUR1)[i])
#     j<-rbind(j, i)
#     models[[modeln]][[i]]<-summary(modeltry)
#   }
# }
# 
# models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)
# 
# #  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
# models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)
# 
# # rank the R2's of these models
# models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))
# 
# #  this is the index of the row with the highest R2 and  no negative betas in this subset
# models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j
# 
# subset(models[[modeln]]$resultspos, rank==1)
# 
# # this is the model
# models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]
# 
# # here are the names
# models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetA_staph_LUR1)[models[[1]]$indexbestmodel], names(VGOB1_subsetA_staph_LUR1)[models[[2]]$indexbestmodel] , names(VGOB1_subsetA_staph_LUR1)[models[[3]]$indexbestmodel], names(VGOB1_subsetA_staph_LUR1)[models[[4]]$indexbestmodel], names(VGOB1_subsetA_staph_LUR1)[models[[5]]$indexbestmodel], names(VGOB1_subsetA_staph_LUR1)[models[[6]]$indexbestmodel], names(VGOB1_subsetA_staph_LUR1)[models[[7]]$indexbestmodel], names(VGOB1_subsetA_staph_LUR1)[models[[8]]$indexbestmodel])
# 
# #  this is the r2 or that model
# models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2
# 
# #  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
# models[[modeln]]$bestmodel <- lm(VGOB1_subsetA_staph_LUR1$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetA_staph_LUR1[,models[[1]]$indexbestmodel]+VGOB1_subsetA_staph_LUR1[,models[[2]]$indexbestmodel]+VGOB1_subsetA_staph_LUR1[,models[[3]]$indexbestmodel]+ VGOB1_subsetA_staph_LUR1[,models[[4]]$indexbestmodel]+ VGOB1_subsetA_staph_LUR1[,models[[5]]$indexbestmodel]+ VGOB1_subsetA_staph_LUR1[,models[[6]]$indexbestmodel]+ VGOB1_subsetA_staph_LUR1[,models[[7]]$indexbestmodel]+ VGOB1_subsetA_staph_LUR1[,models[[8]]$indexbestmodel]) 
# 
# models[[1]]$summarybestmodel
# models[[2]]$summarybestmodel
# models[[3]]$summarybestmodel
# models[[4]]$summarybestmodel
# models[[5]]$summarybestmodel
# models[[6]]$summarybestmodel
# models[[7]]$summarybestmodel
# models[[8]]$summarybestmodel
# models[[1]]$namesbestmodel
# models[[2]]$namesbestmodel
# models[[3]]$namesbestmodel
# models[[4]]$namesbestmodel
# models[[5]]$namesbestmodel
# models[[6]]$namesbestmodel
# models[[7]]$namesbestmodel
# models[[8]]$namesbestmodel
# models[[1]]$R2bestmodel
# models[[2]]$R2bestmodel
# models[[3]]$R2bestmodel
# models[[4]]$R2bestmodel
# models[[5]]$R2bestmodel
# models[[6]]$R2bestmodel
# models[[7]]$R2bestmodel
# models[[8]]$R2bestmodel

#   CODE FOR PICKING OUT THE BEST MODEL #   
temp <- 0
besti <- 0
for (i in 1:10){ #  think this runs the loop 10 times - not fully sure thought - but not to do with the number of models I don't think - as when I change to 3, I still get the model with 4 variables as best model
  print(models[[i]]$R2bestmodel)
  #       print(models[[i]]$summarybestmodel$coefficients=-1,4])
  #       if((models[[i]]$R2bestmodel-temp > 0.0) && (all(models[[i]]$summarybestmodel$coefficients[-1,4]<0.1))){
  #         temp <- models[[i]]$R2bestmodel
  #         besti <- i
  #         }
  if((models[[i]]$R2bestmodel-temp > 0.0) && (all(models[[i]]$summarybestmodel$coefficients[-1,4]<0.1))){
    temp <- models[[i]]$R2bestmodel
    besti <- i
  }else{
    finalBestModel_staph_LUR1_subsetA <- models[[besti]]$bestmodel
    finalBestModelNames_staph_subsetA <- models[[besti]]$namesbestmodel
    Sites <- 1:dim(VGOB1_subsetA_staph_LUR1)[1] # full original model
    #  CVaR2<-escCV_staph_LUR1(Sites)[2] # Cross Validation
    maxCD<-max(cooks.distance(finalBestModel_staph_LUR1_subsetA))
    if(length(finalBestModelNames_staph_subsetA)<2){ # vif fn doesnot work when only 1 variable...       # 
      maxVIF<-"NA"
    }else{
      maxVIF<-max(vif(finalBestModel_staph_LUR1_subsetA))
    }
    print(paste("This is the best staph model for subset A: ",besti,
                "(AdjR2: ",format(models[[besti]]$R2bestmodel,digits=3), "; MaxCD: ",format(maxCD,digits=3),"; MaxVIF: ",
                format(maxVIF,digits=3),")", sep=''))
    print(finalBestModelNames_staph_subsetA)
    break
  }
}

#  Overview of the final best model using the algorithm selection process (taking into account VIF, R^2, and p-values)
finalBestModel_staph_LUR1_subsetA 
finalBestModelNames_staph_subsetA
models[[besti]]$summarybestmodel
models[[besti]]$R2bestmodel

#### B ####
# LUR model building process for subset B
# This is the dataframe with the relevant predictor vars for LUR1 models for subset B (55 sites)
VGOB1_subsetB_staph_LUR1 # n.b. this dataframe only includes microbial marker concentrations for staph unlike the dataframe Measurements_livestockpreds_LUR1 as previously used for the model building. 

#  Now set the values of some variables that will be needed
nfirstvar_LUR_1 <- 3  
nlastvar_LUR_1 <- 10

# Function building to run the models 
# 1 #  

models<-list()
modeln<-1
models[[modeln]]<-list()

R2<-1
betaaddedvar<-1
addedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_1:nlastvar_LUR_1){
  if (is.numeric(VGOB1_subsetB_staph_LUR1[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetB_staph_LUR1$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetB_staph_LUR1[,i])                            
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    #  Measurements_livestockpreds_LUR1[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR1)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetB_staph_LUR1)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)
models[[modeln]]$results

#  this are the candidates models with the highest R2, not a negative beta for the new, nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)
models[[modeln]]$resultspos

#  rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))
models[[modeln]]$resultspos

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j
models[[modeln]]$indexbestmodel

subset(models[[modeln]]$resultspos, rank==1)
subset(models[[modeln]]$resultspos)

#  this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]
models[[modeln]]$summarybestmodel

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetB_staph_LUR1)[models[[1]]$indexbestmodel])
models[[modeln]]$namesbestmodel

#  this is the r2 of that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2
models[[modeln]]$R2bestmodel

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetB_staph_LUR1$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetB_staph_LUR1[,models[[1]]$indexbestmodel]) 
models[[modeln]]$bestmodel

summary(models[[modeln]]$bestmodel)

#  The first model includes the predictor: nPigMultipFarmWghtDist.3000m.sum.Tr.1P9 - meaning the number of multiplier pig farms weighted to distance in a 3000m buffer

# 2 #  
# Add 2nd variable (the only difference of the above part is that now modeln=2 the model statement has 2 variables)
# and the call for the list of variable names in the model changed slightly

modeln<-2

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_1:nlastvar_LUR_1){
  if (is.numeric(VGOB1_subsetB_staph_LUR1[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetB_staph_LUR1$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetB_staph_LUR1[,models[[1]]$indexbestmodel]+ VGOB1_subsetB_staph_LUR1[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # Measurements_livestockpreds_LUR1[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR1)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetB_staph_LUR1)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  these are the candidate models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)
models[[modeln]]$resultspos

#  rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))
models[[modeln]]$resultspos

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j
models[[modeln]]$indexbestmodel

subset(models[[modeln]]$resultspos, rank==1)

# this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]
models[[modeln]]$summarybestmodel

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetB_staph_LUR1)[models[[1]]$indexbestmodel], names(VGOB1_subsetB_staph_LUR1)[models[[2]]$indexbestmodel] )
models[[modeln]]$namesbestmodel

# this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2
models[[modeln]]$R2bestmodel

# this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetB_staph_LUR1$staph_copiespm3.ln.diffmeth.mean~                               VGOB1_subsetB_staph_LUR1[,models[[1]]$indexbestmodel]+                           VGOB1_subsetB_staph_LUR1[,models[[2]]$indexbestmodel]) 

models[[modeln]]$bestmodel

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel


# The next part of the code (n=3-8) does not work
# This is because one of the coefficients included in the model with 6 variables is negative, the code does not allow for this. I can stop here.

# # 3 #  
# # add third variable (the only difference of the above part is that now modeln=3 the model statement has 3 variables)
# # and the call for the list of variable names in the model changed slightly
# 
# modeln<-3
# 
# models[[modeln]]<-list()
# 
# R2<-1
# addedvar<-1
# betaaddedvar<-1
# minbetas<-1
# j<-1
# 
# for (i in nfirstvar_LUR_1:nlastvar_LUR_1){
#   if (is.numeric(VGOB1_subsetB_staph_LUR1[,i])==TRUE){  
#     modeltry<-lm(VGOB1_subsetB_staph_LUR1$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetB_staph_LUR1[,models[[1]]$indexbestmodel]+VGOB1_subsetB_staph_LUR1[,models[[2]]$indexbestmodel]+ VGOB1_subsetB_staph_LUR1[,i]) 
#     R2<-rbind(R2,summary(modeltry)$adj.r.squared)
#     # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
#     betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
#     #  find out if there is a negative beta at All. The intercept does not count [-1]!
#     minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
#     # All[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR1)[i]
#     addedvar<-rbind(addedvar,names(VGOB1_subsetB_staph_LUR1)[i])
#     j<-rbind(j, i)
#     models[[modeln]][[i]]<-summary(modeltry)
#   }
# }
# 
# models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)
# 
# #  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
# models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)
# 
# #  rank the R2's of these models
# models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))
# 
# #  this is the index of the row with the highest R2 and  no negative betas in this subset
# models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j
# 
# subset(models[[modeln]]$resultspos, rank==1)
# 
# #  this is the model
# models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]
# 
# #  here are the names
# models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetB_staph_LUR1)[models[[1]]$indexbestmodel], names(VGOB1_subsetB_staph_LUR1)[models[[2]]$indexbestmodel], names(VGOB1_subsetB_staph_LUR1)[models[[3]]$indexbestmodel])
# 
# #  this is the r2 or that model
# models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2
# 
# #  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
# models[[modeln]]$bestmodel <- lm(VGOB1_subsetB_staph_LUR1$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetB_staph_LUR1[,models[[1]]$indexbestmodel]+ VGOB1_subsetB_staph_LUR1[,models[[2]]$indexbestmodel]+ VGOB1_subsetB_staph_LUR1[,models[[3]]$indexbestmodel]) 
# 
# models[[1]]$summarybestmodel
# models[[2]]$summarybestmodel
# models[[3]]$summarybestmodel
# models[[1]]$namesbestmodel
# models[[2]]$namesbestmodel
# models[[3]]$namesbestmodel
# models[[1]]$R2bestmodel
# models[[2]]$R2bestmodel
# models[[3]]$R2bestmodel
# 
# 
# # 4 #  
# #  add forth variable (the only difference of the above part is that now model n=4 the model statement more variables)
# #  and the call for the list of variable names in the model changed slightly
# modeln<-4
# 
# models[[modeln]]<-list()
# 
# R2<-1
# addedvar<-1
# betaaddedvar<-1
# minbetas<-1
# j<-1
# 
# 
# for (i in nfirstvar_LUR_1:nlastvar_LUR_1){
#   if (is.numeric(VGOB1_subsetB_staph_LUR1[,i])==TRUE){
#     modeltry<-lm(VGOB1_subsetB_staph_LUR1$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetB_staph_LUR1[,models[[1]]$indexbestmodel]+VGOB1_subsetB_staph_LUR1[,models[[2]]$indexbestmodel]+VGOB1_subsetB_staph_LUR1[,models[[3]]$indexbestmodel]+VGOB1_subsetB_staph_LUR1[,i]) 
#     R2<-rbind(R2,summary(modeltry)$adj.r.squared)
#     #  the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
#     betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])
#     #  find out if there is a negative beta at All. The intercept does not count [-1]!
#     minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
#     #  All[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR1)[i]
#     addedvar<-rbind(addedvar,names(VGOB1_subsetB_staph_LUR1)[i])
#     j<-rbind(j, i)
#     models[[modeln]][[i]]<-summary(modeltry)
#   }
# }
# 
# models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)
# 
# #  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
# models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)
# 
# # rank the R2's of these models
# models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))
# 
# #  this is the index of the row with the highest R2 and  no negative betas in this subset
# models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j
# 
# subset(models[[modeln]]$resultspos, rank==1)
# 
# #  this is the model
# models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]
# 
# #  here are the names
# models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetB_staph_LUR1)[models[[1]]$indexbestmodel], names(VGOB1_subsetB_staph_LUR1)[models[[2]]$indexbestmodel], names(VGOB1_subsetB_staph_LUR1)[models[[3]]$indexbestmodel], names(VGOB1_subsetB_staph_LUR1)[models[[4]]$indexbestmodel])
# 
# #  this is the r2 of that model
# models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2
# 
# #  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
# models[[modeln]]$bestmodel <- lm(VGOB1_subsetB_staph_LUR1$staph_copiespm3.ln.diffmeth.mean~ VGOB1_subsetB_staph_LUR1[,models[[1]]$indexbestmodel]+ VGOB1_subsetB_staph_LUR1[,models[[2]]$indexbestmodel]+ VGOB1_subsetB_staph_LUR1[,models[[3]]$indexbestmodel]+ VGOB1_subsetB_staph_LUR1[,models[[4]]$indexbestmodel]) 
# 
# 
# models[[1]]$summarybestmodel
# models[[2]]$summarybestmodel
# models[[3]]$summarybestmodel
# models[[4]]$summarybestmodel
# models[[1]]$namesbestmodel
# models[[2]]$namesbestmodel
# models[[3]]$namesbestmodel
# models[[4]]$namesbestmodel
# models[[1]]$R2bestmodel
# models[[2]]$R2bestmodel
# models[[3]]$R2bestmodel
# models[[4]]$R2bestmodel
# 
# 
# # 5 #  
# # add fifth variable (the only difference of the above part is that now modeln=5 the model statement more variables)
# # and the call for the list of variable names in the model changed slightly
# modeln<-5
# 
# models[[modeln]]<-list()
# 
# R2<-1
# addedvar<-1
# betaaddedvar<-1
# minbetas<-1
# j<-1
# 
# for (i in nfirstvar_LUR_1:nlastvar_LUR_1){
#   if (is.numeric(VGOB1_subsetB_staph_LUR1[,i])==TRUE){
#     modeltry<-lm(VGOB1_subsetB_staph_LUR1$staph_copiespm3.ln.diffmeth.mean~ VGOB1_subsetB_staph_LUR1[,models[[1]]$indexbestmodel]+ VGOB1_subsetB_staph_LUR1[,models[[2]]$indexbestmodel]+ VGOB1_subsetB_staph_LUR1[,models[[3]]$indexbestmodel]+ VGOB1_subsetB_staph_LUR1[,models[[4]]$indexbestmodel]+ VGOB1_subsetB_staph_LUR1[,i]) 
#   
# R2<-rbind(R2,summary(modeltry)$adj.r.squared)
# # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
#     betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
#     #  find out if there is a negative beta at All. The intercept does not count [-1]!
#     minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
#     # All[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR1)[i]
#     addedvar<-rbind(addedvar,names(VGOB1_subsetB_staph_LUR1)[i])
#     j<-rbind(j, i)
#     models[[modeln]][[i]]<-summary(modeltry)
#   }
# }
# 
# models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)
# 
# #  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
# models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)
# 
# # rank the R2's of these models
# models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))
# 
# #  this is the index of the row with the highest R2 and  no negative betas in this subset
# models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j
# 
# subset(models[[modeln]]$resultspos, rank==1)
# 
# #  this is the model
# models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]
# 
# # here are the names
# models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetB_staph_LUR1)[models[[1]]$indexbestmodel], names(VGOB1_subsetB_staph_LUR1)[models[[2]]$indexbestmodel], names(VGOB1_subsetB_staph_LUR1)[models[[3]]$indexbestmodel], names(VGOB1_subsetB_staph_LUR1)[models[[4]]$indexbestmodel], names(VGOB1_subsetB_staph_LUR1)[models[[5]]$indexbestmodel])
# 
# #  this is the r2 or that model
# models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2
# 
# #  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
# models[[modeln]]$bestmodel <- lm(VGOB1_subsetB_staph_LUR1$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetB_staph_LUR1[,models[[1]]$indexbestmodel]+VGOB1_subsetB_staph_LUR1[,models[[2]]$indexbestmodel]+VGOB1_subsetB_staph_LUR1[,models[[3]]$indexbestmodel]+ VGOB1_subsetB_staph_LUR1[,models[[4]]$indexbestmodel]+ VGOB1_subsetB_staph_LUR1[,models[[5]]$indexbestmodel]) 
# models[[1]]$summarybestmodel
# models[[2]]$summarybestmodel
# models[[3]]$summarybestmodel
# models[[4]]$summarybestmodel
# models[[5]]$summarybestmodel
# models[[1]]$namesbestmodel
# models[[2]]$namesbestmodel
# models[[3]]$namesbestmodel
# models[[4]]$namesbestmodel
# models[[5]]$namesbestmodel
# models[[1]]$R2bestmodel
# models[[2]]$R2bestmodel
# models[[3]]$R2bestmodel
# models[[4]]$R2bestmodel
# models[[5]]$R2bestmodel
# 
# # 6 #  
# # add sixth variable (the only difference of the above part is that now model n=6 the model statement more variables)
# #  and the call for the list of variable names in the model changed slightly
# 
# modeln<-6
# 
# models[[modeln]]<-list()
# 
# R2<-1
# addedvar<-1
# betaaddedvar<-1
# minbetas<-1
# j<-1
# 
# for (i in nfirstvar_LUR_1 :nlastvar_LUR_1){
#   if (is.numeric(VGOB1_subsetB_staph_LUR1[,i])==TRUE){
#     modeltry<-lm(VGOB1_subsetB_staph_LUR1$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetB_staph_LUR1[,models[[1]]$indexbestmodel]+VGOB1_subsetB_staph_LUR1[,models[[2]]$indexbestmodel]+VGOB1_subsetB_staph_LUR1[,models[[3]]$indexbestmodel]+VGOB1_subsetB_staph_LUR1[,models[[4]]$indexbestmodel]+VGOB1_subsetB_staph_LUR1[,models[[5]]$indexbestmodel]+ VGOB1_subsetB_staph_LUR1[,i]) 
#     R2<-rbind(R2,summary(modeltry)$adj.r.squared)
#     # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
#     betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
#     #  find out if there is a negative beta at All. The intercept does not count [-1]!
#     minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
#     # All[,i] is the row that's being tried out now. the name of that row can be found in  names(All)[i]
#     addedvar<-rbind(addedvar,names(VGOB1_subsetB_staph_LUR1)[i])
#     j<-rbind(j, i)
#     models[[modeln]][[i]]<-summary(modeltry)
#   }
# }
# 
# models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)
# 
# #  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
# models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)
# 
# # rank the R2's of these models
# models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))
# 
# #  this is the index of the row with the highest R2 and  no negative betas in this subset
# models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j
# 
# subset(models[[modeln]]$resultspos, rank==1)
# 
# # this is the model
# models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]
# 
# # here are the names
# models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetB_staph_LUR1)[models[[1]]$indexbestmodel], names(VGOB1_subsetB_staph_LUR1)[models[[2]]$indexbestmodel] , names(VGOB1_subsetB_staph_LUR1)[models[[3]]$indexbestmodel], names(VGOB1_subsetB_staph_LUR1)[models[[4]]$indexbestmodel], names(VGOB1_subsetB_staph_LUR1)[models[[5]]$indexbestmodel], names(VGOB1_subsetB_staph_LUR1)[models[[6]]$indexbestmodel])
# 
# #  this is the r2 or that model
# models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2
# 
# #  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
# models[[modeln]]$bestmodel <- lm(VGOB1_subsetB_staph_LUR1$staph_copiespm3.ln.diffmeth.mean~ VGOB1_subsetB_staph_LUR1[,models[[1]]$indexbestmodel]+ VGOB1_subsetB_staph_LUR1[,models[[2]]$indexbestmodel]+ VGOB1_subsetB_staph_LUR1[,models[[3]]$indexbestmodel]+ VGOB1_subsetB_staph_LUR1[,models[[4]]$indexbestmodel]+ VGOB1_subsetB_staph_LUR1[,models[[5]]$indexbestmodel]+ VGOB1_subsetB_staph_LUR1[,models[[6]]$indexbestmodel]) 
# 
# models[[1]]$summarybestmodel
# models[[2]]$summarybestmodel
# models[[3]]$summarybestmodel
# models[[4]]$summarybestmodel
# models[[5]]$summarybestmodel
# models[[6]]$summarybestmodel
# models[[1]]$namesbestmodel
# models[[2]]$namesbestmodel
# models[[3]]$namesbestmodel
# models[[4]]$namesbestmodel
# models[[5]]$namesbestmodel
# models[[6]]$namesbestmodel
# models[[1]]$R2bestmodel
# models[[2]]$R2bestmodel
# models[[3]]$R2bestmodel
# models[[4]]$R2bestmodel
# models[[5]]$R2bestmodel
# models[[6]]$R2bestmodel
# 
# 
# # 7 #  
# # add seventh variable (the only difference of the above part is that now model n=7 the model statement more variables)
# #  and the call for the list of variable names in the model changed slightly
# 
# modeln<-7
# 
# models[[modeln]]<-list()
# 
# R2<-1
# addedvar<-1
# betaaddedvar<-1
# minbetas<-1
# j<-1
# 
# for (i in nfirstvar_LUR_1 :nlastvar_LUR_1){
#   if (is.numeric(VGOB1_subsetB_staph_LUR1[,i])==TRUE){
#     modeltry<- lm(VGOB1_subsetB_staph_LUR1$staph_copiespm3.ln.diffmeth.mean~ VGOB1_subsetB_staph_LUR1[,models[[1]]$indexbestmodel]+ VGOB1_subsetB_staph_LUR1[,models[[2]]$indexbestmodel]+ VGOB1_subsetB_staph_LUR1[,models[[3]]$indexbestmodel]+ VGOB1_subsetB_staph_LUR1[,models[[4]]$indexbestmodel]+ VGOB1_subsetB_staph_LUR1[,models[[5]]$indexbestmodel]+ VGOB1_subsetB_staph_LUR1[,models[[6]]$indexbestmodel]+ VGOB1_subsetB_staph_LUR1[,i]) 
#     R2<-rbind(R2,summary(modeltry)$adj.r.squared)
#     # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
#     betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
#     #  find out if there is a negative beta at All. The intercept does not count [-1]!
#     minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
#     # Measurements_livestockpreds_LUR1[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR1)[i]
#     addedvar<-rbind(addedvar,names(VGOB1_subsetB_staph_LUR1)[i])
#     j<-rbind(j, i)
#     models[[modeln]][[i]]<-summary(modeltry)
#   }
# }
# 
# models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)
# 
# #  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
# models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)
# 
# # rank the R2's of these models
# models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))
# 
# #  this is the index of the row with the highest R2 and  no negative betas in this subset
# models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j
# 
# subset(models[[modeln]]$resultspos, rank==1)
# 
# # this is the model
# models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]
# 
# # here are the names
# models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetB_staph_LUR1)[models[[1]]$indexbestmodel], names(VGOB1_subsetB_staph_LUR1)[models[[2]]$indexbestmodel] , names(VGOB1_subsetB_staph_LUR1)[models[[3]]$indexbestmodel], names(VGOB1_subsetB_staph_LUR1)[models[[4]]$indexbestmodel], names(VGOB1_subsetB_staph_LUR1)[models[[5]]$indexbestmodel], names(VGOB1_subsetB_staph_LUR1)[models[[6]]$indexbestmodel], names(VGOB1_subsetB_staph_LUR1)[models[[7]]$indexbestmodel])
# 
# #  this is the r2 or that model
# models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2
# 
# #  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
# models[[modeln]]$bestmodel <- lm(VGOB1_subsetB_staph_LUR1$staph_copiespm3.ln.diffmeth.mean~ VGOB1_subsetB_staph_LUR1[,models[[1]]$indexbestmodel]+ VGOB1_subsetB_staph_LUR1[,models[[2]]$indexbestmodel]+ VGOB1_subsetB_staph_LUR1[,models[[3]]$indexbestmodel]+ VGOB1_subsetB_staph_LUR1[,models[[4]]$indexbestmodel]+ VGOB1_subsetB_staph_LUR1[,models[[5]]$indexbestmodel]+ VGOB1_subsetB_staph_LUR1[,models[[6]]$indexbestmodel]+ VGOB1_subsetB_staph_LUR1[,models[[7]]$indexbestmodel]) 
# 
# models[[1]]$summarybestmodel
# models[[2]]$summarybestmodel
# models[[3]]$summarybestmodel
# models[[4]]$summarybestmodel
# models[[5]]$summarybestmodel
# models[[6]]$summarybestmodel
# models[[7]]$summarybestmodel
# models[[1]]$namesbestmodel
# models[[2]]$namesbestmodel
# models[[3]]$namesbestmodel
# models[[4]]$namesbestmodel
# models[[5]]$namesbestmodel
# models[[6]]$namesbestmodel
# models[[7]]$namesbestmodel
# models[[1]]$R2bestmodel
# models[[2]]$R2bestmodel
# models[[3]]$R2bestmodel
# models[[4]]$R2bestmodel
# models[[5]]$R2bestmodel
# models[[6]]$R2bestmodel
# models[[7]]$R2bestmodel
# 
# # 8 #  
# # add eighth variable (the only difference of the above part is that now modeln=7 the model statement more variables)
# # and the call for the list of variable names in the model changed slightly
# 
# modeln<-8
# 
# models[[modeln]]<-list()
# 
# R2<-1
# addedvar<-1
# betaaddedvar<-1
# minbetas<-1
# j<-1
# 
# for (i in nfirstvar_LUR_1 :nlastvar_LUR_1){
#   if (is.numeric(VGOB1_subsetB_staph_LUR1[,i])==TRUE){
#     modeltry<- lm(VGOB1_subsetB_staph_LUR1$staph_copiespm3.ln.diffmeth.mean~ VGOB1_subsetB_staph_LUR1[,models[[1]]$indexbestmodel]+ VGOB1_subsetB_staph_LUR1[,models[[2]]$indexbestmodel]+ VGOB1_subsetB_staph_LUR1[,models[[3]]$indexbestmodel]+ VGOB1_subsetB_staph_LUR1[,models[[4]]$indexbestmodel]+ VGOB1_subsetB_staph_LUR1[,models[[5]]$indexbestmodel]+ VGOB1_subsetB_staph_LUR1[,models[[6]]$indexbestmodel]+ VGOB1_subsetB_staph_LUR1[,models[[7]]$indexbestmodel]+ VGOB1_subsetB_staph_LUR1[,i]) 
#     R2<-rbind(R2,summary(modeltry)$adj.r.squared)
#     # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
#     betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
#     #  find out if there is a negative beta at All. The intercept does not count [-1]!
#     minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
#     # Measurements_livestockpreds_LUR1[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR1)[i]
#     addedvar<-rbind(addedvar,names(VGOB1_subsetB_staph_LUR1)[i])
#     j<-rbind(j, i)
#     models[[modeln]][[i]]<-summary(modeltry)
#   }
# }
# 
# models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)
# 
# #  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
# models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)
# 
# # rank the R2's of these models
# models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))
# 
# #  this is the index of the row with the highest R2 and  no negative betas in this subset
# models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j
# 
# subset(models[[modeln]]$resultspos, rank==1)
# 
# # this is the model
# models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]
# 
# # here are the names
# models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetB_staph_LUR1)[models[[1]]$indexbestmodel], names(VGOB1_subsetB_staph_LUR1)[models[[2]]$indexbestmodel] , names(VGOB1_subsetB_staph_LUR1)[models[[3]]$indexbestmodel], names(VGOB1_subsetB_staph_LUR1)[models[[4]]$indexbestmodel], names(VGOB1_subsetB_staph_LUR1)[models[[5]]$indexbestmodel], names(VGOB1_subsetB_staph_LUR1)[models[[6]]$indexbestmodel], names(VGOB1_subsetB_staph_LUR1)[models[[7]]$indexbestmodel], names(VGOB1_subsetB_staph_LUR1)[models[[8]]$indexbestmodel])
# 
# #  this is the r2 or that model
# models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2
# 
# #  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
# models[[modeln]]$bestmodel <- lm(VGOB1_subsetB_staph_LUR1$staph_copiespm3.ln.diffmeth.mean~ VGOB1_subsetB_staph_LUR1[,models[[1]]$indexbestmodel]+ VGOB1_subsetB_staph_LUR1[,models[[2]]$indexbestmodel]+ VGOB1_subsetB_staph_LUR1[,models[[3]]$indexbestmodel]+ VGOB1_subsetB_staph_LUR1[,models[[4]]$indexbestmodel]+ VGOB1_subsetB_staph_LUR1[,models[[5]]$indexbestmodel]+ VGOB1_subsetB_staph_LUR1[,models[[6]]$indexbestmodel]+ VGOB1_subsetB_staph_LUR1[,models[[7]]$indexbestmodel]+ VGOB1_subsetB_staph_LUR1[,models[[8]]$indexbestmodel]) 
# 
# models[[1]]$summarybestmodel
# models[[2]]$summarybestmodel
# models[[3]]$summarybestmodel
# models[[4]]$summarybestmodel
# models[[5]]$summarybestmodel
# models[[6]]$summarybestmodel
# models[[7]]$summarybestmodel
# models[[8]]$summarybestmodel
# models[[1]]$namesbestmodel
# models[[2]]$namesbestmodel
# models[[3]]$namesbestmodel
# models[[4]]$namesbestmodel
# models[[5]]$namesbestmodel
# models[[6]]$namesbestmodel
# models[[7]]$namesbestmodel
# models[[8]]$namesbestmodel
# models[[1]]$R2bestmodel
# models[[2]]$R2bestmodel
# models[[3]]$R2bestmodel
# models[[4]]$R2bestmodel
# models[[5]]$R2bestmodel
# models[[6]]$R2bestmodel
# models[[7]]$R2bestmodel
# models[[8]]$R2bestmodel

#   CODE FOR PICKING OUT THE BEST MODEL #   
temp <- 0
besti <- 0
for (i in 1:10){ #  think this runs the loop 10 times - not fully sure thought - but not to do with the number of models I don't think - as when I change to 3, I still get the model with 4 variables as best model
  print(models[[i]]$R2bestmodel)
  #       print(models[[i]]$summarybestmodel$coefficients=-1,4])
  #       if((models[[i]]$R2bestmodel-temp > 0.0) && (all(models[[i]]$summarybestmodel$coefficients[-1,4]<0.1))){
  #         temp <- models[[i]]$R2bestmodel
  #         besti <- i
  #         }
  if((models[[i]]$R2bestmodel-temp > 0.0) && (all(models[[i]]$summarybestmodel$coefficients[-1,4]<0.1))){
    temp <- models[[i]]$R2bestmodel
    besti <- i
  }else{
    finalBestModel_staph_LUR1_subsetB <- models[[besti]]$bestmodel
    finalBestModelNames_staph_subsetB <- models[[besti]]$namesbestmodel
    Sites <- 1:dim(VGOB1_subsetB_staph_LUR1)[1] # full original model
    #  CVaR2<-escCV_staph_LUR1(Sites)[2] # Cross Validation
    maxCD<-max(cooks.distance(finalBestModel_staph_LUR1_subsetB))
    if(length(finalBestModelNames_staph_subsetB)<2){ # vif fn doesnot work when only 1 variable...       # 
      maxVIF<-"NA"
    }else{
      maxVIF<-max(vif(finalBestModel_staph_LUR1_subsetB))
    }
    print(paste("This is the best staph model for subset B of 10-fold CV: ",besti,
                "(AdjR2: ",format(models[[besti]]$R2bestmodel,digits=3), "; MaxCD: ",format(maxCD,digits=3),"; MaxVIF: ",
                format(maxVIF,digits=3),")", sep=''))
    print(finalBestModelNames_staph_subsetB)
    break
  }
}

#  Overview of the final best model using the algorithm selection process (taking into account VIF, R^2, and p-values)
finalBestModel_staph_LUR1_subsetB 
finalBestModelNames_staph_subsetB 
models[[besti]]$summarybestmodel
models[[besti]]$R2bestmodel

#### C ####
# LUR model building process for subset C
#  This is the dataframe with the relevant predictor vars for LUR1 models for subset C (55 sites)
VGOB1_subsetC_staph_LUR1 # n.b. this dataframe only includes microbial marker concentrations for staph unlike the dataframe Measurements_livestockpreds_LUR1 as previously used for the model building. 

#  Now set the values of some variables that will be needed
nfirstvar_LUR_1 <- 3  
nlastvar_LUR_1 <- 10

# Function building to run the models 
# 1 #  

models<-list()
modeln<-1
models[[modeln]]<-list()

R2<-1
betaaddedvar<-1
addedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_1:nlastvar_LUR_1){
  if (is.numeric(VGOB1_subsetC_staph_LUR1[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetC_staph_LUR1$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetC_staph_LUR1[,i])                            
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    #  Measurements_livestockpreds_LUR1[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR1)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetC_staph_LUR1)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)
models[[modeln]]$results

#  this are the candidates models with the highest R2, not a negative beta for the new, nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)
models[[modeln]]$resultspos

#  rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))
models[[modeln]]$resultspos

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j
models[[modeln]]$indexbestmodel

subset(models[[modeln]]$resultspos, rank==1)
subset(models[[modeln]]$resultspos)

#  this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]
models[[modeln]]$summarybestmodel

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetC_staph_LUR1)[models[[1]]$indexbestmodel])
models[[modeln]]$namesbestmodel

#  this is the r2 of that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2
models[[modeln]]$R2bestmodel

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetC_staph_LUR1$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetC_staph_LUR1[,models[[1]]$indexbestmodel]) 
models[[modeln]]$bestmodel

summary(models[[modeln]]$bestmodel)

#  The first model includes the predictor: nPigMultipFarmWghtDist.3000m.sum.Tr.1P9 - meaning the number of multiplier pig farms weighted to distance in a 3000m buffer

# 2 #  
# Add 2nd variable (the only difference of the above part is that now modeln=2 the model statement has 2 variables)
# and the call for the list of variable names in the model changed slightly

modeln<-2

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_1:nlastvar_LUR_1){
  if (is.numeric(VGOB1_subsetC_staph_LUR1[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetC_staph_LUR1$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetC_staph_LUR1[,models[[1]]$indexbestmodel]+ VGOB1_subsetC_staph_LUR1[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # Measurements_livestockpreds_LUR1[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR1)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetC_staph_LUR1)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  these are the candidate models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)
models[[modeln]]$resultspos

#  rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))
models[[modeln]]$resultspos

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j
models[[modeln]]$indexbestmodel

subset(models[[modeln]]$resultspos, rank==1)

# this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]
models[[modeln]]$summarybestmodel

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetC_staph_LUR1)[models[[1]]$indexbestmodel], names(VGOB1_subsetC_staph_LUR1)[models[[2]]$indexbestmodel] )
models[[modeln]]$namesbestmodel

# this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2
models[[modeln]]$R2bestmodel

# this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetC_staph_LUR1$staph_copiespm3.ln.diffmeth.mean~                               VGOB1_subsetC_staph_LUR1[,models[[1]]$indexbestmodel]+                           VGOB1_subsetC_staph_LUR1[,models[[2]]$indexbestmodel]) 

models[[modeln]]$bestmodel

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel


# 3 #  
# add third variable (the only difference of the above part is that now modeln=3 the model statement has 3 variables)
# and the call for the list of variable names in the model changed slightly

modeln<-3

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_1:nlastvar_LUR_1){
  if (is.numeric(VGOB1_subsetC_staph_LUR1[,i])==TRUE){  
    modeltry<-lm(VGOB1_subsetC_staph_LUR1$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetC_staph_LUR1[,models[[1]]$indexbestmodel]+VGOB1_subsetC_staph_LUR1[,models[[2]]$indexbestmodel]+ VGOB1_subsetC_staph_LUR1[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # All[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR1)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetC_staph_LUR1)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

#  rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

#  this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

#  here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetC_staph_LUR1)[models[[1]]$indexbestmodel], names(VGOB1_subsetC_staph_LUR1)[models[[2]]$indexbestmodel], names(VGOB1_subsetC_staph_LUR1)[models[[3]]$indexbestmodel])

#  this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetC_staph_LUR1$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetC_staph_LUR1[,models[[1]]$indexbestmodel]+ VGOB1_subsetC_staph_LUR1[,models[[2]]$indexbestmodel]+ VGOB1_subsetC_staph_LUR1[,models[[3]]$indexbestmodel]) 

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel


# The next part of the code (n=4-8) does not work
# This is because one of the coefficients included in the model with 6 variables is negative, the code does not allow for this. I can stop here.

# # 4 #  
# #  add forth variable (the only difference of the above part is that now model n=4 the model statement more variables)
# #  and the call for the list of variable names in the model changed slightly
# modeln<-4
# 
# models[[modeln]]<-list()
# 
# R2<-1
# addedvar<-1
# betaaddedvar<-1
# minbetas<-1
# j<-1
# 
# 
# for (i in nfirstvar_LUR_1:nlastvar_LUR_1){
#   if (is.numeric(VGOB1_subsetC_staph_LUR1[,i])==TRUE){
#     modeltry<-lm(VGOB1_subsetC_staph_LUR1$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetC_staph_LUR1[,models[[1]]$indexbestmodel]+VGOB1_subsetC_staph_LUR1[,models[[2]]$indexbestmodel]+VGOB1_subsetC_staph_LUR1[,models[[3]]$indexbestmodel]+VGOB1_subsetC_staph_LUR1[,i]) 
#     R2<-rbind(R2,summary(modeltry)$adj.r.squared)
#     #  the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
#     betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])
#     #  find out if there is a negative beta at All. The intercept does not count [-1]!
#     minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
#     #  All[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR1)[i]
#     addedvar<-rbind(addedvar,names(VGOB1_subsetC_staph_LUR1)[i])
#     j<-rbind(j, i)
#     models[[modeln]][[i]]<-summary(modeltry)
#   }
# }
# 
# models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)
# 
# #  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
# models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)
# 
# # rank the R2's of these models
# models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))
# 
# #  this is the index of the row with the highest R2 and  no negative betas in this subset
# models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j
# 
# subset(models[[modeln]]$resultspos, rank==1)
# 
# #  this is the model
# models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]
# 
# #  here are the names
# models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetC_staph_LUR1)[models[[1]]$indexbestmodel], names(VGOB1_subsetC_staph_LUR1)[models[[2]]$indexbestmodel], names(VGOB1_subsetC_staph_LUR1)[models[[3]]$indexbestmodel], names(VGOB1_subsetC_staph_LUR1)[models[[4]]$indexbestmodel])
# 
# #  this is the r2 of that model
# models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2
# 
# #  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
# models[[modeln]]$bestmodel <- lm(VGOB1_subsetC_staph_LUR1$staph_copiespm3.ln.diffmeth.mean~ VGOB1_subsetC_staph_LUR1[,models[[1]]$indexbestmodel]+ VGOB1_subsetC_staph_LUR1[,models[[2]]$indexbestmodel]+VGOB1_subsetC_staph_LUR1[,models[[3]]$indexbestmodel]+ VGOB1_subsetC_staph_LUR1[,models[[4]]$indexbestmodel]) 
# 
# 
# models[[1]]$summarybestmodel
# models[[2]]$summarybestmodel
# models[[3]]$summarybestmodel
# models[[4]]$summarybestmodel
# models[[1]]$namesbestmodel
# models[[2]]$namesbestmodel
# models[[3]]$namesbestmodel
# models[[4]]$namesbestmodel
# models[[1]]$R2bestmodel
# models[[2]]$R2bestmodel
# models[[3]]$R2bestmodel
# models[[4]]$R2bestmodel
# 
# 
# # 5 #  
# # add fifth variable (the only difference of the above part is that now modeln=5 the model statement more variables)
# # and the call for the list of variable names in the model changed slightly
# modeln<-5
# 
# models[[modeln]]<-list()
# 
# R2<-1
# addedvar<-1
# betaaddedvar<-1
# minbetas<-1
# j<-1
# 
# for (i in nfirstvar_LUR_1:nlastvar_LUR_1){
#   if (is.numeric(VGOB1_subsetC_staph_LUR1[,i])==TRUE){
#     modeltry<-lm(VGOB1_subsetC_staph_LUR1$staph_copiespm3.ln.diffmeth.mean~ VGOB1_subsetC_staph_LUR1[,models[[1]]$indexbestmodel]+ VGOB1_subsetC_staph_LUR1[,models[[2]]$indexbestmodel]+ VGOB1_subsetC_staph_LUR1[,models[[3]]$indexbestmodel]+ VGOB1_subsetC_staph_LUR1[,models[[4]]$indexbestmodel]+ VGOB1_subsetC_staph_LUR1[,i]) 
#   
# R2<-rbind(R2,summary(modeltry)$adj.r.squared)
# # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
#     betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
#     #  find out if there is a negative beta at All. The intercept does not count [-1]!
#     minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
#     # All[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR1)[i]
#     addedvar<-rbind(addedvar,names(VGOB1_subsetC_staph_LUR1)[i])
#     j<-rbind(j, i)
#     models[[modeln]][[i]]<-summary(modeltry)
#   }
# }
# 
# models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)
# 
# #  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
# models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)
# 
# # rank the R2's of these models
# models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))
# 
# #  this is the index of the row with the highest R2 and  no negative betas in this subset
# models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j
# 
# subset(models[[modeln]]$resultspos, rank==1)
# 
# #  this is the model
# models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]
# 
# # here are the names
# models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetC_staph_LUR1)[models[[1]]$indexbestmodel], names(VGOB1_subsetC_staph_LUR1)[models[[2]]$indexbestmodel], names(VGOB1_subsetC_staph_LUR1)[models[[3]]$indexbestmodel], names(VGOB1_subsetC_staph_LUR1)[models[[4]]$indexbestmodel], names(VGOB1_subsetC_staph_LUR1)[models[[5]]$indexbestmodel])
# 
# #  this is the r2 or that model
# models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2
# 
# #  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
# models[[modeln]]$bestmodel <- lm(VGOB1_subsetC_staph_LUR1$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetC_staph_LUR1[,models[[1]]$indexbestmodel]+VGOB1_subsetC_staph_LUR1[,models[[2]]$indexbestmodel]+VGOB1_subsetC_staph_LUR1[,models[[3]]$indexbestmodel]+ VGOB1_subsetC_staph_LUR1[,models[[4]]$indexbestmodel]+ VGOB1_subsetC_staph_LUR1[,models[[5]]$indexbestmodel]) 
# models[[1]]$summarybestmodel
# models[[2]]$summarybestmodel
# models[[3]]$summarybestmodel
# models[[4]]$summarybestmodel
# models[[5]]$summarybestmodel
# models[[1]]$namesbestmodel
# models[[2]]$namesbestmodel
# models[[3]]$namesbestmodel
# models[[4]]$namesbestmodel
# models[[5]]$namesbestmodel
# models[[1]]$R2bestmodel
# models[[2]]$R2bestmodel
# models[[3]]$R2bestmodel
# models[[4]]$R2bestmodel
# models[[5]]$R2bestmodel
# 
# # 6 #  
# # add sixth variable (the only difference of the above part is that now model n=6 the model statement more variables)
# #  and the call for the list of variable names in the model changed slightly
# 
# modeln<-6
# 
# models[[modeln]]<-list()
# 
# R2<-1
# addedvar<-1
# betaaddedvar<-1
# minbetas<-1
# j<-1
# 
# for (i in nfirstvar_LUR_1 :nlastvar_LUR_1){
#   if (is.numeric(VGOB1_subsetC_staph_LUR1[,i])==TRUE){
#     modeltry<-lm(VGOB1_subsetC_staph_LUR1$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetC_staph_LUR1[,models[[1]]$indexbestmodel]+VGOB1_subsetC_staph_LUR1[,models[[2]]$indexbestmodel]+VGOB1_subsetC_staph_LUR1[,models[[3]]$indexbestmodel]+VGOB1_subsetC_staph_LUR1[,models[[4]]$indexbestmodel]+VGOB1_subsetC_staph_LUR1[,models[[5]]$indexbestmodel]+ VGOB1_subsetC_staph_LUR1[,i]) 
#     R2<-rbind(R2,summary(modeltry)$adj.r.squared)
#     # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
#     betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
#     #  find out if there is a negative beta at All. The intercept does not count [-1]!
#     minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
#     # All[,i] is the row that's being tried out now. the name of that row can be found in  names(All)[i]
#     addedvar<-rbind(addedvar,names(VGOB1_subsetC_staph_LUR1)[i])
#     j<-rbind(j, i)
#     models[[modeln]][[i]]<-summary(modeltry)
#   }
# }
# 
# models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)
# 
# #  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
# models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)
# 
# # rank the R2's of these models
# models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))
# 
# #  this is the index of the row with the highest R2 and  no negative betas in this subset
# models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j
# 
# subset(models[[modeln]]$resultspos, rank==1)
# 
# # this is the model
# models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]
# 
# # here are the names
# models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetC_staph_LUR1)[models[[1]]$indexbestmodel], names(VGOB1_subsetC_staph_LUR1)[models[[2]]$indexbestmodel] , names(VGOB1_subsetC_staph_LUR1)[models[[3]]$indexbestmodel], names(VGOB1_subsetC_staph_LUR1)[models[[4]]$indexbestmodel], names(VGOB1_subsetC_staph_LUR1)[models[[5]]$indexbestmodel], names(VGOB1_subsetC_staph_LUR1)[models[[6]]$indexbestmodel])
# 
# #  this is the r2 or that model
# models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2
# 
# #  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
# models[[modeln]]$bestmodel <- lm(VGOB1_subsetC_staph_LUR1$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetC_staph_LUR1[,models[[1]]$indexbestmodel]+VGOB1_subsetC_staph_LUR1[,models[[2]]$indexbestmodel]+VGOB1_subsetC_staph_LUR1[,models[[3]]$indexbestmodel]+ VGOB1_subsetC_staph_LUR1[,models[[4]]$indexbestmodel]+ VGOB1_subsetC_staph_LUR1[,models[[5]]$indexbestmodel]+ VGOB1_subsetC_staph_LUR1[,models[[6]]$indexbestmodel]) 
# 
# models[[1]]$summarybestmodel
# models[[2]]$summarybestmodel
# models[[3]]$summarybestmodel
# models[[4]]$summarybestmodel
# models[[5]]$summarybestmodel
# models[[6]]$summarybestmodel
# models[[1]]$namesbestmodel
# models[[2]]$namesbestmodel
# models[[3]]$namesbestmodel
# models[[4]]$namesbestmodel
# models[[5]]$namesbestmodel
# models[[6]]$namesbestmodel
# models[[1]]$R2bestmodel
# models[[2]]$R2bestmodel
# models[[3]]$R2bestmodel
# models[[4]]$R2bestmodel
# models[[5]]$R2bestmodel
# models[[6]]$R2bestmodel
# 
# 
# # 7 #  
# # add seventh variable (the only difference of the above part is that now model n=7 the model statement more variables)
# #  and the call for the list of variable names in the model changed slightly
# 
# modeln<-7
# 
# models[[modeln]]<-list()
# 
# R2<-1
# addedvar<-1
# betaaddedvar<-1
# minbetas<-1
# j<-1
# 
# for (i in nfirstvar_LUR_1 :nlastvar_LUR_1){
#   if (is.numeric(VGOB1_subsetC_staph_LUR1[,i])==TRUE){
#     modeltry<-lm(VGOB1_subsetC_staph_LUR1$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetC_staph_LUR1[,models[[1]]$indexbestmodel]+VGOB1_subsetC_staph_LUR1[,models[[2]]$indexbestmodel]+VGOB1_subsetC_staph_LUR1[,models[[3]]$indexbestmodel]+VGOB1_subsetC_staph_LUR1[,models[[4]]$indexbestmodel]+VGOB1_subsetC_staph_LUR1[,models[[5]]$indexbestmodel]+VGOB1_subsetC_staph_LUR1[,models[[6]]$indexbestmodel]+ VGOB1_subsetC_staph_LUR1[,i]) 
#     R2<-rbind(R2,summary(modeltry)$adj.r.squared)
#     # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
#     betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
#     #  find out if there is a negative beta at All. The intercept does not count [-1]!
#     minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
#     # Measurements_livestockpreds_LUR1[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR1)[i]
#     addedvar<-rbind(addedvar,names(VGOB1_subsetC_staph_LUR1)[i])
#     j<-rbind(j, i)
#     models[[modeln]][[i]]<-summary(modeltry)
#   }
# }
# 
# models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)
# 
# #  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
# models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)
# 
# # rank the R2's of these models
# models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))
# 
# #  this is the index of the row with the highest R2 and  no negative betas in this subset
# models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j
# 
# subset(models[[modeln]]$resultspos, rank==1)
# 
# # this is the model
# models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]
# 
# # here are the names
# models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetC_staph_LUR1)[models[[1]]$indexbestmodel], names(VGOB1_subsetC_staph_LUR1)[models[[2]]$indexbestmodel] , names(VGOB1_subsetC_staph_LUR1)[models[[3]]$indexbestmodel], names(VGOB1_subsetC_staph_LUR1)[models[[4]]$indexbestmodel], names(VGOB1_subsetC_staph_LUR1)[models[[5]]$indexbestmodel], names(VGOB1_subsetC_staph_LUR1)[models[[6]]$indexbestmodel], names(VGOB1_subsetC_staph_LUR1)[models[[7]]$indexbestmodel])
# 
# #  this is the r2 or that model
# models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2
# 
# #  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
# models[[modeln]]$bestmodel <- lm(VGOB1_subsetC_staph_LUR1$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetC_staph_LUR1[,models[[1]]$indexbestmodel]+VGOB1_subsetC_staph_LUR1[,models[[2]]$indexbestmodel]+VGOB1_subsetC_staph_LUR1[,models[[3]]$indexbestmodel]+ VGOB1_subsetC_staph_LUR1[,models[[4]]$indexbestmodel]+ VGOB1_subsetC_staph_LUR1[,models[[5]]$indexbestmodel]+ VGOB1_subsetC_staph_LUR1[,models[[6]]$indexbestmodel]+ VGOB1_subsetC_staph_LUR1[,models[[7]]$indexbestmodel]) 
# 
# models[[1]]$summarybestmodel
# models[[2]]$summarybestmodel
# models[[3]]$summarybestmodel
# models[[4]]$summarybestmodel
# models[[5]]$summarybestmodel
# models[[6]]$summarybestmodel
# models[[7]]$summarybestmodel
# models[[1]]$namesbestmodel
# models[[2]]$namesbestmodel
# models[[3]]$namesbestmodel
# models[[4]]$namesbestmodel
# models[[5]]$namesbestmodel
# models[[6]]$namesbestmodel
# models[[7]]$namesbestmodel
# models[[1]]$R2bestmodel
# models[[2]]$R2bestmodel
# models[[3]]$R2bestmodel
# models[[4]]$R2bestmodel
# models[[5]]$R2bestmodel
# models[[6]]$R2bestmodel
# models[[7]]$R2bestmodel
# 
# # 8 #  
# # add eighth variable (the only difference of the above part is that now modeln=7 the model statement more variables)
# # and the call for the list of variable names in the model changed slightly
# 
# modeln<-8
# 
# models[[modeln]]<-list()
# 
# R2<-1
# addedvar<-1
# betaaddedvar<-1
# minbetas<-1
# j<-1
# 
# for (i in nfirstvar_LUR_1 :nlastvar_LUR_1){
#   if (is.numeric(VGOB1_subsetC_staph_LUR1[,i])==TRUE){
#     modeltry<-lm(VGOB1_subsetC_staph_LUR1$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetC_staph_LUR1[,models[[1]]$indexbestmodel]+VGOB1_subsetC_staph_LUR1[,models[[2]]$indexbestmodel]+VGOB1_subsetC_staph_LUR1[,models[[3]]$indexbestmodel]+VGOB1_subsetC_staph_LUR1[,models[[4]]$indexbestmodel]+VGOB1_subsetC_staph_LUR1[,models[[5]]$indexbestmodel]+VGOB1_subsetC_staph_LUR1[,models[[6]]$indexbestmodel]+ VGOB1_subsetC_staph_LUR1[,models[[7]]$indexbestmodel]+ VGOB1_subsetC_staph_LUR1[,i]) 
#     R2<-rbind(R2,summary(modeltry)$adj.r.squared)
#     # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
#     betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
#     #  find out if there is a negative beta at All. The intercept does not count [-1]!
#     minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
#     # Measurements_livestockpreds_LUR1[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR1)[i]
#     addedvar<-rbind(addedvar,names(VGOB1_subsetC_staph_LUR1)[i])
#     j<-rbind(j, i)
#     models[[modeln]][[i]]<-summary(modeltry)
#   }
# }
# 
# models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)
# 
# #  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
# models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)
# 
# # rank the R2's of these models
# models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))
# 
# #  this is the index of the row with the highest R2 and  no negative betas in this subset
# models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j
# 
# subset(models[[modeln]]$resultspos, rank==1)
# 
# # this is the model
# models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]
# 
# # here are the names
# models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetC_staph_LUR1)[models[[1]]$indexbestmodel], names(VGOB1_subsetC_staph_LUR1)[models[[2]]$indexbestmodel] , names(VGOB1_subsetC_staph_LUR1)[models[[3]]$indexbestmodel], names(VGOB1_subsetC_staph_LUR1)[models[[4]]$indexbestmodel], names(VGOB1_subsetC_staph_LUR1)[models[[5]]$indexbestmodel], names(VGOB1_subsetC_staph_LUR1)[models[[6]]$indexbestmodel], names(VGOB1_subsetC_staph_LUR1)[models[[7]]$indexbestmodel], names(VGOB1_subsetC_staph_LUR1)[models[[8]]$indexbestmodel])
# 
# #  this is the r2 or that model
# models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2
# 
# #  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
# models[[modeln]]$bestmodel <- lm(VGOB1_subsetC_staph_LUR1$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetC_staph_LUR1[,models[[1]]$indexbestmodel]+VGOB1_subsetC_staph_LUR1[,models[[2]]$indexbestmodel]+VGOB1_subsetC_staph_LUR1[,models[[3]]$indexbestmodel]+ VGOB1_subsetC_staph_LUR1[,models[[4]]$indexbestmodel]+ VGOB1_subsetC_staph_LUR1[,models[[5]]$indexbestmodel]+ VGOB1_subsetC_staph_LUR1[,models[[6]]$indexbestmodel]+ VGOB1_subsetC_staph_LUR1[,models[[7]]$indexbestmodel]+ VGOB1_subsetC_staph_LUR1[,models[[8]]$indexbestmodel]) 
# 
# models[[1]]$summarybestmodel
# models[[2]]$summarybestmodel
# models[[3]]$summarybestmodel
# models[[4]]$summarybestmodel
# models[[5]]$summarybestmodel
# models[[6]]$summarybestmodel
# models[[7]]$summarybestmodel
# models[[8]]$summarybestmodel
# models[[1]]$namesbestmodel
# models[[2]]$namesbestmodel
# models[[3]]$namesbestmodel
# models[[4]]$namesbestmodel
# models[[5]]$namesbestmodel
# models[[6]]$namesbestmodel
# models[[7]]$namesbestmodel
# models[[8]]$namesbestmodel
# models[[1]]$R2bestmodel
# models[[2]]$R2bestmodel
# models[[3]]$R2bestmodel
# models[[4]]$R2bestmodel
# models[[5]]$R2bestmodel
# models[[6]]$R2bestmodel
# models[[7]]$R2bestmodel
# models[[8]]$R2bestmodel

#   CODE FOR PICKING OUT THE BEST MODEL #   
temp <- 0
besti <- 0
for (i in 1:10){ #  think this runs the loop 10 times - not fully sure thought - but not to do with the number of models I don't think - as when I change to 3, I still get the model with 4 variables as best model
  print(models[[i]]$R2bestmodel)
  #       print(models[[i]]$summarybestmodel$coefficients=-1,4])
  #       if((models[[i]]$R2bestmodel-temp > 0.0) && (all(models[[i]]$summarybestmodel$coefficients[-1,4]<0.1))){
  #         temp <- models[[i]]$R2bestmodel
  #         besti <- i
  #         }
  if((models[[i]]$R2bestmodel-temp > 0.0) && (all(models[[i]]$summarybestmodel$coefficients[-1,4]<0.1))){
    temp <- models[[i]]$R2bestmodel
    besti <- i
  }else{
    finalBestModel_staph_LUR1_subsetC <- models[[besti]]$bestmodel
    finalBestModelNames_staph_subsetC <- models[[besti]]$namesbestmodel
    Sites <- 1:dim(VGOB1_subsetC_staph_LUR1)[1] # full original model
    #  CVaR2<-escCV_staph_LUR1(Sites)[2] # Cross Validation
    maxCD<-max(cooks.distance(finalBestModel_staph_LUR1_subsetC))
    if(length(finalBestModelNames_staph_subsetC)<2){ # vif fn doesnot work when only 1 variable...       # 
      maxVIF<-"NA"
    }else{
      maxVIF<-max(vif(finalBestModel_staph_LUR1_subsetC))
    }
    print(paste("This is the best staph model for subset C: ",besti,
                "(AdjR2: ",format(models[[besti]]$R2bestmodel,digits=3), "; MaxCD: ",format(maxCD,digits=3),"; MaxVIF: ",
                format(maxVIF,digits=3),")", sep=''))
    print(finalBestModelNames_staph_subsetC)
    break
  }
}

#  Overview of the final best model using the algorithm selection process (taking into account VIF, R^2, and p-values)
finalBestModel_staph_LUR1_subsetC
finalBestModelNames_staph_subsetC
models[[besti]]$summarybestmodel
models[[besti]]$R2bestmodel

#### D ####
# LUR model building process for subset D
#  This is the dataframe with the relevant predictor vars for LUR1 models for subset D (55 sites)
VGOB1_subsetD_staph_LUR1 # n.b. this dataframe only includes microbial marker concentrations for staph unlike the dataframe Measurements_livestockpreds_LUR1 as previously used for the model building. 

#  Now set the values of some variables that will be needed
nfirstvar_LUR_1 <- 3  
nlastvar_LUR_1 <- 10

# Function building to run the models 
# 1 #  

models<-list()
modeln<-1
models[[modeln]]<-list()

R2<-1
betaaddedvar<-1
addedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_1:nlastvar_LUR_1){
  if (is.numeric(VGOB1_subsetD_staph_LUR1[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetD_staph_LUR1$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetD_staph_LUR1[,i])                            
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    #  Measurements_livestockpreds_LUR1[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR1)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetD_staph_LUR1)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)
models[[modeln]]$results

#  this are the candidates models with the highest R2, not a negative beta for the new, nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)
models[[modeln]]$resultspos

#  rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))
models[[modeln]]$resultspos

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j
models[[modeln]]$indexbestmodel

subset(models[[modeln]]$resultspos, rank==1)
subset(models[[modeln]]$resultspos)

#  this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]
models[[modeln]]$summarybestmodel

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetD_staph_LUR1)[models[[1]]$indexbestmodel])
models[[modeln]]$namesbestmodel

#  this is the r2 of that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2
models[[modeln]]$R2bestmodel

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetD_staph_LUR1$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetD_staph_LUR1[,models[[1]]$indexbestmodel]) 
models[[modeln]]$bestmodel

summary(models[[modeln]]$bestmodel)

#  The first model includes the predictor: nPigMultipFarmWghtDist.3000m.sum.Tr.1P9 - meaning the number of multiplier pig farms weighted to distance in a 3000m buffer

# 2 #  
# Add 2nd variable (the only difference of the above part is that now modeln=2 the model statement has 2 variables)
# and the call for the list of variable names in the model changed slightly

modeln<-2

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_1:nlastvar_LUR_1){
  if (is.numeric(VGOB1_subsetD_staph_LUR1[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetD_staph_LUR1$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetD_staph_LUR1[,models[[1]]$indexbestmodel]+ VGOB1_subsetD_staph_LUR1[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # Measurements_livestockpreds_LUR1[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR1)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetD_staph_LUR1)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  these are the candidate models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)
models[[modeln]]$resultspos

#  rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))
models[[modeln]]$resultspos

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j
models[[modeln]]$indexbestmodel

subset(models[[modeln]]$resultspos, rank==1)

# this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]
models[[modeln]]$summarybestmodel

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetD_staph_LUR1)[models[[1]]$indexbestmodel], names(VGOB1_subsetD_staph_LUR1)[models[[2]]$indexbestmodel] )
models[[modeln]]$namesbestmodel

# this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2
models[[modeln]]$R2bestmodel

# this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetD_staph_LUR1$staph_copiespm3.ln.diffmeth.mean~                               VGOB1_subsetD_staph_LUR1[,models[[1]]$indexbestmodel]+                           VGOB1_subsetD_staph_LUR1[,models[[2]]$indexbestmodel]) 

models[[modeln]]$bestmodel

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel


# The next part of the code (n=3-8) does not work
# This is because one of the coefficients included in the model with 6 variables is negative, the code does not allow for this. I can stop here.

# # 3 #  
# # add third variable (the only difference of the above part is that now modeln=3 the model statement has 3 variables)
# # and the call for the list of variable names in the model changed slightly
# 
# modeln<-3
# 
# models[[modeln]]<-list()
# 
# R2<-1
# addedvar<-1
# betaaddedvar<-1
# minbetas<-1
# j<-1
# 
# for (i in nfirstvar_LUR_1:nlastvar_LUR_1){
#   if (is.numeric(VGOB1_subsetD_staph_LUR1[,i])==TRUE){  
#     modeltry<-lm(VGOB1_subsetD_staph_LUR1$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetD_staph_LUR1[,models[[1]]$indexbestmodel]+VGOB1_subsetD_staph_LUR1[,models[[2]]$indexbestmodel]+ VGOB1_subsetD_staph_LUR1[,i]) 
#     R2<-rbind(R2,summary(modeltry)$adj.r.squared)
#     # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
#     betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
#     #  find out if there is a negative beta at All. The intercept does not count [-1]!
#     minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
#     # All[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR1)[i]
#     addedvar<-rbind(addedvar,names(VGOB1_subsetD_staph_LUR1)[i])
#     j<-rbind(j, i)
#     models[[modeln]][[i]]<-summary(modeltry)
#   }
# }
# 
# models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)
# 
# #  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
# models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)
# 
# #  rank the R2's of these models
# models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))
# 
# #  this is the index of the row with the highest R2 and  no negative betas in this subset
# models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j
# 
# subset(models[[modeln]]$resultspos, rank==1)
# 
# #  this is the model
# models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]
# 
# #  here are the names
# models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetD_staph_LUR1)[models[[1]]$indexbestmodel], names(VGOB1_subsetD_staph_LUR1)[models[[2]]$indexbestmodel], names(VGOB1_subsetD_staph_LUR1)[models[[3]]$indexbestmodel])
# 
# #  this is the r2 or that model
# models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2
# 
# #  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
# models[[modeln]]$bestmodel <- lm(VGOB1_subsetD_staph_LUR1$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetD_staph_LUR1[,models[[1]]$indexbestmodel]+ VGOB1_subsetD_staph_LUR1[,models[[2]]$indexbestmodel]+ VGOB1_subsetD_staph_LUR1[,models[[3]]$indexbestmodel]) 
# 
# models[[1]]$summarybestmodel
# models[[2]]$summarybestmodel
# models[[3]]$summarybestmodel
# models[[1]]$namesbestmodel
# models[[2]]$namesbestmodel
# models[[3]]$namesbestmodel
# models[[1]]$R2bestmodel
# models[[2]]$R2bestmodel
# models[[3]]$R2bestmodel
# 
# 
# # 4 #  
# #  add forth variable (the only difference of the above part is that now model n=4 the model statement more variables)
# #  and the call for the list of variable names in the model changed slightly
# modeln<-4
# 
# models[[modeln]]<-list()
# 
# R2<-1
# addedvar<-1
# betaaddedvar<-1
# minbetas<-1
# j<-1
# 
# 
# for (i in nfirstvar_LUR_1:nlastvar_LUR_1){
#   if (is.numeric(VGOB1_subsetD_staph_LUR1[,i])==TRUE){
#     modeltry<-lm(VGOB1_subsetD_staph_LUR1$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetD_staph_LUR1[,models[[1]]$indexbestmodel]+VGOB1_subsetD_staph_LUR1[,models[[2]]$indexbestmodel]+VGOB1_subsetD_staph_LUR1[,models[[3]]$indexbestmodel]+VGOB1_subsetD_staph_LUR1[,i]) 
#     R2<-rbind(R2,summary(modeltry)$adj.r.squared)
#     #  the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
#     betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])
#     #  find out if there is a negative beta at All. The intercept does not count [-1]!
#     minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
#     #  All[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR1)[i]
#     addedvar<-rbind(addedvar,names(VGOB1_subsetD_staph_LUR1)[i])
#     j<-rbind(j, i)
#     models[[modeln]][[i]]<-summary(modeltry)
#   }
# }
# 
# models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)
# 
# #  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
# models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)
# 
# # rank the R2's of these models
# models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))
# 
# #  this is the index of the row with the highest R2 and  no negative betas in this subset
# models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j
# 
# subset(models[[modeln]]$resultspos, rank==1)
# 
# #  this is the model
# models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]
# 
# #  here are the names
# models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetD_staph_LUR1)[models[[1]]$indexbestmodel], names(VGOB1_subsetD_staph_LUR1)[models[[2]]$indexbestmodel], names(VGOB1_subsetD_staph_LUR1)[models[[3]]$indexbestmodel], names(VGOB1_subsetD_staph_LUR1)[models[[4]]$indexbestmodel])
# 
# #  this is the r2 of that model
# models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2
# 
# #  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
# models[[modeln]]$bestmodel <- lm(VGOB1_subsetD_staph_LUR1$staph_copiespm3.ln.diffmeth.mean~ VGOB1_subsetD_staph_LUR1[,models[[1]]$indexbestmodel]+ VGOB1_subsetD_staph_LUR1[,models[[2]]$indexbestmodel]+VGOB1_subsetD_staph_LUR1[,models[[3]]$indexbestmodel]+ VGOB1_subsetD_staph_LUR1[,models[[4]]$indexbestmodel]) 
# 
# 
# models[[1]]$summarybestmodel
# models[[2]]$summarybestmodel
# models[[3]]$summarybestmodel
# models[[4]]$summarybestmodel
# models[[1]]$namesbestmodel
# models[[2]]$namesbestmodel
# models[[3]]$namesbestmodel
# models[[4]]$namesbestmodel
# models[[1]]$R2bestmodel
# models[[2]]$R2bestmodel
# models[[3]]$R2bestmodel
# models[[4]]$R2bestmodel
# 
# 
# # 5 #  
# # add fifth variable (the only difference of the above part is that now modeln=5 the model statement more variables)
# # and the call for the list of variable names in the model changed slightly
# modeln<-5
# 
# models[[modeln]]<-list()
# 
# R2<-1
# addedvar<-1
# betaaddedvar<-1
# minbetas<-1
# j<-1
# 
# for (i in nfirstvar_LUR_1:nlastvar_LUR_1){
#   if (is.numeric(VGOB1_subsetD_staph_LUR1[,i])==TRUE){
#     modeltry<-lm(VGOB1_subsetD_staph_LUR1$staph_copiespm3.ln.diffmeth.mean~ VGOB1_subsetD_staph_LUR1[,models[[1]]$indexbestmodel]+ VGOB1_subsetD_staph_LUR1[,models[[2]]$indexbestmodel]+ VGOB1_subsetD_staph_LUR1[,models[[3]]$indexbestmodel]+ VGOB1_subsetD_staph_LUR1[,models[[4]]$indexbestmodel]+ VGOB1_subsetD_staph_LUR1[,i]) 
#   
# R2<-rbind(R2,summary(modeltry)$adj.r.squared)
# # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
#     betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
#     #  find out if there is a negative beta at All. The intercept does not count [-1]!
#     minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
#     # All[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR1)[i]
#     addedvar<-rbind(addedvar,names(VGOB1_subsetD_staph_LUR1)[i])
#     j<-rbind(j, i)
#     models[[modeln]][[i]]<-summary(modeltry)
#   }
# }
# 
# models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)
# 
# #  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
# models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)
# 
# # rank the R2's of these models
# models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))
# 
# #  this is the index of the row with the highest R2 and  no negative betas in this subset
# models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j
# 
# subset(models[[modeln]]$resultspos, rank==1)
# 
# #  this is the model
# models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]
# 
# # here are the names
# models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetD_staph_LUR1)[models[[1]]$indexbestmodel], names(VGOB1_subsetD_staph_LUR1)[models[[2]]$indexbestmodel], names(VGOB1_subsetD_staph_LUR1)[models[[3]]$indexbestmodel], names(VGOB1_subsetD_staph_LUR1)[models[[4]]$indexbestmodel], names(VGOB1_subsetD_staph_LUR1)[models[[5]]$indexbestmodel])
# 
# #  this is the r2 or that model
# models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2
# 
# #  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
# models[[modeln]]$bestmodel <- lm(VGOB1_subsetD_staph_LUR1$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetD_staph_LUR1[,models[[1]]$indexbestmodel]+VGOB1_subsetD_staph_LUR1[,models[[2]]$indexbestmodel]+VGOB1_subsetD_staph_LUR1[,models[[3]]$indexbestmodel]+ VGOB1_subsetD_staph_LUR1[,models[[4]]$indexbestmodel]+ VGOB1_subsetD_staph_LUR1[,models[[5]]$indexbestmodel]) 
# models[[1]]$summarybestmodel
# models[[2]]$summarybestmodel
# models[[3]]$summarybestmodel
# models[[4]]$summarybestmodel
# models[[5]]$summarybestmodel
# models[[1]]$namesbestmodel
# models[[2]]$namesbestmodel
# models[[3]]$namesbestmodel
# models[[4]]$namesbestmodel
# models[[5]]$namesbestmodel
# models[[1]]$R2bestmodel
# models[[2]]$R2bestmodel
# models[[3]]$R2bestmodel
# models[[4]]$R2bestmodel
# models[[5]]$R2bestmodel
# 
# # 6 #  
# # add sixth variable (the only difference of the above part is that now model n=6 the model statement more variables)
# #  and the call for the list of variable names in the model changed slightly
# 
# modeln<-6
# 
# models[[modeln]]<-list()
# 
# R2<-1
# addedvar<-1
# betaaddedvar<-1
# minbetas<-1
# j<-1
# 
# for (i in nfirstvar_LUR_1 :nlastvar_LUR_1){
#   if (is.numeric(VGOB1_subsetD_staph_LUR1[,i])==TRUE){
#     modeltry<-lm(VGOB1_subsetD_staph_LUR1$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetD_staph_LUR1[,models[[1]]$indexbestmodel]+VGOB1_subsetD_staph_LUR1[,models[[2]]$indexbestmodel]+VGOB1_subsetD_staph_LUR1[,models[[3]]$indexbestmodel]+VGOB1_subsetD_staph_LUR1[,models[[4]]$indexbestmodel]+VGOB1_subsetD_staph_LUR1[,models[[5]]$indexbestmodel]+ VGOB1_subsetD_staph_LUR1[,i]) 
#     R2<-rbind(R2,summary(modeltry)$adj.r.squared)
#     # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
#     betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
#     #  find out if there is a negative beta at All. The intercept does not count [-1]!
#     minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
#     # All[,i] is the row that's being tried out now. the name of that row can be found in  names(All)[i]
#     addedvar<-rbind(addedvar,names(VGOB1_subsetD_staph_LUR1)[i])
#     j<-rbind(j, i)
#     models[[modeln]][[i]]<-summary(modeltry)
#   }
# }
# 
# models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)
# 
# #  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
# models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)
# 
# # rank the R2's of these models
# models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))
# 
# #  this is the index of the row with the highest R2 and  no negative betas in this subset
# models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j
# 
# subset(models[[modeln]]$resultspos, rank==1)
# 
# # this is the model
# models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]
# 
# # here are the names
# models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetD_staph_LUR1)[models[[1]]$indexbestmodel], names(VGOB1_subsetD_staph_LUR1)[models[[2]]$indexbestmodel] , names(VGOB1_subsetD_staph_LUR1)[models[[3]]$indexbestmodel], names(VGOB1_subsetD_staph_LUR1)[models[[4]]$indexbestmodel], names(VGOB1_subsetD_staph_LUR1)[models[[5]]$indexbestmodel], names(VGOB1_subsetD_staph_LUR1)[models[[6]]$indexbestmodel])
# 
# #  this is the r2 or that model
# models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2
# 
# #  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
# models[[modeln]]$bestmodel <- lm(VGOB1_subsetD_staph_LUR1$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetD_staph_LUR1[,models[[1]]$indexbestmodel]+VGOB1_subsetD_staph_LUR1[,models[[2]]$indexbestmodel]+VGOB1_subsetD_staph_LUR1[,models[[3]]$indexbestmodel]+ VGOB1_subsetD_staph_LUR1[,models[[4]]$indexbestmodel]+ VGOB1_subsetD_staph_LUR1[,models[[5]]$indexbestmodel]+ VGOB1_subsetD_staph_LUR1[,models[[6]]$indexbestmodel]) 
# 
# models[[1]]$summarybestmodel
# models[[2]]$summarybestmodel
# models[[3]]$summarybestmodel
# models[[4]]$summarybestmodel
# models[[5]]$summarybestmodel
# models[[6]]$summarybestmodel
# models[[1]]$namesbestmodel
# models[[2]]$namesbestmodel
# models[[3]]$namesbestmodel
# models[[4]]$namesbestmodel
# models[[5]]$namesbestmodel
# models[[6]]$namesbestmodel
# models[[1]]$R2bestmodel
# models[[2]]$R2bestmodel
# models[[3]]$R2bestmodel
# models[[4]]$R2bestmodel
# models[[5]]$R2bestmodel
# models[[6]]$R2bestmodel
# 
# 
# # 7 #  
# # add seventh variable (the only difference of the above part is that now model n=7 the model statement more variables)
# #  and the call for the list of variable names in the model changed slightly
# 
# modeln<-7
# 
# models[[modeln]]<-list()
# 
# R2<-1
# addedvar<-1
# betaaddedvar<-1
# minbetas<-1
# j<-1
# 
# for (i in nfirstvar_LUR_1 :nlastvar_LUR_1){
#   if (is.numeric(VGOB1_subsetD_staph_LUR1[,i])==TRUE){
#     modeltry<-lm(VGOB1_subsetD_staph_LUR1$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetD_staph_LUR1[,models[[1]]$indexbestmodel]+VGOB1_subsetD_staph_LUR1[,models[[2]]$indexbestmodel]+VGOB1_subsetD_staph_LUR1[,models[[3]]$indexbestmodel]+VGOB1_subsetD_staph_LUR1[,models[[4]]$indexbestmodel]+VGOB1_subsetD_staph_LUR1[,models[[5]]$indexbestmodel]+VGOB1_subsetD_staph_LUR1[,models[[6]]$indexbestmodel]+ VGOB1_subsetD_staph_LUR1[,i]) 
#     R2<-rbind(R2,summary(modeltry)$adj.r.squared)
#     # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
#     betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
#     #  find out if there is a negative beta at All. The intercept does not count [-1]!
#     minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
#     # Measurements_livestockpreds_LUR1[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR1)[i]
#     addedvar<-rbind(addedvar,names(VGOB1_subsetD_staph_LUR1)[i])
#     j<-rbind(j, i)
#     models[[modeln]][[i]]<-summary(modeltry)
#   }
# }
# 
# models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)
# 
# #  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
# models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)
# 
# # rank the R2's of these models
# models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))
# 
# #  this is the index of the row with the highest R2 and  no negative betas in this subset
# models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j
# 
# subset(models[[modeln]]$resultspos, rank==1)
# 
# # this is the model
# models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]
# 
# # here are the names
# models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetD_staph_LUR1)[models[[1]]$indexbestmodel], names(VGOB1_subsetD_staph_LUR1)[models[[2]]$indexbestmodel] , names(VGOB1_subsetD_staph_LUR1)[models[[3]]$indexbestmodel], names(VGOB1_subsetD_staph_LUR1)[models[[4]]$indexbestmodel], names(VGOB1_subsetD_staph_LUR1)[models[[5]]$indexbestmodel], names(VGOB1_subsetD_staph_LUR1)[models[[6]]$indexbestmodel], names(VGOB1_subsetD_staph_LUR1)[models[[7]]$indexbestmodel])
# 
# #  this is the r2 or that model
# models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2
# 
# #  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
# models[[modeln]]$bestmodel <- lm(VGOB1_subsetD_staph_LUR1$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetD_staph_LUR1[,models[[1]]$indexbestmodel]+VGOB1_subsetD_staph_LUR1[,models[[2]]$indexbestmodel]+VGOB1_subsetD_staph_LUR1[,models[[3]]$indexbestmodel]+ VGOB1_subsetD_staph_LUR1[,models[[4]]$indexbestmodel]+ VGOB1_subsetD_staph_LUR1[,models[[5]]$indexbestmodel]+ VGOB1_subsetD_staph_LUR1[,models[[6]]$indexbestmodel]+ VGOB1_subsetD_staph_LUR1[,models[[7]]$indexbestmodel]) 
# 
# models[[1]]$summarybestmodel
# models[[2]]$summarybestmodel
# models[[3]]$summarybestmodel
# models[[4]]$summarybestmodel
# models[[5]]$summarybestmodel
# models[[6]]$summarybestmodel
# models[[7]]$summarybestmodel
# models[[1]]$namesbestmodel
# models[[2]]$namesbestmodel
# models[[3]]$namesbestmodel
# models[[4]]$namesbestmodel
# models[[5]]$namesbestmodel
# models[[6]]$namesbestmodel
# models[[7]]$namesbestmodel
# models[[1]]$R2bestmodel
# models[[2]]$R2bestmodel
# models[[3]]$R2bestmodel
# models[[4]]$R2bestmodel
# models[[5]]$R2bestmodel
# models[[6]]$R2bestmodel
# models[[7]]$R2bestmodel
# 
# # 8 #  
# # add eighth variable (the only difference of the above part is that now modeln=7 the model statement more variables)
# # and the call for the list of variable names in the model changed slightly
# 
# modeln<-8
# 
# models[[modeln]]<-list()
# 
# R2<-1
# addedvar<-1
# betaaddedvar<-1
# minbetas<-1
# j<-1
# 
# for (i in nfirstvar_LUR_1 :nlastvar_LUR_1){
#   if (is.numeric(VGOB1_subsetD_staph_LUR1[,i])==TRUE){
#     modeltry<-lm(VGOB1_subsetD_staph_LUR1$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetD_staph_LUR1[,models[[1]]$indexbestmodel]+VGOB1_subsetD_staph_LUR1[,models[[2]]$indexbestmodel]+VGOB1_subsetD_staph_LUR1[,models[[3]]$indexbestmodel]+VGOB1_subsetD_staph_LUR1[,models[[4]]$indexbestmodel]+VGOB1_subsetD_staph_LUR1[,models[[5]]$indexbestmodel]+VGOB1_subsetD_staph_LUR1[,models[[6]]$indexbestmodel]+ VGOB1_subsetD_staph_LUR1[,models[[7]]$indexbestmodel]+ VGOB1_subsetD_staph_LUR1[,i]) 
#     R2<-rbind(R2,summary(modeltry)$adj.r.squared)
#     # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
#     betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
#     #  find out if there is a negative beta at All. The intercept does not count [-1]!
#     minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
#     # Measurements_livestockpreds_LUR1[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR1)[i]
#     addedvar<-rbind(addedvar,names(VGOB1_subsetD_staph_LUR1)[i])
#     j<-rbind(j, i)
#     models[[modeln]][[i]]<-summary(modeltry)
#   }
# }
# 
# models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)
# 
# #  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
# models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)
# 
# # rank the R2's of these models
# models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))
# 
# #  this is the index of the row with the highest R2 and  no negative betas in this subset
# models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j
# 
# subset(models[[modeln]]$resultspos, rank==1)
# 
# # this is the model
# models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]
# 
# # here are the names
# models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetD_staph_LUR1)[models[[1]]$indexbestmodel], names(VGOB1_subsetD_staph_LUR1)[models[[2]]$indexbestmodel] , names(VGOB1_subsetD_staph_LUR1)[models[[3]]$indexbestmodel], names(VGOB1_subsetD_staph_LUR1)[models[[4]]$indexbestmodel], names(VGOB1_subsetD_staph_LUR1)[models[[5]]$indexbestmodel], names(VGOB1_subsetD_staph_LUR1)[models[[6]]$indexbestmodel], names(VGOB1_subsetD_staph_LUR1)[models[[7]]$indexbestmodel], names(VGOB1_subsetD_staph_LUR1)[models[[8]]$indexbestmodel])
# 
# #  this is the r2 or that model
# models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2
# 
# #  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
# models[[modeln]]$bestmodel <- lm(VGOB1_subsetD_staph_LUR1$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetD_staph_LUR1[,models[[1]]$indexbestmodel]+VGOB1_subsetD_staph_LUR1[,models[[2]]$indexbestmodel]+VGOB1_subsetD_staph_LUR1[,models[[3]]$indexbestmodel]+ VGOB1_subsetD_staph_LUR1[,models[[4]]$indexbestmodel]+ VGOB1_subsetD_staph_LUR1[,models[[5]]$indexbestmodel]+ VGOB1_subsetD_staph_LUR1[,models[[6]]$indexbestmodel]+ VGOB1_subsetD_staph_LUR1[,models[[7]]$indexbestmodel]+ VGOB1_subsetD_staph_LUR1[,models[[8]]$indexbestmodel]) 
# 
# models[[1]]$summarybestmodel
# models[[2]]$summarybestmodel
# models[[3]]$summarybestmodel
# models[[4]]$summarybestmodel
# models[[5]]$summarybestmodel
# models[[6]]$summarybestmodel
# models[[7]]$summarybestmodel
# models[[8]]$summarybestmodel
# models[[1]]$namesbestmodel
# models[[2]]$namesbestmodel
# models[[3]]$namesbestmodel
# models[[4]]$namesbestmodel
# models[[5]]$namesbestmodel
# models[[6]]$namesbestmodel
# models[[7]]$namesbestmodel
# models[[8]]$namesbestmodel
# models[[1]]$R2bestmodel
# models[[2]]$R2bestmodel
# models[[3]]$R2bestmodel
# models[[4]]$R2bestmodel
# models[[5]]$R2bestmodel
# models[[6]]$R2bestmodel
# models[[7]]$R2bestmodel
# models[[8]]$R2bestmodel

#   CODE FOR PICKING OUT THE BEST MODEL #   
temp <- 0
besti <- 0
for (i in 1:10){ #  think this runs the loop 10 times - not fully sure thought - but not to do with the number of models I don't think - as when I change to 3, I still get the model with 4 variables as best model
  print(models[[i]]$R2bestmodel)
  #       print(models[[i]]$summarybestmodel$coefficients=-1,4])
  #       if((models[[i]]$R2bestmodel-temp > 0.0) && (all(models[[i]]$summarybestmodel$coefficients[-1,4]<0.1))){
  #         temp <- models[[i]]$R2bestmodel
  #         besti <- i
  #         }
  if((models[[i]]$R2bestmodel-temp > 0.0) && (all(models[[i]]$summarybestmodel$coefficients[-1,4]<0.1))){
    temp <- models[[i]]$R2bestmodel
    besti <- i
  }else{
    finalBestModel_staph_LUR1_subsetD <- models[[besti]]$bestmodel
    finalBestModelNames_staph_subsetD <- models[[besti]]$namesbestmodel
    Sites <- 1:dim(VGOB1_subsetD_staph_LUR1)[1] # full original model
    #  CVaR2<-escCV_staph_LUR1(Sites)[2] # Cross Validation
    maxCD<-max(cooks.distance(finalBestModel_staph_LUR1_subsetD))
    if(length(finalBestModelNames_staph_subsetD)<2){ # vif fn doesnot work when only 1 variable...       # 
      maxVIF<-"NA"
    }else{
      maxVIF<-max(vif(finalBestModel_staph_LUR1_subsetD))
    }
    print(paste("This is the best staph model for subset D: ",besti,
                "(AdjR2: ",format(models[[besti]]$R2bestmodel,digits=3), "; MaxCD: ",format(maxCD,digits=3),"; MaxVIF: ",
                format(maxVIF,digits=3),")", sep=''))
    print(finalBestModelNames_staph_subsetD)
    break
  }
}

#  Overview of the final best model using the algorithm selection process (taking into account VIF, R^2, and p-values)
finalBestModel_staph_LUR1_subsetD
finalBestModelNames_staph_subsetD
models[[besti]]$summarybestmodel
models[[besti]]$R2bestmodel


#### E ####
# LUR model building process for subset E
#  This is the dataframe with the relevant predictor vars for LUR1 models for subset E (55 sites)
VGOB1_subsetE_staph_LUR1 # n.b. this dataframe only includes microbial marker concentrations for staph unlike the dataframe Measurements_livestockpreds_LUR1 as previously used for the model building. 

#  Now set the values of some variables that will be needed
nfirstvar_LUR_1 <- 3  
nlastvar_LUR_1 <- 10

# Function building to run the models 
# 1 #  

models<-list()
modeln<-1
models[[modeln]]<-list()

R2<-1
betaaddedvar<-1
addedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_1:nlastvar_LUR_1){
  if (is.numeric(VGOB1_subsetE_staph_LUR1[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetE_staph_LUR1$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetE_staph_LUR1[,i])                            
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    #  Measurements_livestockpreds_LUR1[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR1)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetE_staph_LUR1)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)
models[[modeln]]$results

#  this are the candidates models with the highest R2, not a negative beta for the new, nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)
models[[modeln]]$resultspos

#  rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))
models[[modeln]]$resultspos

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j
models[[modeln]]$indexbestmodel

subset(models[[modeln]]$resultspos, rank==1)
subset(models[[modeln]]$resultspos)

#  this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]
models[[modeln]]$summarybestmodel

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetE_staph_LUR1)[models[[1]]$indexbestmodel])
models[[modeln]]$namesbestmodel

#  this is the r2 of that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2
models[[modeln]]$R2bestmodel

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetE_staph_LUR1$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetE_staph_LUR1[,models[[1]]$indexbestmodel]) 
models[[modeln]]$bestmodel

summary(models[[modeln]]$bestmodel)

#  The first model includes the predictor: nPigMultipFarmWghtDist.3000m.sum.Tr.1P9 - meaning the number of multiplier pig farms weighted to distance in a 3000m buffer

# 2 #  
# Add 2nd variable (the only difference of the above part is that now modeln=2 the model statement has 2 variables)
# and the call for the list of variable names in the model changed slightly

modeln<-2

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_1:nlastvar_LUR_1){
  if (is.numeric(VGOB1_subsetE_staph_LUR1[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetE_staph_LUR1$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetE_staph_LUR1[,models[[1]]$indexbestmodel]+ VGOB1_subsetE_staph_LUR1[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # Measurements_livestockpreds_LUR1[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR1)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetE_staph_LUR1)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  these are the candidate models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)
models[[modeln]]$resultspos

#  rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))
models[[modeln]]$resultspos

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j
models[[modeln]]$indexbestmodel

subset(models[[modeln]]$resultspos, rank==1)

# this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]
models[[modeln]]$summarybestmodel

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetE_staph_LUR1)[models[[1]]$indexbestmodel], names(VGOB1_subsetE_staph_LUR1)[models[[2]]$indexbestmodel] )
models[[modeln]]$namesbestmodel

# this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2
models[[modeln]]$R2bestmodel

# this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetE_staph_LUR1$staph_copiespm3.ln.diffmeth.mean~                               VGOB1_subsetE_staph_LUR1[,models[[1]]$indexbestmodel]+                           VGOB1_subsetE_staph_LUR1[,models[[2]]$indexbestmodel]) 

models[[modeln]]$bestmodel

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel


# The next part of the code (n=3-8) does not work
# This is because one of the coefficients included in the model with 6 variables is negative, the code does not allow for this. I can stop here.

# # 3 #  
# # add third variable (the only difference of the above part is that now modeln=3 the model statement has 3 variables)
# # and the call for the list of variable names in the model changed slightly
# 
# modeln<-3
# 
# models[[modeln]]<-list()
# 
# R2<-1
# addedvar<-1
# betaaddedvar<-1
# minbetas<-1
# j<-1
# 
# for (i in nfirstvar_LUR_1:nlastvar_LUR_1){
#   if (is.numeric(VGOB1_subsetE_staph_LUR1[,i])==TRUE){  
#     modeltry<-lm(VGOB1_subsetE_staph_LUR1$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetE_staph_LUR1[,models[[1]]$indexbestmodel]+VGOB1_subsetE_staph_LUR1[,models[[2]]$indexbestmodel]+ VGOB1_subsetE_staph_LUR1[,i]) 
#     R2<-rbind(R2,summary(modeltry)$adj.r.squared)
#     # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
#     betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
#     #  find out if there is a negative beta at All. The intercept does not count [-1]!
#     minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
#     # All[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR1)[i]
#     addedvar<-rbind(addedvar,names(VGOB1_subsetE_staph_LUR1)[i])
#     j<-rbind(j, i)
#     models[[modeln]][[i]]<-summary(modeltry)
#   }
# }
# 
# models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)
# 
# #  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
# models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)
# 
# #  rank the R2's of these models
# models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))
# 
# #  this is the index of the row with the highest R2 and  no negative betas in this subset
# models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j
# 
# subset(models[[modeln]]$resultspos, rank==1)
# 
# #  this is the model
# models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]
# 
# #  here are the names
# models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetE_staph_LUR1)[models[[1]]$indexbestmodel], names(VGOB1_subsetE_staph_LUR1)[models[[2]]$indexbestmodel], names(VGOB1_subsetE_staph_LUR1)[models[[3]]$indexbestmodel])
# 
# #  this is the r2 or that model
# models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2
# 
# #  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
# models[[modeln]]$bestmodel <- lm(VGOB1_subsetE_staph_LUR1$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetE_staph_LUR1[,models[[1]]$indexbestmodel]+ VGOB1_subsetE_staph_LUR1[,models[[2]]$indexbestmodel]+ VGOB1_subsetE_staph_LUR1[,models[[3]]$indexbestmodel]) 
# 
# models[[1]]$summarybestmodel
# models[[2]]$summarybestmodel
# models[[3]]$summarybestmodel
# models[[1]]$namesbestmodel
# models[[2]]$namesbestmodel
# models[[3]]$namesbestmodel
# models[[1]]$R2bestmodel
# models[[2]]$R2bestmodel
# models[[3]]$R2bestmodel
# 
# 
# # 4 #  
# #  add forth variable (the only difference of the above part is that now model n=4 the model statement more variables)
# #  and the call for the list of variable names in the model changed slightly
# modeln<-4
# 
# models[[modeln]]<-list()
# 
# R2<-1
# addedvar<-1
# betaaddedvar<-1
# minbetas<-1
# j<-1
# 
# 
# for (i in nfirstvar_LUR_1:nlastvar_LUR_1){
#   if (is.numeric(VGOB1_subsetE_staph_LUR1[,i])==TRUE){
#     modeltry<-lm(VGOB1_subsetE_staph_LUR1$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetE_staph_LUR1[,models[[1]]$indexbestmodel]+VGOB1_subsetE_staph_LUR1[,models[[2]]$indexbestmodel]+VGOB1_subsetE_staph_LUR1[,models[[3]]$indexbestmodel]+VGOB1_subsetE_staph_LUR1[,i]) 
#     R2<-rbind(R2,summary(modeltry)$adj.r.squared)
#     #  the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
#     betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])
#     #  find out if there is a negative beta at All. The intercept does not count [-1]!
#     minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
#     #  All[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR1)[i]
#     addedvar<-rbind(addedvar,names(VGOB1_subsetE_staph_LUR1)[i])
#     j<-rbind(j, i)
#     models[[modeln]][[i]]<-summary(modeltry)
#   }
# }
# 
# models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)
# 
# #  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
# models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)
# 
# # rank the R2's of these models
# models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))
# 
# #  this is the index of the row with the highest R2 and  no negative betas in this subset
# models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j
# 
# subset(models[[modeln]]$resultspos, rank==1)
# 
# #  this is the model
# models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]
# 
# #  here are the names
# models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetE_staph_LUR1)[models[[1]]$indexbestmodel], names(VGOB1_subsetE_staph_LUR1)[models[[2]]$indexbestmodel], names(VGOB1_subsetE_staph_LUR1)[models[[3]]$indexbestmodel], names(VGOB1_subsetE_staph_LUR1)[models[[4]]$indexbestmodel])
# 
# #  this is the r2 of that model
# models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2
# 
# #  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
# models[[modeln]]$bestmodel <- lm(VGOB1_subsetE_staph_LUR1$staph_copiespm3.ln.diffmeth.mean~ VGOB1_subsetE_staph_LUR1[,models[[1]]$indexbestmodel]+ VGOB1_subsetE_staph_LUR1[,models[[2]]$indexbestmodel]+VGOB1_subsetE_staph_LUR1[,models[[3]]$indexbestmodel]+ VGOB1_subsetE_staph_LUR1[,models[[4]]$indexbestmodel]) 
# 
# 
# models[[1]]$summarybestmodel
# models[[2]]$summarybestmodel
# models[[3]]$summarybestmodel
# models[[4]]$summarybestmodel
# models[[1]]$namesbestmodel
# models[[2]]$namesbestmodel
# models[[3]]$namesbestmodel
# models[[4]]$namesbestmodel
# models[[1]]$R2bestmodel
# models[[2]]$R2bestmodel
# models[[3]]$R2bestmodel
# models[[4]]$R2bestmodel
# 
# 
# # 5 #  
# # add fifth variable (the only difference of the above part is that now modeln=5 the model statement more variables)
# # and the call for the list of variable names in the model changed slightly
# modeln<-5
# 
# models[[modeln]]<-list()
# 
# R2<-1
# addedvar<-1
# betaaddedvar<-1
# minbetas<-1
# j<-1
# 
# for (i in nfirstvar_LUR_1:nlastvar_LUR_1){
#   if (is.numeric(VGOB1_subsetE_staph_LUR1[,i])==TRUE){
#     modeltry<-lm(VGOB1_subsetE_staph_LUR1$staph_copiespm3.ln.diffmeth.mean~ VGOB1_subsetE_staph_LUR1[,models[[1]]$indexbestmodel]+ VGOB1_subsetE_staph_LUR1[,models[[2]]$indexbestmodel]+ VGOB1_subsetE_staph_LUR1[,models[[3]]$indexbestmodel]+ VGOB1_subsetE_staph_LUR1[,models[[4]]$indexbestmodel]+ VGOB1_subsetE_staph_LUR1[,i]) 
#   
# R2<-rbind(R2,summary(modeltry)$adj.r.squared)
# # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
#     betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
#     #  find out if there is a negative beta at All. The intercept does not count [-1]!
#     minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
#     # All[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR1)[i]
#     addedvar<-rbind(addedvar,names(VGOB1_subsetE_staph_LUR1)[i])
#     j<-rbind(j, i)
#     models[[modeln]][[i]]<-summary(modeltry)
#   }
# }
# 
# models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)
# 
# #  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
# models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)
# 
# # rank the R2's of these models
# models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))
# 
# #  this is the index of the row with the highest R2 and  no negative betas in this subset
# models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j
# 
# subset(models[[modeln]]$resultspos, rank==1)
# 
# #  this is the model
# models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]
# 
# # here are the names
# models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetE_staph_LUR1)[models[[1]]$indexbestmodel], names(VGOB1_subsetE_staph_LUR1)[models[[2]]$indexbestmodel], names(VGOB1_subsetE_staph_LUR1)[models[[3]]$indexbestmodel], names(VGOB1_subsetE_staph_LUR1)[models[[4]]$indexbestmodel], names(VGOB1_subsetE_staph_LUR1)[models[[5]]$indexbestmodel])
# 
# #  this is the r2 or that model
# models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2
# 
# #  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
# models[[modeln]]$bestmodel <- lm(VGOB1_subsetE_staph_LUR1$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetE_staph_LUR1[,models[[1]]$indexbestmodel]+VGOB1_subsetE_staph_LUR1[,models[[2]]$indexbestmodel]+VGOB1_subsetE_staph_LUR1[,models[[3]]$indexbestmodel]+ VGOB1_subsetE_staph_LUR1[,models[[4]]$indexbestmodel]+ VGOB1_subsetE_staph_LUR1[,models[[5]]$indexbestmodel]) 
# models[[1]]$summarybestmodel
# models[[2]]$summarybestmodel
# models[[3]]$summarybestmodel
# models[[4]]$summarybestmodel
# models[[5]]$summarybestmodel
# models[[1]]$namesbestmodel
# models[[2]]$namesbestmodel
# models[[3]]$namesbestmodel
# models[[4]]$namesbestmodel
# models[[5]]$namesbestmodel
# models[[1]]$R2bestmodel
# models[[2]]$R2bestmodel
# models[[3]]$R2bestmodel
# models[[4]]$R2bestmodel
# models[[5]]$R2bestmodel
# 
# # 6 #  
# # add sixth variable (the only difference of the above part is that now model n=6 the model statement more variables)
# #  and the call for the list of variable names in the model changed slightly
# 
# modeln<-6
# 
# models[[modeln]]<-list()
# 
# R2<-1
# addedvar<-1
# betaaddedvar<-1
# minbetas<-1
# j<-1
# 
# for (i in nfirstvar_LUR_1 :nlastvar_LUR_1){
#   if (is.numeric(VGOB1_subsetE_staph_LUR1[,i])==TRUE){
#     modeltry<-lm(VGOB1_subsetE_staph_LUR1$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetE_staph_LUR1[,models[[1]]$indexbestmodel]+VGOB1_subsetE_staph_LUR1[,models[[2]]$indexbestmodel]+VGOB1_subsetE_staph_LUR1[,models[[3]]$indexbestmodel]+VGOB1_subsetE_staph_LUR1[,models[[4]]$indexbestmodel]+VGOB1_subsetE_staph_LUR1[,models[[5]]$indexbestmodel]+ VGOB1_subsetE_staph_LUR1[,i]) 
#     R2<-rbind(R2,summary(modeltry)$adj.r.squared)
#     # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
#     betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
#     #  find out if there is a negative beta at All. The intercept does not count [-1]!
#     minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
#     # All[,i] is the row that's being tried out now. the name of that row can be found in  names(All)[i]
#     addedvar<-rbind(addedvar,names(VGOB1_subsetE_staph_LUR1)[i])
#     j<-rbind(j, i)
#     models[[modeln]][[i]]<-summary(modeltry)
#   }
# }
# 
# models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)
# 
# #  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
# models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)
# 
# # rank the R2's of these models
# models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))
# 
# #  this is the index of the row with the highest R2 and  no negative betas in this subset
# models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j
# 
# subset(models[[modeln]]$resultspos, rank==1)
# 
# # this is the model
# models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]
# 
# # here are the names
# models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetE_staph_LUR1)[models[[1]]$indexbestmodel], names(VGOB1_subsetE_staph_LUR1)[models[[2]]$indexbestmodel] , names(VGOB1_subsetE_staph_LUR1)[models[[3]]$indexbestmodel], names(VGOB1_subsetE_staph_LUR1)[models[[4]]$indexbestmodel], names(VGOB1_subsetE_staph_LUR1)[models[[5]]$indexbestmodel], names(VGOB1_subsetE_staph_LUR1)[models[[6]]$indexbestmodel])
# 
# #  this is the r2 or that model
# models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2
# 
# #  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
# models[[modeln]]$bestmodel <- lm(VGOB1_subsetE_staph_LUR1$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetE_staph_LUR1[,models[[1]]$indexbestmodel]+VGOB1_subsetE_staph_LUR1[,models[[2]]$indexbestmodel]+VGOB1_subsetE_staph_LUR1[,models[[3]]$indexbestmodel]+ VGOB1_subsetE_staph_LUR1[,models[[4]]$indexbestmodel]+ VGOB1_subsetE_staph_LUR1[,models[[5]]$indexbestmodel]+ VGOB1_subsetE_staph_LUR1[,models[[6]]$indexbestmodel]) 
# 
# models[[1]]$summarybestmodel
# models[[2]]$summarybestmodel
# models[[3]]$summarybestmodel
# models[[4]]$summarybestmodel
# models[[5]]$summarybestmodel
# models[[6]]$summarybestmodel
# models[[1]]$namesbestmodel
# models[[2]]$namesbestmodel
# models[[3]]$namesbestmodel
# models[[4]]$namesbestmodel
# models[[5]]$namesbestmodel
# models[[6]]$namesbestmodel
# models[[1]]$R2bestmodel
# models[[2]]$R2bestmodel
# models[[3]]$R2bestmodel
# models[[4]]$R2bestmodel
# models[[5]]$R2bestmodel
# models[[6]]$R2bestmodel
# 
# 
# # 7 #  
# # add seventh variable (the only difference of the above part is that now model n=7 the model statement more variables)
# #  and the call for the list of variable names in the model changed slightly
# 
# modeln<-7
# 
# models[[modeln]]<-list()
# 
# R2<-1
# addedvar<-1
# betaaddedvar<-1
# minbetas<-1
# j<-1
# 
# for (i in nfirstvar_LUR_1 :nlastvar_LUR_1){
#   if (is.numeric(VGOB1_subsetE_staph_LUR1[,i])==TRUE){
#     modeltry<-lm(VGOB1_subsetE_staph_LUR1$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetE_staph_LUR1[,models[[1]]$indexbestmodel]+VGOB1_subsetE_staph_LUR1[,models[[2]]$indexbestmodel]+VGOB1_subsetE_staph_LUR1[,models[[3]]$indexbestmodel]+VGOB1_subsetE_staph_LUR1[,models[[4]]$indexbestmodel]+VGOB1_subsetE_staph_LUR1[,models[[5]]$indexbestmodel]+VGOB1_subsetE_staph_LUR1[,models[[6]]$indexbestmodel]+ VGOB1_subsetE_staph_LUR1[,i]) 
#     R2<-rbind(R2,summary(modeltry)$adj.r.squared)
#     # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
#     betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
#     #  find out if there is a negative beta at All. The intercept does not count [-1]!
#     minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
#     # Measurements_livestockpreds_LUR1[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR1)[i]
#     addedvar<-rbind(addedvar,names(VGOB1_subsetE_staph_LUR1)[i])
#     j<-rbind(j, i)
#     models[[modeln]][[i]]<-summary(modeltry)
#   }
# }
# 
# models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)
# 
# #  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
# models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)
# 
# # rank the R2's of these models
# models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))
# 
# #  this is the index of the row with the highest R2 and  no negative betas in this subset
# models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j
# 
# subset(models[[modeln]]$resultspos, rank==1)
# 
# # this is the model
# models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]
# 
# # here are the names
# models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetE_staph_LUR1)[models[[1]]$indexbestmodel], names(VGOB1_subsetE_staph_LUR1)[models[[2]]$indexbestmodel] , names(VGOB1_subsetE_staph_LUR1)[models[[3]]$indexbestmodel], names(VGOB1_subsetE_staph_LUR1)[models[[4]]$indexbestmodel], names(VGOB1_subsetE_staph_LUR1)[models[[5]]$indexbestmodel], names(VGOB1_subsetE_staph_LUR1)[models[[6]]$indexbestmodel], names(VGOB1_subsetE_staph_LUR1)[models[[7]]$indexbestmodel])
# 
# #  this is the r2 or that model
# models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2
# 
# #  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
# models[[modeln]]$bestmodel <- lm(VGOB1_subsetE_staph_LUR1$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetE_staph_LUR1[,models[[1]]$indexbestmodel]+VGOB1_subsetE_staph_LUR1[,models[[2]]$indexbestmodel]+VGOB1_subsetE_staph_LUR1[,models[[3]]$indexbestmodel]+ VGOB1_subsetE_staph_LUR1[,models[[4]]$indexbestmodel]+ VGOB1_subsetE_staph_LUR1[,models[[5]]$indexbestmodel]+ VGOB1_subsetE_staph_LUR1[,models[[6]]$indexbestmodel]+ VGOB1_subsetE_staph_LUR1[,models[[7]]$indexbestmodel]) 
# 
# models[[1]]$summarybestmodel
# models[[2]]$summarybestmodel
# models[[3]]$summarybestmodel
# models[[4]]$summarybestmodel
# models[[5]]$summarybestmodel
# models[[6]]$summarybestmodel
# models[[7]]$summarybestmodel
# models[[1]]$namesbestmodel
# models[[2]]$namesbestmodel
# models[[3]]$namesbestmodel
# models[[4]]$namesbestmodel
# models[[5]]$namesbestmodel
# models[[6]]$namesbestmodel
# models[[7]]$namesbestmodel
# models[[1]]$R2bestmodel
# models[[2]]$R2bestmodel
# models[[3]]$R2bestmodel
# models[[4]]$R2bestmodel
# models[[5]]$R2bestmodel
# models[[6]]$R2bestmodel
# models[[7]]$R2bestmodel
# 
# # 8 #  
# # add eighth variable (the only difference of the above part is that now modeln=7 the model statement more variables)
# # and the call for the list of variable names in the model changed slightly
# 
# modeln<-8
# 
# models[[modeln]]<-list()
# 
# R2<-1
# addedvar<-1
# betaaddedvar<-1
# minbetas<-1
# j<-1
# 
# for (i in nfirstvar_LUR_1 :nlastvar_LUR_1){
#   if (is.numeric(VGOB1_subsetE_staph_LUR1[,i])==TRUE){
#     modeltry<-lm(VGOB1_subsetE_staph_LUR1$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetE_staph_LUR1[,models[[1]]$indexbestmodel]+VGOB1_subsetE_staph_LUR1[,models[[2]]$indexbestmodel]+VGOB1_subsetE_staph_LUR1[,models[[3]]$indexbestmodel]+VGOB1_subsetE_staph_LUR1[,models[[4]]$indexbestmodel]+VGOB1_subsetE_staph_LUR1[,models[[5]]$indexbestmodel]+VGOB1_subsetE_staph_LUR1[,models[[6]]$indexbestmodel]+ VGOB1_subsetE_staph_LUR1[,models[[7]]$indexbestmodel]+ VGOB1_subsetE_staph_LUR1[,i]) 
#     R2<-rbind(R2,summary(modeltry)$adj.r.squared)
#     # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
#     betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
#     #  find out if there is a negative beta at All. The intercept does not count [-1]!
#     minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
#     # Measurements_livestockpreds_LUR1[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR1)[i]
#     addedvar<-rbind(addedvar,names(VGOB1_subsetE_staph_LUR1)[i])
#     j<-rbind(j, i)
#     models[[modeln]][[i]]<-summary(modeltry)
#   }
# }
# 
# models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)
# 
# #  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
# models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)
# 
# # rank the R2's of these models
# models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))
# 
# #  this is the index of the row with the highest R2 and  no negative betas in this subset
# models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j
# 
# subset(models[[modeln]]$resultspos, rank==1)
# 
# # this is the model
# models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]
# 
# # here are the names
# models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetE_staph_LUR1)[models[[1]]$indexbestmodel], names(VGOB1_subsetE_staph_LUR1)[models[[2]]$indexbestmodel] , names(VGOB1_subsetE_staph_LUR1)[models[[3]]$indexbestmodel], names(VGOB1_subsetE_staph_LUR1)[models[[4]]$indexbestmodel], names(VGOB1_subsetE_staph_LUR1)[models[[5]]$indexbestmodel], names(VGOB1_subsetE_staph_LUR1)[models[[6]]$indexbestmodel], names(VGOB1_subsetE_staph_LUR1)[models[[7]]$indexbestmodel], names(VGOB1_subsetE_staph_LUR1)[models[[8]]$indexbestmodel])
# 
# #  this is the r2 or that model
# models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2
# 
# #  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
# models[[modeln]]$bestmodel <- lm(VGOB1_subsetE_staph_LUR1$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetE_staph_LUR1[,models[[1]]$indexbestmodel]+VGOB1_subsetE_staph_LUR1[,models[[2]]$indexbestmodel]+VGOB1_subsetE_staph_LUR1[,models[[3]]$indexbestmodel]+ VGOB1_subsetE_staph_LUR1[,models[[4]]$indexbestmodel]+ VGOB1_subsetE_staph_LUR1[,models[[5]]$indexbestmodel]+ VGOB1_subsetE_staph_LUR1[,models[[6]]$indexbestmodel]+ VGOB1_subsetE_staph_LUR1[,models[[7]]$indexbestmodel]+ VGOB1_subsetE_staph_LUR1[,models[[8]]$indexbestmodel]) 
# 
# models[[1]]$summarybestmodel
# models[[2]]$summarybestmodel
# models[[3]]$summarybestmodel
# models[[4]]$summarybestmodel
# models[[5]]$summarybestmodel
# models[[6]]$summarybestmodel
# models[[7]]$summarybestmodel
# models[[8]]$summarybestmodel
# models[[1]]$namesbestmodel
# models[[2]]$namesbestmodel
# models[[3]]$namesbestmodel
# models[[4]]$namesbestmodel
# models[[5]]$namesbestmodel
# models[[6]]$namesbestmodel
# models[[7]]$namesbestmodel
# models[[8]]$namesbestmodel
# models[[1]]$R2bestmodel
# models[[2]]$R2bestmodel
# models[[3]]$R2bestmodel
# models[[4]]$R2bestmodel
# models[[5]]$R2bestmodel
# models[[6]]$R2bestmodel
# models[[7]]$R2bestmodel
# models[[8]]$R2bestmodel


#   CODE FOR PICKING OUT THE BEST MODEL #   
temp <- 0
besti <- 0
for (i in 1:10){ #  think this runs the loop 10 times - not fully sure thought - but not to do with the number of models I don't think - as when I change to 3, I still get the model with 4 variables as best model
  print(models[[i]]$R2bestmodel)
  #       print(models[[i]]$summarybestmodel$coefficients=-1,4])
  #       if((models[[i]]$R2bestmodel-temp > 0.0) && (all(models[[i]]$summarybestmodel$coefficients[-1,4]<0.1))){
  #         temp <- models[[i]]$R2bestmodel
  #         besti <- i
  #         }
  if((models[[i]]$R2bestmodel-temp > 0.0) && (all(models[[i]]$summarybestmodel$coefficients[-1,4]<0.1))){
    temp <- models[[i]]$R2bestmodel
    besti <- i
  }else{
    finalBestModel_staph_LUR1_subsetE <- models[[besti]]$bestmodel
    finalBestModelNames_staph_subsetE <- models[[besti]]$namesbestmodel
    Sites <- 1:dim(VGOB1_subsetE_staph_LUR1)[1] # full original model
    #  CVaR2<-escCV_staph_LUR1(Sites)[2] # Cross Validation
    maxCD<-max(cooks.distance(finalBestModel_staph_LUR1_subsetE))
    if(length(finalBestModelNames_staph_subsetE)<2){ # vif fn doesnot work when only 1 variable...       # 
      maxVIF<-"NA"
    }else{
      maxVIF<-max(vif(finalBestModel_staph_LUR1_subsetE))
    }
    print(paste("This is the best staph model for subset E: ",besti,
                "(AdjR2: ",format(models[[besti]]$R2bestmodel,digits=3), "; MaxCD: ",format(maxCD,digits=3),"; MaxVIF: ",
                format(maxVIF,digits=3),")", sep=''))
    print(finalBestModelNames_staph_subsetE)
    break
  }
}

#  Overview of the final best model using the algorithm selection process (taking into account VIF, R^2, and p-values)
finalBestModel_staph_LUR1_subsetE
finalBestModelNames_staph_subsetE
models[[besti]]$summarybestmodel
models[[besti]]$R2bestmodel

#### F ####
# LUR model building process for subset F
#  This is the dataframe with the relevant predictor vars for LUR1 models for subset F (55 sites)
VGOB1_subsetF_staph_LUR1 # n.b. this dataframe only includes microbial marker concentrations for staph unlike the dataframe Measurements_livestockpreds_LUR1 as previously used for the model building. 

#  Now set the values of some variables that will be needed
nfirstvar_LUR_1 <- 3  
nlastvar_LUR_1 <- 10

# Function building to run the models 
# 1 #  

models<-list()
modeln<-1
models[[modeln]]<-list()

R2<-1
betaaddedvar<-1
addedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_1:nlastvar_LUR_1){
  if (is.numeric(VGOB1_subsetF_staph_LUR1[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetF_staph_LUR1$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetF_staph_LUR1[,i])                            
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    #  Measurements_livestockpreds_LUR1[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR1)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetF_staph_LUR1)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)
models[[modeln]]$results

#  this are the candidates models with the highest R2, not a negative beta for the new, nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)
models[[modeln]]$resultspos

#  rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))
models[[modeln]]$resultspos

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j
models[[modeln]]$indexbestmodel

subset(models[[modeln]]$resultspos, rank==1)
subset(models[[modeln]]$resultspos)

#  this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]
models[[modeln]]$summarybestmodel

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetF_staph_LUR1)[models[[1]]$indexbestmodel])
models[[modeln]]$namesbestmodel

#  this is the r2 of that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2
models[[modeln]]$R2bestmodel

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetF_staph_LUR1$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetF_staph_LUR1[,models[[1]]$indexbestmodel]) 
models[[modeln]]$bestmodel

summary(models[[modeln]]$bestmodel)

#  The first model includes the predictor: nPigMultipFarmWghtDist.3000m.sum.Tr.1P9 - meaning the number of multiplier pig farms weighted to distance in a 3000m buffer

# 2 #  
# Add 2nd variable (the only difference of the above part is that now modeln=2 the model statement has 2 variables)
# and the call for the list of variable names in the model changed slightly

modeln<-2

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_1:nlastvar_LUR_1){
  if (is.numeric(VGOB1_subsetF_staph_LUR1[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetF_staph_LUR1$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetF_staph_LUR1[,models[[1]]$indexbestmodel]+ VGOB1_subsetF_staph_LUR1[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # Measurements_livestockpreds_LUR1[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR1)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetF_staph_LUR1)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  these are the candidate models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)
models[[modeln]]$resultspos

#  rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))
models[[modeln]]$resultspos

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j
models[[modeln]]$indexbestmodel

subset(models[[modeln]]$resultspos, rank==1)

# this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]
models[[modeln]]$summarybestmodel

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetF_staph_LUR1)[models[[1]]$indexbestmodel], names(VGOB1_subsetF_staph_LUR1)[models[[2]]$indexbestmodel] )
models[[modeln]]$namesbestmodel

# this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2
models[[modeln]]$R2bestmodel

# this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetF_staph_LUR1$staph_copiespm3.ln.diffmeth.mean~                               VGOB1_subsetF_staph_LUR1[,models[[1]]$indexbestmodel]+                           VGOB1_subsetF_staph_LUR1[,models[[2]]$indexbestmodel]) 

models[[modeln]]$bestmodel

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel


# 3 #  
# add third variable (the only difference of the above part is that now modeln=3 the model statement has 3 variables)
# and the call for the list of variable names in the model changed slightly

modeln<-3

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_1:nlastvar_LUR_1){
  if (is.numeric(VGOB1_subsetF_staph_LUR1[,i])==TRUE){  
    modeltry<-lm(VGOB1_subsetF_staph_LUR1$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetF_staph_LUR1[,models[[1]]$indexbestmodel]+VGOB1_subsetF_staph_LUR1[,models[[2]]$indexbestmodel]+ VGOB1_subsetF_staph_LUR1[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # All[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR1)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetF_staph_LUR1)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

#  rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

#  this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

#  here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetF_staph_LUR1)[models[[1]]$indexbestmodel], names(VGOB1_subsetF_staph_LUR1)[models[[2]]$indexbestmodel], names(VGOB1_subsetF_staph_LUR1)[models[[3]]$indexbestmodel])

#  this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetF_staph_LUR1$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetF_staph_LUR1[,models[[1]]$indexbestmodel]+ VGOB1_subsetF_staph_LUR1[,models[[2]]$indexbestmodel]+ VGOB1_subsetF_staph_LUR1[,models[[3]]$indexbestmodel]) 

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel


# 4 #  
#  add forth variable (the only difference of the above part is that now model n=4 the model statement more variables)
#  and the call for the list of variable names in the model changed slightly
modeln<-4

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1


for (i in nfirstvar_LUR_1:nlastvar_LUR_1){
  if (is.numeric(VGOB1_subsetF_staph_LUR1[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetF_staph_LUR1$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetF_staph_LUR1[,models[[1]]$indexbestmodel]+VGOB1_subsetF_staph_LUR1[,models[[2]]$indexbestmodel]+VGOB1_subsetF_staph_LUR1[,models[[3]]$indexbestmodel]+VGOB1_subsetF_staph_LUR1[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    #  the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    #  All[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR1)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetF_staph_LUR1)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

#  this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

#  here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetF_staph_LUR1)[models[[1]]$indexbestmodel], names(VGOB1_subsetF_staph_LUR1)[models[[2]]$indexbestmodel], names(VGOB1_subsetF_staph_LUR1)[models[[3]]$indexbestmodel], names(VGOB1_subsetF_staph_LUR1)[models[[4]]$indexbestmodel])

#  this is the r2 of that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetF_staph_LUR1$staph_copiespm3.ln.diffmeth.mean~ VGOB1_subsetF_staph_LUR1[,models[[1]]$indexbestmodel]+ VGOB1_subsetF_staph_LUR1[,models[[2]]$indexbestmodel]+VGOB1_subsetF_staph_LUR1[,models[[3]]$indexbestmodel]+ VGOB1_subsetF_staph_LUR1[,models[[4]]$indexbestmodel]) 


models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel


# The next part of the code (n=5-8) does not work
# This is because one of the coefficients included in the model with 6 variables is negative, the code does not allow for this. I can stop here.

# # 5 #  
# # add fifth variable (the only difference of the above part is that now modeln=5 the model statement more variables)
# # and the call for the list of variable names in the model changed slightly
# modeln<-5
# 
# models[[modeln]]<-list()
# 
# R2<-1
# addedvar<-1
# betaaddedvar<-1
# minbetas<-1
# j<-1
# 
# for (i in nfirstvar_LUR_1:nlastvar_LUR_1){
#   if (is.numeric(VGOB1_subsetF_staph_LUR1[,i])==TRUE){
#     modeltry<-lm(VGOB1_subsetF_staph_LUR1$staph_copiespm3.ln.diffmeth.mean~ VGOB1_subsetF_staph_LUR1[,models[[1]]$indexbestmodel]+ VGOB1_subsetF_staph_LUR1[,models[[2]]$indexbestmodel]+ VGOB1_subsetF_staph_LUR1[,models[[3]]$indexbestmodel]+ VGOB1_subsetF_staph_LUR1[,models[[4]]$indexbestmodel]+ VGOB1_subsetF_staph_LUR1[,i]) 
#   
# R2<-rbind(R2,summary(modeltry)$adj.r.squared)
# # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
#     betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
#     #  find out if there is a negative beta at All. The intercept does not count [-1]!
#     minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
#     # All[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR1)[i]
#     addedvar<-rbind(addedvar,names(VGOB1_subsetF_staph_LUR1)[i])
#     j<-rbind(j, i)
#     models[[modeln]][[i]]<-summary(modeltry)
#   }
# }
# 
# models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)
# 
# #  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
# models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)
# 
# # rank the R2's of these models
# models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))
# 
# #  this is the index of the row with the highest R2 and  no negative betas in this subset
# models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j
# 
# subset(models[[modeln]]$resultspos, rank==1)
# 
# #  this is the model
# models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]
# 
# # here are the names
# models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetF_staph_LUR1)[models[[1]]$indexbestmodel], names(VGOB1_subsetF_staph_LUR1)[models[[2]]$indexbestmodel], names(VGOB1_subsetF_staph_LUR1)[models[[3]]$indexbestmodel], names(VGOB1_subsetF_staph_LUR1)[models[[4]]$indexbestmodel], names(VGOB1_subsetF_staph_LUR1)[models[[5]]$indexbestmodel])
# 
# #  this is the r2 or that model
# models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2
# 
# #  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
# models[[modeln]]$bestmodel <- lm(VGOB1_subsetF_staph_LUR1$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetF_staph_LUR1[,models[[1]]$indexbestmodel]+VGOB1_subsetF_staph_LUR1[,models[[2]]$indexbestmodel]+VGOB1_subsetF_staph_LUR1[,models[[3]]$indexbestmodel]+ VGOB1_subsetF_staph_LUR1[,models[[4]]$indexbestmodel]+ VGOB1_subsetF_staph_LUR1[,models[[5]]$indexbestmodel]) 
# models[[1]]$summarybestmodel
# models[[2]]$summarybestmodel
# models[[3]]$summarybestmodel
# models[[4]]$summarybestmodel
# models[[5]]$summarybestmodel
# models[[1]]$namesbestmodel
# models[[2]]$namesbestmodel
# models[[3]]$namesbestmodel
# models[[4]]$namesbestmodel
# models[[5]]$namesbestmodel
# models[[1]]$R2bestmodel
# models[[2]]$R2bestmodel
# models[[3]]$R2bestmodel
# models[[4]]$R2bestmodel
# models[[5]]$R2bestmodel
# 
# # 6 #  
# # add sixth variable (the only difference of the above part is that now model n=6 the model statement more variables)
# #  and the call for the list of variable names in the model changed slightly
# 
# modeln<-6
# 
# models[[modeln]]<-list()
# 
# R2<-1
# addedvar<-1
# betaaddedvar<-1
# minbetas<-1
# j<-1
# 
# for (i in nfirstvar_LUR_1 :nlastvar_LUR_1){
#   if (is.numeric(VGOB1_subsetF_staph_LUR1[,i])==TRUE){
#     modeltry<-lm(VGOB1_subsetF_staph_LUR1$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetF_staph_LUR1[,models[[1]]$indexbestmodel]+VGOB1_subsetF_staph_LUR1[,models[[2]]$indexbestmodel]+VGOB1_subsetF_staph_LUR1[,models[[3]]$indexbestmodel]+VGOB1_subsetF_staph_LUR1[,models[[4]]$indexbestmodel]+VGOB1_subsetF_staph_LUR1[,models[[5]]$indexbestmodel]+ VGOB1_subsetF_staph_LUR1[,i]) 
#     R2<-rbind(R2,summary(modeltry)$adj.r.squared)
#     # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
#     betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
#     #  find out if there is a negative beta at All. The intercept does not count [-1]!
#     minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
#     # All[,i] is the row that's being tried out now. the name of that row can be found in  names(All)[i]
#     addedvar<-rbind(addedvar,names(VGOB1_subsetF_staph_LUR1)[i])
#     j<-rbind(j, i)
#     models[[modeln]][[i]]<-summary(modeltry)
#   }
# }
# 
# models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)
# 
# #  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
# models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)
# 
# # rank the R2's of these models
# models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))
# 
# #  this is the index of the row with the highest R2 and  no negative betas in this subset
# models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j
# 
# subset(models[[modeln]]$resultspos, rank==1)
# 
# # this is the model
# models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]
# 
# # here are the names
# models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetF_staph_LUR1)[models[[1]]$indexbestmodel], names(VGOB1_subsetF_staph_LUR1)[models[[2]]$indexbestmodel] , names(VGOB1_subsetF_staph_LUR1)[models[[3]]$indexbestmodel], names(VGOB1_subsetF_staph_LUR1)[models[[4]]$indexbestmodel], names(VGOB1_subsetF_staph_LUR1)[models[[5]]$indexbestmodel], names(VGOB1_subsetF_staph_LUR1)[models[[6]]$indexbestmodel])
# 
# #  this is the r2 or that model
# models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2
# 
# #  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
# models[[modeln]]$bestmodel <- lm(VGOB1_subsetF_staph_LUR1$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetF_staph_LUR1[,models[[1]]$indexbestmodel]+VGOB1_subsetF_staph_LUR1[,models[[2]]$indexbestmodel]+VGOB1_subsetF_staph_LUR1[,models[[3]]$indexbestmodel]+ VGOB1_subsetF_staph_LUR1[,models[[4]]$indexbestmodel]+ VGOB1_subsetF_staph_LUR1[,models[[5]]$indexbestmodel]+ VGOB1_subsetF_staph_LUR1[,models[[6]]$indexbestmodel]) 
# 
# models[[1]]$summarybestmodel
# models[[2]]$summarybestmodel
# models[[3]]$summarybestmodel
# models[[4]]$summarybestmodel
# models[[5]]$summarybestmodel
# models[[6]]$summarybestmodel
# models[[1]]$namesbestmodel
# models[[2]]$namesbestmodel
# models[[3]]$namesbestmodel
# models[[4]]$namesbestmodel
# models[[5]]$namesbestmodel
# models[[6]]$namesbestmodel
# models[[1]]$R2bestmodel
# models[[2]]$R2bestmodel
# models[[3]]$R2bestmodel
# models[[4]]$R2bestmodel
# models[[5]]$R2bestmodel
# models[[6]]$R2bestmodel
# 
# 
# # 7 #  
# # add seventh variable (the only difference of the above part is that now model n=7 the model statement more variables)
# #  and the call for the list of variable names in the model changed slightly
# 
# modeln<-7
# 
# models[[modeln]]<-list()
# 
# R2<-1
# addedvar<-1
# betaaddedvar<-1
# minbetas<-1
# j<-1
# 
# for (i in nfirstvar_LUR_1 :nlastvar_LUR_1){
#   if (is.numeric(VGOB1_subsetF_staph_LUR1[,i])==TRUE){
#     modeltry<-lm(VGOB1_subsetF_staph_LUR1$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetF_staph_LUR1[,models[[1]]$indexbestmodel]+VGOB1_subsetF_staph_LUR1[,models[[2]]$indexbestmodel]+VGOB1_subsetF_staph_LUR1[,models[[3]]$indexbestmodel]+VGOB1_subsetF_staph_LUR1[,models[[4]]$indexbestmodel]+VGOB1_subsetF_staph_LUR1[,models[[5]]$indexbestmodel]+VGOB1_subsetF_staph_LUR1[,models[[6]]$indexbestmodel]+ VGOB1_subsetF_staph_LUR1[,i]) 
#     R2<-rbind(R2,summary(modeltry)$adj.r.squared)
#     # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
#     betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
#     #  find out if there is a negative beta at All. The intercept does not count [-1]!
#     minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
#     # Measurements_livestockpreds_LUR1[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR1)[i]
#     addedvar<-rbind(addedvar,names(VGOB1_subsetF_staph_LUR1)[i])
#     j<-rbind(j, i)
#     models[[modeln]][[i]]<-summary(modeltry)
#   }
# }
# 
# models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)
# 
# #  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
# models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)
# 
# # rank the R2's of these models
# models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))
# 
# #  this is the index of the row with the highest R2 and  no negative betas in this subset
# models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j
# 
# subset(models[[modeln]]$resultspos, rank==1)
# 
# # this is the model
# models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]
# 
# # here are the names
# models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetF_staph_LUR1)[models[[1]]$indexbestmodel], names(VGOB1_subsetF_staph_LUR1)[models[[2]]$indexbestmodel] , names(VGOB1_subsetF_staph_LUR1)[models[[3]]$indexbestmodel], names(VGOB1_subsetF_staph_LUR1)[models[[4]]$indexbestmodel], names(VGOB1_subsetF_staph_LUR1)[models[[5]]$indexbestmodel], names(VGOB1_subsetF_staph_LUR1)[models[[6]]$indexbestmodel], names(VGOB1_subsetF_staph_LUR1)[models[[7]]$indexbestmodel])
# 
# #  this is the r2 or that model
# models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2
# 
# #  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
# models[[modeln]]$bestmodel <- lm(VGOB1_subsetF_staph_LUR1$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetF_staph_LUR1[,models[[1]]$indexbestmodel]+VGOB1_subsetF_staph_LUR1[,models[[2]]$indexbestmodel]+VGOB1_subsetF_staph_LUR1[,models[[3]]$indexbestmodel]+ VGOB1_subsetF_staph_LUR1[,models[[4]]$indexbestmodel]+ VGOB1_subsetF_staph_LUR1[,models[[5]]$indexbestmodel]+ VGOB1_subsetF_staph_LUR1[,models[[6]]$indexbestmodel]+ VGOB1_subsetF_staph_LUR1[,models[[7]]$indexbestmodel]) 
# 
# models[[1]]$summarybestmodel
# models[[2]]$summarybestmodel
# models[[3]]$summarybestmodel
# models[[4]]$summarybestmodel
# models[[5]]$summarybestmodel
# models[[6]]$summarybestmodel
# models[[7]]$summarybestmodel
# models[[1]]$namesbestmodel
# models[[2]]$namesbestmodel
# models[[3]]$namesbestmodel
# models[[4]]$namesbestmodel
# models[[5]]$namesbestmodel
# models[[6]]$namesbestmodel
# models[[7]]$namesbestmodel
# models[[1]]$R2bestmodel
# models[[2]]$R2bestmodel
# models[[3]]$R2bestmodel
# models[[4]]$R2bestmodel
# models[[5]]$R2bestmodel
# models[[6]]$R2bestmodel
# models[[7]]$R2bestmodel
# 
# # 8 #  
# # add eighth variable (the only difference of the above part is that now modeln=7 the model statement more variables)
# # and the call for the list of variable names in the model changed slightly
# 
# modeln<-8
# 
# models[[modeln]]<-list()
# 
# R2<-1
# addedvar<-1
# betaaddedvar<-1
# minbetas<-1
# j<-1
# 
# for (i in nfirstvar_LUR_1 :nlastvar_LUR_1){
#   if (is.numeric(VGOB1_subsetF_staph_LUR1[,i])==TRUE){
#     modeltry<-lm(VGOB1_subsetF_staph_LUR1$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetF_staph_LUR1[,models[[1]]$indexbestmodel]+VGOB1_subsetF_staph_LUR1[,models[[2]]$indexbestmodel]+VGOB1_subsetF_staph_LUR1[,models[[3]]$indexbestmodel]+VGOB1_subsetF_staph_LUR1[,models[[4]]$indexbestmodel]+VGOB1_subsetF_staph_LUR1[,models[[5]]$indexbestmodel]+VGOB1_subsetF_staph_LUR1[,models[[6]]$indexbestmodel]+ VGOB1_subsetF_staph_LUR1[,models[[7]]$indexbestmodel]+ VGOB1_subsetF_staph_LUR1[,i]) 
#     R2<-rbind(R2,summary(modeltry)$adj.r.squared)
#     # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
#     betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
#     #  find out if there is a negative beta at All. The intercept does not count [-1]!
#     minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
#     # Measurements_livestockpreds_LUR1[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR1)[i]
#     addedvar<-rbind(addedvar,names(VGOB1_subsetF_staph_LUR1)[i])
#     j<-rbind(j, i)
#     models[[modeln]][[i]]<-summary(modeltry)
#   }
# }
# 
# models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)
# 
# #  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
# models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)
# 
# # rank the R2's of these models
# models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))
# 
# #  this is the index of the row with the highest R2 and  no negative betas in this subset
# models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j
# 
# subset(models[[modeln]]$resultspos, rank==1)
# 
# # this is the model
# models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]
# 
# # here are the names
# models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetF_staph_LUR1)[models[[1]]$indexbestmodel], names(VGOB1_subsetF_staph_LUR1)[models[[2]]$indexbestmodel] , names(VGOB1_subsetF_staph_LUR1)[models[[3]]$indexbestmodel], names(VGOB1_subsetF_staph_LUR1)[models[[4]]$indexbestmodel], names(VGOB1_subsetF_staph_LUR1)[models[[5]]$indexbestmodel], names(VGOB1_subsetF_staph_LUR1)[models[[6]]$indexbestmodel], names(VGOB1_subsetF_staph_LUR1)[models[[7]]$indexbestmodel], names(VGOB1_subsetF_staph_LUR1)[models[[8]]$indexbestmodel])
# 
# #  this is the r2 or that model
# models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2
# 
# #  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
# models[[modeln]]$bestmodel <- lm(VGOB1_subsetF_staph_LUR1$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetF_staph_LUR1[,models[[1]]$indexbestmodel]+VGOB1_subsetF_staph_LUR1[,models[[2]]$indexbestmodel]+VGOB1_subsetF_staph_LUR1[,models[[3]]$indexbestmodel]+ VGOB1_subsetF_staph_LUR1[,models[[4]]$indexbestmodel]+ VGOB1_subsetF_staph_LUR1[,models[[5]]$indexbestmodel]+ VGOB1_subsetF_staph_LUR1[,models[[6]]$indexbestmodel]+ VGOB1_subsetF_staph_LUR1[,models[[7]]$indexbestmodel]+ VGOB1_subsetF_staph_LUR1[,models[[8]]$indexbestmodel]) 
# 
# models[[1]]$summarybestmodel
# models[[2]]$summarybestmodel
# models[[3]]$summarybestmodel
# models[[4]]$summarybestmodel
# models[[5]]$summarybestmodel
# models[[6]]$summarybestmodel
# models[[7]]$summarybestmodel
# models[[8]]$summarybestmodel
# models[[1]]$namesbestmodel
# models[[2]]$namesbestmodel
# models[[3]]$namesbestmodel
# models[[4]]$namesbestmodel
# models[[5]]$namesbestmodel
# models[[6]]$namesbestmodel
# models[[7]]$namesbestmodel
# models[[8]]$namesbestmodel
# models[[1]]$R2bestmodel
# models[[2]]$R2bestmodel
# models[[3]]$R2bestmodel
# models[[4]]$R2bestmodel
# models[[5]]$R2bestmodel
# models[[6]]$R2bestmodel
# models[[7]]$R2bestmodel
# models[[8]]$R2bestmodel

#   CODE FOR PICKING OUT THE BEST MODEL #   
temp <- 0
besti <- 0
for (i in 1:10){ #  think this runs the loop 10 times - not fully sure thought - but not to do with the number of models I don't think - as when I change to 3, I still get the model with 4 variables as best model
  print(models[[i]]$R2bestmodel)
  #       print(models[[i]]$summarybestmodel$coefficients=-1,4])
  #       if((models[[i]]$R2bestmodel-temp > 0.0) && (all(models[[i]]$summarybestmodel$coefficients[-1,4]<0.1))){
  #         temp <- models[[i]]$R2bestmodel
  #         besti <- i
  #         }
  if((models[[i]]$R2bestmodel-temp > 0.0) && (all(models[[i]]$summarybestmodel$coefficients[-1,4]<0.1))){
    temp <- models[[i]]$R2bestmodel
    besti <- i
  }else{
    finalBestModel_staph_LUR1_subsetF <- models[[besti]]$bestmodel
    finalBestModelNames_staph_subsetF <- models[[besti]]$namesbestmodel
    Sites <- 1:dim(VGOB1_subsetF_staph_LUR1)[1] # full original model
    #  CVaR2<-escCV_staph_LUR1(Sites)[2] # Cross Validation
    maxCD<-max(cooks.distance(finalBestModel_staph_LUR1_subsetF))
    if(length(finalBestModelNames_staph_subsetF)<2){ # vif fn doesnot work when only 1 variable...       # 
      maxVIF<-"NA"
    }else{
      maxVIF<-max(vif(finalBestModel_staph_LUR1_subsetF))
    }
    print(paste("This is the best staph model for subset F: ",besti,
                "(AdjR2: ",format(models[[besti]]$R2bestmodel,digits=3), "; MaxCD: ",format(maxCD,digits=3),"; MaxVIF: ",
                format(maxVIF,digits=3),")", sep=''))
    print(finalBestModelNames_staph_subsetF)
    break
  }
}

#  Overview of the final best model using the algorithm selection process (taking into account VIF, R^2, and p-values)
finalBestModel_staph_LUR1_subsetF
finalBestModelNames_staph_subsetF
models[[besti]]$summarybestmodel
models[[besti]]$R2bestmodel

#### G ####
# LUR model building process for subset G
#  This is the dataframe with the relevant predictor vars for LUR1 models for subset G (55 sites)
VGOB1_subsetG_staph_LUR1 # n.b. this dataframe only includes microbial marker concentrations for staph unlike the dataframe Measurements_livestockpreds_LUR1 as previously used for the model building. 

#  Now set the values of some variables that will be needed
nfirstvar_LUR_1 <- 3  
nlastvar_LUR_1 <- 10

# Function building to run the models 
# 1 #  

models<-list()
modeln<-1
models[[modeln]]<-list()

R2<-1
betaaddedvar<-1
addedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_1:nlastvar_LUR_1){
  if (is.numeric(VGOB1_subsetG_staph_LUR1[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetG_staph_LUR1$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetG_staph_LUR1[,i])                            
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    #  Measurements_livestockpreds_LUR1[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR1)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetG_staph_LUR1)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)
models[[modeln]]$results

#  this are the candidates models with the highest R2, not a negative beta for the new, nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)
models[[modeln]]$resultspos

#  rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))
models[[modeln]]$resultspos

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j
models[[modeln]]$indexbestmodel

subset(models[[modeln]]$resultspos, rank==1)
subset(models[[modeln]]$resultspos)

#  this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]
models[[modeln]]$summarybestmodel

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetG_staph_LUR1)[models[[1]]$indexbestmodel])
models[[modeln]]$namesbestmodel

#  this is the r2 of that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2
models[[modeln]]$R2bestmodel

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetG_staph_LUR1$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetG_staph_LUR1[,models[[1]]$indexbestmodel]) 
models[[modeln]]$bestmodel

summary(models[[modeln]]$bestmodel)

#  The first model includes the predictor: nPigMultipFarmWghtDist.3000m.sum.Tr.1P9 - meaning the number of multiplier pig farms weighted to distance in a 3000m buffer

# 2 #  
# Add 2nd variable (the only difference of the above part is that now modeln=2 the model statement has 2 variables)
# and the call for the list of variable names in the model changed slightly

modeln<-2

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_1:nlastvar_LUR_1){
  if (is.numeric(VGOB1_subsetG_staph_LUR1[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetG_staph_LUR1$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetG_staph_LUR1[,models[[1]]$indexbestmodel]+ VGOB1_subsetG_staph_LUR1[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # Measurements_livestockpreds_LUR1[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR1)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetG_staph_LUR1)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  these are the candidate models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)
models[[modeln]]$resultspos

#  rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))
models[[modeln]]$resultspos

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j
models[[modeln]]$indexbestmodel

subset(models[[modeln]]$resultspos, rank==1)

# this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]
models[[modeln]]$summarybestmodel

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetG_staph_LUR1)[models[[1]]$indexbestmodel], names(VGOB1_subsetG_staph_LUR1)[models[[2]]$indexbestmodel] )
models[[modeln]]$namesbestmodel

# this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2
models[[modeln]]$R2bestmodel

# this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetG_staph_LUR1$staph_copiespm3.ln.diffmeth.mean~                               VGOB1_subsetG_staph_LUR1[,models[[1]]$indexbestmodel]+                           VGOB1_subsetG_staph_LUR1[,models[[2]]$indexbestmodel]) 

models[[modeln]]$bestmodel

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel


# 3 #  
# add third variable (the only difference of the above part is that now modeln=3 the model statement has 3 variables)
# and the call for the list of variable names in the model changed slightly

modeln<-3

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_1:nlastvar_LUR_1){
  if (is.numeric(VGOB1_subsetG_staph_LUR1[,i])==TRUE){  
    modeltry<-lm(VGOB1_subsetG_staph_LUR1$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetG_staph_LUR1[,models[[1]]$indexbestmodel]+VGOB1_subsetG_staph_LUR1[,models[[2]]$indexbestmodel]+ VGOB1_subsetG_staph_LUR1[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # All[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR1)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetG_staph_LUR1)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

#  rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

#  this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

#  here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetG_staph_LUR1)[models[[1]]$indexbestmodel], names(VGOB1_subsetG_staph_LUR1)[models[[2]]$indexbestmodel], names(VGOB1_subsetG_staph_LUR1)[models[[3]]$indexbestmodel])

#  this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetG_staph_LUR1$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetG_staph_LUR1[,models[[1]]$indexbestmodel]+ VGOB1_subsetG_staph_LUR1[,models[[2]]$indexbestmodel]+ VGOB1_subsetG_staph_LUR1[,models[[3]]$indexbestmodel]) 

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel


# The next part of the code (n=4-8) does not work
# This is because one of the coefficients included in the model with 6 variables is negative, the code does not allow for this. I can stop here.

# # 4 #  
# #  add forth variable (the only difference of the above part is that now model n=4 the model statement more variables)
# #  and the call for the list of variable names in the model changed slightly
# modeln<-4
# 
# models[[modeln]]<-list()
# 
# R2<-1
# addedvar<-1
# betaaddedvar<-1
# minbetas<-1
# j<-1
# 
# 
# for (i in nfirstvar_LUR_1:nlastvar_LUR_1){
#   if (is.numeric(VGOB1_subsetG_staph_LUR1[,i])==TRUE){
#     modeltry<-lm(VGOB1_subsetG_staph_LUR1$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetG_staph_LUR1[,models[[1]]$indexbestmodel]+VGOB1_subsetG_staph_LUR1[,models[[2]]$indexbestmodel]+VGOB1_subsetG_staph_LUR1[,models[[3]]$indexbestmodel]+VGOB1_subsetG_staph_LUR1[,i]) 
#     R2<-rbind(R2,summary(modeltry)$adj.r.squared)
#     #  the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
#     betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])
#     #  find out if there is a negative beta at All. The intercept does not count [-1]!
#     minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
#     #  All[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR1)[i]
#     addedvar<-rbind(addedvar,names(VGOB1_subsetG_staph_LUR1)[i])
#     j<-rbind(j, i)
#     models[[modeln]][[i]]<-summary(modeltry)
#   }
# }
# 
# models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)
# 
# #  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
# models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)
# 
# # rank the R2's of these models
# models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))
# 
# #  this is the index of the row with the highest R2 and  no negative betas in this subset
# models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j
# 
# subset(models[[modeln]]$resultspos, rank==1)
# 
# #  this is the model
# models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]
# 
# #  here are the names
# models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetG_staph_LUR1)[models[[1]]$indexbestmodel], names(VGOB1_subsetG_staph_LUR1)[models[[2]]$indexbestmodel], names(VGOB1_subsetG_staph_LUR1)[models[[3]]$indexbestmodel], names(VGOB1_subsetG_staph_LUR1)[models[[4]]$indexbestmodel])
# 
# #  this is the r2 of that model
# models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2
# 
# #  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
# models[[modeln]]$bestmodel <- lm(VGOB1_subsetG_staph_LUR1$staph_copiespm3.ln.diffmeth.mean~ VGOB1_subsetG_staph_LUR1[,models[[1]]$indexbestmodel]+ VGOB1_subsetG_staph_LUR1[,models[[2]]$indexbestmodel]+VGOB1_subsetG_staph_LUR1[,models[[3]]$indexbestmodel]+ VGOB1_subsetG_staph_LUR1[,models[[4]]$indexbestmodel]) 
# 
# 
# models[[1]]$summarybestmodel
# models[[2]]$summarybestmodel
# models[[3]]$summarybestmodel
# models[[4]]$summarybestmodel
# models[[1]]$namesbestmodel
# models[[2]]$namesbestmodel
# models[[3]]$namesbestmodel
# models[[4]]$namesbestmodel
# models[[1]]$R2bestmodel
# models[[2]]$R2bestmodel
# models[[3]]$R2bestmodel
# models[[4]]$R2bestmodel
# 
# 
# # 5 #  
# # add fifth variable (the only difference of the above part is that now modeln=5 the model statement more variables)
# # and the call for the list of variable names in the model changed slightly
# modeln<-5
# 
# models[[modeln]]<-list()
# 
# R2<-1
# addedvar<-1
# betaaddedvar<-1
# minbetas<-1
# j<-1
# 
# for (i in nfirstvar_LUR_1:nlastvar_LUR_1){
#   if (is.numeric(VGOB1_subsetG_staph_LUR1[,i])==TRUE){
#     modeltry<-lm(VGOB1_subsetG_staph_LUR1$staph_copiespm3.ln.diffmeth.mean~ VGOB1_subsetG_staph_LUR1[,models[[1]]$indexbestmodel]+ VGOB1_subsetG_staph_LUR1[,models[[2]]$indexbestmodel]+ VGOB1_subsetG_staph_LUR1[,models[[3]]$indexbestmodel]+ VGOB1_subsetG_staph_LUR1[,models[[4]]$indexbestmodel]+ VGOB1_subsetG_staph_LUR1[,i]) 
#   
# R2<-rbind(R2,summary(modeltry)$adj.r.squared)
# # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
#     betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
#     #  find out if there is a negative beta at All. The intercept does not count [-1]!
#     minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
#     # All[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR1)[i]
#     addedvar<-rbind(addedvar,names(VGOB1_subsetG_staph_LUR1)[i])
#     j<-rbind(j, i)
#     models[[modeln]][[i]]<-summary(modeltry)
#   }
# }
# 
# models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)
# 
# #  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
# models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)
# 
# # rank the R2's of these models
# models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))
# 
# #  this is the index of the row with the highest R2 and  no negative betas in this subset
# models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j
# 
# subset(models[[modeln]]$resultspos, rank==1)
# 
# #  this is the model
# models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]
# 
# # here are the names
# models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetG_staph_LUR1)[models[[1]]$indexbestmodel], names(VGOB1_subsetG_staph_LUR1)[models[[2]]$indexbestmodel], names(VGOB1_subsetG_staph_LUR1)[models[[3]]$indexbestmodel], names(VGOB1_subsetG_staph_LUR1)[models[[4]]$indexbestmodel], names(VGOB1_subsetG_staph_LUR1)[models[[5]]$indexbestmodel])
# 
# #  this is the r2 or that model
# models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2
# 
# #  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
# models[[modeln]]$bestmodel <- lm(VGOB1_subsetG_staph_LUR1$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetG_staph_LUR1[,models[[1]]$indexbestmodel]+VGOB1_subsetG_staph_LUR1[,models[[2]]$indexbestmodel]+VGOB1_subsetG_staph_LUR1[,models[[3]]$indexbestmodel]+ VGOB1_subsetG_staph_LUR1[,models[[4]]$indexbestmodel]+ VGOB1_subsetG_staph_LUR1[,models[[5]]$indexbestmodel]) 
# models[[1]]$summarybestmodel
# models[[2]]$summarybestmodel
# models[[3]]$summarybestmodel
# models[[4]]$summarybestmodel
# models[[5]]$summarybestmodel
# models[[1]]$namesbestmodel
# models[[2]]$namesbestmodel
# models[[3]]$namesbestmodel
# models[[4]]$namesbestmodel
# models[[5]]$namesbestmodel
# models[[1]]$R2bestmodel
# models[[2]]$R2bestmodel
# models[[3]]$R2bestmodel
# models[[4]]$R2bestmodel
# models[[5]]$R2bestmodel
# 
# # 6 #  
# # add sixth variable (the only difference of the above part is that now model n=6 the model statement more variables)
# #  and the call for the list of variable names in the model changed slightly
# 
# modeln<-6
# 
# models[[modeln]]<-list()
# 
# R2<-1
# addedvar<-1
# betaaddedvar<-1
# minbetas<-1
# j<-1
# 
# for (i in nfirstvar_LUR_1 :nlastvar_LUR_1){
#   if (is.numeric(VGOB1_subsetG_staph_LUR1[,i])==TRUE){
#     modeltry<-lm(VGOB1_subsetG_staph_LUR1$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetG_staph_LUR1[,models[[1]]$indexbestmodel]+VGOB1_subsetG_staph_LUR1[,models[[2]]$indexbestmodel]+VGOB1_subsetG_staph_LUR1[,models[[3]]$indexbestmodel]+VGOB1_subsetG_staph_LUR1[,models[[4]]$indexbestmodel]+VGOB1_subsetG_staph_LUR1[,models[[5]]$indexbestmodel]+ VGOB1_subsetG_staph_LUR1[,i]) 
#     R2<-rbind(R2,summary(modeltry)$adj.r.squared)
#     # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
#     betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
#     #  find out if there is a negative beta at All. The intercept does not count [-1]!
#     minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
#     # All[,i] is the row that's being tried out now. the name of that row can be found in  names(All)[i]
#     addedvar<-rbind(addedvar,names(VGOB1_subsetG_staph_LUR1)[i])
#     j<-rbind(j, i)
#     models[[modeln]][[i]]<-summary(modeltry)
#   }
# }
# 
# models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)
# 
# #  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
# models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)
# 
# # rank the R2's of these models
# models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))
# 
# #  this is the index of the row with the highest R2 and  no negative betas in this subset
# models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j
# 
# subset(models[[modeln]]$resultspos, rank==1)
# 
# # this is the model
# models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]
# 
# # here are the names
# models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetG_staph_LUR1)[models[[1]]$indexbestmodel], names(VGOB1_subsetG_staph_LUR1)[models[[2]]$indexbestmodel] , names(VGOB1_subsetG_staph_LUR1)[models[[3]]$indexbestmodel], names(VGOB1_subsetG_staph_LUR1)[models[[4]]$indexbestmodel], names(VGOB1_subsetG_staph_LUR1)[models[[5]]$indexbestmodel], names(VGOB1_subsetG_staph_LUR1)[models[[6]]$indexbestmodel])
# 
# #  this is the r2 or that model
# models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2
# 
# #  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
# models[[modeln]]$bestmodel <- lm(VGOB1_subsetG_staph_LUR1$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetG_staph_LUR1[,models[[1]]$indexbestmodel]+VGOB1_subsetG_staph_LUR1[,models[[2]]$indexbestmodel]+VGOB1_subsetG_staph_LUR1[,models[[3]]$indexbestmodel]+ VGOB1_subsetG_staph_LUR1[,models[[4]]$indexbestmodel]+ VGOB1_subsetG_staph_LUR1[,models[[5]]$indexbestmodel]+ VGOB1_subsetG_staph_LUR1[,models[[6]]$indexbestmodel]) 
# 
# models[[1]]$summarybestmodel
# models[[2]]$summarybestmodel
# models[[3]]$summarybestmodel
# models[[4]]$summarybestmodel
# models[[5]]$summarybestmodel
# models[[6]]$summarybestmodel
# models[[1]]$namesbestmodel
# models[[2]]$namesbestmodel
# models[[3]]$namesbestmodel
# models[[4]]$namesbestmodel
# models[[5]]$namesbestmodel
# models[[6]]$namesbestmodel
# models[[1]]$R2bestmodel
# models[[2]]$R2bestmodel
# models[[3]]$R2bestmodel
# models[[4]]$R2bestmodel
# models[[5]]$R2bestmodel
# models[[6]]$R2bestmodel
# 
# 
# # 7 #  
# # add seventh variable (the only difference of the above part is that now model n=7 the model statement more variables)
# #  and the call for the list of variable names in the model changed slightly
# 
# modeln<-7
# 
# models[[modeln]]<-list()
# 
# R2<-1
# addedvar<-1
# betaaddedvar<-1
# minbetas<-1
# j<-1
# 
# for (i in nfirstvar_LUR_1 :nlastvar_LUR_1){
#   if (is.numeric(VGOB1_subsetG_staph_LUR1[,i])==TRUE){
#     modeltry<-lm(VGOB1_subsetG_staph_LUR1$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetG_staph_LUR1[,models[[1]]$indexbestmodel]+VGOB1_subsetG_staph_LUR1[,models[[2]]$indexbestmodel]+VGOB1_subsetG_staph_LUR1[,models[[3]]$indexbestmodel]+VGOB1_subsetG_staph_LUR1[,models[[4]]$indexbestmodel]+VGOB1_subsetG_staph_LUR1[,models[[5]]$indexbestmodel]+VGOB1_subsetG_staph_LUR1[,models[[6]]$indexbestmodel]+ VGOB1_subsetG_staph_LUR1[,i]) 
#     R2<-rbind(R2,summary(modeltry)$adj.r.squared)
#     # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
#     betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
#     #  find out if there is a negative beta at All. The intercept does not count [-1]!
#     minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
#     # Measurements_livestockpreds_LUR1[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR1)[i]
#     addedvar<-rbind(addedvar,names(VGOB1_subsetG_staph_LUR1)[i])
#     j<-rbind(j, i)
#     models[[modeln]][[i]]<-summary(modeltry)
#   }
# }
# 
# models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)
# 
# #  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
# models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)
# 
# # rank the R2's of these models
# models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))
# 
# #  this is the index of the row with the highest R2 and  no negative betas in this subset
# models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j
# 
# subset(models[[modeln]]$resultspos, rank==1)
# 
# # this is the model
# models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]
# 
# # here are the names
# models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetG_staph_LUR1)[models[[1]]$indexbestmodel], names(VGOB1_subsetG_staph_LUR1)[models[[2]]$indexbestmodel] , names(VGOB1_subsetG_staph_LUR1)[models[[3]]$indexbestmodel], names(VGOB1_subsetG_staph_LUR1)[models[[4]]$indexbestmodel], names(VGOB1_subsetG_staph_LUR1)[models[[5]]$indexbestmodel], names(VGOB1_subsetG_staph_LUR1)[models[[6]]$indexbestmodel], names(VGOB1_subsetG_staph_LUR1)[models[[7]]$indexbestmodel])
# 
# #  this is the r2 or that model
# models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2
# 
# #  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
# models[[modeln]]$bestmodel <- lm(VGOB1_subsetG_staph_LUR1$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetG_staph_LUR1[,models[[1]]$indexbestmodel]+VGOB1_subsetG_staph_LUR1[,models[[2]]$indexbestmodel]+VGOB1_subsetG_staph_LUR1[,models[[3]]$indexbestmodel]+ VGOB1_subsetG_staph_LUR1[,models[[4]]$indexbestmodel]+ VGOB1_subsetG_staph_LUR1[,models[[5]]$indexbestmodel]+ VGOB1_subsetG_staph_LUR1[,models[[6]]$indexbestmodel]+ VGOB1_subsetG_staph_LUR1[,models[[7]]$indexbestmodel]) 
# 
# models[[1]]$summarybestmodel
# models[[2]]$summarybestmodel
# models[[3]]$summarybestmodel
# models[[4]]$summarybestmodel
# models[[5]]$summarybestmodel
# models[[6]]$summarybestmodel
# models[[7]]$summarybestmodel
# models[[1]]$namesbestmodel
# models[[2]]$namesbestmodel
# models[[3]]$namesbestmodel
# models[[4]]$namesbestmodel
# models[[5]]$namesbestmodel
# models[[6]]$namesbestmodel
# models[[7]]$namesbestmodel
# models[[1]]$R2bestmodel
# models[[2]]$R2bestmodel
# models[[3]]$R2bestmodel
# models[[4]]$R2bestmodel
# models[[5]]$R2bestmodel
# models[[6]]$R2bestmodel
# models[[7]]$R2bestmodel
# 
# # 8 #  
# # add eighth variable (the only difference of the above part is that now modeln=7 the model statement more variables)
# # and the call for the list of variable names in the model changed slightly
# 
# modeln<-8
# 
# models[[modeln]]<-list()
# 
# R2<-1
# addedvar<-1
# betaaddedvar<-1
# minbetas<-1
# j<-1
# 
# for (i in nfirstvar_LUR_1 :nlastvar_LUR_1){
#   if (is.numeric(VGOB1_subsetG_staph_LUR1[,i])==TRUE){
#     modeltry<-lm(VGOB1_subsetG_staph_LUR1$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetG_staph_LUR1[,models[[1]]$indexbestmodel]+VGOB1_subsetG_staph_LUR1[,models[[2]]$indexbestmodel]+VGOB1_subsetG_staph_LUR1[,models[[3]]$indexbestmodel]+VGOB1_subsetG_staph_LUR1[,models[[4]]$indexbestmodel]+VGOB1_subsetG_staph_LUR1[,models[[5]]$indexbestmodel]+VGOB1_subsetG_staph_LUR1[,models[[6]]$indexbestmodel]+ VGOB1_subsetG_staph_LUR1[,models[[7]]$indexbestmodel]+ VGOB1_subsetG_staph_LUR1[,i]) 
#     R2<-rbind(R2,summary(modeltry)$adj.r.squared)
#     # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
#     betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
#     #  find out if there is a negative beta at All. The intercept does not count [-1]!
#     minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
#     # Measurements_livestockpreds_LUR1[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR1)[i]
#     addedvar<-rbind(addedvar,names(VGOB1_subsetG_staph_LUR1)[i])
#     j<-rbind(j, i)
#     models[[modeln]][[i]]<-summary(modeltry)
#   }
# }
# 
# models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)
# 
# #  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
# models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)
# 
# # rank the R2's of these models
# models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))
# 
# #  this is the index of the row with the highest R2 and  no negative betas in this subset
# models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j
# 
# subset(models[[modeln]]$resultspos, rank==1)
# 
# # this is the model
# models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]
# 
# # here are the names
# models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetG_staph_LUR1)[models[[1]]$indexbestmodel], names(VGOB1_subsetG_staph_LUR1)[models[[2]]$indexbestmodel] , names(VGOB1_subsetG_staph_LUR1)[models[[3]]$indexbestmodel], names(VGOB1_subsetG_staph_LUR1)[models[[4]]$indexbestmodel], names(VGOB1_subsetG_staph_LUR1)[models[[5]]$indexbestmodel], names(VGOB1_subsetG_staph_LUR1)[models[[6]]$indexbestmodel], names(VGOB1_subsetG_staph_LUR1)[models[[7]]$indexbestmodel], names(VGOB1_subsetG_staph_LUR1)[models[[8]]$indexbestmodel])
# 
# #  this is the r2 or that model
# models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2
# 
# #  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
# models[[modeln]]$bestmodel <- lm(VGOB1_subsetG_staph_LUR1$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetG_staph_LUR1[,models[[1]]$indexbestmodel]+VGOB1_subsetG_staph_LUR1[,models[[2]]$indexbestmodel]+VGOB1_subsetG_staph_LUR1[,models[[3]]$indexbestmodel]+ VGOB1_subsetG_staph_LUR1[,models[[4]]$indexbestmodel]+ VGOB1_subsetG_staph_LUR1[,models[[5]]$indexbestmodel]+ VGOB1_subsetG_staph_LUR1[,models[[6]]$indexbestmodel]+ VGOB1_subsetG_staph_LUR1[,models[[7]]$indexbestmodel]+ VGOB1_subsetG_staph_LUR1[,models[[8]]$indexbestmodel]) 
# 
# models[[1]]$summarybestmodel
# models[[2]]$summarybestmodel
# models[[3]]$summarybestmodel
# models[[4]]$summarybestmodel
# models[[5]]$summarybestmodel
# models[[6]]$summarybestmodel
# models[[7]]$summarybestmodel
# models[[8]]$summarybestmodel
# models[[1]]$namesbestmodel
# models[[2]]$namesbestmodel
# models[[3]]$namesbestmodel
# models[[4]]$namesbestmodel
# models[[5]]$namesbestmodel
# models[[6]]$namesbestmodel
# models[[7]]$namesbestmodel
# models[[8]]$namesbestmodel
# models[[1]]$R2bestmodel
# models[[2]]$R2bestmodel
# models[[3]]$R2bestmodel
# models[[4]]$R2bestmodel
# models[[5]]$R2bestmodel
# models[[6]]$R2bestmodel
# models[[7]]$R2bestmodel
# models[[8]]$R2bestmodel

#   CODE FOR PICKING OUT THE BEST MODEL #   
temp <- 0
besti <- 0
for (i in 1:10){ #  think this runs the loop 10 times - not fully sure thought - but not to do with the number of models I don't think - as when I change to 3, I still get the model with 4 variables as best model
  print(models[[i]]$R2bestmodel)
  #       print(models[[i]]$summarybestmodel$coefficients=-1,4])
  #       if((models[[i]]$R2bestmodel-temp > 0.0) && (all(models[[i]]$summarybestmodel$coefficients[-1,4]<0.1))){
  #         temp <- models[[i]]$R2bestmodel
  #         besti <- i
  #         }
  if((models[[i]]$R2bestmodel-temp > 0.0) && (all(models[[i]]$summarybestmodel$coefficients[-1,4]<0.1))){
    temp <- models[[i]]$R2bestmodel
    besti <- i
  }else{
    finalBestModel_staph_LUR1_subsetG <- models[[besti]]$bestmodel
    finalBestModelNames_staph_subsetG <- models[[besti]]$namesbestmodel
    Sites <- 1:dim(VGOB1_subsetG_staph_LUR1)[1] # full original model
    #  CVaR2<-escCV_staph_LUR1(Sites)[2] # Cross Validation
    maxCD<-max(cooks.distance(finalBestModel_staph_LUR1_subsetG))
    if(length(finalBestModelNames_staph_subsetG)<2){ # vif fn doesnot work when only 1 variable...       # 
      maxVIF<-"NA"
    }else{
      maxVIF<-max(vif(finalBestModel_staph_LUR1_subsetG))
    }
    print(paste("This is the best staph model for subset G: ",besti,
                "(AdjR2: ",format(models[[besti]]$R2bestmodel,digits=3), "; MaxCD: ",format(maxCD,digits=3),"; MaxVIF: ",
                format(maxVIF,digits=3),")", sep=''))
    print(finalBestModelNames_staph_subsetG)
    break
  }
}

#  Overview of the final best model using the algorithm selection process (taking into account VIF, R^2, and p-values)
finalBestModel_staph_LUR1_subsetG
finalBestModelNames_staph_subsetG
models[[besti]]$summarybestmodel
models[[besti]]$R2bestmodel

#### H ####
# LUR model building process for subset H
#  This is the dataframe with the relevant predictor vars for LUR1 models for subset H (55 sites)
VGOB1_subsetH_staph_LUR1 # n.b. this dataframe only includes microbial marker concentrations for staph unlike the dataframe Measurements_livestockpreds_LUR1 as previously used for the model building. 

#  Now set the values of some variables that will be needed
nfirstvar_LUR_1 <- 3  
nlastvar_LUR_1 <- 10

# Function building to run the models 
# 1 #  

models<-list()
modeln<-1
models[[modeln]]<-list()

R2<-1
betaaddedvar<-1
addedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_1:nlastvar_LUR_1){
  if (is.numeric(VGOB1_subsetH_staph_LUR1[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetH_staph_LUR1$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetH_staph_LUR1[,i])                            
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    #  Measurements_livestockpreds_LUR1[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR1)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetH_staph_LUR1)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)
models[[modeln]]$results

#  this are the candidates models with the highest R2, not a negative beta for the new, nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)
models[[modeln]]$resultspos

#  rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))
models[[modeln]]$resultspos

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j
models[[modeln]]$indexbestmodel

subset(models[[modeln]]$resultspos, rank==1)
subset(models[[modeln]]$resultspos)

#  this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]
models[[modeln]]$summarybestmodel

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetH_staph_LUR1)[models[[1]]$indexbestmodel])
models[[modeln]]$namesbestmodel

#  this is the r2 of that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2
models[[modeln]]$R2bestmodel

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetH_staph_LUR1$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetH_staph_LUR1[,models[[1]]$indexbestmodel]) 
models[[modeln]]$bestmodel

summary(models[[modeln]]$bestmodel)

#  The first model includes the predictor: nPigMultipFarmWghtDist.3000m.sum.Tr.1P9 - meaning the number of multiplier pig farms weighted to distance in a 3000m buffer

# 2 #  
# Add 2nd variable (the only difference of the above part is that now modeln=2 the model statement has 2 variables)
# and the call for the list of variable names in the model changed slightly

modeln<-2

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_1:nlastvar_LUR_1){
  if (is.numeric(VGOB1_subsetH_staph_LUR1[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetH_staph_LUR1$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetH_staph_LUR1[,models[[1]]$indexbestmodel]+ VGOB1_subsetH_staph_LUR1[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # Measurements_livestockpreds_LUR1[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR1)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetH_staph_LUR1)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  these are the candidate models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)
models[[modeln]]$resultspos

#  rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))
models[[modeln]]$resultspos

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j
models[[modeln]]$indexbestmodel

subset(models[[modeln]]$resultspos, rank==1)

# this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]
models[[modeln]]$summarybestmodel

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetH_staph_LUR1)[models[[1]]$indexbestmodel], names(VGOB1_subsetH_staph_LUR1)[models[[2]]$indexbestmodel] )
models[[modeln]]$namesbestmodel

# this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2
models[[modeln]]$R2bestmodel

# this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetH_staph_LUR1$staph_copiespm3.ln.diffmeth.mean~                               VGOB1_subsetH_staph_LUR1[,models[[1]]$indexbestmodel]+                           VGOB1_subsetH_staph_LUR1[,models[[2]]$indexbestmodel]) 

models[[modeln]]$bestmodel

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel


# 3 #  
# add third variable (the only difference of the above part is that now modeln=3 the model statement has 3 variables)
# and the call for the list of variable names in the model changed slightly

modeln<-3

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_1:nlastvar_LUR_1){
  if (is.numeric(VGOB1_subsetH_staph_LUR1[,i])==TRUE){  
    modeltry<-lm(VGOB1_subsetH_staph_LUR1$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetH_staph_LUR1[,models[[1]]$indexbestmodel]+VGOB1_subsetH_staph_LUR1[,models[[2]]$indexbestmodel]+ VGOB1_subsetH_staph_LUR1[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # All[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR1)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetH_staph_LUR1)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

#  rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

#  this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

#  here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetH_staph_LUR1)[models[[1]]$indexbestmodel], names(VGOB1_subsetH_staph_LUR1)[models[[2]]$indexbestmodel], names(VGOB1_subsetH_staph_LUR1)[models[[3]]$indexbestmodel])

#  this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetH_staph_LUR1$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetH_staph_LUR1[,models[[1]]$indexbestmodel]+ VGOB1_subsetH_staph_LUR1[,models[[2]]$indexbestmodel]+ VGOB1_subsetH_staph_LUR1[,models[[3]]$indexbestmodel]) 

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel


# The next part of the code (n=4-8) does not work
# This is because one of the coefficients included in the model with 6 variables is negative, the code does not allow for this. I can stop here.


# # 4 #  
# #  add forth variable (the only difference of the above part is that now model n=4 the model statement more variables)
# #  and the call for the list of variable names in the model changed slightly
# modeln<-4
# 
# models[[modeln]]<-list()
# 
# R2<-1
# addedvar<-1
# betaaddedvar<-1
# minbetas<-1
# j<-1
# 
# 
# for (i in nfirstvar_LUR_1:nlastvar_LUR_1){
#   if (is.numeric(VGOB1_subsetH_staph_LUR1[,i])==TRUE){
#     modeltry<-lm(VGOB1_subsetH_staph_LUR1$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetH_staph_LUR1[,models[[1]]$indexbestmodel]+VGOB1_subsetH_staph_LUR1[,models[[2]]$indexbestmodel]+VGOB1_subsetH_staph_LUR1[,models[[3]]$indexbestmodel]+VGOB1_subsetH_staph_LUR1[,i]) 
#     R2<-rbind(R2,summary(modeltry)$adj.r.squared)
#     #  the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
#     betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])
#     #  find out if there is a negative beta at All. The intercept does not count [-1]!
#     minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
#     #  All[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR1)[i]
#     addedvar<-rbind(addedvar,names(VGOB1_subsetH_staph_LUR1)[i])
#     j<-rbind(j, i)
#     models[[modeln]][[i]]<-summary(modeltry)
#   }
# }
# 
# models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)
# 
# #  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
# models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)
# 
# # rank the R2's of these models
# models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))
# 
# #  this is the index of the row with the highest R2 and  no negative betas in this subset
# models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j
# 
# subset(models[[modeln]]$resultspos, rank==1)
# 
# #  this is the model
# models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]
# 
# #  here are the names
# models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetH_staph_LUR1)[models[[1]]$indexbestmodel], names(VGOB1_subsetH_staph_LUR1)[models[[2]]$indexbestmodel], names(VGOB1_subsetH_staph_LUR1)[models[[3]]$indexbestmodel], names(VGOB1_subsetH_staph_LUR1)[models[[4]]$indexbestmodel])
# 
# #  this is the r2 of that model
# models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2
# 
# #  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
# models[[modeln]]$bestmodel <- lm(VGOB1_subsetH_staph_LUR1$staph_copiespm3.ln.diffmeth.mean~ VGOB1_subsetH_staph_LUR1[,models[[1]]$indexbestmodel]+ VGOB1_subsetH_staph_LUR1[,models[[2]]$indexbestmodel]+VGOB1_subsetH_staph_LUR1[,models[[3]]$indexbestmodel]+ VGOB1_subsetH_staph_LUR1[,models[[4]]$indexbestmodel]) 
# 
# 
# models[[1]]$summarybestmodel
# models[[2]]$summarybestmodel
# models[[3]]$summarybestmodel
# models[[4]]$summarybestmodel
# models[[1]]$namesbestmodel
# models[[2]]$namesbestmodel
# models[[3]]$namesbestmodel
# models[[4]]$namesbestmodel
# models[[1]]$R2bestmodel
# models[[2]]$R2bestmodel
# models[[3]]$R2bestmodel
# models[[4]]$R2bestmodel
# 
# 
# # 5 #  
# # add fifth variable (the only difference of the above part is that now modeln=5 the model statement more variables)
# # and the call for the list of variable names in the model changed slightly
# modeln<-5
# 
# models[[modeln]]<-list()
# 
# R2<-1
# addedvar<-1
# betaaddedvar<-1
# minbetas<-1
# j<-1
# 
# for (i in nfirstvar_LUR_1:nlastvar_LUR_1){
#   if (is.numeric(VGOB1_subsetH_staph_LUR1[,i])==TRUE){
#     modeltry<-lm(VGOB1_subsetH_staph_LUR1$staph_copiespm3.ln.diffmeth.mean~ VGOB1_subsetH_staph_LUR1[,models[[1]]$indexbestmodel]+ VGOB1_subsetH_staph_LUR1[,models[[2]]$indexbestmodel]+ VGOB1_subsetH_staph_LUR1[,models[[3]]$indexbestmodel]+ VGOB1_subsetH_staph_LUR1[,models[[4]]$indexbestmodel]+ VGOB1_subsetH_staph_LUR1[,i]) 
#   
# R2<-rbind(R2,summary(modeltry)$adj.r.squared)
# # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
#     betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
#     #  find out if there is a negative beta at All. The intercept does not count [-1]!
#     minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
#     # All[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR1)[i]
#     addedvar<-rbind(addedvar,names(VGOB1_subsetH_staph_LUR1)[i])
#     j<-rbind(j, i)
#     models[[modeln]][[i]]<-summary(modeltry)
#   }
# }
# 
# models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)
# 
# #  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
# models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)
# 
# # rank the R2's of these models
# models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))
# 
# #  this is the index of the row with the highest R2 and  no negative betas in this subset
# models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j
# 
# subset(models[[modeln]]$resultspos, rank==1)
# 
# #  this is the model
# models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]
# 
# # here are the names
# models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetH_staph_LUR1)[models[[1]]$indexbestmodel], names(VGOB1_subsetH_staph_LUR1)[models[[2]]$indexbestmodel], names(VGOB1_subsetH_staph_LUR1)[models[[3]]$indexbestmodel], names(VGOB1_subsetH_staph_LUR1)[models[[4]]$indexbestmodel], names(VGOB1_subsetH_staph_LUR1)[models[[5]]$indexbestmodel])
# 
# #  this is the r2 or that model
# models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2
# 
# #  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
# models[[modeln]]$bestmodel <- lm(VGOB1_subsetH_staph_LUR1$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetH_staph_LUR1[,models[[1]]$indexbestmodel]+VGOB1_subsetH_staph_LUR1[,models[[2]]$indexbestmodel]+VGOB1_subsetH_staph_LUR1[,models[[3]]$indexbestmodel]+ VGOB1_subsetH_staph_LUR1[,models[[4]]$indexbestmodel]+ VGOB1_subsetH_staph_LUR1[,models[[5]]$indexbestmodel]) 
# models[[1]]$summarybestmodel
# models[[2]]$summarybestmodel
# models[[3]]$summarybestmodel
# models[[4]]$summarybestmodel
# models[[5]]$summarybestmodel
# models[[1]]$namesbestmodel
# models[[2]]$namesbestmodel
# models[[3]]$namesbestmodel
# models[[4]]$namesbestmodel
# models[[5]]$namesbestmodel
# models[[1]]$R2bestmodel
# models[[2]]$R2bestmodel
# models[[3]]$R2bestmodel
# models[[4]]$R2bestmodel
# models[[5]]$R2bestmodel
# 
# # 6 #  
# # add sixth variable (the only difference of the above part is that now model n=6 the model statement more variables)
# #  and the call for the list of variable names in the model changed slightly
# 
# modeln<-6
# 
# models[[modeln]]<-list()
# 
# R2<-1
# addedvar<-1
# betaaddedvar<-1
# minbetas<-1
# j<-1
# 
# for (i in nfirstvar_LUR_1 :nlastvar_LUR_1){
#   if (is.numeric(VGOB1_subsetH_staph_LUR1[,i])==TRUE){
#     modeltry<-lm(VGOB1_subsetH_staph_LUR1$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetH_staph_LUR1[,models[[1]]$indexbestmodel]+VGOB1_subsetH_staph_LUR1[,models[[2]]$indexbestmodel]+VGOB1_subsetH_staph_LUR1[,models[[3]]$indexbestmodel]+VGOB1_subsetH_staph_LUR1[,models[[4]]$indexbestmodel]+VGOB1_subsetH_staph_LUR1[,models[[5]]$indexbestmodel]+ VGOB1_subsetH_staph_LUR1[,i]) 
#     R2<-rbind(R2,summary(modeltry)$adj.r.squared)
#     # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
#     betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
#     #  find out if there is a negative beta at All. The intercept does not count [-1]!
#     minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
#     # All[,i] is the row that's being tried out now. the name of that row can be found in  names(All)[i]
#     addedvar<-rbind(addedvar,names(VGOB1_subsetH_staph_LUR1)[i])
#     j<-rbind(j, i)
#     models[[modeln]][[i]]<-summary(modeltry)
#   }
# }
# 
# models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)
# 
# #  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
# models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)
# 
# # rank the R2's of these models
# models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))
# 
# #  this is the index of the row with the highest R2 and  no negative betas in this subset
# models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j
# 
# subset(models[[modeln]]$resultspos, rank==1)
# 
# # this is the model
# models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]
# 
# # here are the names
# models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetH_staph_LUR1)[models[[1]]$indexbestmodel], names(VGOB1_subsetH_staph_LUR1)[models[[2]]$indexbestmodel] , names(VGOB1_subsetH_staph_LUR1)[models[[3]]$indexbestmodel], names(VGOB1_subsetH_staph_LUR1)[models[[4]]$indexbestmodel], names(VGOB1_subsetH_staph_LUR1)[models[[5]]$indexbestmodel], names(VGOB1_subsetH_staph_LUR1)[models[[6]]$indexbestmodel])
# 
# #  this is the r2 or that model
# models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2
# 
# #  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
# models[[modeln]]$bestmodel <- lm(VGOB1_subsetH_staph_LUR1$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetH_staph_LUR1[,models[[1]]$indexbestmodel]+VGOB1_subsetH_staph_LUR1[,models[[2]]$indexbestmodel]+VGOB1_subsetH_staph_LUR1[,models[[3]]$indexbestmodel]+ VGOB1_subsetH_staph_LUR1[,models[[4]]$indexbestmodel]+ VGOB1_subsetH_staph_LUR1[,models[[5]]$indexbestmodel]+ VGOB1_subsetH_staph_LUR1[,models[[6]]$indexbestmodel]) 
# 
# models[[1]]$summarybestmodel
# models[[2]]$summarybestmodel
# models[[3]]$summarybestmodel
# models[[4]]$summarybestmodel
# models[[5]]$summarybestmodel
# models[[6]]$summarybestmodel
# models[[1]]$namesbestmodel
# models[[2]]$namesbestmodel
# models[[3]]$namesbestmodel
# models[[4]]$namesbestmodel
# models[[5]]$namesbestmodel
# models[[6]]$namesbestmodel
# models[[1]]$R2bestmodel
# models[[2]]$R2bestmodel
# models[[3]]$R2bestmodel
# models[[4]]$R2bestmodel
# models[[5]]$R2bestmodel
# models[[6]]$R2bestmodel
# 
# 
# # 7 #  
# # add seventh variable (the only difference of the above part is that now model n=7 the model statement more variables)
# #  and the call for the list of variable names in the model changed slightly
# 
# modeln<-7
# 
# models[[modeln]]<-list()
# 
# R2<-1
# addedvar<-1
# betaaddedvar<-1
# minbetas<-1
# j<-1
# 
# for (i in nfirstvar_LUR_1 :nlastvar_LUR_1){
#   if (is.numeric(VGOB1_subsetH_staph_LUR1[,i])==TRUE){
#     modeltry<-lm(VGOB1_subsetH_staph_LUR1$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetH_staph_LUR1[,models[[1]]$indexbestmodel]+VGOB1_subsetH_staph_LUR1[,models[[2]]$indexbestmodel]+VGOB1_subsetH_staph_LUR1[,models[[3]]$indexbestmodel]+VGOB1_subsetH_staph_LUR1[,models[[4]]$indexbestmodel]+VGOB1_subsetH_staph_LUR1[,models[[5]]$indexbestmodel]+VGOB1_subsetH_staph_LUR1[,models[[6]]$indexbestmodel]+ VGOB1_subsetH_staph_LUR1[,i]) 
#     R2<-rbind(R2,summary(modeltry)$adj.r.squared)
#     # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
#     betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
#     #  find out if there is a negative beta at All. The intercept does not count [-1]!
#     minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
#     # Measurements_livestockpreds_LUR1[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR1)[i]
#     addedvar<-rbind(addedvar,names(VGOB1_subsetH_staph_LUR1)[i])
#     j<-rbind(j, i)
#     models[[modeln]][[i]]<-summary(modeltry)
#   }
# }
# 
# models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)
# 
# #  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
# models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)
# 
# # rank the R2's of these models
# models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))
# 
# #  this is the index of the row with the highest R2 and  no negative betas in this subset
# models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j
# 
# subset(models[[modeln]]$resultspos, rank==1)
# 
# # this is the model
# models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]
# 
# # here are the names
# models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetH_staph_LUR1)[models[[1]]$indexbestmodel], names(VGOB1_subsetH_staph_LUR1)[models[[2]]$indexbestmodel] , names(VGOB1_subsetH_staph_LUR1)[models[[3]]$indexbestmodel], names(VGOB1_subsetH_staph_LUR1)[models[[4]]$indexbestmodel], names(VGOB1_subsetH_staph_LUR1)[models[[5]]$indexbestmodel], names(VGOB1_subsetH_staph_LUR1)[models[[6]]$indexbestmodel], names(VGOB1_subsetH_staph_LUR1)[models[[7]]$indexbestmodel])
# 
# #  this is the r2 or that model
# models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2
# 
# #  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
# models[[modeln]]$bestmodel <- lm(VGOB1_subsetH_staph_LUR1$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetH_staph_LUR1[,models[[1]]$indexbestmodel]+VGOB1_subsetH_staph_LUR1[,models[[2]]$indexbestmodel]+VGOB1_subsetH_staph_LUR1[,models[[3]]$indexbestmodel]+ VGOB1_subsetH_staph_LUR1[,models[[4]]$indexbestmodel]+ VGOB1_subsetH_staph_LUR1[,models[[5]]$indexbestmodel]+ VGOB1_subsetH_staph_LUR1[,models[[6]]$indexbestmodel]+ VGOB1_subsetH_staph_LUR1[,models[[7]]$indexbestmodel]) 
# 
# models[[1]]$summarybestmodel
# models[[2]]$summarybestmodel
# models[[3]]$summarybestmodel
# models[[4]]$summarybestmodel
# models[[5]]$summarybestmodel
# models[[6]]$summarybestmodel
# models[[7]]$summarybestmodel
# models[[1]]$namesbestmodel
# models[[2]]$namesbestmodel
# models[[3]]$namesbestmodel
# models[[4]]$namesbestmodel
# models[[5]]$namesbestmodel
# models[[6]]$namesbestmodel
# models[[7]]$namesbestmodel
# models[[1]]$R2bestmodel
# models[[2]]$R2bestmodel
# models[[3]]$R2bestmodel
# models[[4]]$R2bestmodel
# models[[5]]$R2bestmodel
# models[[6]]$R2bestmodel
# models[[7]]$R2bestmodel
# 
# # 8 #  
# # add eighth variable (the only difference of the above part is that now modeln=7 the model statement more variables)
# # and the call for the list of variable names in the model changed slightly
# 
# modeln<-8
# 
# models[[modeln]]<-list()
# 
# R2<-1
# addedvar<-1
# betaaddedvar<-1
# minbetas<-1
# j<-1
# 
# for (i in nfirstvar_LUR_1 :nlastvar_LUR_1){
#   if (is.numeric(VGOB1_subsetH_staph_LUR1[,i])==TRUE){
#     modeltry<-lm(VGOB1_subsetH_staph_LUR1$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetH_staph_LUR1[,models[[1]]$indexbestmodel]+VGOB1_subsetH_staph_LUR1[,models[[2]]$indexbestmodel]+VGOB1_subsetH_staph_LUR1[,models[[3]]$indexbestmodel]+VGOB1_subsetH_staph_LUR1[,models[[4]]$indexbestmodel]+VGOB1_subsetH_staph_LUR1[,models[[5]]$indexbestmodel]+VGOB1_subsetH_staph_LUR1[,models[[6]]$indexbestmodel]+ VGOB1_subsetH_staph_LUR1[,models[[7]]$indexbestmodel]+ VGOB1_subsetH_staph_LUR1[,i]) 
#     R2<-rbind(R2,summary(modeltry)$adj.r.squared)
#     # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
#     betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
#     #  find out if there is a negative beta at All. The intercept does not count [-1]!
#     minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
#     # Measurements_livestockpreds_LUR1[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR1)[i]
#     addedvar<-rbind(addedvar,names(VGOB1_subsetH_staph_LUR1)[i])
#     j<-rbind(j, i)
#     models[[modeln]][[i]]<-summary(modeltry)
#   }
# }
# 
# models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)
# 
# #  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
# models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)
# 
# # rank the R2's of these models
# models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))
# 
# #  this is the index of the row with the highest R2 and  no negative betas in this subset
# models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j
# 
# subset(models[[modeln]]$resultspos, rank==1)
# 
# # this is the model
# models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]
# 
# # here are the names
# models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetH_staph_LUR1)[models[[1]]$indexbestmodel], names(VGOB1_subsetH_staph_LUR1)[models[[2]]$indexbestmodel] , names(VGOB1_subsetH_staph_LUR1)[models[[3]]$indexbestmodel], names(VGOB1_subsetH_staph_LUR1)[models[[4]]$indexbestmodel], names(VGOB1_subsetH_staph_LUR1)[models[[5]]$indexbestmodel], names(VGOB1_subsetH_staph_LUR1)[models[[6]]$indexbestmodel], names(VGOB1_subsetH_staph_LUR1)[models[[7]]$indexbestmodel], names(VGOB1_subsetH_staph_LUR1)[models[[8]]$indexbestmodel])
# 
# #  this is the r2 or that model
# models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2
# 
# #  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
# models[[modeln]]$bestmodel <- lm(VGOB1_subsetH_staph_LUR1$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetH_staph_LUR1[,models[[1]]$indexbestmodel]+VGOB1_subsetH_staph_LUR1[,models[[2]]$indexbestmodel]+VGOB1_subsetH_staph_LUR1[,models[[3]]$indexbestmodel]+ VGOB1_subsetH_staph_LUR1[,models[[4]]$indexbestmodel]+ VGOB1_subsetH_staph_LUR1[,models[[5]]$indexbestmodel]+ VGOB1_subsetH_staph_LUR1[,models[[6]]$indexbestmodel]+ VGOB1_subsetH_staph_LUR1[,models[[7]]$indexbestmodel]+ VGOB1_subsetH_staph_LUR1[,models[[8]]$indexbestmodel]) 
# 
# models[[1]]$summarybestmodel
# models[[2]]$summarybestmodel
# models[[3]]$summarybestmodel
# models[[4]]$summarybestmodel
# models[[5]]$summarybestmodel
# models[[6]]$summarybestmodel
# models[[7]]$summarybestmodel
# models[[8]]$summarybestmodel
# models[[1]]$namesbestmodel
# models[[2]]$namesbestmodel
# models[[3]]$namesbestmodel
# models[[4]]$namesbestmodel
# models[[5]]$namesbestmodel
# models[[6]]$namesbestmodel
# models[[7]]$namesbestmodel
# models[[8]]$namesbestmodel
# models[[1]]$R2bestmodel
# models[[2]]$R2bestmodel
# models[[3]]$R2bestmodel
# models[[4]]$R2bestmodel
# models[[5]]$R2bestmodel
# models[[6]]$R2bestmodel
# models[[7]]$R2bestmodel
# models[[8]]$R2bestmodel


#   CODE FOR PICKING OUT THE BEST MODEL #   
temp <- 0
besti <- 0
for (i in 1:10){ #  think this runs the loop 10 times - not fully sure thought - but not to do with the number of models I don't think - as when I change to 3, I still get the model with 4 variables as best model
  print(models[[i]]$R2bestmodel)
  #       print(models[[i]]$summarybestmodel$coefficients=-1,4])
  #       if((models[[i]]$R2bestmodel-temp > 0.0) && (all(models[[i]]$summarybestmodel$coefficients[-1,4]<0.1))){
  #         temp <- models[[i]]$R2bestmodel
  #         besti <- i
  #         }
  if((models[[i]]$R2bestmodel-temp > 0.0) && (all(models[[i]]$summarybestmodel$coefficients[-1,4]<0.1))){
    temp <- models[[i]]$R2bestmodel
    besti <- i
  }else{
    finalBestModel_staph_LUR1_subsetH <- models[[besti]]$bestmodel
    finalBestModelNames_staph_subsetH <- models[[besti]]$namesbestmodel
    Sites <- 1:dim(VGOB1_subsetH_staph_LUR1)[1] # full original model
    #  CVaR2<-escCV_staph_LUR1(Sites)[2] # Cross Validation
    maxCD<-max(cooks.distance(finalBestModel_staph_LUR1_subsetH))
    if(length(finalBestModelNames_staph_subsetH)<2){ # vif fn doesnot work when only 1 variable...       # 
      maxVIF<-"NA"
    }else{
      maxVIF<-max(vif(finalBestModel_staph_LUR1_subsetH))
    }
    print(paste("This is the best staph model for subset H: ",besti,
                "(AdjR2: ",format(models[[besti]]$R2bestmodel,digits=3), "; MaxCD: ",format(maxCD,digits=3),"; MaxVIF: ",
                format(maxVIF,digits=3),")", sep=''))
    print(finalBestModelNames_staph_subsetH)
    break
  }
}

#  Overview of the final best model using the algorithm selection process (taking into account VIF, R^2, and p-values)
finalBestModel_staph_LUR1_subsetH
finalBestModelNames_staph_subsetH
models[[besti]]$summarybestmodel
models[[besti]]$R2bestmodel


#### I ####
# LUR model building process for subset I
#  This is the dataframe with the relevant predictor vars for LUR1 models for subset I (55 sites)
VGOB1_subsetI_staph_LUR1 # n.b. this dataframe only includes microbial marker concentrations for staph unlike the dataframe Measurements_livestockpreds_LUR1 as previously used for the model building. 

#  Now set the values of some variables that will be needed
nfirstvar_LUR_1 <- 3  
nlastvar_LUR_1 <- 10

# Function building to run the models 
# 1 #  

models<-list()
modeln<-1
models[[modeln]]<-list()

R2<-1
betaaddedvar<-1
addedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_1:nlastvar_LUR_1){
  if (is.numeric(VGOB1_subsetI_staph_LUR1[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetI_staph_LUR1$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetI_staph_LUR1[,i])                            
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    #  Measurements_livestockpreds_LUR1[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR1)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetI_staph_LUR1)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)
models[[modeln]]$results

#  this are the candidates models with the highest R2, not a negative beta for the new, nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)
models[[modeln]]$resultspos

#  rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))
models[[modeln]]$resultspos

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j
models[[modeln]]$indexbestmodel

subset(models[[modeln]]$resultspos, rank==1)
subset(models[[modeln]]$resultspos)

#  this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]
models[[modeln]]$summarybestmodel

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetI_staph_LUR1)[models[[1]]$indexbestmodel])
models[[modeln]]$namesbestmodel

#  this is the r2 of that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2
models[[modeln]]$R2bestmodel

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetI_staph_LUR1$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetI_staph_LUR1[,models[[1]]$indexbestmodel]) 
models[[modeln]]$bestmodel

summary(models[[modeln]]$bestmodel)

#  The first model includes the predictor: nPigMultipFarmWghtDist.3000m.sum.Tr.1P9 - meaning the number of multiplier pig farms weighted to distance in a 3000m buffer

# 2 #  
# Add 2nd variable (the only difference of the above part is that now modeln=2 the model statement has 2 variables)
# and the call for the list of variable names in the model changed slightly

modeln<-2

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_1:nlastvar_LUR_1){
  if (is.numeric(VGOB1_subsetI_staph_LUR1[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetI_staph_LUR1$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetI_staph_LUR1[,models[[1]]$indexbestmodel]+ VGOB1_subsetI_staph_LUR1[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # Measurements_livestockpreds_LUR1[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR1)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetI_staph_LUR1)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  these are the candidate models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)
models[[modeln]]$resultspos

#  rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))
models[[modeln]]$resultspos

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j
models[[modeln]]$indexbestmodel

subset(models[[modeln]]$resultspos, rank==1)

# this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]
models[[modeln]]$summarybestmodel

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetI_staph_LUR1)[models[[1]]$indexbestmodel], names(VGOB1_subsetI_staph_LUR1)[models[[2]]$indexbestmodel] )
models[[modeln]]$namesbestmodel

# this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2
models[[modeln]]$R2bestmodel

# this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetI_staph_LUR1$staph_copiespm3.ln.diffmeth.mean~                               VGOB1_subsetI_staph_LUR1[,models[[1]]$indexbestmodel]+                           VGOB1_subsetI_staph_LUR1[,models[[2]]$indexbestmodel]) 

models[[modeln]]$bestmodel

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel


# The next part of the code (n=3-8) does not work
# This is because one of the coefficients included in the model with 6 variables is negative, the code does not allow for this. I can stop here.

# # 3 #  
# # add third variable (the only difference of the above part is that now modeln=3 the model statement has 3 variables)
# # and the call for the list of variable names in the model changed slightly
# 
# modeln<-3
# 
# models[[modeln]]<-list()
# 
# R2<-1
# addedvar<-1
# betaaddedvar<-1
# minbetas<-1
# j<-1
# 
# for (i in nfirstvar_LUR_1:nlastvar_LUR_1){
#   if (is.numeric(VGOB1_subsetI_staph_LUR1[,i])==TRUE){  
#     modeltry<-lm(VGOB1_subsetI_staph_LUR1$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetI_staph_LUR1[,models[[1]]$indexbestmodel]+VGOB1_subsetI_staph_LUR1[,models[[2]]$indexbestmodel]+ VGOB1_subsetI_staph_LUR1[,i]) 
#     R2<-rbind(R2,summary(modeltry)$adj.r.squared)
#     # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
#     betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
#     #  find out if there is a negative beta at All. The intercept does not count [-1]!
#     minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
#     # All[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR1)[i]
#     addedvar<-rbind(addedvar,names(VGOB1_subsetI_staph_LUR1)[i])
#     j<-rbind(j, i)
#     models[[modeln]][[i]]<-summary(modeltry)
#   }
# }
# 
# models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)
# 
# #  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
# models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)
# 
# #  rank the R2's of these models
# models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))
# 
# #  this is the index of the row with the highest R2 and  no negative betas in this subset
# models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j
# 
# subset(models[[modeln]]$resultspos, rank==1)
# 
# #  this is the model
# models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]
# 
# #  here are the names
# models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetI_staph_LUR1)[models[[1]]$indexbestmodel], names(VGOB1_subsetI_staph_LUR1)[models[[2]]$indexbestmodel], names(VGOB1_subsetI_staph_LUR1)[models[[3]]$indexbestmodel])
# 
# #  this is the r2 or that model
# models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2
# 
# #  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
# models[[modeln]]$bestmodel <- lm(VGOB1_subsetI_staph_LUR1$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetI_staph_LUR1[,models[[1]]$indexbestmodel]+ VGOB1_subsetI_staph_LUR1[,models[[2]]$indexbestmodel]+ VGOB1_subsetI_staph_LUR1[,models[[3]]$indexbestmodel]) 
# 
# models[[1]]$summarybestmodel
# models[[2]]$summarybestmodel
# models[[3]]$summarybestmodel
# models[[1]]$namesbestmodel
# models[[2]]$namesbestmodel
# models[[3]]$namesbestmodel
# models[[1]]$R2bestmodel
# models[[2]]$R2bestmodel
# models[[3]]$R2bestmodel
# 
# 
# # 4 #  
# #  add forth variable (the only difference of the above part is that now model n=4 the model statement more variables)
# #  and the call for the list of variable names in the model changed slightly
# modeln<-4
# 
# models[[modeln]]<-list()
# 
# R2<-1
# addedvar<-1
# betaaddedvar<-1
# minbetas<-1
# j<-1
# 
# 
# for (i in nfirstvar_LUR_1:nlastvar_LUR_1){
#   if (is.numeric(VGOB1_subsetI_staph_LUR1[,i])==TRUE){
#     modeltry<-lm(VGOB1_subsetI_staph_LUR1$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetI_staph_LUR1[,models[[1]]$indexbestmodel]+VGOB1_subsetI_staph_LUR1[,models[[2]]$indexbestmodel]+VGOB1_subsetI_staph_LUR1[,models[[3]]$indexbestmodel]+VGOB1_subsetI_staph_LUR1[,i]) 
#     R2<-rbind(R2,summary(modeltry)$adj.r.squared)
#     #  the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
#     betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])
#     #  find out if there is a negative beta at All. The intercept does not count [-1]!
#     minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
#     #  All[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR1)[i]
#     addedvar<-rbind(addedvar,names(VGOB1_subsetI_staph_LUR1)[i])
#     j<-rbind(j, i)
#     models[[modeln]][[i]]<-summary(modeltry)
#   }
# }
# 
# models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)
# 
# #  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
# models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)
# 
# # rank the R2's of these models
# models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))
# 
# #  this is the index of the row with the highest R2 and  no negative betas in this subset
# models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j
# 
# subset(models[[modeln]]$resultspos, rank==1)
# 
# #  this is the model
# models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]
# 
# #  here are the names
# models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetI_staph_LUR1)[models[[1]]$indexbestmodel], names(VGOB1_subsetI_staph_LUR1)[models[[2]]$indexbestmodel], names(VGOB1_subsetI_staph_LUR1)[models[[3]]$indexbestmodel], names(VGOB1_subsetI_staph_LUR1)[models[[4]]$indexbestmodel])
# 
# #  this is the r2 of that model
# models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2
# 
# #  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
# models[[modeln]]$bestmodel <- lm(VGOB1_subsetI_staph_LUR1$staph_copiespm3.ln.diffmeth.mean~ VGOB1_subsetI_staph_LUR1[,models[[1]]$indexbestmodel]+ VGOB1_subsetI_staph_LUR1[,models[[2]]$indexbestmodel]+VGOB1_subsetI_staph_LUR1[,models[[3]]$indexbestmodel]+ VGOB1_subsetI_staph_LUR1[,models[[4]]$indexbestmodel]) 
# 
# 
# models[[1]]$summarybestmodel
# models[[2]]$summarybestmodel
# models[[3]]$summarybestmodel
# models[[4]]$summarybestmodel
# models[[1]]$namesbestmodel
# models[[2]]$namesbestmodel
# models[[3]]$namesbestmodel
# models[[4]]$namesbestmodel
# models[[1]]$R2bestmodel
# models[[2]]$R2bestmodel
# models[[3]]$R2bestmodel
# models[[4]]$R2bestmodel
# 
# 
# # 5 #  
# # add fifth variable (the only difference of the above part is that now modeln=5 the model statement more variables)
# # and the call for the list of variable names in the model changed slightly
# modeln<-5
# 
# models[[modeln]]<-list()
# 
# R2<-1
# addedvar<-1
# betaaddedvar<-1
# minbetas<-1
# j<-1
# 
# for (i in nfirstvar_LUR_1:nlastvar_LUR_1){
#   if (is.numeric(VGOB1_subsetI_staph_LUR1[,i])==TRUE){
#     modeltry<-lm(VGOB1_subsetI_staph_LUR1$staph_copiespm3.ln.diffmeth.mean~ VGOB1_subsetI_staph_LUR1[,models[[1]]$indexbestmodel]+ VGOB1_subsetI_staph_LUR1[,models[[2]]$indexbestmodel]+ VGOB1_subsetI_staph_LUR1[,models[[3]]$indexbestmodel]+ VGOB1_subsetI_staph_LUR1[,models[[4]]$indexbestmodel]+ VGOB1_subsetI_staph_LUR1[,i]) 
#   
# R2<-rbind(R2,summary(modeltry)$adj.r.squared)
# # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
#     betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
#     #  find out if there is a negative beta at All. The intercept does not count [-1]!
#     minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
#     # All[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR1)[i]
#     addedvar<-rbind(addedvar,names(VGOB1_subsetI_staph_LUR1)[i])
#     j<-rbind(j, i)
#     models[[modeln]][[i]]<-summary(modeltry)
#   }
# }
# 
# models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)
# 
# #  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
# models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)
# 
# # rank the R2's of these models
# models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))
# 
# #  this is the index of the row with the highest R2 and  no negative betas in this subset
# models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j
# 
# subset(models[[modeln]]$resultspos, rank==1)
# 
# #  this is the model
# models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]
# 
# # here are the names
# models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetI_staph_LUR1)[models[[1]]$indexbestmodel], names(VGOB1_subsetI_staph_LUR1)[models[[2]]$indexbestmodel], names(VGOB1_subsetI_staph_LUR1)[models[[3]]$indexbestmodel], names(VGOB1_subsetI_staph_LUR1)[models[[4]]$indexbestmodel], names(VGOB1_subsetI_staph_LUR1)[models[[5]]$indexbestmodel])
# 
# #  this is the r2 or that model
# models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2
# 
# #  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
# models[[modeln]]$bestmodel <- lm(VGOB1_subsetI_staph_LUR1$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetI_staph_LUR1[,models[[1]]$indexbestmodel]+VGOB1_subsetI_staph_LUR1[,models[[2]]$indexbestmodel]+VGOB1_subsetI_staph_LUR1[,models[[3]]$indexbestmodel]+ VGOB1_subsetI_staph_LUR1[,models[[4]]$indexbestmodel]+ VGOB1_subsetI_staph_LUR1[,models[[5]]$indexbestmodel]) 
# models[[1]]$summarybestmodel
# models[[2]]$summarybestmodel
# models[[3]]$summarybestmodel
# models[[4]]$summarybestmodel
# models[[5]]$summarybestmodel
# models[[1]]$namesbestmodel
# models[[2]]$namesbestmodel
# models[[3]]$namesbestmodel
# models[[4]]$namesbestmodel
# models[[5]]$namesbestmodel
# models[[1]]$R2bestmodel
# models[[2]]$R2bestmodel
# models[[3]]$R2bestmodel
# models[[4]]$R2bestmodel
# models[[5]]$R2bestmodel
# 
# # 6 #  
# # add sixth variable (the only difference of the above part is that now model n=6 the model statement more variables)
# #  and the call for the list of variable names in the model changed slightly
# 
# modeln<-6
# 
# models[[modeln]]<-list()
# 
# R2<-1
# addedvar<-1
# betaaddedvar<-1
# minbetas<-1
# j<-1
# 
# for (i in nfirstvar_LUR_1 :nlastvar_LUR_1){
#   if (is.numeric(VGOB1_subsetI_staph_LUR1[,i])==TRUE){
#     modeltry<-lm(VGOB1_subsetI_staph_LUR1$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetI_staph_LUR1[,models[[1]]$indexbestmodel]+VGOB1_subsetI_staph_LUR1[,models[[2]]$indexbestmodel]+VGOB1_subsetI_staph_LUR1[,models[[3]]$indexbestmodel]+VGOB1_subsetI_staph_LUR1[,models[[4]]$indexbestmodel]+VGOB1_subsetI_staph_LUR1[,models[[5]]$indexbestmodel]+ VGOB1_subsetI_staph_LUR1[,i]) 
#     R2<-rbind(R2,summary(modeltry)$adj.r.squared)
#     # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
#     betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
#     #  find out if there is a negative beta at All. The intercept does not count [-1]!
#     minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
#     # All[,i] is the row that's being tried out now. the name of that row can be found in  names(All)[i]
#     addedvar<-rbind(addedvar,names(VGOB1_subsetI_staph_LUR1)[i])
#     j<-rbind(j, i)
#     models[[modeln]][[i]]<-summary(modeltry)
#   }
# }
# 
# models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)
# 
# #  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
# models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)
# 
# # rank the R2's of these models
# models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))
# 
# #  this is the index of the row with the highest R2 and  no negative betas in this subset
# models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j
# 
# subset(models[[modeln]]$resultspos, rank==1)
# 
# # this is the model
# models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]
# 
# # here are the names
# models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetI_staph_LUR1)[models[[1]]$indexbestmodel], names(VGOB1_subsetI_staph_LUR1)[models[[2]]$indexbestmodel] , names(VGOB1_subsetI_staph_LUR1)[models[[3]]$indexbestmodel], names(VGOB1_subsetI_staph_LUR1)[models[[4]]$indexbestmodel], names(VGOB1_subsetI_staph_LUR1)[models[[5]]$indexbestmodel], names(VGOB1_subsetI_staph_LUR1)[models[[6]]$indexbestmodel])
# 
# #  this is the r2 or that model
# models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2
# 
# #  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
# models[[modeln]]$bestmodel <- lm(VGOB1_subsetI_staph_LUR1$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetI_staph_LUR1[,models[[1]]$indexbestmodel]+VGOB1_subsetI_staph_LUR1[,models[[2]]$indexbestmodel]+VGOB1_subsetI_staph_LUR1[,models[[3]]$indexbestmodel]+ VGOB1_subsetI_staph_LUR1[,models[[4]]$indexbestmodel]+ VGOB1_subsetI_staph_LUR1[,models[[5]]$indexbestmodel]+ VGOB1_subsetI_staph_LUR1[,models[[6]]$indexbestmodel]) 
# 
# models[[1]]$summarybestmodel
# models[[2]]$summarybestmodel
# models[[3]]$summarybestmodel
# models[[4]]$summarybestmodel
# models[[5]]$summarybestmodel
# models[[6]]$summarybestmodel
# models[[1]]$namesbestmodel
# models[[2]]$namesbestmodel
# models[[3]]$namesbestmodel
# models[[4]]$namesbestmodel
# models[[5]]$namesbestmodel
# models[[6]]$namesbestmodel
# models[[1]]$R2bestmodel
# models[[2]]$R2bestmodel
# models[[3]]$R2bestmodel
# models[[4]]$R2bestmodel
# models[[5]]$R2bestmodel
# models[[6]]$R2bestmodel
# 
# 
# # 7 #  
# # add seventh variable (the only difference of the above part is that now model n=7 the model statement more variables)
# #  and the call for the list of variable names in the model changed slightly
# 
# modeln<-7
# 
# models[[modeln]]<-list()
# 
# R2<-1
# addedvar<-1
# betaaddedvar<-1
# minbetas<-1
# j<-1
# 
# for (i in nfirstvar_LUR_1 :nlastvar_LUR_1){
#   if (is.numeric(VGOB1_subsetI_staph_LUR1[,i])==TRUE){
#     modeltry<-lm(VGOB1_subsetI_staph_LUR1$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetI_staph_LUR1[,models[[1]]$indexbestmodel]+VGOB1_subsetI_staph_LUR1[,models[[2]]$indexbestmodel]+VGOB1_subsetI_staph_LUR1[,models[[3]]$indexbestmodel]+VGOB1_subsetI_staph_LUR1[,models[[4]]$indexbestmodel]+VGOB1_subsetI_staph_LUR1[,models[[5]]$indexbestmodel]+VGOB1_subsetI_staph_LUR1[,models[[6]]$indexbestmodel]+ VGOB1_subsetI_staph_LUR1[,i]) 
#     R2<-rbind(R2,summary(modeltry)$adj.r.squared)
#     # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
#     betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
#     #  find out if there is a negative beta at All. The intercept does not count [-1]!
#     minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
#     # Measurements_livestockpreds_LUR1[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR1)[i]
#     addedvar<-rbind(addedvar,names(VGOB1_subsetI_staph_LUR1)[i])
#     j<-rbind(j, i)
#     models[[modeln]][[i]]<-summary(modeltry)
#   }
# }
# 
# models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)
# 
# #  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
# models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)
# 
# # rank the R2's of these models
# models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))
# 
# #  this is the index of the row with the highest R2 and  no negative betas in this subset
# models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j
# 
# subset(models[[modeln]]$resultspos, rank==1)
# 
# # this is the model
# models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]
# 
# # here are the names
# models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetI_staph_LUR1)[models[[1]]$indexbestmodel], names(VGOB1_subsetI_staph_LUR1)[models[[2]]$indexbestmodel] , names(VGOB1_subsetI_staph_LUR1)[models[[3]]$indexbestmodel], names(VGOB1_subsetI_staph_LUR1)[models[[4]]$indexbestmodel], names(VGOB1_subsetI_staph_LUR1)[models[[5]]$indexbestmodel], names(VGOB1_subsetI_staph_LUR1)[models[[6]]$indexbestmodel], names(VGOB1_subsetI_staph_LUR1)[models[[7]]$indexbestmodel])
# 
# #  this is the r2 or that model
# models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2
# 
# #  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
# models[[modeln]]$bestmodel <- lm(VGOB1_subsetI_staph_LUR1$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetI_staph_LUR1[,models[[1]]$indexbestmodel]+VGOB1_subsetI_staph_LUR1[,models[[2]]$indexbestmodel]+VGOB1_subsetI_staph_LUR1[,models[[3]]$indexbestmodel]+ VGOB1_subsetI_staph_LUR1[,models[[4]]$indexbestmodel]+ VGOB1_subsetI_staph_LUR1[,models[[5]]$indexbestmodel]+ VGOB1_subsetI_staph_LUR1[,models[[6]]$indexbestmodel]+ VGOB1_subsetI_staph_LUR1[,models[[7]]$indexbestmodel]) 
# 
# models[[1]]$summarybestmodel
# models[[2]]$summarybestmodel
# models[[3]]$summarybestmodel
# models[[4]]$summarybestmodel
# models[[5]]$summarybestmodel
# models[[6]]$summarybestmodel
# models[[7]]$summarybestmodel
# models[[1]]$namesbestmodel
# models[[2]]$namesbestmodel
# models[[3]]$namesbestmodel
# models[[4]]$namesbestmodel
# models[[5]]$namesbestmodel
# models[[6]]$namesbestmodel
# models[[7]]$namesbestmodel
# models[[1]]$R2bestmodel
# models[[2]]$R2bestmodel
# models[[3]]$R2bestmodel
# models[[4]]$R2bestmodel
# models[[5]]$R2bestmodel
# models[[6]]$R2bestmodel
# models[[7]]$R2bestmodel
# 
# # 8 #  
# # add eighth variable (the only difference of the above part is that now modeln=7 the model statement more variables)
# # and the call for the list of variable names in the model changed slightly
# 
# modeln<-8
# 
# models[[modeln]]<-list()
# 
# R2<-1
# addedvar<-1
# betaaddedvar<-1
# minbetas<-1
# j<-1
# 
# for (i in nfirstvar_LUR_1 :nlastvar_LUR_1){
#   if (is.numeric(VGOB1_subsetI_staph_LUR1[,i])==TRUE){
#     modeltry<-lm(VGOB1_subsetI_staph_LUR1$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetI_staph_LUR1[,models[[1]]$indexbestmodel]+VGOB1_subsetI_staph_LUR1[,models[[2]]$indexbestmodel]+VGOB1_subsetI_staph_LUR1[,models[[3]]$indexbestmodel]+VGOB1_subsetI_staph_LUR1[,models[[4]]$indexbestmodel]+VGOB1_subsetI_staph_LUR1[,models[[5]]$indexbestmodel]+VGOB1_subsetI_staph_LUR1[,models[[6]]$indexbestmodel]+ VGOB1_subsetI_staph_LUR1[,models[[7]]$indexbestmodel]+ VGOB1_subsetI_staph_LUR1[,i]) 
#     R2<-rbind(R2,summary(modeltry)$adj.r.squared)
#     # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
#     betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
#     #  find out if there is a negative beta at All. The intercept does not count [-1]!
#     minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
#     # Measurements_livestockpreds_LUR1[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR1)[i]
#     addedvar<-rbind(addedvar,names(VGOB1_subsetI_staph_LUR1)[i])
#     j<-rbind(j, i)
#     models[[modeln]][[i]]<-summary(modeltry)
#   }
# }
# 
# models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)
# 
# #  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
# models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)
# 
# # rank the R2's of these models
# models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))
# 
# #  this is the index of the row with the highest R2 and  no negative betas in this subset
# models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j
# 
# subset(models[[modeln]]$resultspos, rank==1)
# 
# # this is the model
# models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]
# 
# # here are the names
# models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetI_staph_LUR1)[models[[1]]$indexbestmodel], names(VGOB1_subsetI_staph_LUR1)[models[[2]]$indexbestmodel] , names(VGOB1_subsetI_staph_LUR1)[models[[3]]$indexbestmodel], names(VGOB1_subsetI_staph_LUR1)[models[[4]]$indexbestmodel], names(VGOB1_subsetI_staph_LUR1)[models[[5]]$indexbestmodel], names(VGOB1_subsetI_staph_LUR1)[models[[6]]$indexbestmodel], names(VGOB1_subsetI_staph_LUR1)[models[[7]]$indexbestmodel], names(VGOB1_subsetI_staph_LUR1)[models[[8]]$indexbestmodel])
# 
# #  this is the r2 or that model
# models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2
# 
# #  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
# models[[modeln]]$bestmodel <- lm(VGOB1_subsetI_staph_LUR1$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetI_staph_LUR1[,models[[1]]$indexbestmodel]+VGOB1_subsetI_staph_LUR1[,models[[2]]$indexbestmodel]+VGOB1_subsetI_staph_LUR1[,models[[3]]$indexbestmodel]+ VGOB1_subsetI_staph_LUR1[,models[[4]]$indexbestmodel]+ VGOB1_subsetI_staph_LUR1[,models[[5]]$indexbestmodel]+ VGOB1_subsetI_staph_LUR1[,models[[6]]$indexbestmodel]+ VGOB1_subsetI_staph_LUR1[,models[[7]]$indexbestmodel]+ VGOB1_subsetI_staph_LUR1[,models[[8]]$indexbestmodel]) 
# 
# models[[1]]$summarybestmodel
# models[[2]]$summarybestmodel
# models[[3]]$summarybestmodel
# models[[4]]$summarybestmodel
# models[[5]]$summarybestmodel
# models[[6]]$summarybestmodel
# models[[7]]$summarybestmodel
# models[[8]]$summarybestmodel
# models[[1]]$namesbestmodel
# models[[2]]$namesbestmodel
# models[[3]]$namesbestmodel
# models[[4]]$namesbestmodel
# models[[5]]$namesbestmodel
# models[[6]]$namesbestmodel
# models[[7]]$namesbestmodel
# models[[8]]$namesbestmodel
# models[[1]]$R2bestmodel
# models[[2]]$R2bestmodel
# models[[3]]$R2bestmodel
# models[[4]]$R2bestmodel
# models[[5]]$R2bestmodel
# models[[6]]$R2bestmodel
# models[[7]]$R2bestmodel
# models[[8]]$R2bestmodel

#   CODE FOR PICKING OUT THE BEST MODEL #   
temp <- 0
besti <- 0
for (i in 1:10){ #  think this runs the loop 10 times - not fully sure thought - but not to do with the number of models I don't think - as when I change to 3, I still get the model with 4 variables as best model
  print(models[[i]]$R2bestmodel)
  #       print(models[[i]]$summarybestmodel$coefficients=-1,4])
  #       if((models[[i]]$R2bestmodel-temp > 0.0) && (all(models[[i]]$summarybestmodel$coefficients[-1,4]<0.1))){
  #         temp <- models[[i]]$R2bestmodel
  #         besti <- i
  #         }
  if((models[[i]]$R2bestmodel-temp > 0.0) && (all(models[[i]]$summarybestmodel$coefficients[-1,4]<0.1))){
    temp <- models[[i]]$R2bestmodel
    besti <- i
  }else{
    finalBestModel_staph_LUR1_subsetI <- models[[besti]]$bestmodel
    finalBestModelNames_staph_subsetI <- models[[besti]]$namesbestmodel
    Sites <- 1:dim(VGOB1_subsetI_staph_LUR1)[1] # full original model
    #  CVaR2<-escCV_staph_LUR1(Sites)[2] # Cross Validation
    maxCD<-max(cooks.distance(finalBestModel_staph_LUR1_subsetI))
    if(length(finalBestModelNames_staph_subsetI)<2){ # vif fn doesnot work when only 1 variable...       # 
      maxVIF<-"NA"
    }else{
      maxVIF<-max(vif(finalBestModel_staph_LUR1_subsetI))
    }
    print(paste("This is the best staph model for subset I: ",besti,
                "(AdjR2: ",format(models[[besti]]$R2bestmodel,digits=3), "; MaxCD: ",format(maxCD,digits=3),"; MaxVIF: ",
                format(maxVIF,digits=3),")", sep=''))
    print(finalBestModelNames_staph_subsetI)
    break
  }
}

#  Overview of the final best model using the algorithm selection process (taking into account VIF, R^2, and p-values)
finalBestModel_staph_LUR1_subsetI
finalBestModelNames_staph_subsetI
models[[besti]]$summarybestmodel
models[[besti]]$R2bestmodel

#### J ####
# LUR model building process for subset J
#  This is the dataframe with the relevant predictor vars for LUR1 models for subset J (55 sites)
VGOB1_subsetJ_staph_LUR1 # n.b. this dataframe only includes microbial marker concentrations for staph unlike the dataframe Measurements_livestockpreds_LUR1 as previously used for the model building. 

#  Now set the values of some variables that will be needed
nfirstvar_LUR_1 <- 3  
nlastvar_LUR_1 <- 10

# Function building to run the models 
# 1 #  

models<-list()
modeln<-1
models[[modeln]]<-list()

R2<-1
betaaddedvar<-1
addedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_1:nlastvar_LUR_1){
  if (is.numeric(VGOB1_subsetJ_staph_LUR1[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetJ_staph_LUR1$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetJ_staph_LUR1[,i])                            
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    #  Measurements_livestockpreds_LUR1[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR1)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetJ_staph_LUR1)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)
models[[modeln]]$results

#  this are the candidates models with the highest R2, not a negative beta for the new, nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)
models[[modeln]]$resultspos

#  rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))
models[[modeln]]$resultspos

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j
models[[modeln]]$indexbestmodel

subset(models[[modeln]]$resultspos, rank==1)
subset(models[[modeln]]$resultspos)

#  this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]
models[[modeln]]$summarybestmodel

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetJ_staph_LUR1)[models[[1]]$indexbestmodel])
models[[modeln]]$namesbestmodel

#  this is the r2 of that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2
models[[modeln]]$R2bestmodel

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetJ_staph_LUR1$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetJ_staph_LUR1[,models[[1]]$indexbestmodel]) 
models[[modeln]]$bestmodel

summary(models[[modeln]]$bestmodel)

#  The first model includes the predictor: nPigMultipFarmWghtDist.3000m.sum.Tr.1P9 - meaning the number of multiplier pig farms weighted to distance in a 3000m buffer

# 2 #  
# Add 2nd variable (the only difference of the above part is that now modeln=2 the model statement has 2 variables)
# and the call for the list of variable names in the model changed slightly

modeln<-2

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_1:nlastvar_LUR_1){
  if (is.numeric(VGOB1_subsetJ_staph_LUR1[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetJ_staph_LUR1$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetJ_staph_LUR1[,models[[1]]$indexbestmodel]+ VGOB1_subsetJ_staph_LUR1[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # Measurements_livestockpreds_LUR1[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR1)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetJ_staph_LUR1)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  these are the candidate models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)
models[[modeln]]$resultspos

#  rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))
models[[modeln]]$resultspos

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j
models[[modeln]]$indexbestmodel

subset(models[[modeln]]$resultspos, rank==1)

# this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]
models[[modeln]]$summarybestmodel

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetJ_staph_LUR1)[models[[1]]$indexbestmodel], names(VGOB1_subsetJ_staph_LUR1)[models[[2]]$indexbestmodel] )
models[[modeln]]$namesbestmodel

# this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2
models[[modeln]]$R2bestmodel

# this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetJ_staph_LUR1$staph_copiespm3.ln.diffmeth.mean~                               VGOB1_subsetJ_staph_LUR1[,models[[1]]$indexbestmodel]+                           VGOB1_subsetJ_staph_LUR1[,models[[2]]$indexbestmodel]) 

models[[modeln]]$bestmodel

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel


# 3 #  
# add third variable (the only difference of the above part is that now modeln=3 the model statement has 3 variables)
# and the call for the list of variable names in the model changed slightly

modeln<-3

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_1:nlastvar_LUR_1){
  if (is.numeric(VGOB1_subsetJ_staph_LUR1[,i])==TRUE){  
    modeltry<-lm(VGOB1_subsetJ_staph_LUR1$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetJ_staph_LUR1[,models[[1]]$indexbestmodel]+VGOB1_subsetJ_staph_LUR1[,models[[2]]$indexbestmodel]+ VGOB1_subsetJ_staph_LUR1[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # All[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR1)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetJ_staph_LUR1)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

#  rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

#  this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

#  here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetJ_staph_LUR1)[models[[1]]$indexbestmodel], names(VGOB1_subsetJ_staph_LUR1)[models[[2]]$indexbestmodel], names(VGOB1_subsetJ_staph_LUR1)[models[[3]]$indexbestmodel])

#  this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetJ_staph_LUR1$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetJ_staph_LUR1[,models[[1]]$indexbestmodel]+ VGOB1_subsetJ_staph_LUR1[,models[[2]]$indexbestmodel]+ VGOB1_subsetJ_staph_LUR1[,models[[3]]$indexbestmodel]) 

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel


# The next part of the code (n=4-8) does not work
# This is because one of the coefficients included in the model with 6 variables is negative, the code does not allow for this. I can stop here.

# # 4 #  
# #  add forth variable (the only difference of the above part is that now model n=4 the model statement more variables)
# #  and the call for the list of variable names in the model changed slightly
# modeln<-4
# 
# models[[modeln]]<-list()
# 
# R2<-1
# addedvar<-1
# betaaddedvar<-1
# minbetas<-1
# j<-1
# 
# 
# for (i in nfirstvar_LUR_1:nlastvar_LUR_1){
#   if (is.numeric(VGOB1_subsetJ_staph_LUR1[,i])==TRUE){
#     modeltry<-lm(VGOB1_subsetJ_staph_LUR1$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetJ_staph_LUR1[,models[[1]]$indexbestmodel]+VGOB1_subsetJ_staph_LUR1[,models[[2]]$indexbestmodel]+VGOB1_subsetJ_staph_LUR1[,models[[3]]$indexbestmodel]+VGOB1_subsetJ_staph_LUR1[,i]) 
#     R2<-rbind(R2,summary(modeltry)$adj.r.squared)
#     #  the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
#     betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])
#     #  find out if there is a negative beta at All. The intercept does not count [-1]!
#     minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
#     #  All[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR1)[i]
#     addedvar<-rbind(addedvar,names(VGOB1_subsetJ_staph_LUR1)[i])
#     j<-rbind(j, i)
#     models[[modeln]][[i]]<-summary(modeltry)
#   }
# }
# 
# models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)
# 
# #  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
# models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)
# 
# # rank the R2's of these models
# models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))
# 
# #  this is the index of the row with the highest R2 and  no negative betas in this subset
# models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j
# 
# subset(models[[modeln]]$resultspos, rank==1)
# 
# #  this is the model
# models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]
# 
# #  here are the names
# models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetJ_staph_LUR1)[models[[1]]$indexbestmodel], names(VGOB1_subsetJ_staph_LUR1)[models[[2]]$indexbestmodel], names(VGOB1_subsetJ_staph_LUR1)[models[[3]]$indexbestmodel], names(VGOB1_subsetJ_staph_LUR1)[models[[4]]$indexbestmodel])
# 
# #  this is the r2 of that model
# models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2
# 
# #  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
# models[[modeln]]$bestmodel <- lm(VGOB1_subsetJ_staph_LUR1$staph_copiespm3.ln.diffmeth.mean~ VGOB1_subsetJ_staph_LUR1[,models[[1]]$indexbestmodel]+ VGOB1_subsetJ_staph_LUR1[,models[[2]]$indexbestmodel]+VGOB1_subsetJ_staph_LUR1[,models[[3]]$indexbestmodel]+ VGOB1_subsetJ_staph_LUR1[,models[[4]]$indexbestmodel]) 
# 
# 
# models[[1]]$summarybestmodel
# models[[2]]$summarybestmodel
# models[[3]]$summarybestmodel
# models[[4]]$summarybestmodel
# models[[1]]$namesbestmodel
# models[[2]]$namesbestmodel
# models[[3]]$namesbestmodel
# models[[4]]$namesbestmodel
# models[[1]]$R2bestmodel
# models[[2]]$R2bestmodel
# models[[3]]$R2bestmodel
# models[[4]]$R2bestmodel
# 
# 
# # 5 #  
# # add fifth variable (the only difference of the above part is that now modeln=5 the model statement more variables)
# # and the call for the list of variable names in the model changed slightly
# modeln<-5
# 
# models[[modeln]]<-list()
# 
# R2<-1
# addedvar<-1
# betaaddedvar<-1
# minbetas<-1
# j<-1
# 
# for (i in nfirstvar_LUR_1:nlastvar_LUR_1){
#   if (is.numeric(VGOB1_subsetJ_staph_LUR1[,i])==TRUE){
#     modeltry<-lm(VGOB1_subsetJ_staph_LUR1$staph_copiespm3.ln.diffmeth.mean~ VGOB1_subsetJ_staph_LUR1[,models[[1]]$indexbestmodel]+ VGOB1_subsetJ_staph_LUR1[,models[[2]]$indexbestmodel]+ VGOB1_subsetJ_staph_LUR1[,models[[3]]$indexbestmodel]+ VGOB1_subsetJ_staph_LUR1[,models[[4]]$indexbestmodel]+ VGOB1_subsetJ_staph_LUR1[,i]) 
#   
# R2<-rbind(R2,summary(modeltry)$adj.r.squared)
# # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
#     betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
#     #  find out if there is a negative beta at All. The intercept does not count [-1]!
#     minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
#     # All[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR1)[i]
#     addedvar<-rbind(addedvar,names(VGOB1_subsetJ_staph_LUR1)[i])
#     j<-rbind(j, i)
#     models[[modeln]][[i]]<-summary(modeltry)
#   }
# }
# 
# models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)
# 
# #  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
# models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)
# 
# # rank the R2's of these models
# models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))
# 
# #  this is the index of the row with the highest R2 and  no negative betas in this subset
# models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j
# 
# subset(models[[modeln]]$resultspos, rank==1)
# 
# #  this is the model
# models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]
# 
# # here are the names
# models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetJ_staph_LUR1)[models[[1]]$indexbestmodel], names(VGOB1_subsetJ_staph_LUR1)[models[[2]]$indexbestmodel], names(VGOB1_subsetJ_staph_LUR1)[models[[3]]$indexbestmodel], names(VGOB1_subsetJ_staph_LUR1)[models[[4]]$indexbestmodel], names(VGOB1_subsetJ_staph_LUR1)[models[[5]]$indexbestmodel])
# 
# #  this is the r2 or that model
# models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2
# 
# #  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
# models[[modeln]]$bestmodel <- lm(VGOB1_subsetJ_staph_LUR1$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetJ_staph_LUR1[,models[[1]]$indexbestmodel]+VGOB1_subsetJ_staph_LUR1[,models[[2]]$indexbestmodel]+VGOB1_subsetJ_staph_LUR1[,models[[3]]$indexbestmodel]+ VGOB1_subsetJ_staph_LUR1[,models[[4]]$indexbestmodel]+ VGOB1_subsetJ_staph_LUR1[,models[[5]]$indexbestmodel]) 
# models[[1]]$summarybestmodel
# models[[2]]$summarybestmodel
# models[[3]]$summarybestmodel
# models[[4]]$summarybestmodel
# models[[5]]$summarybestmodel
# models[[1]]$namesbestmodel
# models[[2]]$namesbestmodel
# models[[3]]$namesbestmodel
# models[[4]]$namesbestmodel
# models[[5]]$namesbestmodel
# models[[1]]$R2bestmodel
# models[[2]]$R2bestmodel
# models[[3]]$R2bestmodel
# models[[4]]$R2bestmodel
# models[[5]]$R2bestmodel
# 
# # 6 #  
# # add sixth variable (the only difference of the above part is that now model n=6 the model statement more variables)
# #  and the call for the list of variable names in the model changed slightly
# 
# modeln<-6
# 
# models[[modeln]]<-list()
# 
# R2<-1
# addedvar<-1
# betaaddedvar<-1
# minbetas<-1
# j<-1
# 
# for (i in nfirstvar_LUR_1 :nlastvar_LUR_1){
#   if (is.numeric(VGOB1_subsetJ_staph_LUR1[,i])==TRUE){
#     modeltry<-lm(VGOB1_subsetJ_staph_LUR1$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetJ_staph_LUR1[,models[[1]]$indexbestmodel]+VGOB1_subsetJ_staph_LUR1[,models[[2]]$indexbestmodel]+VGOB1_subsetJ_staph_LUR1[,models[[3]]$indexbestmodel]+VGOB1_subsetJ_staph_LUR1[,models[[4]]$indexbestmodel]+VGOB1_subsetJ_staph_LUR1[,models[[5]]$indexbestmodel]+ VGOB1_subsetJ_staph_LUR1[,i]) 
#     R2<-rbind(R2,summary(modeltry)$adj.r.squared)
#     # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
#     betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
#     #  find out if there is a negative beta at All. The intercept does not count [-1]!
#     minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
#     # All[,i] is the row that's being tried out now. the name of that row can be found in  names(All)[i]
#     addedvar<-rbind(addedvar,names(VGOB1_subsetJ_staph_LUR1)[i])
#     j<-rbind(j, i)
#     models[[modeln]][[i]]<-summary(modeltry)
#   }
# }
# 
# models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)
# 
# #  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
# models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)
# 
# # rank the R2's of these models
# models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))
# 
# #  this is the index of the row with the highest R2 and  no negative betas in this subset
# models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j
# 
# subset(models[[modeln]]$resultspos, rank==1)
# 
# # this is the model
# models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]
# 
# # here are the names
# models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetJ_staph_LUR1)[models[[1]]$indexbestmodel], names(VGOB1_subsetJ_staph_LUR1)[models[[2]]$indexbestmodel] , names(VGOB1_subsetJ_staph_LUR1)[models[[3]]$indexbestmodel], names(VGOB1_subsetJ_staph_LUR1)[models[[4]]$indexbestmodel], names(VGOB1_subsetJ_staph_LUR1)[models[[5]]$indexbestmodel], names(VGOB1_subsetJ_staph_LUR1)[models[[6]]$indexbestmodel])
# 
# #  this is the r2 or that model
# models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2
# 
# #  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
# models[[modeln]]$bestmodel <- lm(VGOB1_subsetJ_staph_LUR1$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetJ_staph_LUR1[,models[[1]]$indexbestmodel]+VGOB1_subsetJ_staph_LUR1[,models[[2]]$indexbestmodel]+VGOB1_subsetJ_staph_LUR1[,models[[3]]$indexbestmodel]+ VGOB1_subsetJ_staph_LUR1[,models[[4]]$indexbestmodel]+ VGOB1_subsetJ_staph_LUR1[,models[[5]]$indexbestmodel]+ VGOB1_subsetJ_staph_LUR1[,models[[6]]$indexbestmodel]) 
# 
# models[[1]]$summarybestmodel
# models[[2]]$summarybestmodel
# models[[3]]$summarybestmodel
# models[[4]]$summarybestmodel
# models[[5]]$summarybestmodel
# models[[6]]$summarybestmodel
# models[[1]]$namesbestmodel
# models[[2]]$namesbestmodel
# models[[3]]$namesbestmodel
# models[[4]]$namesbestmodel
# models[[5]]$namesbestmodel
# models[[6]]$namesbestmodel
# models[[1]]$R2bestmodel
# models[[2]]$R2bestmodel
# models[[3]]$R2bestmodel
# models[[4]]$R2bestmodel
# models[[5]]$R2bestmodel
# models[[6]]$R2bestmodel
# 
# 
# # 7 #  
# # add seventh variable (the only difference of the above part is that now model n=7 the model statement more variables)
# #  and the call for the list of variable names in the model changed slightly
# 
# modeln<-7
# 
# models[[modeln]]<-list()
# 
# R2<-1
# addedvar<-1
# betaaddedvar<-1
# minbetas<-1
# j<-1
# 
# for (i in nfirstvar_LUR_1 :nlastvar_LUR_1){
#   if (is.numeric(VGOB1_subsetJ_staph_LUR1[,i])==TRUE){
#     modeltry<-lm(VGOB1_subsetJ_staph_LUR1$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetJ_staph_LUR1[,models[[1]]$indexbestmodel]+VGOB1_subsetJ_staph_LUR1[,models[[2]]$indexbestmodel]+VGOB1_subsetJ_staph_LUR1[,models[[3]]$indexbestmodel]+VGOB1_subsetJ_staph_LUR1[,models[[4]]$indexbestmodel]+VGOB1_subsetJ_staph_LUR1[,models[[5]]$indexbestmodel]+VGOB1_subsetJ_staph_LUR1[,models[[6]]$indexbestmodel]+ VGOB1_subsetJ_staph_LUR1[,i]) 
#     R2<-rbind(R2,summary(modeltry)$adj.r.squared)
#     # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
#     betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
#     #  find out if there is a negative beta at All. The intercept does not count [-1]!
#     minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
#     # Measurements_livestockpreds_LUR1[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR1)[i]
#     addedvar<-rbind(addedvar,names(VGOB1_subsetJ_staph_LUR1)[i])
#     j<-rbind(j, i)
#     models[[modeln]][[i]]<-summary(modeltry)
#   }
# }
# 
# models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)
# 
# #  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
# models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)
# 
# # rank the R2's of these models
# models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))
# 
# #  this is the index of the row with the highest R2 and  no negative betas in this subset
# models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j
# 
# subset(models[[modeln]]$resultspos, rank==1)
# 
# # this is the model
# models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]
# 
# # here are the names
# models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetJ_staph_LUR1)[models[[1]]$indexbestmodel], names(VGOB1_subsetJ_staph_LUR1)[models[[2]]$indexbestmodel] , names(VGOB1_subsetJ_staph_LUR1)[models[[3]]$indexbestmodel], names(VGOB1_subsetJ_staph_LUR1)[models[[4]]$indexbestmodel], names(VGOB1_subsetJ_staph_LUR1)[models[[5]]$indexbestmodel], names(VGOB1_subsetJ_staph_LUR1)[models[[6]]$indexbestmodel], names(VGOB1_subsetJ_staph_LUR1)[models[[7]]$indexbestmodel])
# 
# #  this is the r2 or that model
# models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2
# 
# #  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
# models[[modeln]]$bestmodel <- lm(VGOB1_subsetJ_staph_LUR1$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetJ_staph_LUR1[,models[[1]]$indexbestmodel]+VGOB1_subsetJ_staph_LUR1[,models[[2]]$indexbestmodel]+VGOB1_subsetJ_staph_LUR1[,models[[3]]$indexbestmodel]+ VGOB1_subsetJ_staph_LUR1[,models[[4]]$indexbestmodel]+ VGOB1_subsetJ_staph_LUR1[,models[[5]]$indexbestmodel]+ VGOB1_subsetJ_staph_LUR1[,models[[6]]$indexbestmodel]+ VGOB1_subsetJ_staph_LUR1[,models[[7]]$indexbestmodel]) 
# 
# models[[1]]$summarybestmodel
# models[[2]]$summarybestmodel
# models[[3]]$summarybestmodel
# models[[4]]$summarybestmodel
# models[[5]]$summarybestmodel
# models[[6]]$summarybestmodel
# models[[7]]$summarybestmodel
# models[[1]]$namesbestmodel
# models[[2]]$namesbestmodel
# models[[3]]$namesbestmodel
# models[[4]]$namesbestmodel
# models[[5]]$namesbestmodel
# models[[6]]$namesbestmodel
# models[[7]]$namesbestmodel
# models[[1]]$R2bestmodel
# models[[2]]$R2bestmodel
# models[[3]]$R2bestmodel
# models[[4]]$R2bestmodel
# models[[5]]$R2bestmodel
# models[[6]]$R2bestmodel
# models[[7]]$R2bestmodel
# 
# # 8 #  
# # add eighth variable (the only difference of the above part is that now modeln=7 the model statement more variables)
# # and the call for the list of variable names in the model changed slightly
# 
# modeln<-8
# 
# models[[modeln]]<-list()
# 
# R2<-1
# addedvar<-1
# betaaddedvar<-1
# minbetas<-1
# j<-1
# 
# for (i in nfirstvar_LUR_1 :nlastvar_LUR_1){
#   if (is.numeric(VGOB1_subsetJ_staph_LUR1[,i])==TRUE){
#     modeltry<-lm(VGOB1_subsetJ_staph_LUR1$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetJ_staph_LUR1[,models[[1]]$indexbestmodel]+VGOB1_subsetJ_staph_LUR1[,models[[2]]$indexbestmodel]+VGOB1_subsetJ_staph_LUR1[,models[[3]]$indexbestmodel]+VGOB1_subsetJ_staph_LUR1[,models[[4]]$indexbestmodel]+VGOB1_subsetJ_staph_LUR1[,models[[5]]$indexbestmodel]+VGOB1_subsetJ_staph_LUR1[,models[[6]]$indexbestmodel]+ VGOB1_subsetJ_staph_LUR1[,models[[7]]$indexbestmodel]+ VGOB1_subsetJ_staph_LUR1[,i]) 
#     R2<-rbind(R2,summary(modeltry)$adj.r.squared)
#     # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
#     betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
#     #  find out if there is a negative beta at All. The intercept does not count [-1]!
#     minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
#     # Measurements_livestockpreds_LUR1[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR1)[i]
#     addedvar<-rbind(addedvar,names(VGOB1_subsetJ_staph_LUR1)[i])
#     j<-rbind(j, i)
#     models[[modeln]][[i]]<-summary(modeltry)
#   }
# }
# 
# models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)
# 
# #  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
# models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)
# 
# # rank the R2's of these models
# models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))
# 
# #  this is the index of the row with the highest R2 and  no negative betas in this subset
# models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j
# 
# subset(models[[modeln]]$resultspos, rank==1)
# 
# # this is the model
# models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]
# 
# # here are the names
# models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetJ_staph_LUR1)[models[[1]]$indexbestmodel], names(VGOB1_subsetJ_staph_LUR1)[models[[2]]$indexbestmodel] , names(VGOB1_subsetJ_staph_LUR1)[models[[3]]$indexbestmodel], names(VGOB1_subsetJ_staph_LUR1)[models[[4]]$indexbestmodel], names(VGOB1_subsetJ_staph_LUR1)[models[[5]]$indexbestmodel], names(VGOB1_subsetJ_staph_LUR1)[models[[6]]$indexbestmodel], names(VGOB1_subsetJ_staph_LUR1)[models[[7]]$indexbestmodel], names(VGOB1_subsetJ_staph_LUR1)[models[[8]]$indexbestmodel])
# 
# #  this is the r2 or that model
# models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2
# 
# #  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
# models[[modeln]]$bestmodel <- lm(VGOB1_subsetJ_staph_LUR1$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetJ_staph_LUR1[,models[[1]]$indexbestmodel]+VGOB1_subsetJ_staph_LUR1[,models[[2]]$indexbestmodel]+VGOB1_subsetJ_staph_LUR1[,models[[3]]$indexbestmodel]+ VGOB1_subsetJ_staph_LUR1[,models[[4]]$indexbestmodel]+ VGOB1_subsetJ_staph_LUR1[,models[[5]]$indexbestmodel]+ VGOB1_subsetJ_staph_LUR1[,models[[6]]$indexbestmodel]+ VGOB1_subsetJ_staph_LUR1[,models[[7]]$indexbestmodel]+ VGOB1_subsetJ_staph_LUR1[,models[[8]]$indexbestmodel]) 
# 
# models[[1]]$summarybestmodel
# models[[2]]$summarybestmodel
# models[[3]]$summarybestmodel
# models[[4]]$summarybestmodel
# models[[5]]$summarybestmodel
# models[[6]]$summarybestmodel
# models[[7]]$summarybestmodel
# models[[8]]$summarybestmodel
# models[[1]]$namesbestmodel
# models[[2]]$namesbestmodel
# models[[3]]$namesbestmodel
# models[[4]]$namesbestmodel
# models[[5]]$namesbestmodel
# models[[6]]$namesbestmodel
# models[[7]]$namesbestmodel
# models[[8]]$namesbestmodel
# models[[1]]$R2bestmodel
# models[[2]]$R2bestmodel
# models[[3]]$R2bestmodel
# models[[4]]$R2bestmodel
# models[[5]]$R2bestmodel
# models[[6]]$R2bestmodel
# models[[7]]$R2bestmodel
# models[[8]]$R2bestmodel


#   CODE FOR PICKING OUT THE BEST MODEL #   
temp <- 0
besti <- 0
for (i in 1:10){ #  think this runs the loop 10 times - not fully sure thought - but not to do with the number of models I don't think - as when I change to 3, I still get the model with 4 variables as best model
  print(models[[i]]$R2bestmodel)
  #       print(models[[i]]$summarybestmodel$coefficients=-1,4])
  #       if((models[[i]]$R2bestmodel-temp > 0.0) && (all(models[[i]]$summarybestmodel$coefficients[-1,4]<0.1))){
  #         temp <- models[[i]]$R2bestmodel
  #         besti <- i
  #         }
  if((models[[i]]$R2bestmodel-temp > 0.0) && (all(models[[i]]$summarybestmodel$coefficients[-1,4]<0.1))){
    temp <- models[[i]]$R2bestmodel
    besti <- i
  }else{
    finalBestModel_staph_LUR1_subsetJ <- models[[besti]]$bestmodel
    finalBestModelNames_staph_subsetJ <- models[[besti]]$namesbestmodel
    Sites <- 1:dim(VGOB1_subsetJ_staph_LUR1)[1] # full original model
    #  CVaR2<-escCV_staph_LUR1(Sites)[2] # Cross Validation
    maxCD<-max(cooks.distance(finalBestModel_staph_LUR1_subsetJ))
    if(length(finalBestModelNames_staph_subsetJ)<2){ # vif fn doesnot work when only 1 variable...       # 
      maxVIF<-"NA"
    }else{
      maxVIF<-max(vif(finalBestModel_staph_LUR1_subsetJ))
    }
    print(paste("This is the best staph model for subset J: ",besti,
                "(AdjR2: ",format(models[[besti]]$R2bestmodel,digits=3), "; MaxCD: ",format(maxCD,digits=3),"; MaxVIF: ",
                format(maxVIF,digits=3),")", sep=''))
    print(finalBestModelNames_staph_subsetJ)
    break
  }
}

#  Overview of the final best model using the algorithm selection process (taking into account VIF, R^2, and p-values)
finalBestModel_staph_LUR1_subsetJ
finalBestModelNames_staph_subsetJ
models[[besti]]$summarybestmodel
models[[besti]]$R2bestmodel

#### Predicting hold out sites ####
# These are the models from the 10 subsets: 
finalBestModel_staph_LUR1_subsetA
finalBestModel_staph_LUR1_subsetB
finalBestModel_staph_LUR1_subsetC
finalBestModel_staph_LUR1_subsetD
finalBestModel_staph_LUR1_subsetE
finalBestModel_staph_LUR1_subsetF
finalBestModel_staph_LUR1_subsetG
finalBestModel_staph_LUR1_subsetH
finalBestModel_staph_LUR1_subsetI
finalBestModel_staph_LUR1_subsetJ

#  Selecting of test sets
#  valID 1 to 10
VGOB1_subsetvalID1_staph_LUR1 <- subset(VGOB1_FINAL_staph_LUR1, valID == 1)
VGOB1_subsetvalID2_staph_LUR1 <- subset(VGOB1_FINAL_staph_LUR1, valID == 2)
VGOB1_subsetvalID3_staph_LUR1 <- subset(VGOB1_FINAL_staph_LUR1, valID == 3)
VGOB1_subsetvalID4_staph_LUR1 <- subset(VGOB1_FINAL_staph_LUR1, valID == 4)
VGOB1_subsetvalID5_staph_LUR1 <- subset(VGOB1_FINAL_staph_LUR1, valID == 5)
VGOB1_subsetvalID6_staph_LUR1 <- subset(VGOB1_FINAL_staph_LUR1, valID == 6)
VGOB1_subsetvalID7_staph_LUR1 <- subset(VGOB1_FINAL_staph_LUR1, valID == 7)
VGOB1_subsetvalID8_staph_LUR1 <- subset(VGOB1_FINAL_staph_LUR1, valID == 8)
VGOB1_subsetvalID9_staph_LUR1 <- subset(VGOB1_FINAL_staph_LUR1, valID == 9)
VGOB1_subsetvalID10_staph_LUR1 <- subset(VGOB1_FINAL_staph_LUR1, valID == 10)

#  For every subset predict (based on LUR model for that subset, so the training sites) the concentrations at the sites left out (test sites) to enable comparisons observed vs predicted 

#  Set 1
finalBestModel_staph_LUR1_subsetA
finalBestModelNames_staph_subsetA
summary(finalBestModel_staph_LUR1_subsetA)
# write the model out
finalBestModel_staph_LUR1_subsetA_lm <- lm(staph_copiespm3.ln.diffmeth.mean~  nAnyFarmWghtDist.3000m.sum.95Win.10to90scaled, data = VGOB1_subsetA_staph_LUR1)
VGOB1_subsetvalID1_staph_LUR1$staph_PRED_HV <- predict(finalBestModel_staph_LUR1_subsetA_lm,VGOB1_subsetvalID1_staph_LUR1)
summary(VGOB1_subsetvalID1_staph_LUR1$staph_PRED_HV)
plot(VGOB1_subsetvalID1_staph_LUR1$staph_PRED_HV, VGOB1_subsetvalID1_staph_LUR1$staph_copiespm3.ln.diffmeth.mean, xlab="staph predicted (HV)", ylab="staph concentration observed")
VGOB1_subsetvalID1_staph_LUR1_lm <- lm(staph_copiespm3.ln.diffmeth.mean~staph_PRED_HV, data=VGOB1_subsetvalID1_staph_LUR1 )
summary(VGOB1_subsetvalID1_staph_LUR1_lm)

#  Set 2
finalBestModel_staph_LUR1_subsetB
finalBestModelNames_staph_subsetB
summary(finalBestModel_staph_LUR1_subsetB)
# write the model out
finalBestModel_staph_LUR1_subsetB_lm <- lm(staph_copiespm3.ln.diffmeth.mean~ nAnyFarmWghtDist.3000m.sum.95Win.10to90scaled , data = VGOB1_subsetB_staph_LUR1)
VGOB1_subsetvalID2_staph_LUR1$staph_PRED_HV <- predict(finalBestModel_staph_LUR1_subsetB_lm,VGOB1_subsetvalID2_staph_LUR1)
summary(VGOB1_subsetvalID2_staph_LUR1$staph_PRED_HV)
plot(VGOB1_subsetvalID2_staph_LUR1$staph_PRED_HV, VGOB1_subsetvalID2_staph_LUR1$staph_copiespm3.ln.diffmeth.mean, xlab="staph predicted (HV)", ylab="staph concentration observed")
VGOB1_subsetvalID2_staph_LUR1_lm <- lm(staph_copiespm3.ln.diffmeth.mean~staph_PRED_HV, data=VGOB1_subsetvalID2_staph_LUR1)
summary(VGOB1_subsetvalID2_staph_LUR1_lm)

#  Set 3
finalBestModel_staph_LUR1_subsetC
finalBestModelNames_staph_subsetC
summary(finalBestModel_staph_LUR1_subsetC)
# write the model out
finalBestModel_staph_LUR1_subsetC_lm <- lm(staph_copiespm3.ln.diffmeth.mean~ nAnyFarmWghtDist.3000m.sum.95Win.10to90scaled , data = VGOB1_subsetC_staph_LUR1)
VGOB1_subsetvalID3_staph_LUR1$staph_PRED_HV <- predict(finalBestModel_staph_LUR1_subsetC_lm,VGOB1_subsetvalID3_staph_LUR1)
summary(VGOB1_subsetvalID3_staph_LUR1$staph_PRED_HV)
plot(VGOB1_subsetvalID3_staph_LUR1$staph_PRED_HV, VGOB1_subsetvalID3_staph_LUR1$staph_copiespm3.ln.diffmeth.mean, xlab="staph predicted (HV)", ylab="staph concentration observed")
VGOB1_subsetvalID3_staph_LUR1_lm <- lm(staph_copiespm3.ln.diffmeth.mean~staph_PRED_HV, data=VGOB1_subsetvalID3_staph_LUR1 )
summary(VGOB1_subsetvalID3_staph_LUR1_lm)

#  Set 4
finalBestModel_staph_LUR1_subsetD
finalBestModelNames_staph_subsetD
summary(finalBestModel_staph_LUR1_subsetD)
# write the model out
finalBestModel_staph_LUR1_subsetD_lm <- lm(staph_copiespm3.ln.diffmeth.mean~ nAnyFarmWghtDist.3000m.sum.95Win.10to90scaled, data = VGOB1_subsetD_staph_LUR1)
VGOB1_subsetvalID4_staph_LUR1$staph_PRED_HV <- predict(finalBestModel_staph_LUR1_subsetD_lm,VGOB1_subsetvalID4_staph_LUR1)
summary(VGOB1_subsetvalID4_staph_LUR1$staph_PRED_HV)
plot(VGOB1_subsetvalID4_staph_LUR1$staph_PRED_HV, VGOB1_subsetvalID4_staph_LUR1$staph_copiespm3.ln.diffmeth.mean, xlab="staph predicted (HV)", ylab="staph concentration observed")
VGOB1_subsetvalID4_staph_LUR1_lm <- lm(staph_copiespm3.ln.diffmeth.mean~staph_PRED_HV, data=VGOB1_subsetvalID4_staph_LUR1 )
summary(VGOB1_subsetvalID4_staph_LUR1_lm)

#  Set 5
finalBestModel_staph_LUR1_subsetE
finalBestModelNames_staph_subsetE
summary(finalBestModel_staph_LUR1_subsetE)
# write the model out
finalBestModel_staph_LUR1_subsetE_lm <- lm(staph_copiespm3.ln.diffmeth.mean~ nAnyFarmWghtDist.3000m.sum.95Win.10to90scaled, data = VGOB1_subsetE_staph_LUR1)
VGOB1_subsetvalID5_staph_LUR1$staph_PRED_HV <- predict(finalBestModel_staph_LUR1_subsetE_lm,VGOB1_subsetvalID5_staph_LUR1)
summary(VGOB1_subsetvalID5_staph_LUR1$staph_PRED_HV)
plot(VGOB1_subsetvalID5_staph_LUR1$staph_PRED_HV, VGOB1_subsetvalID5_staph_LUR1$staph_copiespm3.ln.diffmeth.mean, xlab="staph predicted (HV)", ylab="staph concentration observed")
VGOB1_subsetvalID5_staph_LUR1_lm <- lm(staph_copiespm3.ln.diffmeth.mean~staph_PRED_HV, data=VGOB1_subsetvalID5_staph_LUR1)
summary(VGOB1_subsetvalID5_staph_LUR1_lm)

#  Set 6
finalBestModel_staph_LUR1_subsetF
finalBestModelNames_staph_subsetF
summary(finalBestModel_staph_LUR1_subsetF)
# write the model out
finalBestModel_staph_LUR1_subsetF_lm <- lm(staph_copiespm3.ln.diffmeth.mean~ nAnyFarmWghtDist.3000m.sum.95Win.10to90scaled, data = VGOB1_subsetF_staph_LUR1)
VGOB1_subsetvalID6_staph_LUR1$staph_PRED_HV <- predict(finalBestModel_staph_LUR1_subsetF_lm,VGOB1_subsetvalID1_staph_LUR1)
summary(VGOB1_subsetvalID6_staph_LUR1$staph_PRED_HV)
plot(VGOB1_subsetvalID6_staph_LUR1$staph_PRED_HV, VGOB1_subsetvalID6_staph_LUR1$staph_copiespm3.ln.diffmeth.mean, xlab="staph predicted (HV)", ylab="staph concentration observed")
VGOB1_subsetvalID6_staph_LUR1_lm <- lm(staph_copiespm3.ln.diffmeth.mean~staph_PRED_HV, data=VGOB1_subsetvalID6_staph_LUR1 )
summary(VGOB1_subsetvalID6_staph_LUR1_lm)

#  Set 7
finalBestModel_staph_LUR1_subsetG
finalBestModelNames_staph_subsetG
summary(finalBestModel_staph_LUR1_subsetG)
# write the model out
finalBestModel_staph_LUR1_subsetG_lm <- lm(staph_copiespm3.ln.diffmeth.mean~ nAnyFarmWghtDist.3000m.sum.95Win.10to90scaled, data = VGOB1_subsetG_staph_LUR1)
VGOB1_subsetvalID7_staph_LUR1$staph_PRED_HV <- predict(finalBestModel_staph_LUR1_subsetG_lm,VGOB1_subsetvalID7_staph_LUR1)
summary(VGOB1_subsetvalID7_staph_LUR1$staph_PRED_HV)
plot(VGOB1_subsetvalID7_staph_LUR1$staph_PRED_HV, VGOB1_subsetvalID7_staph_LUR1$staph_copiespm3.ln.diffmeth.mean, xlab="staph predicted (HV)", ylab="staph concentration observed")
VGOB1_subsetvalID7_staph_LUR1_lm <- lm(staph_copiespm3.ln.diffmeth.mean~staph_PRED_HV, data=VGOB1_subsetvalID7_staph_LUR1)
summary(VGOB1_subsetvalID7_staph_LUR1_lm)

#  Set 8
finalBestModel_staph_LUR1_subsetH
finalBestModelNames_staph_subsetH
summary(finalBestModel_staph_LUR1_subsetH)
# write the model out
finalBestModel_staph_LUR1_subsetH_lm <- lm(staph_copiespm3.ln.diffmeth.mean~ nAnyFarmWghtDist.3000m.sum.95Win.10to90scaled, data = VGOB1_subsetH_staph_LUR1)
VGOB1_subsetvalID8_staph_LUR1$staph_PRED_HV <- predict(finalBestModel_staph_LUR1_subsetH_lm,VGOB1_subsetvalID8_staph_LUR1)
summary(VGOB1_subsetvalID8_staph_LUR1$staph_PRED_HV)
plot(VGOB1_subsetvalID8_staph_LUR1$staph_PRED_HV, VGOB1_subsetvalID8_staph_LUR1$staph_copiespm3.ln.diffmeth.mean, xlab="staph predicted (HV)", ylab="staph concentration observed")
VGOB1_subsetvalID8_staph_LUR1_lm <- lm(staph_copiespm3.ln.diffmeth.mean~staph_PRED_HV, data=VGOB1_subsetvalID8_staph_LUR1)
summary(VGOB1_subsetvalID8_staph_LUR1_lm)

#  Set 9
finalBestModel_staph_LUR1_subsetI
finalBestModelNames_staph_subsetI
summary(finalBestModel_staph_LUR1_subsetI)
# write the model out
finalBestModel_staph_LUR1_subsetI_lm <- lm(staph_copiespm3.ln.diffmeth.mean~ AllFarm.3000m.95Win.10to90scaled, data = VGOB1_subsetI_staph_LUR1)
VGOB1_subsetvalID9_staph_LUR1$staph_PRED_HV <- predict(finalBestModel_staph_LUR1_subsetI_lm,VGOB1_subsetvalID9_staph_LUR1)
summary(VGOB1_subsetvalID9_staph_LUR1$staph_PRED_HV)
plot(VGOB1_subsetvalID9_staph_LUR1$staph_PRED_HV, VGOB1_subsetvalID9_staph_LUR1$staph_copiespm3.ln.diffmeth.mean, xlab="staph predicted (HV)", ylab="staph concentration observed")
VGOB1_subsetvalID9_staph_LUR1_lm <- lm(staph_copiespm3.ln.diffmeth.mean~staph_PRED_HV, data=VGOB1_subsetvalID9_staph_LUR1 )
summary(VGOB1_subsetvalID9_staph_LUR1_lm)

#  Set 10
finalBestModel_staph_LUR1_subsetJ
finalBestModelNames_staph_subsetJ
summary(finalBestModel_staph_LUR1_subsetJ)
# write the model out
finalBestModel_staph_LUR1_subsetJ_lm <- lm(staph_copiespm3.ln.diffmeth.mean~nAnyFarmWghtDist.3000m.sum.95Win.10to90scaled, data = VGOB1_subsetJ_staph_LUR1)
VGOB1_subsetvalID10_staph_LUR1$staph_PRED_HV <- predict(finalBestModel_staph_LUR1_subsetJ_lm,VGOB1_subsetvalID10_staph_LUR1)
summary(VGOB1_subsetvalID10_staph_LUR1$staph_PRED_HV)
plot(VGOB1_subsetvalID10_staph_LUR1$staph_PRED_HV, VGOB1_subsetvalID10_staph_LUR1$staph_copiespm3.ln.diffmeth.mean, xlab="staph predicted (HV)", ylab="staph concentration observed")
VGOB1_subsetvalID10_staph_LUR1_lm <- lm(staph_copiespm3.ln.diffmeth.mean~staph_PRED_HV, data=VGOB1_subsetvalID10_staph_LUR1)
summary(VGOB1_subsetvalID10_staph_LUR1_lm)

# Calculate max VIF and cook's distnace of each subset (each fold of the 10-fold CV)
# Since all models only include 1 variable, VIF is not possible to calculate
maxCD_staph_LUR1_subsetA <- max(cooks.distance(finalBestModel_staph_LUR1_subsetA))
maxCD_staph_LUR1_subsetB <- max(cooks.distance(finalBestModel_staph_LUR1_subsetB))
maxCD_staph_LUR1_subsetC <- max(cooks.distance(finalBestModel_staph_LUR1_subsetC))
maxCD_staph_LUR1_subsetD <- max(cooks.distance(finalBestModel_staph_LUR1_subsetD))
maxCD_staph_LUR1_subsetE <- max(cooks.distance(finalBestModel_staph_LUR1_subsetE))
maxCD_staph_LUR1_subsetF <- max(cooks.distance(finalBestModel_staph_LUR1_subsetF))
maxCD_staph_LUR1_subsetG <- max(cooks.distance(finalBestModel_staph_LUR1_subsetG))
maxCD_staph_LUR1_subsetH <- max(cooks.distance(finalBestModel_staph_LUR1_subsetH))
maxCD_staph_LUR1_subsetI <- max(cooks.distance(finalBestModel_staph_LUR1_subsetI))
maxCD_staph_LUR1_subsetJ <- max(cooks.distance(finalBestModel_staph_LUR1_subsetJ))

staph_LUR1_maxCD_subsetvalID1to10 <- c(maxCD_staph_LUR1_subsetA, maxCD_staph_LUR1_subsetB, maxCD_staph_LUR1_subsetC, maxCD_staph_LUR1_subsetD, maxCD_staph_LUR1_subsetE, maxCD_staph_LUR1_subsetF, maxCD_staph_LUR1_subsetG, maxCD_staph_LUR1_subsetH, maxCD_staph_LUR1_subsetI, maxCD_staph_LUR1_subsetJ)

staph_LUR1_maxCD_df <- as.data.frame(staph_LUR1_maxCD_subsetvalID1to10)

row.names(staph_LUR1_maxCD_df) <- c("SubsetA", "SubsetB", "SubsetC", "SubsetD", "SubsetE", "SubsetF", "SubsetG", "SubsetH", "SubsetI", "SubsetJ")

write_xlsx(staph_LUR1_maxCD_df,"Output_files\\staph_LUR1_maxCD_df.xlsx")

#  Merging of all test sets to make overall comparisons of predicted vs observed
VGOB1_subsetvalID1to10_staph_LUR1_10foldCV <- rbind(VGOB1_subsetvalID1_staph_LUR1, VGOB1_subsetvalID2_staph_LUR1, VGOB1_subsetvalID3_staph_LUR1, VGOB1_subsetvalID4_staph_LUR1, VGOB1_subsetvalID5_staph_LUR1, VGOB1_subsetvalID6_staph_LUR1, VGOB1_subsetvalID7_staph_LUR1, VGOB1_subsetvalID8_staph_LUR1, VGOB1_subsetvalID9_staph_LUR1, VGOB1_subsetvalID10_staph_LUR1)

#  Overall comparison of predicted vs observed
plot(VGOB1_subsetvalID1to10_staph_LUR1_10foldCV$staph_PRED_HV, VGOB1_subsetvalID1to10_staph_LUR1_10foldCV$staph_copiespm3.ln.diffmeth.mean, xlab="LUR1-predicted staph DNA concentration (ln copies/m^3)", ylab="Observed staph DNA concentration (ln copies/m^3)", cex.lab=0.85)
abline(lm(VGOB1_subsetvalID1to10_staph_LUR1_10foldCV$staph_copiespm3.ln.diffmeth.mean ~ VGOB1_subsetvalID1to10_staph_LUR1_10foldCV$staph_PRED_HV))

VGOB1_subsetvalID1to10_staph_LUR1_10foldCV_lm <- lm(staph_copiespm3.ln.diffmeth.mean ~ staph_PRED_HV, data=VGOB1_subsetvalID1to10_staph_LUR1_10foldCV)
summary(VGOB1_subsetvalID1to10_staph_LUR1_10foldCV_lm)

# 10-fold CV multiple R2 for Staph LUR1 = 0.09027

#  Calculate RMSE
RMSE_staph_LUR1_10foldCV <- sqrt(mean((VGOB1_subsetvalID1to10_staph_LUR1_10foldCV$staph_copiespm3.ln.diffmeth.mean - VGOB1_subsetvalID1to10_staph_LUR1_10foldCV$staph_PRED_HV)^2))
RMSE_staph_LUR1_10foldCV

#  Save these predicted concentrations as an excel file along with the actual measured concentrations of staph at each of the measurement sites 
#  These are the predicted concentrations for the sites that were left out of the model training procedure in 10-fold cross validation 
staph_LUR1_10foldCV_preds <- VGOB1_subsetvalID1to10_staph_LUR1_10foldCV$staph_PRED_HV 
#  These are the actual measured concentrations at the 61 measurement sites - these are in the same order as the above sites in order to match the predicted concentrations (i.e. not in order 1-61)
VGOB1_subsetvalID1to10_staph_LUR1_10foldCV$staph_copiespm3.ln.diffmeth.mean

VGOB1_subsetvalID1to10_staph_LUR1_10foldCV$Loc_ID

#  Create a dataframe 
staph_SLR_10foldCVpreds_observed <- data.frame(VGOB1_subsetvalID1to10_staph_LUR1_10foldCV$Loc_ID,VGOB1_subsetvalID1to10_staph_LUR1_10foldCV$staph_copiespm3.ln.diffmeth.mean, VGOB1_subsetvalID1to10_staph_LUR1_10foldCV$staph_PRED_HV)
print(staph_SLR_10foldCVpreds_observed)

#  Save as xls file 
write_xlsx(staph_SLR_10foldCVpreds_observed,"Output_files//staph_LUR1_10foldCV_observed_predicted.xlsx")
```
#  Staph LUR2 - training model
```{r}
#  This is the df with the predictors to be entered into model 2 
Measurements_livestockpreds_LUR2 <- read.csv("Input_files//Measurements_livestockpreds_LUR2.csv")
Measurements_livestockpreds_LUR2 

#  Now set the values of some variables that will be needed
nfirstvar_LUR_2 <- 6  #  given that the list of explanatory variables is at the end of the table: specify in which row the first explanatory variable is
nlastvar_LUR_2 <- 74

#  Function building to run the models 
models<-list()
#  1 # 
modeln<-1
models[[modeln]]<-list()

R2<-1
betaaddedvar<-1
addedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_2:nlastvar_LUR_2){
  if (is.numeric(Measurements_livestockpreds_LUR2[,i])==TRUE){
    modeltry<-lm(staph~Measurements_livestockpreds_LUR2[,i])                            
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    # find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # Measurements_livestockpreds_LUR2[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR2)[i]
    addedvar<-rbind(addedvar,names(Measurements_livestockpreds_LUR2)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)
models[[modeln]]$results

#  this are the candidates models with the highest R2, not a negative beta for the new, nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)
models[[modeln]]$resultspos

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))
models[[modeln]]$resultspos

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j
models[[modeln]]$indexbestmodel

subset(models[[modeln]]$resultspos, rank==1)
subset(models[[modeln]]$resultspos)

#  this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]
models[[modeln]]$summarybestmodel

# here are the names
models[[modeln]]$namesbestmodel<-c(names(Measurements_livestockpreds_LUR2)[models[[1]]$indexbestmodel])
models[[modeln]]$namesbestmodel

# this is the r2 of that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2
models[[modeln]]$R2bestmodel

# this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(staph~Measurements_livestockpreds_LUR2[,models[[1]]$indexbestmodel]) 
models[[modeln]]$bestmodel

summary(models[[modeln]]$bestmodel)


#  2 # 

#  Add 2nd variable (the only difference of the above part is that now modeln=2 the model statement has 2 variables)
#  and the cAll for the list of variable names in the model changed slightly

modeln<-2

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_2:nlastvar_LUR_2){
  if (is.numeric(Measurements_livestockpreds_LUR2[,i])==TRUE){
    modeltry<-lm(staph~Measurements_livestockpreds_LUR2[,models[[1]]$indexbestmodel]+ Measurements_livestockpreds_LUR2[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    # find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # Measurements_livestockpreds_LUR2[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR2)[i]
    addedvar<-rbind(addedvar,names(Measurements_livestockpreds_LUR2)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  these are the candidate models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)
models[[modeln]]$resultspos

#  rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))
models[[modeln]]$resultspos

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j
models[[modeln]]$indexbestmodel

subset(models[[modeln]]$resultspos, rank==1)

# this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]
models[[modeln]]$summarybestmodel

# here are the names
models[[modeln]]$namesbestmodel<-c(names(Measurements_livestockpreds_LUR2)[models[[1]]$indexbestmodel], names(Measurements_livestockpreds_LUR2)[models[[2]]$indexbestmodel] )
models[[modeln]]$namesbestmodel

# this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2
models[[modeln]]$R2bestmodel

# this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(staph~Measurements_livestockpreds_LUR2[,models[[1]]$indexbestmodel]+Measurements_livestockpreds_LUR2[,models[[2]]$indexbestmodel]) 
models[[modeln]]$bestmodel

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel

models[[1]]$namesbestmodel
models[[2]]$namesbestmodel

models[[1]]$R2bestmodel
models[[2]]$R2bestmodel

#  at this point I always check whether the next model (with 2 variables) is more than 1% better than the one before and if not I end here
#  R2 of the second model is quite a lot higher than the 1st model, so 2nd is better probably 

#  3 # 

#  add third variable (the only difference of the above part is that now modeln=3 the model statement has 3 variables)
#  and the cAll for the list of variable names in the model changed slightly

modeln<-3

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_2:nlastvar_LUR_2){
  if (is.numeric(Measurements_livestockpreds_LUR2[,i])==TRUE){  
    modeltry<-lm(staph~Measurements_livestockpreds_LUR2[,models[[1]]$indexbestmodel]+Measurements_livestockpreds_LUR2[,models[[2]]$indexbestmodel]+ Measurements_livestockpreds_LUR2[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    # find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # All[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR2)[i]
    addedvar<-rbind(addedvar,names(Measurements_livestockpreds_LUR2)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))


#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

# this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

# here are the names
models[[modeln]]$namesbestmodel<-c(names(Measurements_livestockpreds_LUR2)[models[[1]]$indexbestmodel], names(Measurements_livestockpreds_LUR2)[models[[2]]$indexbestmodel] , names(Measurements_livestockpreds_LUR2)[models[[3]]$indexbestmodel])

# this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

# this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(staph~Measurements_livestockpreds_LUR2[,models[[1]]$indexbestmodel]+Measurements_livestockpreds_LUR2[,models[[2]]$indexbestmodel]+Measurements_livestockpreds_LUR2[,models[[3]]$indexbestmodel]) 

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel

models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel

models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel

#  at this point I always check whether the next model is more than 1% better than the one before and if not I end here
#  Yes model 3 is >1% better than model 2 therefore I continue

#  4 # 

#  add forth variable (the only difference of the above part is that now model n=4 the model statement more variables)
#  and the cAll for the list of variable names in the model changed slightly

modeln<-4

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_2:nlastvar_LUR_2){
  if (is.numeric(Measurements_livestockpreds_LUR2[,i])==TRUE){
    modeltry<-lm(staph~Measurements_livestockpreds_LUR2[,models[[1]]$indexbestmodel]+Measurements_livestockpreds_LUR2[,models[[2]]$indexbestmodel]+Measurements_livestockpreds_LUR2[,models[[3]]$indexbestmodel]+ Measurements_livestockpreds_LUR2[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    # find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # All[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR2)[i]
    addedvar<-rbind(addedvar,names(Measurements_livestockpreds_LUR2)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

# this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

# here are the names
models[[modeln]]$namesbestmodel<-c(names(Measurements_livestockpreds_LUR2)[models[[1]]$indexbestmodel], names(Measurements_livestockpreds_LUR2)[models[[2]]$indexbestmodel] , names(Measurements_livestockpreds_LUR2)[models[[3]]$indexbestmodel], names(Measurements_livestockpreds_LUR2)[models[[4]]$indexbestmodel])

# this is the r2 of that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

# this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(staph~Measurements_livestockpreds_LUR2[,models[[1]]$indexbestmodel]+Measurements_livestockpreds_LUR2[,models[[2]]$indexbestmodel]+Measurements_livestockpreds_LUR2[,models[[3]]$indexbestmodel]+ Measurements_livestockpreds_LUR2[,models[[4]]$indexbestmodel]) 


models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel

#  at this point I always check whether the next model is more than 1% better than the one before and if not I end here
#  No model 4 R^2 only increases by 0.640521% 
#  I will continue with a few more models that the algorithm can compare

#  5 # 
#  add fifth variable (the only difference of the above part is that now modeln=5 the model statement more variables)
#  and the cAll for the list of variable names in the model changed slightly
modeln<-5

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_2:nlastvar_LUR_2){
  if (is.numeric(Measurements_livestockpreds_LUR2[,i])==TRUE){
    modeltry<-lm(staph~Measurements_livestockpreds_LUR2[,models[[1]]$indexbestmodel]+Measurements_livestockpreds_LUR2[,models[[2]]$indexbestmodel]+Measurements_livestockpreds_LUR2[,models[[3]]$indexbestmodel]+Measurements_livestockpreds_LUR2[,models[[4]]$indexbestmodel]+ Measurements_livestockpreds_LUR2[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    # find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # All[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR2)[i]
    addedvar<-rbind(addedvar,names(Measurements_livestockpreds_LUR2)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

#  this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

# here are the names
models[[modeln]]$namesbestmodel<-c(names(Measurements_livestockpreds_LUR2)[models[[1]]$indexbestmodel], names(Measurements_livestockpreds_LUR2)[models[[2]]$indexbestmodel] , names(Measurements_livestockpreds_LUR2)[models[[3]]$indexbestmodel], names(Measurements_livestockpreds_LUR2)[models[[4]]$indexbestmodel], names(Measurements_livestockpreds_LUR2)[models[[5]]$indexbestmodel])


# this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

# this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(staph~Measurements_livestockpreds_LUR2[,models[[1]]$indexbestmodel]+Measurements_livestockpreds_LUR2[,models[[2]]$indexbestmodel]+Measurements_livestockpreds_LUR2[,models[[3]]$indexbestmodel]+ Measurements_livestockpreds_LUR2[,models[[4]]$indexbestmodel]+ Measurements_livestockpreds_LUR2[,models[[5]]$indexbestmodel]) 


models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[5]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[5]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel
models[[5]]$R2bestmodel

#  at this point I always check whether the next model is more than 1% better than the one before and if not I end here

#  6 # 
#  add sixth variable (the only difference of the above part is that now modeln=6 the modelstatement more variables)
#  and the cAll for the list of variable names in the model changed slightly

modeln<-6

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_2 :nlastvar_LUR_2){
  if (is.numeric(Measurements_livestockpreds_LUR2[,i])==TRUE){
    modeltry<-lm(staph~Measurements_livestockpreds_LUR2[,models[[1]]$indexbestmodel]+Measurements_livestockpreds_LUR2[,models[[2]]$indexbestmodel]+Measurements_livestockpreds_LUR2[,models[[3]]$indexbestmodel]+Measurements_livestockpreds_LUR2[,models[[4]]$indexbestmodel]+Measurements_livestockpreds_LUR2[,models[[5]]$indexbestmodel]+ Measurements_livestockpreds_LUR2[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    # find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # All[,i] is the row that's being tried out now. the name of that row can be found in  names(All)[i]
    addedvar<-rbind(addedvar,names(Measurements_livestockpreds_LUR2)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

# this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

# here are the names
models[[modeln]]$namesbestmodel<-c(names(Measurements_livestockpreds_LUR2)[models[[1]]$indexbestmodel], names(Measurements_livestockpreds_LUR2)[models[[2]]$indexbestmodel] , names(Measurements_livestockpreds_LUR2)[models[[3]]$indexbestmodel], names(Measurements_livestockpreds_LUR2)[models[[4]]$indexbestmodel], names(Measurements_livestockpreds_LUR2)[models[[5]]$indexbestmodel], names(Measurements_livestockpreds_LUR2)[models[[6]]$indexbestmodel])

# this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

# this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(staph~Measurements_livestockpreds_LUR2[,models[[1]]$indexbestmodel]+Measurements_livestockpreds_LUR2[,models[[2]]$indexbestmodel]+Measurements_livestockpreds_LUR2[,models[[3]]$indexbestmodel]+ Measurements_livestockpreds_LUR2[,models[[4]]$indexbestmodel]+ Measurements_livestockpreds_LUR2[,models[[5]]$indexbestmodel]+ Measurements_livestockpreds_LUR2[,models[[6]]$indexbestmodel]) 

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[5]]$summarybestmodel
models[[6]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[5]]$namesbestmodel
models[[6]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel
models[[5]]$R2bestmodel
models[[6]]$R2bestmodel

#  7 # 
modeln<-7

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_2 :nlastvar_LUR_2){
  if (is.numeric(Measurements_livestockpreds_LUR2[,i])==TRUE){
    modeltry<-lm(staph~Measurements_livestockpreds_LUR2[,models[[1]]$indexbestmodel]+Measurements_livestockpreds_LUR2[,models[[2]]$indexbestmodel]+Measurements_livestockpreds_LUR2[,models[[3]]$indexbestmodel]+Measurements_livestockpreds_LUR2[,models[[4]]$indexbestmodel]+Measurements_livestockpreds_LUR2[,models[[5]]$indexbestmodel]+Measurements_livestockpreds_LUR2[,models[[6]]$indexbestmodel]+ Measurements_livestockpreds_LUR2[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    # find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # Measurements_livestockpreds_LUR3[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR3)[i]
    addedvar<-rbind(addedvar,names(Measurements_livestockpreds_LUR2)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

# this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

# here are the names
models[[modeln]]$namesbestmodel<-c(names(Measurements_livestockpreds_LUR2)[models[[1]]$indexbestmodel], names(Measurements_livestockpreds_LUR2)[models[[2]]$indexbestmodel] , names(Measurements_livestockpreds_LUR2)[models[[3]]$indexbestmodel], names(Measurements_livestockpreds_LUR2)[models[[4]]$indexbestmodel], names(Measurements_livestockpreds_LUR2)[models[[5]]$indexbestmodel], names(Measurements_livestockpreds_LUR2)[models[[6]]$indexbestmodel],
names(Measurements_livestockpreds_LUR2)[models[[7]]$indexbestmodel])

# this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

# this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(staph~Measurements_livestockpreds_LUR2[,models[[1]]$indexbestmodel]+Measurements_livestockpreds_LUR2[,models[[2]]$indexbestmodel]+Measurements_livestockpreds_LUR2[,models[[3]]$indexbestmodel]+ Measurements_livestockpreds_LUR2[,models[[4]]$indexbestmodel]+ Measurements_livestockpreds_LUR2[,models[[5]]$indexbestmodel]+ Measurements_livestockpreds_LUR2[,models[[6]]$indexbestmodel]+
Measurements_livestockpreds_LUR2[,models[[7]]$indexbestmodel]) 

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[5]]$summarybestmodel
models[[6]]$summarybestmodel
models[[7]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[5]]$namesbestmodel
models[[6]]$namesbestmodel
models[[7]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel
models[[5]]$R2bestmodel
models[[6]]$R2bestmodel
models[[7]]$R2bestmodel

#  8 # 
#  add eighth variable (the only difference of the above part is that now modeln=8 the modelstatement more variables)
#  and the cAll for the list of variable names in the model changed slightly

modeln<-8

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_2 :nlastvar_LUR_2){
  if (is.numeric(Measurements_livestockpreds_LUR2[,i])==TRUE){
    modeltry<-lm(staph~Measurements_livestockpreds_LUR2[,models[[1]]$indexbestmodel]+Measurements_livestockpreds_LUR2[,models[[2]]$indexbestmodel]+Measurements_livestockpreds_LUR2[,models[[3]]$indexbestmodel]+Measurements_livestockpreds_LUR2[,models[[4]]$indexbestmodel]+Measurements_livestockpreds_LUR2[,models[[5]]$indexbestmodel]+Measurements_livestockpreds_LUR2[,models[[6]]$indexbestmodel]+ Measurements_livestockpreds_LUR2[,models[[7]]$indexbestmodel]+ Measurements_livestockpreds_LUR2[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    # find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # Measurements_livestockpreds_LUR3[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR3)[i]
    addedvar<-rbind(addedvar,names(Measurements_livestockpreds_LUR2)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

# this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

# here are the names
models[[modeln]]$namesbestmodel<-c(names(Measurements_livestockpreds_LUR2)[models[[1]]$indexbestmodel], names(Measurements_livestockpreds_LUR2)[models[[2]]$indexbestmodel] , names(Measurements_livestockpreds_LUR2)[models[[3]]$indexbestmodel], names(Measurements_livestockpreds_LUR2)[models[[4]]$indexbestmodel], names(Measurements_livestockpreds_LUR2)[models[[5]]$indexbestmodel], names(Measurements_livestockpreds_LUR2)[models[[6]]$indexbestmodel],
names(Measurements_livestockpreds_LUR2)[models[[7]]$indexbestmodel],
names(Measurements_livestockpreds_LUR2)[models[[8]]$indexbestmodel] )

# this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

# this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(staph~Measurements_livestockpreds_LUR2[,models[[1]]$indexbestmodel]+Measurements_livestockpreds_LUR2[,models[[2]]$indexbestmodel]+Measurements_livestockpreds_LUR2[,models[[3]]$indexbestmodel]+ Measurements_livestockpreds_LUR2[,models[[4]]$indexbestmodel]+ Measurements_livestockpreds_LUR2[,models[[5]]$indexbestmodel]+ Measurements_livestockpreds_LUR2[,models[[6]]$indexbestmodel]+
Measurements_livestockpreds_LUR2[,models[[7]]$indexbestmodel] +Measurements_livestockpreds_LUR2[,models[[8]]$indexbestmodel]) 

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[5]]$summarybestmodel
models[[6]]$summarybestmodel
models[[7]]$summarybestmodel
models[[8]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[5]]$namesbestmodel
models[[6]]$namesbestmodel
models[[7]]$namesbestmodel
models[[8]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel
models[[5]]$R2bestmodel
models[[6]]$R2bestmodel
models[[7]]$R2bestmodel
models[[8]]$R2bestmodel

#  9 # 

modeln<-9

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_2 :nlastvar_LUR_2){
  if (is.numeric(Measurements_livestockpreds_LUR2[,i])==TRUE){
    modeltry<-lm(staph~Measurements_livestockpreds_LUR2[,models[[1]]$indexbestmodel]+Measurements_livestockpreds_LUR2[,models[[2]]$indexbestmodel]+Measurements_livestockpreds_LUR2[,models[[3]]$indexbestmodel]+Measurements_livestockpreds_LUR2[,models[[4]]$indexbestmodel]+Measurements_livestockpreds_LUR2[,models[[5]]$indexbestmodel]+ Measurements_livestockpreds_LUR2[,models[[6]]$indexbestmodel]+ Measurements_livestockpreds_LUR2[,models[[7]]$indexbestmodel]+ Measurements_livestockpreds_LUR2[,models[[8]]$indexbestmodel]+ Measurements_livestockpreds_LUR2[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    # find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # Measurements_livestockpreds_LUR2[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR2)[i]
    addedvar<-rbind(addedvar,names(Measurements_livestockpreds_LUR2)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

# this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

# here are the names
models[[modeln]]$namesbestmodel<-c(names(Measurements_livestockpreds_LUR2)[models[[1]]$indexbestmodel], names(Measurements_livestockpreds_LUR2)[models[[2]]$indexbestmodel] , names(Measurements_livestockpreds_LUR2)[models[[3]]$indexbestmodel], names(Measurements_livestockpreds_LUR2)[models[[4]]$indexbestmodel], names(Measurements_livestockpreds_LUR2)[models[[5]]$indexbestmodel], names(Measurements_livestockpreds_LUR2)[models[[6]]$indexbestmodel], names(Measurements_livestockpreds_LUR2)[models[[7]]$indexbestmodel], names(Measurements_livestockpreds_LUR2)[models[[8]]$indexbestmodel], names(Measurements_livestockpreds_LUR2)[models[[9]]$indexbestmodel])

# this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

# this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(staph~Measurements_livestockpreds_LUR2[,models[[1]]$indexbestmodel]+Measurements_livestockpreds_LUR2[,models[[2]]$indexbestmodel]+Measurements_livestockpreds_LUR2[,models[[3]]$indexbestmodel]+ Measurements_livestockpreds_LUR2[,models[[4]]$indexbestmodel]+ Measurements_livestockpreds_LUR2[,models[[5]]$indexbestmodel]+ Measurements_livestockpreds_LUR2[,models[[6]]$indexbestmodel]+ Measurements_livestockpreds_LUR2[,models[[7]]$indexbestmodel]+ Measurements_livestockpreds_LUR2[,models[[8]]$indexbestmodel]+ Measurements_livestockpreds_LUR2[,models[[9]]$indexbestmodel]) 

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[5]]$summarybestmodel
models[[6]]$summarybestmodel
models[[7]]$summarybestmodel
models[[8]]$summarybestmodel
models[[9]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[5]]$namesbestmodel
models[[6]]$namesbestmodel
models[[7]]$namesbestmodel
models[[8]]$namesbestmodel
models[[9]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel
models[[5]]$R2bestmodel
models[[6]]$R2bestmodel
models[[7]]$R2bestmodel
models[[8]]$R2bestmodel
models[[9]]$R2bestmodel


#  at this point I always check wether the nextmodel is more than 1%better than the one before and if not I end here
#  last step is to exclude All var with p>0.1 one by one with the lowest p first, until All <0.1.

#  10 # 
modeln<-10

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_2 :nlastvar_LUR_2){
  if (is.numeric(Measurements_livestockpreds_LUR2[,i])==TRUE){
    modeltry<-lm(staph~Measurements_livestockpreds_LUR2[,models[[1]]$indexbestmodel]+Measurements_livestockpreds_LUR2[,models[[2]]$indexbestmodel]+Measurements_livestockpreds_LUR2[,models[[3]]$indexbestmodel]+Measurements_livestockpreds_LUR2[,models[[4]]$indexbestmodel]+Measurements_livestockpreds_LUR2[,models[[5]]$indexbestmodel]+ Measurements_livestockpreds_LUR2[,models[[6]]$indexbestmodel]+ Measurements_livestockpreds_LUR2[,models[[7]]$indexbestmodel]+ Measurements_livestockpreds_LUR2[,models[[8]]$indexbestmodel]+ Measurements_livestockpreds_LUR2[,models[[9]]$indexbestmodel]+ Measurements_livestockpreds_LUR2[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    # find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # Measurements_livestockpreds_LUR2[,i] is the row that's being tried out now. the name of that row can be found in  names(All)[i]
    addedvar<-rbind(addedvar,names(Measurements_livestockpreds_LUR2)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

# this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

# here are the names
models[[modeln]]$namesbestmodel<-c(names(Measurements_livestockpreds_LUR2)[models[[1]]$indexbestmodel], names(Measurements_livestockpreds_LUR2)[models[[2]]$indexbestmodel] , names(Measurements_livestockpreds_LUR2)[models[[3]]$indexbestmodel], names(Measurements_livestockpreds_LUR2)[models[[4]]$indexbestmodel], names(Measurements_livestockpreds_LUR2)[models[[5]]$indexbestmodel], names(Measurements_livestockpreds_LUR2)[models[[6]]$indexbestmodel], names(Measurements_livestockpreds_LUR2)[models[[7]]$indexbestmodel], names(Measurements_livestockpreds_LUR2)[models[[8]]$indexbestmodel], names(Measurements_livestockpreds_LUR2)[models[[9]]$indexbestmodel], names(Measurements_livestockpreds_LUR2)[models[[10]]$indexbestmodel])

# this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

# this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(staph~Measurements_livestockpreds_LUR2[,models[[1]]$indexbestmodel]+Measurements_livestockpreds_LUR2[,models[[2]]$indexbestmodel]+Measurements_livestockpreds_LUR2[,models[[3]]$indexbestmodel]+ Measurements_livestockpreds_LUR2[,models[[4]]$indexbestmodel]+ Measurements_livestockpreds_LUR2[,models[[5]]$indexbestmodel]+ Measurements_livestockpreds_LUR2[,models[[6]]$indexbestmodel]+ Measurements_livestockpreds_LUR2[,models[[7]]$indexbestmodel]+ Measurements_livestockpreds_LUR2[,models[[8]]$indexbestmodel]+ Measurements_livestockpreds_LUR2[,models[[9]]$indexbestmodel]+ Measurements_livestockpreds_LUR2[,models[[10]]$indexbestmodel]) 

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[5]]$summarybestmodel
models[[6]]$summarybestmodel
models[[7]]$summarybestmodel
models[[8]]$summarybestmodel
models[[9]]$summarybestmodel
models[[10]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[5]]$namesbestmodel
models[[6]]$namesbestmodel
models[[7]]$namesbestmodel
models[[8]]$namesbestmodel
models[[9]]$namesbestmodel
models[[10]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel
models[[5]]$R2bestmodel
models[[6]]$R2bestmodel
models[[7]]$R2bestmodel
models[[8]]$R2bestmodel
models[[9]]$R2bestmodel
models[[10]]$R2bestmodel


#  11 # 
modeln<-11

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in  nfirstvar_LUR_2 :nlastvar_LUR_2){
  if (is.numeric(Measurements_livestockpreds_LUR2[,i])==TRUE){
    modeltry<-lm(staph~Measurements_livestockpreds_LUR2[,models[[1]]$indexbestmodel]+Measurements_livestockpreds_LUR2[,models[[2]]$indexbestmodel]+Measurements_livestockpreds_LUR2[,models[[3]]$indexbestmodel]+Measurements_livestockpreds_LUR2[,models[[4]]$indexbestmodel]+Measurements_livestockpreds_LUR2[,models[[5]]$indexbestmodel]+ Measurements_livestockpreds_LUR2[,models[[6]]$indexbestmodel]+ Measurements_livestockpreds_LUR2[,models[[7]]$indexbestmodel]+ Measurements_livestockpreds_LUR2[,models[[8]]$indexbestmodel]+ Measurements_livestockpreds_LUR2[,models[[9]]$indexbestmodel]+ Measurements_livestockpreds_LUR2[,models[[10]]$indexbestmodel] + Measurements_livestockpreds_LUR2[,i])
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    # find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # Measurements_livestockpreds_LUR2[,i] is the row that's being tried out now. the name of that row can be found in  names(All)[i]
    addedvar<-rbind(addedvar,names(Measurements_livestockpreds_LUR2)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

# this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

# here are the names
models[[modeln]]$namesbestmodel<-c(names(Measurements_livestockpreds_LUR2)[models[[1]]$indexbestmodel], names(Measurements_livestockpreds_LUR2)[models[[2]]$indexbestmodel] , names(Measurements_livestockpreds_LUR2)[models[[3]]$indexbestmodel], names(Measurements_livestockpreds_LUR2)[models[[4]]$indexbestmodel], names(Measurements_livestockpreds_LUR2)[models[[5]]$indexbestmodel], names(Measurements_livestockpreds_LUR2)[models[[6]]$indexbestmodel], names(Measurements_livestockpreds_LUR2)[models[[7]]$indexbestmodel], names(Measurements_livestockpreds_LUR2)[models[[8]]$indexbestmodel], names(Measurements_livestockpreds_LUR2)[models[[9]]$indexbestmodel], names(Measurements_livestockpreds_LUR2)[models[[10]]$indexbestmodel], names(Measurements_livestockpreds_LUR2)[models[[11]]$indexbestmodel])

# this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

# this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(staph~Measurements_livestockpreds_LUR2[,models[[1]]$indexbestmodel]+Measurements_livestockpreds_LUR2[,models[[2]]$indexbestmodel]+Measurements_livestockpreds_LUR2[,models[[3]]$indexbestmodel]+ Measurements_livestockpreds_LUR2[,models[[4]]$indexbestmodel]+ Measurements_livestockpreds_LUR2[,models[[5]]$indexbestmodel]+ Measurements_livestockpreds_LUR2[,models[[6]]$indexbestmodel]+ Measurements_livestockpreds_LUR2[,models[[7]]$indexbestmodel]+ Measurements_livestockpreds_LUR2[,models[[8]]$indexbestmodel]+ Measurements_livestockpreds_LUR2[,models[[9]]$indexbestmodel]+ Measurements_livestockpreds_LUR2[,models[[10]]$indexbestmodel] + Measurements_livestockpreds_LUR2[,models[[11]]$indexbestmodel])

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[5]]$summarybestmodel
models[[6]]$summarybestmodel
models[[7]]$summarybestmodel
models[[8]]$summarybestmodel
models[[9]]$summarybestmodel
models[[10]]$summarybestmodel
models[[11]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[5]]$namesbestmodel
models[[6]]$namesbestmodel
models[[7]]$namesbestmodel
models[[8]]$namesbestmodel
models[[9]]$namesbestmodel
models[[10]]$namesbestmodel
models[[11]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel
models[[5]]$R2bestmodel
models[[6]]$R2bestmodel
models[[7]]$R2bestmodel
models[[8]]$R2bestmodel
models[[9]]$R2bestmodel
models[[10]]$R2bestmodel
models[[11]]$R2bestmodel


#  CODE FOR PICKING OUT THE BEST MODEL #  
temp <- 0
besti <- 0
for (i in 1:10){ #  think this runs the loop 10 times - not fully sure thought - but not to do with the number of models I don't think - as when I change to 3, I still get the model with 4 variables as best model
  print(models[[i]]$R2bestmodel)
  #       print(models[[i]]$summarybestmodel$coefficients=-1,4])
  #       if((models[[i]]$R2bestmodel-temp > 0.0) && (all(models[[i]]$summarybestmodel$coefficients[-1,4]<0.1))){
  #         temp <- models[[i]]$R2bestmodel
  #         besti <- i
  #         }
  if((models[[i]]$R2bestmodel-temp > 0.0) && (all(models[[i]]$summarybestmodel$coefficients[-1,4]<0.1))){
    temp <- models[[i]]$R2bestmodel
    besti <- i
  }else{
    finalBestModel <- models[[besti]]$bestmodel
    finalBestModelNames <- models[[besti]]$namesbestmodel
    Sites <- 1:dim(Measurements_livestockpreds_LUR3)[1] # full original model
    #  CVaR2<-escCV_staph_LUR3(Sites)[2] # Cross Validation
    maxCD<-max(cooks.distance(finalBestModel))
    if(length(finalBestModelNames)<2){ # vif fn doesnot work when only 1 variable...       # 
      maxVIF<-"NA"
    }else{
      maxVIF<-max(vif(finalBestModel))
    }
    print(paste("This is the best staph model: ",besti,
                "(AdjR2: ",format(models[[besti]]$R2bestmodel,digits=3), "; MaxCD: ",format(maxCD,digits=3),"; MaxVIF: ",
                format(maxVIF,digits=3),")", sep=''))
    print(finalBestModelNames)
    break
  }
}

#  the final best model includes the predictors: PoultryFarm.3000m.95Win.10to90scaled+ nhorses.1000m.95Win.10to90scaled +HorseFarm.3000m.95Win.10to90scaled
#  this is the model, written out in full
staph_LUR2_algorithmmethod <- lm(staph_copiespm3.ln.diffmeth.mean~PoultryFarm.3000m.95Win.10to90scaled+ nhorses.1000m.95Win.10to90scaled +HorseFarm.3000m.95Win.10to90scaled, data= Measurements_livestockpreds_LUR2)
summary(staph_LUR2_algorithmmethod)

# Calculate RMSE
predicted_staph_LUR2 <- predict(staph_LUR2_algorithmmethod, Measurements_livestockpreds_LUR2)
RMSE_staph_LUR2 <- sqrt(mean((Measurements_livestockpreds_LUR2$staph_copiespm3.ln.diffmeth.mean - predicted_staph_LUR2)^2))
RMSE_staph_LUR2

#  Save these predicted concentrations along with the measured concentrations as an excel file 
#  Create a dataframe 
staph_LUR2_preds_observed <- data.frame(Measurements_livestockpreds_LUR2$Loc_ID,Measurements_livestockpreds_LUR2$staph_copiespm3.ln.diffmeth.mean, predicted_staph_LUR2)
print(staph_LUR2_preds_observed)

#  Save as xls file 
write_xlsx(staph_LUR2_preds_observed,"Output_files//staph_LUR2_preds_observed.xlsx")

#  MODEL CHECKING # 
#  1)Check normality of residuals 
#  2)Check residuals for linearity, independence and homoscedasticity
#  3)Check multicollinearity (VIF)
#  4)Check influential points (Cook's Distance)

#  1) Normality of residuals
boxplot(residuals(staph_LUR2_algorithmmethod),main="boxplot of residuals - e.coli LUR model 2",xlab="LUR2 model residuals")
qqnorm(residuals(staph_LUR2_algorithmmethod),main="QQ-plot of residuals - e.coli LUR model 2",xlab="LUR2 model residuals")

#  2)Check residuals for linearity, independence and homoscedasticity
plot(fitted(staph_LUR2_algorithmmethod),residuals(staph_LUR2_algorithmmethod))

#  3)Check multicollinearity (VIF)
maxvif_staph_LUR2 <- max(vif(staph_LUR2_algorithmmethod))
maxvif_staph_LUR2

#  4)Check influential points (Cook's Distance)
ols_plot_cooksd_bar(staph_LUR2_algorithmmodel, print_plot = TRUE)
maxCD_staph_LUR2<-max(cooks.distance(staph_LUR2_algorithmmodel))
maxCD_staph_LUR2
#  won't remove any outliers - none with cook's d > 1 
```
# Staph LUR2 model - LOOCV
```{r}
#  LOOCV - LUR model 2 for staph 
#  Leave one out cross validation - the goal of cross validation is to get a generalized score of the model. The reason for this generalization is to, hopefully, improve the model’s effectiveness in predicting on future data inputs.
#  It is a type of 'internal' cross validation
Measurements_livestockpreds_LUR2_LOOCV <- Measurements_livestockpreds_LUR2
set.seed(123)
Measurements_livestockpreds_LUR2_LOOCV$staph_LUR2_LOOCV_PRED <- unlist(lapply(1:nrow(Measurements_livestockpreds_LUR2_LOOCV),function(inx){
  train <- Measurements_livestockpreds_LUR2_LOOCV[-inx,,drop=FALSE]
  test <- Measurements_livestockpreds_LUR2_LOOCV[inx,,drop=FALSE]
  cvm <- lm(staph_copiespm3.ln.diffmeth.mean ~ PoultryFarm.3000m.95Win.10to90scaled+ nhorses.1000m.95Win.10to90scaled +HorseFarm.3000m.95Win.10to90scaled, data=train)
  pred <- predict(cvm,newdata=test)
  return(pred)
}))

predicted_staph_LUR2_LOOCV <- Measurements_livestockpreds_LUR2_LOOCV$staph_LUR2_LOOCV_PRED

#  Save these predicted concentrations along with the measured concentrations as an excel file 
#  Create a dataframe 
staph_LUR2_LOOCV_preds_observed <- data.frame(Measurements_livestockpreds_LUR2_LOOCV$Loc_ID,Measurements_livestockpreds_LUR2_LOOCV$staph_copiespm3.ln.diffmeth.mean, Measurements_livestockpreds_LUR2_LOOCV$staph_LUR2_LOOCV_PRED)
print(staph_LUR2_LOOCV_preds_observed)

#  Save as xls file 
write_xlsx(staph_LUR2_LOOCV_preds_observed,"Output_files//staph_LUR2_LOOCV_preds_observed.xlsx")

# Compute the LOOCV model R2
staph_LUR2_LOOCV_lm <- lm(staph_copiespm3.ln.diffmeth.mean ~ staph_LUR2_LOOCV_PRED, data=Measurements_livestockpreds_LUR2_LOOCV)
summary(staph_LUR2_LOOCV_lm)
#  Staph LUR2 model LOOCV multiple R^2 = 0.2657

# Calculate RMSE
preds_staph_LUR2_LOOCV <- predict(staph_LUR2_LOOCV_lm, Measurements_livestockpreds_LUR2_LOOCV)
RMSE_staph_LUR2_LOOCV <- sqrt(mean((Measurements_livestockpreds_LUR2_LOOCV$staph_copiespm3.ln.diffmeth.mean - preds_staph_LUR2_LOOCV)^2))
RMSE_staph_LUR2_LOOCV

#  Plot LOOCV estimations vs. observed concentrations
plot(Measurements_livestockpreds_LUR2_LOOCV$staph_LUR2_LOOCV_PRED, Measurements_livestockpreds_LUR2_LOOCV$staph_copiespm3.ln.diffmeth.mean)
abline(lm(Measurements_livestockpreds_LUR2_LOOCV$staph_copiespm3.ln.diffmeth.mean ~ Measurements_livestockpreds_LUR2_LOOCV$staph_LUR2_LOOCV_PRED))
```
# Staph LUR2 - 10-fold CV
```{r}
options(stringsAsFactors = FALSE) # so that dataframes are not opened in new tabs

# This is the required dataset
Measurements_livestockpreds_LUR2 

#  10-fold hold-out validation is done to assess model robustness. This is done using a random selection of 90% of the measurement sites. 
#  Part 1. Each measurement site gets randomly allocated number out of range 1-10
#  Completely randomly pulling sites
staph_HV_LUR2_df <- Measurements_livestockpreds_LUR2[c(1,3,6:74)] #  new df created with only staph values 
#  Create valID variable 
staph_HV_LUR2_df$valID <- 0
#  Draw 10 samples, thus on average 6 sites per test set (i.e 6 sites are removed from each model and then the model is tested on these 6 sites )
set.seed(123)
VGOB1_FINAL_staph_LUR2 <- c()
for (s in 1:1){
  if (s==1) set <- staph_HV_LUR2_df
  draws <- c(1:nrow(set))
  chosen <- c()
  tempdraws <- draws
  for (d in 1:10){
    list <- sample(tempdraws, length(tempdraws)/(11-d), FALSE)
    set[list,]$valID <- d
    chosen <- c(chosen, list)
    tempdraws <- draws[-chosen]
  }

#  Combine datasets to 1
VGOB1_FINAL_staph_LUR2 <- set
}

summary(set)
rm(set)

#  View the df created
str(VGOB1_FINAL_staph_LUR2, list.len=ncol(VGOB1_FINAL_staph_LUR2))
names(VGOB1_FINAL_staph_LUR2)
summary(VGOB1_FINAL_staph_LUR2)

#  Part 2: Make 10 subsets of dataset based on randomly allocated number (so these are the training datasets) 
#  Then create 10 subsets, each excluding 1 set of 10 sites
VGOB1_subsetA_staph_LUR2 <- subset(VGOB1_FINAL_staph_LUR2, valID != 1)
VGOB1_subsetB_staph_LUR2 <- subset(VGOB1_FINAL_staph_LUR2, valID != 2)  
VGOB1_subsetC_staph_LUR2 <- subset(VGOB1_FINAL_staph_LUR2, valID != 3)
VGOB1_subsetD_staph_LUR2 <- subset(VGOB1_FINAL_staph_LUR2, valID != 4)
VGOB1_subsetE_staph_LUR2 <- subset(VGOB1_FINAL_staph_LUR2, valID != 5)
VGOB1_subsetF_staph_LUR2 <- subset(VGOB1_FINAL_staph_LUR2, valID != 6)
VGOB1_subsetG_staph_LUR2 <- subset(VGOB1_FINAL_staph_LUR2, valID != 7)
VGOB1_subsetH_staph_LUR2 <- subset(VGOB1_FINAL_staph_LUR2, valID != 8)
VGOB1_subsetI_staph_LUR2 <- subset(VGOB1_FINAL_staph_LUR2, valID != 9)
VGOB1_subsetJ_staph_LUR2 <- subset(VGOB1_FINAL_staph_LUR2, valID != 10)

#  Part 3: Build for each subset a LUR model (i.e. go through the whole LUR model script for each subset (so each training set). Start with subset A, until final LUR model. Then subset B, until final LUR model etc.) 

#### A ####
# LUR model building process for subset A
#  This is the dataframe with the relevant predictor vars for LUR2 models for subset A (55 sites)
VGOB1_subsetA_staph_LUR2 # n.b. this dataframe only includes microbial marker concentrations for staph unlike the dataframe Measurements_livestockpreds_LUR2 as previously used for the model building. 

#  Now set the values of some variables that will be needed
nfirstvar_LUR_2 <- 3  
nlastvar_LUR_2 <- 71

# Function building to run the models 
# 1 #  

models<-list()
modeln<-1
models[[modeln]]<-list()

R2<-1
betaaddedvar<-1
addedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_2:nlastvar_LUR_2){
  if (is.numeric(VGOB1_subsetA_staph_LUR2[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetA_staph_LUR2$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetA_staph_LUR2[,i])                            
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    #  Measurements_livestockpreds_LUR2[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR2)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetA_staph_LUR2)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)
models[[modeln]]$results

#  this are the candidates models with the highest R2, not a negative beta for the new, nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)
models[[modeln]]$resultspos

#  rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))
models[[modeln]]$resultspos

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j
models[[modeln]]$indexbestmodel

subset(models[[modeln]]$resultspos, rank==1)
subset(models[[modeln]]$resultspos)

#  this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]
models[[modeln]]$summarybestmodel

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetA_staph_LUR2)[models[[1]]$indexbestmodel])
models[[modeln]]$namesbestmodel

#  this is the r2 of that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2
models[[modeln]]$R2bestmodel

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetA_staph_LUR2$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetA_staph_LUR2[,models[[1]]$indexbestmodel]) 
models[[modeln]]$bestmodel

summary(models[[modeln]]$bestmodel)

#  The first model includes the predictor: nPigMultipFarmWghtDist.3000m.sum.Tr.1P9 - meaning the number of multiplier pig farms weighted to distance in a 3000m buffer

# 2 #  
# Add 2nd variable (the only difference of the above part is that now modeln=2 the model statement has 2 variables)
# and the call for the list of variable names in the model changed slightly

modeln<-2

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_2:nlastvar_LUR_2){
  if (is.numeric(VGOB1_subsetA_staph_LUR2[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetA_staph_LUR2$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetA_staph_LUR2[,models[[1]]$indexbestmodel]+ VGOB1_subsetA_staph_LUR2[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # Measurements_livestockpreds_LUR2[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR2)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetA_staph_LUR2)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  these are the candidate models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)
models[[modeln]]$resultspos

#  rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))
models[[modeln]]$resultspos

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j
models[[modeln]]$indexbestmodel

subset(models[[modeln]]$resultspos, rank==1)

# this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]
models[[modeln]]$summarybestmodel

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetA_staph_LUR2)[models[[1]]$indexbestmodel], names(VGOB1_subsetA_staph_LUR2)[models[[2]]$indexbestmodel] )
models[[modeln]]$namesbestmodel

# this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2
models[[modeln]]$R2bestmodel

# this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetA_staph_LUR2$staph_copiespm3.ln.diffmeth.mean~                               VGOB1_subsetA_staph_LUR2[,models[[1]]$indexbestmodel]+                           VGOB1_subsetA_staph_LUR2[,models[[2]]$indexbestmodel]) 

models[[modeln]]$bestmodel

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel


# 3 #  
# add third variable (the only difference of the above part is that now modeln=3 the model statement has 3 variables)
# and the call for the list of variable names in the model changed slightly

modeln<-3

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_2:nlastvar_LUR_2){
  if (is.numeric(VGOB1_subsetA_staph_LUR2[,i])==TRUE){  
    modeltry<-lm(VGOB1_subsetA_staph_LUR2$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetA_staph_LUR2[,models[[1]]$indexbestmodel]+VGOB1_subsetA_staph_LUR2[,models[[2]]$indexbestmodel]+ VGOB1_subsetA_staph_LUR2[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # All[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR2)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetA_staph_LUR2)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

#  rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

#  this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

#  here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetA_staph_LUR2)[models[[1]]$indexbestmodel], names(VGOB1_subsetA_staph_LUR2)[models[[2]]$indexbestmodel], names(VGOB1_subsetA_staph_LUR2)[models[[3]]$indexbestmodel])

#  this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetA_staph_LUR2$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetA_staph_LUR2[,models[[1]]$indexbestmodel]+ VGOB1_subsetA_staph_LUR2[,models[[2]]$indexbestmodel]+ VGOB1_subsetA_staph_LUR2[,models[[3]]$indexbestmodel]) 

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel


# 4 #  
#  add forth variable (the only difference of the above part is that now model n=4 the model statement more variables)
#  and the call for the list of variable names in the model changed slightly
modeln<-4

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1


for (i in nfirstvar_LUR_2:nlastvar_LUR_2){
  if (is.numeric(VGOB1_subsetA_staph_LUR2[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetA_staph_LUR2$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetA_staph_LUR2[,models[[1]]$indexbestmodel]+VGOB1_subsetA_staph_LUR2[,models[[2]]$indexbestmodel]+VGOB1_subsetA_staph_LUR2[,models[[3]]$indexbestmodel]+VGOB1_subsetA_staph_LUR2[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    #  the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    #  All[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR2)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetA_staph_LUR2)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

#  this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

#  here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetA_staph_LUR2)[models[[1]]$indexbestmodel], names(VGOB1_subsetA_staph_LUR2)[models[[2]]$indexbestmodel], names(VGOB1_subsetA_staph_LUR2)[models[[3]]$indexbestmodel], names(VGOB1_subsetA_staph_LUR2)[models[[4]]$indexbestmodel])

#  this is the r2 of that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetA_staph_LUR2$staph_copiespm3.ln.diffmeth.mean~ VGOB1_subsetA_staph_LUR2[,models[[1]]$indexbestmodel]+ VGOB1_subsetA_staph_LUR2[,models[[2]]$indexbestmodel]+VGOB1_subsetA_staph_LUR2[,models[[3]]$indexbestmodel]+ VGOB1_subsetA_staph_LUR2[,models[[4]]$indexbestmodel]) 


models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel


# 5 #  
# add fifth variable (the only difference of the above part is that now modeln=5 the model statement more variables)
# and the call for the list of variable names in the model changed slightly
modeln<-5

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_2:nlastvar_LUR_2){
  if (is.numeric(VGOB1_subsetA_staph_LUR2[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetA_staph_LUR2$staph_copiespm3.ln.diffmeth.mean~ VGOB1_subsetA_staph_LUR2[,models[[1]]$indexbestmodel]+ VGOB1_subsetA_staph_LUR2[,models[[2]]$indexbestmodel]+ VGOB1_subsetA_staph_LUR2[,models[[3]]$indexbestmodel]+ VGOB1_subsetA_staph_LUR2[,models[[4]]$indexbestmodel]+ VGOB1_subsetA_staph_LUR2[,i]) 
  
R2<-rbind(R2,summary(modeltry)$adj.r.squared)
# the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # All[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR2)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetA_staph_LUR2)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

#  this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetA_staph_LUR2)[models[[1]]$indexbestmodel], names(VGOB1_subsetA_staph_LUR2)[models[[2]]$indexbestmodel], names(VGOB1_subsetA_staph_LUR2)[models[[3]]$indexbestmodel], names(VGOB1_subsetA_staph_LUR2)[models[[4]]$indexbestmodel], names(VGOB1_subsetA_staph_LUR2)[models[[5]]$indexbestmodel])

#  this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetA_staph_LUR2$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetA_staph_LUR2[,models[[1]]$indexbestmodel]+VGOB1_subsetA_staph_LUR2[,models[[2]]$indexbestmodel]+VGOB1_subsetA_staph_LUR2[,models[[3]]$indexbestmodel]+ VGOB1_subsetA_staph_LUR2[,models[[4]]$indexbestmodel]+ VGOB1_subsetA_staph_LUR2[,models[[5]]$indexbestmodel]) 
models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[5]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[5]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel
models[[5]]$R2bestmodel

# 6 #  
# add sixth variable (the only difference of the above part is that now model n=6 the model statement more variables)
#  and the call for the list of variable names in the model changed slightly

modeln<-6

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_2 :nlastvar_LUR_2){
  if (is.numeric(VGOB1_subsetA_staph_LUR2[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetA_staph_LUR2$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetA_staph_LUR2[,models[[1]]$indexbestmodel]+VGOB1_subsetA_staph_LUR2[,models[[2]]$indexbestmodel]+VGOB1_subsetA_staph_LUR2[,models[[3]]$indexbestmodel]+VGOB1_subsetA_staph_LUR2[,models[[4]]$indexbestmodel]+VGOB1_subsetA_staph_LUR2[,models[[5]]$indexbestmodel]+ VGOB1_subsetA_staph_LUR2[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # All[,i] is the row that's being tried out now. the name of that row can be found in  names(All)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetA_staph_LUR2)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

# this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetA_staph_LUR2)[models[[1]]$indexbestmodel], names(VGOB1_subsetA_staph_LUR2)[models[[2]]$indexbestmodel] , names(VGOB1_subsetA_staph_LUR2)[models[[3]]$indexbestmodel], names(VGOB1_subsetA_staph_LUR2)[models[[4]]$indexbestmodel], names(VGOB1_subsetA_staph_LUR2)[models[[5]]$indexbestmodel], names(VGOB1_subsetA_staph_LUR2)[models[[6]]$indexbestmodel])

#  this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetA_staph_LUR2$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetA_staph_LUR2[,models[[1]]$indexbestmodel]+VGOB1_subsetA_staph_LUR2[,models[[2]]$indexbestmodel]+VGOB1_subsetA_staph_LUR2[,models[[3]]$indexbestmodel]+ VGOB1_subsetA_staph_LUR2[,models[[4]]$indexbestmodel]+ VGOB1_subsetA_staph_LUR2[,models[[5]]$indexbestmodel]+ VGOB1_subsetA_staph_LUR2[,models[[6]]$indexbestmodel]) 

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[5]]$summarybestmodel
models[[6]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[5]]$namesbestmodel
models[[6]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel
models[[5]]$R2bestmodel
models[[6]]$R2bestmodel


# 7 #  
# add seventh variable (the only difference of the above part is that now model n=7 the model statement more variables)
#  and the call for the list of variable names in the model changed slightly

modeln<-7

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_2 :nlastvar_LUR_2){
  if (is.numeric(VGOB1_subsetA_staph_LUR2[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetA_staph_LUR2$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetA_staph_LUR2[,models[[1]]$indexbestmodel]+VGOB1_subsetA_staph_LUR2[,models[[2]]$indexbestmodel]+VGOB1_subsetA_staph_LUR2[,models[[3]]$indexbestmodel]+VGOB1_subsetA_staph_LUR2[,models[[4]]$indexbestmodel]+VGOB1_subsetA_staph_LUR2[,models[[5]]$indexbestmodel]+VGOB1_subsetA_staph_LUR2[,models[[6]]$indexbestmodel]+ VGOB1_subsetA_staph_LUR2[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # Measurements_livestockpreds_LUR2[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR2)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetA_staph_LUR2)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

# this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetA_staph_LUR2)[models[[1]]$indexbestmodel], names(VGOB1_subsetA_staph_LUR2)[models[[2]]$indexbestmodel] , names(VGOB1_subsetA_staph_LUR2)[models[[3]]$indexbestmodel], names(VGOB1_subsetA_staph_LUR2)[models[[4]]$indexbestmodel], names(VGOB1_subsetA_staph_LUR2)[models[[5]]$indexbestmodel], names(VGOB1_subsetA_staph_LUR2)[models[[6]]$indexbestmodel], names(VGOB1_subsetA_staph_LUR2)[models[[7]]$indexbestmodel])

#  this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetA_staph_LUR2$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetA_staph_LUR2[,models[[1]]$indexbestmodel]+VGOB1_subsetA_staph_LUR2[,models[[2]]$indexbestmodel]+VGOB1_subsetA_staph_LUR2[,models[[3]]$indexbestmodel]+ VGOB1_subsetA_staph_LUR2[,models[[4]]$indexbestmodel]+ VGOB1_subsetA_staph_LUR2[,models[[5]]$indexbestmodel]+ VGOB1_subsetA_staph_LUR2[,models[[6]]$indexbestmodel]+ VGOB1_subsetA_staph_LUR2[,models[[7]]$indexbestmodel]) 

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[5]]$summarybestmodel
models[[6]]$summarybestmodel
models[[7]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[5]]$namesbestmodel
models[[6]]$namesbestmodel
models[[7]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel
models[[5]]$R2bestmodel
models[[6]]$R2bestmodel
models[[7]]$R2bestmodel

# 8 #  
# add eighth variable (the only difference of the above part is that now modeln=7 the model statement more variables)
# and the call for the list of variable names in the model changed slightly

modeln<-8

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_2 :nlastvar_LUR_2){
  if (is.numeric(VGOB1_subsetA_staph_LUR2[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetA_staph_LUR2$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetA_staph_LUR2[,models[[1]]$indexbestmodel]+VGOB1_subsetA_staph_LUR2[,models[[2]]$indexbestmodel]+VGOB1_subsetA_staph_LUR2[,models[[3]]$indexbestmodel]+VGOB1_subsetA_staph_LUR2[,models[[4]]$indexbestmodel]+VGOB1_subsetA_staph_LUR2[,models[[5]]$indexbestmodel]+VGOB1_subsetA_staph_LUR2[,models[[6]]$indexbestmodel]+ VGOB1_subsetA_staph_LUR2[,models[[7]]$indexbestmodel]+ VGOB1_subsetA_staph_LUR2[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # Measurements_livestockpreds_LUR2[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR2)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetA_staph_LUR2)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

# this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetA_staph_LUR2)[models[[1]]$indexbestmodel], names(VGOB1_subsetA_staph_LUR2)[models[[2]]$indexbestmodel] , names(VGOB1_subsetA_staph_LUR2)[models[[3]]$indexbestmodel], names(VGOB1_subsetA_staph_LUR2)[models[[4]]$indexbestmodel], names(VGOB1_subsetA_staph_LUR2)[models[[5]]$indexbestmodel], names(VGOB1_subsetA_staph_LUR2)[models[[6]]$indexbestmodel], names(VGOB1_subsetA_staph_LUR2)[models[[7]]$indexbestmodel], names(VGOB1_subsetA_staph_LUR2)[models[[8]]$indexbestmodel])

#  this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetA_staph_LUR2$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetA_staph_LUR2[,models[[1]]$indexbestmodel]+VGOB1_subsetA_staph_LUR2[,models[[2]]$indexbestmodel]+VGOB1_subsetA_staph_LUR2[,models[[3]]$indexbestmodel]+ VGOB1_subsetA_staph_LUR2[,models[[4]]$indexbestmodel]+ VGOB1_subsetA_staph_LUR2[,models[[5]]$indexbestmodel]+ VGOB1_subsetA_staph_LUR2[,models[[6]]$indexbestmodel]+ VGOB1_subsetA_staph_LUR2[,models[[7]]$indexbestmodel]+ VGOB1_subsetA_staph_LUR2[,models[[8]]$indexbestmodel]) 

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[5]]$summarybestmodel
models[[6]]$summarybestmodel
models[[7]]$summarybestmodel
models[[8]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[5]]$namesbestmodel
models[[6]]$namesbestmodel
models[[7]]$namesbestmodel
models[[8]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel
models[[5]]$R2bestmodel
models[[6]]$R2bestmodel
models[[7]]$R2bestmodel
models[[8]]$R2bestmodel

# 9 #  
# add ninth variable (the only difference of the above part is that now modeln=9 the model statement more variables)
# and the call for the list of variable names in the model changed slightly

modeln<-9

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_2 :nlastvar_LUR_2){
  if (is.numeric(VGOB1_subsetA_staph_LUR2[,i])==TRUE){
      modeltry<-lm(VGOB1_subsetA_staph_LUR2$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetA_staph_LUR2[,models[[1]]$indexbestmodel]+VGOB1_subsetA_staph_LUR2[,models[[2]]$indexbestmodel]+VGOB1_subsetA_staph_LUR2[,models[[3]]$indexbestmodel]+VGOB1_subsetA_staph_LUR2[,models[[4]]$indexbestmodel]+VGOB1_subsetA_staph_LUR2[,models[[5]]$indexbestmodel]+VGOB1_subsetA_staph_LUR2[,models[[6]]$indexbestmodel]+ VGOB1_subsetA_staph_LUR2[,models[[7]]$indexbestmodel]+ VGOB1_subsetA_staph_LUR2[,models[[8]]$indexbestmodel]+ VGOB1_subsetA_staph_LUR2[,i]) 
        R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # Measurements_livestockpreds_LUR2[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR2)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetA_staph_LUR2)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

# this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetA_staph_LUR2)[models[[1]]$indexbestmodel], names(VGOB1_subsetA_staph_LUR2)[models[[2]]$indexbestmodel] , names(VGOB1_subsetA_staph_LUR2)[models[[3]]$indexbestmodel], names(VGOB1_subsetA_staph_LUR2)[models[[4]]$indexbestmodel], names(VGOB1_subsetA_staph_LUR2)[models[[5]]$indexbestmodel], names(VGOB1_subsetA_staph_LUR2)[models[[6]]$indexbestmodel], names(VGOB1_subsetA_staph_LUR2)[models[[7]]$indexbestmodel], names(VGOB1_subsetA_staph_LUR2)[models[[8]]$indexbestmodel],  names(VGOB1_subsetA_staph_LUR2)[models[[9]]$indexbestmodel])

#  this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetA_staph_LUR2$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetA_staph_LUR2[,models[[1]]$indexbestmodel]+VGOB1_subsetA_staph_LUR2[,models[[2]]$indexbestmodel]+VGOB1_subsetA_staph_LUR2[,models[[3]]$indexbestmodel]+ VGOB1_subsetA_staph_LUR2[,models[[4]]$indexbestmodel]+ VGOB1_subsetA_staph_LUR2[,models[[5]]$indexbestmodel]+ VGOB1_subsetA_staph_LUR2[,models[[6]]$indexbestmodel]+ VGOB1_subsetA_staph_LUR2[,models[[7]]$indexbestmodel]+ VGOB1_subsetA_staph_LUR2[,models[[8]]$indexbestmodel]+ VGOB1_subsetA_staph_LUR2[,models[[9]]$indexbestmodel]) 

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[5]]$summarybestmodel
models[[6]]$summarybestmodel
models[[7]]$summarybestmodel
models[[8]]$summarybestmodel
models[[9]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[5]]$namesbestmodel
models[[6]]$namesbestmodel
models[[7]]$namesbestmodel
models[[8]]$namesbestmodel
models[[9]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel
models[[5]]$R2bestmodel
models[[6]]$R2bestmodel
models[[7]]$R2bestmodel
models[[8]]$R2bestmodel
models[[9]]$R2bestmodel

# 10 #  
#  add tenth variable (the only difference of the above part is that now model n=10 the model statement more variables)
#  and the call for the list of variable names in the model changed slightly

modeln<-10

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_2 :nlastvar_LUR_2){if (is.numeric(VGOB1_subsetA_staph_LUR2[,i])==TRUE){ modeltry<-lm(VGOB1_subsetA_staph_LUR2$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetA_staph_LUR2[,models[[1]]$indexbestmodel]+VGOB1_subsetA_staph_LUR2[,models[[2]]$indexbestmodel]+ VGOB1_subsetA_staph_LUR2[,models[[3]]$indexbestmodel]+VGOB1_subsetA_staph_LUR2[,models[[4]]$indexbestmodel]+ VGOB1_subsetA_staph_LUR2[,models[[5]]$indexbestmodel]+ VGOB1_subsetA_staph_LUR2[,models[[6]]$indexbestmodel]+ VGOB1_subsetA_staph_LUR2[,models[[7]]$indexbestmodel]+ VGOB1_subsetA_staph_LUR2[,models[[8]]$indexbestmodel]+ VGOB1_subsetA_staph_LUR2[,models[[9]]$indexbestmodel]+ VGOB1_subsetA_staph_LUR2[,i]) 

R2<-rbind(R2,summary(modeltry)$adj.r.squared)
# the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # Measurements_livestockpreds_LUR2[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR2)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetA_staph_LUR2)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

# this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

# here are the names
models[[modeln]]$namesbestmodel<-c( names(VGOB1_subsetA_staph_LUR2)[models[[1]]$indexbestmodel],                   names(VGOB1_subsetA_staph_LUR2)[models[[2]]$indexbestmodel] , names(VGOB1_subsetA_staph_LUR2)[models[[3]]$indexbestmodel], names(VGOB1_subsetA_staph_LUR2)[models[[4]]$indexbestmodel], names(VGOB1_subsetA_staph_LUR2)[models[[5]]$indexbestmodel], names(VGOB1_subsetA_staph_LUR2)[models[[6]]$indexbestmodel], names(VGOB1_subsetA_staph_LUR2)[models[[7]]$indexbestmodel], names(VGOB1_subsetA_staph_LUR2)[models[[8]]$indexbestmodel], names(VGOB1_subsetA_staph_LUR2)[models[[9]]$indexbestmodel], names(VGOB1_subsetA_staph_LUR2)[models[[10]]$indexbestmodel])

#  this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetA_staph_LUR2$staph_copiespm3.ln.diffmeth.mean~                                VGOB1_subsetA_staph_LUR2[,models[[1]]$indexbestmodel]+ VGOB1_subsetA_staph_LUR2[,models[[2]]$indexbestmodel]+                           VGOB1_subsetA_staph_LUR2[,models[[3]]$indexbestmodel]+ VGOB1_subsetA_staph_LUR2[,models[[4]]$indexbestmodel]+ VGOB1_subsetA_staph_LUR2[,models[[5]]$indexbestmodel]+ VGOB1_subsetA_staph_LUR2[,models[[6]]$indexbestmodel]+ VGOB1_subsetA_staph_LUR2[,models[[7]]$indexbestmodel]+ VGOB1_subsetA_staph_LUR2[,models[[8]]$indexbestmodel]+ VGOB1_subsetA_staph_LUR2[,models[[9]]$indexbestmodel]+ VGOB1_subsetA_staph_LUR2[,models[[10]]$indexbestmodel]) 

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[5]]$summarybestmodel
models[[6]]$summarybestmodel
models[[7]]$summarybestmodel
models[[8]]$summarybestmodel
models[[9]]$summarybestmodel
models[[10]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[5]]$namesbestmodel
models[[6]]$namesbestmodel
models[[7]]$namesbestmodel
models[[8]]$namesbestmodel
models[[9]]$namesbestmodel
models[[10]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel
models[[5]]$R2bestmodel
models[[6]]$R2bestmodel
models[[7]]$R2bestmodel
models[[8]]$R2bestmodel
models[[9]]$R2bestmodel
models[[10]]$R2bestmodel

#  at this point I always check whether the next model is more than 1% better than the one before and if not I end here

#   CODE FOR PICKING OUT THE BEST MODEL #   
temp <- 0
besti <- 0
for (i in 1:10){ #  think this runs the loop 10 times - not fully sure thought - but not to do with the number of models I don't think - as when I change to 3, I still get the model with 4 variables as best model
  print(models[[i]]$R2bestmodel)
  #       print(models[[i]]$summarybestmodel$coefficients=-1,4])
  #       if((models[[i]]$R2bestmodel-temp > 0.0) && (all(models[[i]]$summarybestmodel$coefficients[-1,4]<0.1))){
  #         temp <- models[[i]]$R2bestmodel
  #         besti <- i
  #         }
  if((models[[i]]$R2bestmodel-temp > 0.0) && (all(models[[i]]$summarybestmodel$coefficients[-1,4]<0.1))){
    temp <- models[[i]]$R2bestmodel
    besti <- i
  }else{
    finalBestModel_staph_LUR2_subsetA <- models[[besti]]$bestmodel
    finalBestModelNames_staph_subsetA <- models[[besti]]$namesbestmodel
    Sites <- 1:dim(VGOB1_subsetA_staph_LUR2)[1] # full original model
    #  CVaR2<-escCV_staph_LUR2(Sites)[2] # Cross Validation
    maxCD<-max(cooks.distance(finalBestModel_staph_LUR2_subsetA))
    if(length(finalBestModelNames_staph_subsetA)<2){ # vif fn doesnot work when only 1 variable...       # 
      maxVIF<-"NA"
    }else{
      maxVIF<-max(vif(finalBestModel_staph_LUR2_subsetA))
    }
    print(paste("This is the best staph model for subset A: ",besti,
                "(AdjR2: ",format(models[[besti]]$R2bestmodel,digits=3), "; MaxCD: ",format(maxCD,digits=3),"; MaxVIF: ",
                format(maxVIF,digits=3),")", sep=''))
    print(finalBestModelNames_staph_subsetA)
    break
  }
}

#  Overview of the final best model using the algorithm selection process (taking into account VIF, R^2, and p-values)
finalBestModel_staph_LUR2_subsetA 
finalBestModelNames_staph_subsetA
models[[besti]]$summarybestmodel
models[[besti]]$R2bestmodel

#### B ####
# LUR model building process for subset B
# This is the dataframe with the relevant predictor vars for LUR2 models for subset B (55 sites)
VGOB1_subsetB_staph_LUR2 # n.b. this dataframe only includes microbial marker concentrations for staph unlike the dataframe Measurements_livestockpreds_LUR2 as previously used for the model building. 

#  Now set the values of some variables that will be needed
nfirstvar_LUR_2 <- 3  
nlastvar_LUR_2 <- 71

# Function building to run the models 
# 1 #  

models<-list()
modeln<-1
models[[modeln]]<-list()

R2<-1
betaaddedvar<-1
addedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_2:nlastvar_LUR_2){
  if (is.numeric(VGOB1_subsetB_staph_LUR2[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetB_staph_LUR2$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetB_staph_LUR2[,i])                            
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    #  Measurements_livestockpreds_LUR2[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR2)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetB_staph_LUR2)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)
models[[modeln]]$results

#  this are the candidates models with the highest R2, not a negative beta for the new, nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)
models[[modeln]]$resultspos

#  rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))
models[[modeln]]$resultspos

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j
models[[modeln]]$indexbestmodel

subset(models[[modeln]]$resultspos, rank==1)
subset(models[[modeln]]$resultspos)

#  this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]
models[[modeln]]$summarybestmodel

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetB_staph_LUR2)[models[[1]]$indexbestmodel])
models[[modeln]]$namesbestmodel

#  this is the r2 of that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2
models[[modeln]]$R2bestmodel

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetB_staph_LUR2$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetB_staph_LUR2[,models[[1]]$indexbestmodel]) 
models[[modeln]]$bestmodel

summary(models[[modeln]]$bestmodel)

#  The first model includes the predictor: nPigMultipFarmWghtDist.3000m.sum.Tr.1P9 - meaning the number of multiplier pig farms weighted to distance in a 3000m buffer

# 2 #  
# Add 2nd variable (the only difference of the above part is that now modeln=2 the model statement has 2 variables)
# and the call for the list of variable names in the model changed slightly

modeln<-2

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_2:nlastvar_LUR_2){
  if (is.numeric(VGOB1_subsetB_staph_LUR2[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetB_staph_LUR2$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetB_staph_LUR2[,models[[1]]$indexbestmodel]+ VGOB1_subsetB_staph_LUR2[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # Measurements_livestockpreds_LUR2[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR2)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetB_staph_LUR2)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  these are the candidate models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)
models[[modeln]]$resultspos

#  rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))
models[[modeln]]$resultspos

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j
models[[modeln]]$indexbestmodel

subset(models[[modeln]]$resultspos, rank==1)

# this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]
models[[modeln]]$summarybestmodel

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetB_staph_LUR2)[models[[1]]$indexbestmodel], names(VGOB1_subsetB_staph_LUR2)[models[[2]]$indexbestmodel] )
models[[modeln]]$namesbestmodel

# this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2
models[[modeln]]$R2bestmodel

# this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetB_staph_LUR2$staph_copiespm3.ln.diffmeth.mean~                               VGOB1_subsetB_staph_LUR2[,models[[1]]$indexbestmodel]+                           VGOB1_subsetB_staph_LUR2[,models[[2]]$indexbestmodel]) 

models[[modeln]]$bestmodel

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel


# 3 #  
# add third variable (the only difference of the above part is that now modeln=3 the model statement has 3 variables)
# and the call for the list of variable names in the model changed slightly

modeln<-3

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_2:nlastvar_LUR_2){
  if (is.numeric(VGOB1_subsetB_staph_LUR2[,i])==TRUE){  
    modeltry<-lm(VGOB1_subsetB_staph_LUR2$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetB_staph_LUR2[,models[[1]]$indexbestmodel]+VGOB1_subsetB_staph_LUR2[,models[[2]]$indexbestmodel]+ VGOB1_subsetB_staph_LUR2[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # All[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR2)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetB_staph_LUR2)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

#  rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

#  this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

#  here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetB_staph_LUR2)[models[[1]]$indexbestmodel], names(VGOB1_subsetB_staph_LUR2)[models[[2]]$indexbestmodel], names(VGOB1_subsetB_staph_LUR2)[models[[3]]$indexbestmodel])

#  this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetB_staph_LUR2$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetB_staph_LUR2[,models[[1]]$indexbestmodel]+ VGOB1_subsetB_staph_LUR2[,models[[2]]$indexbestmodel]+ VGOB1_subsetB_staph_LUR2[,models[[3]]$indexbestmodel]) 

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel


# 4 #  
#  add forth variable (the only difference of the above part is that now model n=4 the model statement more variables)
#  and the call for the list of variable names in the model changed slightly
modeln<-4

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1


for (i in nfirstvar_LUR_2:nlastvar_LUR_2){
  if (is.numeric(VGOB1_subsetB_staph_LUR2[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetB_staph_LUR2$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetB_staph_LUR2[,models[[1]]$indexbestmodel]+VGOB1_subsetB_staph_LUR2[,models[[2]]$indexbestmodel]+VGOB1_subsetB_staph_LUR2[,models[[3]]$indexbestmodel]+VGOB1_subsetB_staph_LUR2[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    #  the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    #  All[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR2)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetB_staph_LUR2)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

#  this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

#  here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetB_staph_LUR2)[models[[1]]$indexbestmodel], names(VGOB1_subsetB_staph_LUR2)[models[[2]]$indexbestmodel], names(VGOB1_subsetB_staph_LUR2)[models[[3]]$indexbestmodel], names(VGOB1_subsetB_staph_LUR2)[models[[4]]$indexbestmodel])

#  this is the r2 of that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetB_staph_LUR2$staph_copiespm3.ln.diffmeth.mean~ VGOB1_subsetB_staph_LUR2[,models[[1]]$indexbestmodel]+ VGOB1_subsetB_staph_LUR2[,models[[2]]$indexbestmodel]+ VGOB1_subsetB_staph_LUR2[,models[[3]]$indexbestmodel]+ VGOB1_subsetB_staph_LUR2[,models[[4]]$indexbestmodel]) 


models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel


# 5 #  
# add fifth variable (the only difference of the above part is that now modeln=5 the model statement more variables)
# and the call for the list of variable names in the model changed slightly
modeln<-5

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_2:nlastvar_LUR_2){
  if (is.numeric(VGOB1_subsetB_staph_LUR2[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetB_staph_LUR2$staph_copiespm3.ln.diffmeth.mean~ VGOB1_subsetB_staph_LUR2[,models[[1]]$indexbestmodel]+ VGOB1_subsetB_staph_LUR2[,models[[2]]$indexbestmodel]+ VGOB1_subsetB_staph_LUR2[,models[[3]]$indexbestmodel]+ VGOB1_subsetB_staph_LUR2[,models[[4]]$indexbestmodel]+ VGOB1_subsetB_staph_LUR2[,i]) 
  
R2<-rbind(R2,summary(modeltry)$adj.r.squared)
# the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # All[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR2)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetB_staph_LUR2)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

#  this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetB_staph_LUR2)[models[[1]]$indexbestmodel], names(VGOB1_subsetB_staph_LUR2)[models[[2]]$indexbestmodel], names(VGOB1_subsetB_staph_LUR2)[models[[3]]$indexbestmodel], names(VGOB1_subsetB_staph_LUR2)[models[[4]]$indexbestmodel], names(VGOB1_subsetB_staph_LUR2)[models[[5]]$indexbestmodel])

#  this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetB_staph_LUR2$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetB_staph_LUR2[,models[[1]]$indexbestmodel]+VGOB1_subsetB_staph_LUR2[,models[[2]]$indexbestmodel]+VGOB1_subsetB_staph_LUR2[,models[[3]]$indexbestmodel]+ VGOB1_subsetB_staph_LUR2[,models[[4]]$indexbestmodel]+ VGOB1_subsetB_staph_LUR2[,models[[5]]$indexbestmodel]) 
models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[5]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[5]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel
models[[5]]$R2bestmodel

# 6 #  
# add sixth variable (the only difference of the above part is that now model n=6 the model statement more variables)
#  and the call for the list of variable names in the model changed slightly

modeln<-6

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_2 :nlastvar_LUR_2){
  if (is.numeric(VGOB1_subsetB_staph_LUR2[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetB_staph_LUR2$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetB_staph_LUR2[,models[[1]]$indexbestmodel]+VGOB1_subsetB_staph_LUR2[,models[[2]]$indexbestmodel]+VGOB1_subsetB_staph_LUR2[,models[[3]]$indexbestmodel]+VGOB1_subsetB_staph_LUR2[,models[[4]]$indexbestmodel]+VGOB1_subsetB_staph_LUR2[,models[[5]]$indexbestmodel]+ VGOB1_subsetB_staph_LUR2[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # All[,i] is the row that's being tried out now. the name of that row can be found in  names(All)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetB_staph_LUR2)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

# this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetB_staph_LUR2)[models[[1]]$indexbestmodel], names(VGOB1_subsetB_staph_LUR2)[models[[2]]$indexbestmodel] , names(VGOB1_subsetB_staph_LUR2)[models[[3]]$indexbestmodel], names(VGOB1_subsetB_staph_LUR2)[models[[4]]$indexbestmodel], names(VGOB1_subsetB_staph_LUR2)[models[[5]]$indexbestmodel], names(VGOB1_subsetB_staph_LUR2)[models[[6]]$indexbestmodel])

#  this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetB_staph_LUR2$staph_copiespm3.ln.diffmeth.mean~ VGOB1_subsetB_staph_LUR2[,models[[1]]$indexbestmodel]+ VGOB1_subsetB_staph_LUR2[,models[[2]]$indexbestmodel]+ VGOB1_subsetB_staph_LUR2[,models[[3]]$indexbestmodel]+ VGOB1_subsetB_staph_LUR2[,models[[4]]$indexbestmodel]+ VGOB1_subsetB_staph_LUR2[,models[[5]]$indexbestmodel]+ VGOB1_subsetB_staph_LUR2[,models[[6]]$indexbestmodel]) 

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[5]]$summarybestmodel
models[[6]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[5]]$namesbestmodel
models[[6]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel
models[[5]]$R2bestmodel
models[[6]]$R2bestmodel


# 7 #  
# add seventh variable (the only difference of the above part is that now model n=7 the model statement more variables)
#  and the call for the list of variable names in the model changed slightly

modeln<-7

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_2 :nlastvar_LUR_2){
  if (is.numeric(VGOB1_subsetB_staph_LUR2[,i])==TRUE){
    modeltry<- lm(VGOB1_subsetB_staph_LUR2$staph_copiespm3.ln.diffmeth.mean~ VGOB1_subsetB_staph_LUR2[,models[[1]]$indexbestmodel]+ VGOB1_subsetB_staph_LUR2[,models[[2]]$indexbestmodel]+ VGOB1_subsetB_staph_LUR2[,models[[3]]$indexbestmodel]+ VGOB1_subsetB_staph_LUR2[,models[[4]]$indexbestmodel]+ VGOB1_subsetB_staph_LUR2[,models[[5]]$indexbestmodel]+ VGOB1_subsetB_staph_LUR2[,models[[6]]$indexbestmodel]+ VGOB1_subsetB_staph_LUR2[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # Measurements_livestockpreds_LUR2[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR2)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetB_staph_LUR2)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

# this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetB_staph_LUR2)[models[[1]]$indexbestmodel], names(VGOB1_subsetB_staph_LUR2)[models[[2]]$indexbestmodel] , names(VGOB1_subsetB_staph_LUR2)[models[[3]]$indexbestmodel], names(VGOB1_subsetB_staph_LUR2)[models[[4]]$indexbestmodel], names(VGOB1_subsetB_staph_LUR2)[models[[5]]$indexbestmodel], names(VGOB1_subsetB_staph_LUR2)[models[[6]]$indexbestmodel], names(VGOB1_subsetB_staph_LUR2)[models[[7]]$indexbestmodel])

#  this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetB_staph_LUR2$staph_copiespm3.ln.diffmeth.mean~ VGOB1_subsetB_staph_LUR2[,models[[1]]$indexbestmodel]+ VGOB1_subsetB_staph_LUR2[,models[[2]]$indexbestmodel]+ VGOB1_subsetB_staph_LUR2[,models[[3]]$indexbestmodel]+ VGOB1_subsetB_staph_LUR2[,models[[4]]$indexbestmodel]+ VGOB1_subsetB_staph_LUR2[,models[[5]]$indexbestmodel]+ VGOB1_subsetB_staph_LUR2[,models[[6]]$indexbestmodel]+ VGOB1_subsetB_staph_LUR2[,models[[7]]$indexbestmodel]) 

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[5]]$summarybestmodel
models[[6]]$summarybestmodel
models[[7]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[5]]$namesbestmodel
models[[6]]$namesbestmodel
models[[7]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel
models[[5]]$R2bestmodel
models[[6]]$R2bestmodel
models[[7]]$R2bestmodel

# 8 #  
# add eighth variable (the only difference of the above part is that now modeln=7 the model statement more variables)
# and the call for the list of variable names in the model changed slightly

modeln<-8

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_2 :nlastvar_LUR_2){
  if (is.numeric(VGOB1_subsetB_staph_LUR2[,i])==TRUE){
    modeltry<- lm(VGOB1_subsetB_staph_LUR2$staph_copiespm3.ln.diffmeth.mean~ VGOB1_subsetB_staph_LUR2[,models[[1]]$indexbestmodel]+ VGOB1_subsetB_staph_LUR2[,models[[2]]$indexbestmodel]+ VGOB1_subsetB_staph_LUR2[,models[[3]]$indexbestmodel]+ VGOB1_subsetB_staph_LUR2[,models[[4]]$indexbestmodel]+ VGOB1_subsetB_staph_LUR2[,models[[5]]$indexbestmodel]+ VGOB1_subsetB_staph_LUR2[,models[[6]]$indexbestmodel]+ VGOB1_subsetB_staph_LUR2[,models[[7]]$indexbestmodel]+ VGOB1_subsetB_staph_LUR2[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # Measurements_livestockpreds_LUR2[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR2)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetB_staph_LUR2)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

# this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetB_staph_LUR2)[models[[1]]$indexbestmodel], names(VGOB1_subsetB_staph_LUR2)[models[[2]]$indexbestmodel] , names(VGOB1_subsetB_staph_LUR2)[models[[3]]$indexbestmodel], names(VGOB1_subsetB_staph_LUR2)[models[[4]]$indexbestmodel], names(VGOB1_subsetB_staph_LUR2)[models[[5]]$indexbestmodel], names(VGOB1_subsetB_staph_LUR2)[models[[6]]$indexbestmodel], names(VGOB1_subsetB_staph_LUR2)[models[[7]]$indexbestmodel], names(VGOB1_subsetB_staph_LUR2)[models[[8]]$indexbestmodel])

#  this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetB_staph_LUR2$staph_copiespm3.ln.diffmeth.mean~ VGOB1_subsetB_staph_LUR2[,models[[1]]$indexbestmodel]+ VGOB1_subsetB_staph_LUR2[,models[[2]]$indexbestmodel]+ VGOB1_subsetB_staph_LUR2[,models[[3]]$indexbestmodel]+ VGOB1_subsetB_staph_LUR2[,models[[4]]$indexbestmodel]+ VGOB1_subsetB_staph_LUR2[,models[[5]]$indexbestmodel]+ VGOB1_subsetB_staph_LUR2[,models[[6]]$indexbestmodel]+ VGOB1_subsetB_staph_LUR2[,models[[7]]$indexbestmodel]+ VGOB1_subsetB_staph_LUR2[,models[[8]]$indexbestmodel]) 

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[5]]$summarybestmodel
models[[6]]$summarybestmodel
models[[7]]$summarybestmodel
models[[8]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[5]]$namesbestmodel
models[[6]]$namesbestmodel
models[[7]]$namesbestmodel
models[[8]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel
models[[5]]$R2bestmodel
models[[6]]$R2bestmodel
models[[7]]$R2bestmodel
models[[8]]$R2bestmodel


# The next part of the code (n=9-10) does not work
# This is because one of the coefficients included in the model with 6 variables is negative, the code does not allow for this. I can stop here.

# # 9 #  
# # add ninth variable (the only difference of the above part is that now modeln=9 the model statement more variables)
# # and the call for the list of variable names in the model changed slightly
# 
# modeln<-9
# 
# models[[modeln]]<-list()
# 
# R2<-1
# addedvar<-1
# betaaddedvar<-1
# minbetas<-1
# j<-1
# 
# for (i in nfirstvar_LUR_2 :nlastvar_LUR_2){
#   if (is.numeric(VGOB1_subsetB_staph_LUR2[,i])==TRUE){
#       modeltry<-lm(VGOB1_subsetB_staph_LUR2$staph_copiespm3.ln.diffmeth.mean~ VGOB1_subsetB_staph_LUR2[,models[[1]]$indexbestmodel]+ VGOB1_subsetB_staph_LUR2[,models[[2]]$indexbestmodel]+ VGOB1_subsetB_staph_LUR2[,models[[3]]$indexbestmodel]+ VGOB1_subsetB_staph_LUR2[,models[[4]]$indexbestmodel]+ VGOB1_subsetB_staph_LUR2[,models[[5]]$indexbestmodel]+ VGOB1_subsetB_staph_LUR2[,models[[6]]$indexbestmodel]+ VGOB1_subsetB_staph_LUR2[,models[[7]]$indexbestmodel]+ VGOB1_subsetB_staph_LUR2[,models[[8]]$indexbestmodel]+ VGOB1_subsetB_staph_LUR2[,i]) 
#         R2<-rbind(R2,summary(modeltry)$adj.r.squared)
#     # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
#     betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
#     #  find out if there is a negative beta at All. The intercept does not count [-1]!
#     minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
#     # Measurements_livestockpreds_LUR2[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR2)[i]
#     addedvar<-rbind(addedvar,names(VGOB1_subsetB_staph_LUR2)[i])
#     j<-rbind(j, i)
#     models[[modeln]][[i]]<-summary(modeltry)
#   }
# }
# 
# models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)
# 
# #  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
# models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)
# 
# # rank the R2's of these models
# models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))
# 
# #  this is the index of the row with the highest R2 and  no negative betas in this subset
# models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j
# 
# subset(models[[modeln]]$resultspos, rank==1)
# 
# # this is the model
# models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]
# 
# # here are the names
# models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetB_staph_LUR2)[models[[1]]$indexbestmodel], names(VGOB1_subsetB_staph_LUR2)[models[[2]]$indexbestmodel] , names(VGOB1_subsetB_staph_LUR2)[models[[3]]$indexbestmodel], names(VGOB1_subsetB_staph_LUR2)[models[[4]]$indexbestmodel], names(VGOB1_subsetB_staph_LUR2)[models[[5]]$indexbestmodel], names(VGOB1_subsetB_staph_LUR2)[models[[6]]$indexbestmodel], names(VGOB1_subsetB_staph_LUR2)[models[[7]]$indexbestmodel], names(VGOB1_subsetB_staph_LUR2)[models[[8]]$indexbestmodel],  names(VGOB1_subsetB_staph_LUR2)[models[[9]]$indexbestmodel])
# 
# #  this is the r2 or that model
# models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2
# 
# #  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
# models[[modeln]]$bestmodel <- lm(VGOB1_subsetB_staph_LUR2$staph_copiespm3.ln.diffmeth.mean~ VGOB1_subsetB_staph_LUR2[,models[[1]]$indexbestmodel]+ VGOB1_subsetB_staph_LUR2[,models[[2]]$indexbestmodel]+ VGOB1_subsetB_staph_LUR2[,models[[3]]$indexbestmodel]+ VGOB1_subsetB_staph_LUR2[,models[[4]]$indexbestmodel]+ VGOB1_subsetB_staph_LUR2[,models[[5]]$indexbestmodel]+ VGOB1_subsetB_staph_LUR2[,models[[6]]$indexbestmodel]+ VGOB1_subsetB_staph_LUR2[,models[[7]]$indexbestmodel]+ VGOB1_subsetB_staph_LUR2[,models[[8]]$indexbestmodel]+ VGOB1_subsetB_staph_LUR2[,models[[9]]$indexbestmodel]) 
# 
# models[[1]]$summarybestmodel
# models[[2]]$summarybestmodel
# models[[3]]$summarybestmodel
# models[[4]]$summarybestmodel
# models[[5]]$summarybestmodel
# models[[6]]$summarybestmodel
# models[[7]]$summarybestmodel
# models[[8]]$summarybestmodel
# models[[9]]$summarybestmodel
# models[[1]]$namesbestmodel
# models[[2]]$namesbestmodel
# models[[3]]$namesbestmodel
# models[[4]]$namesbestmodel
# models[[5]]$namesbestmodel
# models[[6]]$namesbestmodel
# models[[7]]$namesbestmodel
# models[[8]]$namesbestmodel
# models[[9]]$namesbestmodel
# models[[1]]$R2bestmodel
# models[[2]]$R2bestmodel
# models[[3]]$R2bestmodel
# models[[4]]$R2bestmodel
# models[[5]]$R2bestmodel
# models[[6]]$R2bestmodel
# models[[7]]$R2bestmodel
# models[[8]]$R2bestmodel
# models[[9]]$R2bestmodel

# # 10 #  
# #  add tenth variable (the only difference of the above part is that now model n=10 the model statement more variables)
# #  and the call for the list of variable names in the model changed slightly
# 
# modeln<-10
# 
# models[[modeln]]<-list()
# 
# R2<-1
# addedvar<-1
# betaaddedvar<-1
# minbetas<-1
# j<-1
# 
# for (i in nfirstvar_LUR_2 :nlastvar_LUR_2){if (is.numeric(VGOB1_subsetB_staph_LUR2[,i])==TRUE){ modeltry<-lm(VGOB1_subsetB_staph_LUR2$staph_copiespm3.ln.diffmeth.mean~ VGOB1_subsetB_staph_LUR2[,models[[1]]$indexbestmodel]+ VGOB1_subsetB_staph_LUR2[,models[[2]]$indexbestmodel]+ VGOB1_subsetB_staph_LUR2[,models[[3]]$indexbestmodel]+ VGOB1_subsetB_staph_LUR2[,models[[4]]$indexbestmodel]+ VGOB1_subsetB_staph_LUR2[,models[[5]]$indexbestmodel]+ VGOB1_subsetB_staph_LUR2[,models[[6]]$indexbestmodel]+ VGOB1_subsetB_staph_LUR2[,models[[7]]$indexbestmodel]+ VGOB1_subsetB_staph_LUR2[,models[[8]]$indexbestmodel]+ VGOB1_subsetB_staph_LUR2[,models[[9]]$indexbestmodel]+ VGOB1_subsetB_staph_LUR2[,i]) 
# 
# R2<-rbind(R2,summary(modeltry)$adj.r.squared)
# # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
#     betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
#     #  find out if there is a negative beta at All. The intercept does not count [-1]!
#     minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
#     # Measurements_livestockpreds_LUR2[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR2)[i]
#     addedvar<-rbind(addedvar,names(VGOB1_subsetB_staph_LUR2)[i])
#     j<-rbind(j, i)
#     models[[modeln]][[i]]<-summary(modeltry)
#   }
# }
# 
# models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)
# 
# #  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
# models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)
# 
# # rank the R2's of these models
# models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))
# 
# #  this is the index of the row with the highest R2 and  no negative betas in this subset
# models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j
# 
# subset(models[[modeln]]$resultspos, rank==1)
# 
# # this is the model
# models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]
# 
# # here are the names
# models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetB_staph_LUR2)[models[[1]]$indexbestmodel],    names(VGOB1_subsetB_staph_LUR2)[models[[2]]$indexbestmodel], names(VGOB1_subsetB_staph_LUR2)[models[[3]]$indexbestmodel], names(VGOB1_subsetB_staph_LUR2)[models[[4]]$indexbestmodel], names(VGOB1_subsetB_staph_LUR2)[models[[5]]$indexbestmodel], names(VGOB1_subsetB_staph_LUR2)[models[[6]]$indexbestmodel], names(VGOB1_subsetB_staph_LUR2)[models[[7]]$indexbestmodel], names(VGOB1_subsetB_staph_LUR2)[models[[8]]$indexbestmodel], names(VGOB1_subsetB_staph_LUR2)[models[[9]]$indexbestmodel], names(VGOB1_subsetB_staph_LUR2)[models[[10]]$indexbestmodel])
# 
# #  this is the r2 or that model
# models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2
# 
# #  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
# models[[modeln]]$bestmodel <- lm(VGOB1_subsetB_staph_LUR2$staph_copiespm3.ln.diffmeth.mean~        VGOB1_subsetB_staph_LUR2[,models[[1]]$indexbestmodel]+ VGOB1_subsetB_staph_LUR2[,models[[2]]$indexbestmodel]+  VGOB1_subsetB_staph_LUR2[,models[[3]]$indexbestmodel]+ VGOB1_subsetB_staph_LUR2[,models[[4]]$indexbestmodel]+ VGOB1_subsetB_staph_LUR2[,models[[5]]$indexbestmodel]+ VGOB1_subsetB_staph_LUR2[,models[[6]]$indexbestmodel]+ VGOB1_subsetB_staph_LUR2[,models[[7]]$indexbestmodel]+ VGOB1_subsetB_staph_LUR2[,models[[8]]$indexbestmodel]+ VGOB1_subsetB_staph_LUR2[,models[[9]]$indexbestmodel]+ VGOB1_subsetB_staph_LUR2[,models[[10]]$indexbestmodel]) 
# 
# models[[1]]$summarybestmodel
# models[[2]]$summarybestmodel
# models[[3]]$summarybestmodel
# models[[4]]$summarybestmodel
# models[[5]]$summarybestmodel
# models[[6]]$summarybestmodel
# models[[7]]$summarybestmodel
# models[[8]]$summarybestmodel
# models[[9]]$summarybestmodel
# models[[10]]$summarybestmodel
# models[[1]]$namesbestmodel
# models[[2]]$namesbestmodel
# models[[3]]$namesbestmodel
# models[[4]]$namesbestmodel
# models[[5]]$namesbestmodel
# models[[6]]$namesbestmodel
# models[[7]]$namesbestmodel
# models[[8]]$namesbestmodel
# models[[9]]$namesbestmodel
# models[[10]]$namesbestmodel
# models[[1]]$R2bestmodel
# models[[2]]$R2bestmodel
# models[[3]]$R2bestmodel
# models[[4]]$R2bestmodel
# models[[5]]$R2bestmodel
# models[[6]]$R2bestmodel
# models[[7]]$R2bestmodel
# models[[8]]$R2bestmodel
# models[[9]]$R2bestmodel
# models[[10]]$R2bestmodel


#   CODE FOR PICKING OUT THE BEST MODEL #   
temp <- 0
besti <- 0
for (i in 1:10){ #  think this runs the loop 10 times - not fully sure thought - but not to do with the number of models I don't think - as when I change to 3, I still get the model with 4 variables as best model
  print(models[[i]]$R2bestmodel)
  #       print(models[[i]]$summarybestmodel$coefficients=-1,4])
  #       if((models[[i]]$R2bestmodel-temp > 0.0) && (all(models[[i]]$summarybestmodel$coefficients[-1,4]<0.1))){
  #         temp <- models[[i]]$R2bestmodel
  #         besti <- i
  #         }
  if((models[[i]]$R2bestmodel-temp > 0.0) && (all(models[[i]]$summarybestmodel$coefficients[-1,4]<0.1))){
    temp <- models[[i]]$R2bestmodel
    besti <- i
  }else{
    finalBestModel_staph_LUR2_subsetB <- models[[besti]]$bestmodel
    finalBestModelNames_staph_subsetB <- models[[besti]]$namesbestmodel
    Sites <- 1:dim(VGOB1_subsetB_staph_LUR2)[1] # full original model
    #  CVaR2<-escCV_staph_LUR2(Sites)[2] # Cross Validation
    maxCD<-max(cooks.distance(finalBestModel_staph_LUR2_subsetB))
    if(length(finalBestModelNames_staph_subsetB)<2){ # vif fn doesnot work when only 1 variable...       # 
      maxVIF<-"NA"
    }else{
      maxVIF<-max(vif(finalBestModel_staph_LUR2_subsetB))
    }
    print(paste("This is the best staph model for subset B of 10-fold CV: ",besti,
                "(AdjR2: ",format(models[[besti]]$R2bestmodel,digits=3), "; MaxCD: ",format(maxCD,digits=3),"; MaxVIF: ",
                format(maxVIF,digits=3),")", sep=''))
    print(finalBestModelNames_staph_subsetB)
    break
  }
}

#  Overview of the final best model using the algorithm selection process (taking into account VIF, R^2, and p-values)
finalBestModel_staph_LUR2_subsetB 
finalBestModelNames_staph_subsetB 
models[[besti]]$summarybestmodel
models[[besti]]$R2bestmodel

#### C ####
# LUR model building process for subset C
#  This is the dataframe with the relevant predictor vars for LUR2 models for subset C (55 sites)
VGOB1_subsetC_staph_LUR2 # n.b. this dataframe only includes microbial marker concentrations for staph unlike the dataframe Measurements_livestockpreds_LUR2 as previously used for the model building. 

#  Now set the values of some variables that will be needed
nfirstvar_LUR_2 <- 3  
nlastvar_LUR_2 <- 71

# Function building to run the models 
# 1 #  

models<-list()
modeln<-1
models[[modeln]]<-list()

R2<-1
betaaddedvar<-1
addedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_2:nlastvar_LUR_2){
  if (is.numeric(VGOB1_subsetC_staph_LUR2[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetC_staph_LUR2$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetC_staph_LUR2[,i])                            
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    #  Measurements_livestockpreds_LUR2[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR2)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetC_staph_LUR2)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)
models[[modeln]]$results

#  this are the candidates models with the highest R2, not a negative beta for the new, nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)
models[[modeln]]$resultspos

#  rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))
models[[modeln]]$resultspos

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j
models[[modeln]]$indexbestmodel

subset(models[[modeln]]$resultspos, rank==1)
subset(models[[modeln]]$resultspos)

#  this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]
models[[modeln]]$summarybestmodel

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetC_staph_LUR2)[models[[1]]$indexbestmodel])
models[[modeln]]$namesbestmodel

#  this is the r2 of that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2
models[[modeln]]$R2bestmodel

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetC_staph_LUR2$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetC_staph_LUR2[,models[[1]]$indexbestmodel]) 
models[[modeln]]$bestmodel

summary(models[[modeln]]$bestmodel)

#  The first model includes the predictor: nPigMultipFarmWghtDist.3000m.sum.Tr.1P9 - meaning the number of multiplier pig farms weighted to distance in a 3000m buffer

# 2 #  
# Add 2nd variable (the only difference of the above part is that now modeln=2 the model statement has 2 variables)
# and the call for the list of variable names in the model changed slightly

modeln<-2

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_2:nlastvar_LUR_2){
  if (is.numeric(VGOB1_subsetC_staph_LUR2[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetC_staph_LUR2$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetC_staph_LUR2[,models[[1]]$indexbestmodel]+ VGOB1_subsetC_staph_LUR2[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # Measurements_livestockpreds_LUR2[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR2)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetC_staph_LUR2)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  these are the candidate models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)
models[[modeln]]$resultspos

#  rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))
models[[modeln]]$resultspos

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j
models[[modeln]]$indexbestmodel

subset(models[[modeln]]$resultspos, rank==1)

# this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]
models[[modeln]]$summarybestmodel

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetC_staph_LUR2)[models[[1]]$indexbestmodel], names(VGOB1_subsetC_staph_LUR2)[models[[2]]$indexbestmodel] )
models[[modeln]]$namesbestmodel

# this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2
models[[modeln]]$R2bestmodel

# this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetC_staph_LUR2$staph_copiespm3.ln.diffmeth.mean~                               VGOB1_subsetC_staph_LUR2[,models[[1]]$indexbestmodel]+                           VGOB1_subsetC_staph_LUR2[,models[[2]]$indexbestmodel]) 

models[[modeln]]$bestmodel

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel


# 3 #  
# add third variable (the only difference of the above part is that now modeln=3 the model statement has 3 variables)
# and the call for the list of variable names in the model changed slightly

modeln<-3

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_2:nlastvar_LUR_2){
  if (is.numeric(VGOB1_subsetC_staph_LUR2[,i])==TRUE){  
    modeltry<-lm(VGOB1_subsetC_staph_LUR2$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetC_staph_LUR2[,models[[1]]$indexbestmodel]+VGOB1_subsetC_staph_LUR2[,models[[2]]$indexbestmodel]+ VGOB1_subsetC_staph_LUR2[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # All[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR2)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetC_staph_LUR2)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

#  rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

#  this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

#  here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetC_staph_LUR2)[models[[1]]$indexbestmodel], names(VGOB1_subsetC_staph_LUR2)[models[[2]]$indexbestmodel], names(VGOB1_subsetC_staph_LUR2)[models[[3]]$indexbestmodel])

#  this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetC_staph_LUR2$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetC_staph_LUR2[,models[[1]]$indexbestmodel]+ VGOB1_subsetC_staph_LUR2[,models[[2]]$indexbestmodel]+ VGOB1_subsetC_staph_LUR2[,models[[3]]$indexbestmodel]) 

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel


# 4 #  
#  add forth variable (the only difference of the above part is that now model n=4 the model statement more variables)
#  and the call for the list of variable names in the model changed slightly
modeln<-4

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1


for (i in nfirstvar_LUR_2:nlastvar_LUR_2){
  if (is.numeric(VGOB1_subsetC_staph_LUR2[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetC_staph_LUR2$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetC_staph_LUR2[,models[[1]]$indexbestmodel]+VGOB1_subsetC_staph_LUR2[,models[[2]]$indexbestmodel]+VGOB1_subsetC_staph_LUR2[,models[[3]]$indexbestmodel]+VGOB1_subsetC_staph_LUR2[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    #  the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    #  All[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR2)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetC_staph_LUR2)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

#  this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

#  here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetC_staph_LUR2)[models[[1]]$indexbestmodel], names(VGOB1_subsetC_staph_LUR2)[models[[2]]$indexbestmodel], names(VGOB1_subsetC_staph_LUR2)[models[[3]]$indexbestmodel], names(VGOB1_subsetC_staph_LUR2)[models[[4]]$indexbestmodel])

#  this is the r2 of that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetC_staph_LUR2$staph_copiespm3.ln.diffmeth.mean~ VGOB1_subsetC_staph_LUR2[,models[[1]]$indexbestmodel]+ VGOB1_subsetC_staph_LUR2[,models[[2]]$indexbestmodel]+VGOB1_subsetC_staph_LUR2[,models[[3]]$indexbestmodel]+ VGOB1_subsetC_staph_LUR2[,models[[4]]$indexbestmodel]) 


models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel


# 5 #  
# add fifth variable (the only difference of the above part is that now modeln=5 the model statement more variables)
# and the call for the list of variable names in the model changed slightly
modeln<-5

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_2:nlastvar_LUR_2){
  if (is.numeric(VGOB1_subsetC_staph_LUR2[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetC_staph_LUR2$staph_copiespm3.ln.diffmeth.mean~ VGOB1_subsetC_staph_LUR2[,models[[1]]$indexbestmodel]+ VGOB1_subsetC_staph_LUR2[,models[[2]]$indexbestmodel]+ VGOB1_subsetC_staph_LUR2[,models[[3]]$indexbestmodel]+ VGOB1_subsetC_staph_LUR2[,models[[4]]$indexbestmodel]+ VGOB1_subsetC_staph_LUR2[,i]) 
  
R2<-rbind(R2,summary(modeltry)$adj.r.squared)
# the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # All[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR2)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetC_staph_LUR2)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

#  this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetC_staph_LUR2)[models[[1]]$indexbestmodel], names(VGOB1_subsetC_staph_LUR2)[models[[2]]$indexbestmodel], names(VGOB1_subsetC_staph_LUR2)[models[[3]]$indexbestmodel], names(VGOB1_subsetC_staph_LUR2)[models[[4]]$indexbestmodel], names(VGOB1_subsetC_staph_LUR2)[models[[5]]$indexbestmodel])

#  this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetC_staph_LUR2$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetC_staph_LUR2[,models[[1]]$indexbestmodel]+VGOB1_subsetC_staph_LUR2[,models[[2]]$indexbestmodel]+VGOB1_subsetC_staph_LUR2[,models[[3]]$indexbestmodel]+ VGOB1_subsetC_staph_LUR2[,models[[4]]$indexbestmodel]+ VGOB1_subsetC_staph_LUR2[,models[[5]]$indexbestmodel]) 
models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[5]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[5]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel
models[[5]]$R2bestmodel

# 6 #  
# add sixth variable (the only difference of the above part is that now model n=6 the model statement more variables)
#  and the call for the list of variable names in the model changed slightly

modeln<-6

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_2 :nlastvar_LUR_2){
  if (is.numeric(VGOB1_subsetC_staph_LUR2[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetC_staph_LUR2$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetC_staph_LUR2[,models[[1]]$indexbestmodel]+VGOB1_subsetC_staph_LUR2[,models[[2]]$indexbestmodel]+VGOB1_subsetC_staph_LUR2[,models[[3]]$indexbestmodel]+VGOB1_subsetC_staph_LUR2[,models[[4]]$indexbestmodel]+VGOB1_subsetC_staph_LUR2[,models[[5]]$indexbestmodel]+ VGOB1_subsetC_staph_LUR2[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # All[,i] is the row that's being tried out now. the name of that row can be found in  names(All)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetC_staph_LUR2)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

# this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetC_staph_LUR2)[models[[1]]$indexbestmodel], names(VGOB1_subsetC_staph_LUR2)[models[[2]]$indexbestmodel] , names(VGOB1_subsetC_staph_LUR2)[models[[3]]$indexbestmodel], names(VGOB1_subsetC_staph_LUR2)[models[[4]]$indexbestmodel], names(VGOB1_subsetC_staph_LUR2)[models[[5]]$indexbestmodel], names(VGOB1_subsetC_staph_LUR2)[models[[6]]$indexbestmodel])

#  this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetC_staph_LUR2$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetC_staph_LUR2[,models[[1]]$indexbestmodel]+VGOB1_subsetC_staph_LUR2[,models[[2]]$indexbestmodel]+VGOB1_subsetC_staph_LUR2[,models[[3]]$indexbestmodel]+ VGOB1_subsetC_staph_LUR2[,models[[4]]$indexbestmodel]+ VGOB1_subsetC_staph_LUR2[,models[[5]]$indexbestmodel]+ VGOB1_subsetC_staph_LUR2[,models[[6]]$indexbestmodel]) 

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[5]]$summarybestmodel
models[[6]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[5]]$namesbestmodel
models[[6]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel
models[[5]]$R2bestmodel
models[[6]]$R2bestmodel


# 7 #  
# add seventh variable (the only difference of the above part is that now model n=7 the model statement more variables)
#  and the call for the list of variable names in the model changed slightly

modeln<-7

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_2 :nlastvar_LUR_2){
  if (is.numeric(VGOB1_subsetC_staph_LUR2[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetC_staph_LUR2$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetC_staph_LUR2[,models[[1]]$indexbestmodel]+VGOB1_subsetC_staph_LUR2[,models[[2]]$indexbestmodel]+VGOB1_subsetC_staph_LUR2[,models[[3]]$indexbestmodel]+VGOB1_subsetC_staph_LUR2[,models[[4]]$indexbestmodel]+VGOB1_subsetC_staph_LUR2[,models[[5]]$indexbestmodel]+VGOB1_subsetC_staph_LUR2[,models[[6]]$indexbestmodel]+ VGOB1_subsetC_staph_LUR2[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # Measurements_livestockpreds_LUR2[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR2)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetC_staph_LUR2)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

# this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetC_staph_LUR2)[models[[1]]$indexbestmodel], names(VGOB1_subsetC_staph_LUR2)[models[[2]]$indexbestmodel] , names(VGOB1_subsetC_staph_LUR2)[models[[3]]$indexbestmodel], names(VGOB1_subsetC_staph_LUR2)[models[[4]]$indexbestmodel], names(VGOB1_subsetC_staph_LUR2)[models[[5]]$indexbestmodel], names(VGOB1_subsetC_staph_LUR2)[models[[6]]$indexbestmodel], names(VGOB1_subsetC_staph_LUR2)[models[[7]]$indexbestmodel])

#  this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetC_staph_LUR2$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetC_staph_LUR2[,models[[1]]$indexbestmodel]+VGOB1_subsetC_staph_LUR2[,models[[2]]$indexbestmodel]+VGOB1_subsetC_staph_LUR2[,models[[3]]$indexbestmodel]+ VGOB1_subsetC_staph_LUR2[,models[[4]]$indexbestmodel]+ VGOB1_subsetC_staph_LUR2[,models[[5]]$indexbestmodel]+ VGOB1_subsetC_staph_LUR2[,models[[6]]$indexbestmodel]+ VGOB1_subsetC_staph_LUR2[,models[[7]]$indexbestmodel]) 

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[5]]$summarybestmodel
models[[6]]$summarybestmodel
models[[7]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[5]]$namesbestmodel
models[[6]]$namesbestmodel
models[[7]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel
models[[5]]$R2bestmodel
models[[6]]$R2bestmodel
models[[7]]$R2bestmodel

# 8 #  
# add eighth variable (the only difference of the above part is that now modeln=7 the model statement more variables)
# and the call for the list of variable names in the model changed slightly

modeln<-8

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_2 :nlastvar_LUR_2){
  if (is.numeric(VGOB1_subsetC_staph_LUR2[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetC_staph_LUR2$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetC_staph_LUR2[,models[[1]]$indexbestmodel]+VGOB1_subsetC_staph_LUR2[,models[[2]]$indexbestmodel]+VGOB1_subsetC_staph_LUR2[,models[[3]]$indexbestmodel]+VGOB1_subsetC_staph_LUR2[,models[[4]]$indexbestmodel]+VGOB1_subsetC_staph_LUR2[,models[[5]]$indexbestmodel]+VGOB1_subsetC_staph_LUR2[,models[[6]]$indexbestmodel]+ VGOB1_subsetC_staph_LUR2[,models[[7]]$indexbestmodel]+ VGOB1_subsetC_staph_LUR2[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # Measurements_livestockpreds_LUR2[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR2)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetC_staph_LUR2)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

# this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetC_staph_LUR2)[models[[1]]$indexbestmodel], names(VGOB1_subsetC_staph_LUR2)[models[[2]]$indexbestmodel] , names(VGOB1_subsetC_staph_LUR2)[models[[3]]$indexbestmodel], names(VGOB1_subsetC_staph_LUR2)[models[[4]]$indexbestmodel], names(VGOB1_subsetC_staph_LUR2)[models[[5]]$indexbestmodel], names(VGOB1_subsetC_staph_LUR2)[models[[6]]$indexbestmodel], names(VGOB1_subsetC_staph_LUR2)[models[[7]]$indexbestmodel], names(VGOB1_subsetC_staph_LUR2)[models[[8]]$indexbestmodel])

#  this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetC_staph_LUR2$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetC_staph_LUR2[,models[[1]]$indexbestmodel]+VGOB1_subsetC_staph_LUR2[,models[[2]]$indexbestmodel]+VGOB1_subsetC_staph_LUR2[,models[[3]]$indexbestmodel]+ VGOB1_subsetC_staph_LUR2[,models[[4]]$indexbestmodel]+ VGOB1_subsetC_staph_LUR2[,models[[5]]$indexbestmodel]+ VGOB1_subsetC_staph_LUR2[,models[[6]]$indexbestmodel]+ VGOB1_subsetC_staph_LUR2[,models[[7]]$indexbestmodel]+ VGOB1_subsetC_staph_LUR2[,models[[8]]$indexbestmodel]) 

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[5]]$summarybestmodel
models[[6]]$summarybestmodel
models[[7]]$summarybestmodel
models[[8]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[5]]$namesbestmodel
models[[6]]$namesbestmodel
models[[7]]$namesbestmodel
models[[8]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel
models[[5]]$R2bestmodel
models[[6]]$R2bestmodel
models[[7]]$R2bestmodel
models[[8]]$R2bestmodel

# 9 #  
# add ninth variable (the only difference of the above part is that now modeln=9 the model statement more variables)
# and the call for the list of variable names in the model changed slightly

modeln<-9

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_2 :nlastvar_LUR_2){
  if (is.numeric(VGOB1_subsetC_staph_LUR2[,i])==TRUE){
      modeltry<-lm(VGOB1_subsetC_staph_LUR2$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetC_staph_LUR2[,models[[1]]$indexbestmodel]+VGOB1_subsetC_staph_LUR2[,models[[2]]$indexbestmodel]+VGOB1_subsetC_staph_LUR2[,models[[3]]$indexbestmodel]+VGOB1_subsetC_staph_LUR2[,models[[4]]$indexbestmodel]+VGOB1_subsetC_staph_LUR2[,models[[5]]$indexbestmodel]+VGOB1_subsetC_staph_LUR2[,models[[6]]$indexbestmodel]+ VGOB1_subsetC_staph_LUR2[,models[[7]]$indexbestmodel]+ VGOB1_subsetC_staph_LUR2[,models[[8]]$indexbestmodel]+ VGOB1_subsetC_staph_LUR2[,i]) 
        R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # Measurements_livestockpreds_LUR2[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR2)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetC_staph_LUR2)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

# this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetC_staph_LUR2)[models[[1]]$indexbestmodel], names(VGOB1_subsetC_staph_LUR2)[models[[2]]$indexbestmodel] , names(VGOB1_subsetC_staph_LUR2)[models[[3]]$indexbestmodel], names(VGOB1_subsetC_staph_LUR2)[models[[4]]$indexbestmodel], names(VGOB1_subsetC_staph_LUR2)[models[[5]]$indexbestmodel], names(VGOB1_subsetC_staph_LUR2)[models[[6]]$indexbestmodel], names(VGOB1_subsetC_staph_LUR2)[models[[7]]$indexbestmodel], names(VGOB1_subsetC_staph_LUR2)[models[[8]]$indexbestmodel],  names(VGOB1_subsetC_staph_LUR2)[models[[9]]$indexbestmodel])

#  this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetC_staph_LUR2$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetC_staph_LUR2[,models[[1]]$indexbestmodel]+VGOB1_subsetC_staph_LUR2[,models[[2]]$indexbestmodel]+VGOB1_subsetC_staph_LUR2[,models[[3]]$indexbestmodel]+ VGOB1_subsetC_staph_LUR2[,models[[4]]$indexbestmodel]+ VGOB1_subsetC_staph_LUR2[,models[[5]]$indexbestmodel]+ VGOB1_subsetC_staph_LUR2[,models[[6]]$indexbestmodel]+ VGOB1_subsetC_staph_LUR2[,models[[7]]$indexbestmodel]+ VGOB1_subsetC_staph_LUR2[,models[[8]]$indexbestmodel]+ VGOB1_subsetC_staph_LUR2[,models[[9]]$indexbestmodel]) 

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[5]]$summarybestmodel
models[[6]]$summarybestmodel
models[[7]]$summarybestmodel
models[[8]]$summarybestmodel
models[[9]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[5]]$namesbestmodel
models[[6]]$namesbestmodel
models[[7]]$namesbestmodel
models[[8]]$namesbestmodel
models[[9]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel
models[[5]]$R2bestmodel
models[[6]]$R2bestmodel
models[[7]]$R2bestmodel
models[[8]]$R2bestmodel
models[[9]]$R2bestmodel

# 10 #  
#  add tenth variable (the only difference of the above part is that now model n=10 the model statement more variables)
#  and the call for the list of variable names in the model changed slightly

modeln<-10

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_2 :nlastvar_LUR_2){if (is.numeric(VGOB1_subsetC_staph_LUR2[,i])==TRUE){ modeltry<-lm(VGOB1_subsetC_staph_LUR2$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetC_staph_LUR2[,models[[1]]$indexbestmodel]+VGOB1_subsetC_staph_LUR2[,models[[2]]$indexbestmodel]+ VGOB1_subsetC_staph_LUR2[,models[[3]]$indexbestmodel]+VGOB1_subsetC_staph_LUR2[,models[[4]]$indexbestmodel]+ VGOB1_subsetC_staph_LUR2[,models[[5]]$indexbestmodel]+ VGOB1_subsetC_staph_LUR2[,models[[6]]$indexbestmodel]+ VGOB1_subsetC_staph_LUR2[,models[[7]]$indexbestmodel]+ VGOB1_subsetC_staph_LUR2[,models[[8]]$indexbestmodel]+ VGOB1_subsetC_staph_LUR2[,models[[9]]$indexbestmodel]+ VGOB1_subsetC_staph_LUR2[,i]) 

R2<-rbind(R2,summary(modeltry)$adj.r.squared)
# the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # Measurements_livestockpreds_LUR2[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR2)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetC_staph_LUR2)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

# this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

# here are the names
models[[modeln]]$namesbestmodel<-c( names(VGOB1_subsetC_staph_LUR2)[models[[1]]$indexbestmodel],                   names(VGOB1_subsetC_staph_LUR2)[models[[2]]$indexbestmodel] , names(VGOB1_subsetC_staph_LUR2)[models[[3]]$indexbestmodel], names(VGOB1_subsetC_staph_LUR2)[models[[4]]$indexbestmodel], names(VGOB1_subsetC_staph_LUR2)[models[[5]]$indexbestmodel], names(VGOB1_subsetC_staph_LUR2)[models[[6]]$indexbestmodel], names(VGOB1_subsetC_staph_LUR2)[models[[7]]$indexbestmodel], names(VGOB1_subsetC_staph_LUR2)[models[[8]]$indexbestmodel], names(VGOB1_subsetC_staph_LUR2)[models[[9]]$indexbestmodel], names(VGOB1_subsetC_staph_LUR2)[models[[10]]$indexbestmodel])

#  this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetC_staph_LUR2$staph_copiespm3.ln.diffmeth.mean~                                VGOB1_subsetC_staph_LUR2[,models[[1]]$indexbestmodel]+ VGOB1_subsetC_staph_LUR2[,models[[2]]$indexbestmodel]+                           VGOB1_subsetC_staph_LUR2[,models[[3]]$indexbestmodel]+ VGOB1_subsetC_staph_LUR2[,models[[4]]$indexbestmodel]+ VGOB1_subsetC_staph_LUR2[,models[[5]]$indexbestmodel]+ VGOB1_subsetC_staph_LUR2[,models[[6]]$indexbestmodel]+ VGOB1_subsetC_staph_LUR2[,models[[7]]$indexbestmodel]+ VGOB1_subsetC_staph_LUR2[,models[[8]]$indexbestmodel]+ VGOB1_subsetC_staph_LUR2[,models[[9]]$indexbestmodel]+ VGOB1_subsetC_staph_LUR2[,models[[10]]$indexbestmodel]) 

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[5]]$summarybestmodel
models[[6]]$summarybestmodel
models[[7]]$summarybestmodel
models[[8]]$summarybestmodel
models[[9]]$summarybestmodel
models[[10]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[5]]$namesbestmodel
models[[6]]$namesbestmodel
models[[7]]$namesbestmodel
models[[8]]$namesbestmodel
models[[9]]$namesbestmodel
models[[10]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel
models[[5]]$R2bestmodel
models[[6]]$R2bestmodel
models[[7]]$R2bestmodel
models[[8]]$R2bestmodel
models[[9]]$R2bestmodel
models[[10]]$R2bestmodel

#  at this point I always check whether the next model is more than 1% better than the one before and if not I end here

#   CODE FOR PICKING OUT THE BEST MODEL #   
temp <- 0
besti <- 0
for (i in 1:10){ #  think this runs the loop 10 times - not fully sure thought - but not to do with the number of models I don't think - as when I change to 3, I still get the model with 4 variables as best model
  print(models[[i]]$R2bestmodel)
  #       print(models[[i]]$summarybestmodel$coefficients=-1,4])
  #       if((models[[i]]$R2bestmodel-temp > 0.0) && (all(models[[i]]$summarybestmodel$coefficients[-1,4]<0.1))){
  #         temp <- models[[i]]$R2bestmodel
  #         besti <- i
  #         }
  if((models[[i]]$R2bestmodel-temp > 0.0) && (all(models[[i]]$summarybestmodel$coefficients[-1,4]<0.1))){
    temp <- models[[i]]$R2bestmodel
    besti <- i
  }else{
    finalBestModel_staph_LUR2_subsetC <- models[[besti]]$bestmodel
    finalBestModelNames_staph_subsetC <- models[[besti]]$namesbestmodel
    Sites <- 1:dim(VGOB1_subsetC_staph_LUR2)[1] # full original model
    #  CVaR2<-escCV_staph_LUR2(Sites)[2] # Cross Validation
    maxCD<-max(cooks.distance(finalBestModel_staph_LUR2_subsetC))
    if(length(finalBestModelNames_staph_subsetC)<2){ # vif fn doesnot work when only 1 variable...       # 
      maxVIF<-"NA"
    }else{
      maxVIF<-max(vif(finalBestModel_staph_LUR2_subsetC))
    }
    print(paste("This is the best staph model for subset C: ",besti,
                "(AdjR2: ",format(models[[besti]]$R2bestmodel,digits=3), "; MaxCD: ",format(maxCD,digits=3),"; MaxVIF: ",
                format(maxVIF,digits=3),")", sep=''))
    print(finalBestModelNames_staph_subsetC)
    break
  }
}

#  Overview of the final best model using the algorithm selection process (taking into account VIF, R^2, and p-values)
finalBestModel_staph_LUR2_subsetC
finalBestModelNames_staph_subsetC
models[[besti]]$summarybestmodel
models[[besti]]$R2bestmodel

#### D ####
# LUR model building process for subset D
#  This is the dataframe with the relevant predictor vars for LUR2 models for subset D (55 sites)
VGOB1_subsetD_staph_LUR2 # n.b. this dataframe only includes microbial marker concentrations for staph unlike the dataframe Measurements_livestockpreds_LUR2 as previously used for the model building. 

#  Now set the values of some variables that will be needed
nfirstvar_LUR_2 <- 3  
nlastvar_LUR_2 <- 71

# Function building to run the models 
# 1 #  

models<-list()
modeln<-1
models[[modeln]]<-list()

R2<-1
betaaddedvar<-1
addedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_2:nlastvar_LUR_2){
  if (is.numeric(VGOB1_subsetD_staph_LUR2[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetD_staph_LUR2$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetD_staph_LUR2[,i])                            
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    #  Measurements_livestockpreds_LUR2[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR2)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetD_staph_LUR2)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)
models[[modeln]]$results

#  this are the candidates models with the highest R2, not a negative beta for the new, nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)
models[[modeln]]$resultspos

#  rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))
models[[modeln]]$resultspos

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j
models[[modeln]]$indexbestmodel

subset(models[[modeln]]$resultspos, rank==1)
subset(models[[modeln]]$resultspos)

#  this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]
models[[modeln]]$summarybestmodel

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetD_staph_LUR2)[models[[1]]$indexbestmodel])
models[[modeln]]$namesbestmodel

#  this is the r2 of that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2
models[[modeln]]$R2bestmodel

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetD_staph_LUR2$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetD_staph_LUR2[,models[[1]]$indexbestmodel]) 
models[[modeln]]$bestmodel

summary(models[[modeln]]$bestmodel)

#  The first model includes the predictor: nPigMultipFarmWghtDist.3000m.sum.Tr.1P9 - meaning the number of multiplier pig farms weighted to distance in a 3000m buffer

# 2 #  
# Add 2nd variable (the only difference of the above part is that now modeln=2 the model statement has 2 variables)
# and the call for the list of variable names in the model changed slightly

modeln<-2

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_2:nlastvar_LUR_2){
  if (is.numeric(VGOB1_subsetD_staph_LUR2[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetD_staph_LUR2$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetD_staph_LUR2[,models[[1]]$indexbestmodel]+ VGOB1_subsetD_staph_LUR2[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # Measurements_livestockpreds_LUR2[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR2)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetD_staph_LUR2)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  these are the candidate models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)
models[[modeln]]$resultspos

#  rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))
models[[modeln]]$resultspos

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j
models[[modeln]]$indexbestmodel

subset(models[[modeln]]$resultspos, rank==1)

# this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]
models[[modeln]]$summarybestmodel

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetD_staph_LUR2)[models[[1]]$indexbestmodel], names(VGOB1_subsetD_staph_LUR2)[models[[2]]$indexbestmodel] )
models[[modeln]]$namesbestmodel

# this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2
models[[modeln]]$R2bestmodel

# this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetD_staph_LUR2$staph_copiespm3.ln.diffmeth.mean~                               VGOB1_subsetD_staph_LUR2[,models[[1]]$indexbestmodel]+                           VGOB1_subsetD_staph_LUR2[,models[[2]]$indexbestmodel]) 

models[[modeln]]$bestmodel

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel


# 3 #  
# add third variable (the only difference of the above part is that now modeln=3 the model statement has 3 variables)
# and the call for the list of variable names in the model changed slightly

modeln<-3

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_2:nlastvar_LUR_2){
  if (is.numeric(VGOB1_subsetD_staph_LUR2[,i])==TRUE){  
    modeltry<-lm(VGOB1_subsetD_staph_LUR2$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetD_staph_LUR2[,models[[1]]$indexbestmodel]+VGOB1_subsetD_staph_LUR2[,models[[2]]$indexbestmodel]+ VGOB1_subsetD_staph_LUR2[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # All[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR2)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetD_staph_LUR2)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

#  rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

#  this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

#  here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetD_staph_LUR2)[models[[1]]$indexbestmodel], names(VGOB1_subsetD_staph_LUR2)[models[[2]]$indexbestmodel], names(VGOB1_subsetD_staph_LUR2)[models[[3]]$indexbestmodel])

#  this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetD_staph_LUR2$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetD_staph_LUR2[,models[[1]]$indexbestmodel]+ VGOB1_subsetD_staph_LUR2[,models[[2]]$indexbestmodel]+ VGOB1_subsetD_staph_LUR2[,models[[3]]$indexbestmodel]) 

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel


# 4 #  
#  add forth variable (the only difference of the above part is that now model n=4 the model statement more variables)
#  and the call for the list of variable names in the model changed slightly
modeln<-4

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1


for (i in nfirstvar_LUR_2:nlastvar_LUR_2){
  if (is.numeric(VGOB1_subsetD_staph_LUR2[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetD_staph_LUR2$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetD_staph_LUR2[,models[[1]]$indexbestmodel]+VGOB1_subsetD_staph_LUR2[,models[[2]]$indexbestmodel]+VGOB1_subsetD_staph_LUR2[,models[[3]]$indexbestmodel]+VGOB1_subsetD_staph_LUR2[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    #  the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    #  All[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR2)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetD_staph_LUR2)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

#  this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

#  here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetD_staph_LUR2)[models[[1]]$indexbestmodel], names(VGOB1_subsetD_staph_LUR2)[models[[2]]$indexbestmodel], names(VGOB1_subsetD_staph_LUR2)[models[[3]]$indexbestmodel], names(VGOB1_subsetD_staph_LUR2)[models[[4]]$indexbestmodel])

#  this is the r2 of that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetD_staph_LUR2$staph_copiespm3.ln.diffmeth.mean~ VGOB1_subsetD_staph_LUR2[,models[[1]]$indexbestmodel]+ VGOB1_subsetD_staph_LUR2[,models[[2]]$indexbestmodel]+VGOB1_subsetD_staph_LUR2[,models[[3]]$indexbestmodel]+ VGOB1_subsetD_staph_LUR2[,models[[4]]$indexbestmodel]) 


models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel


# 5 #  
# add fifth variable (the only difference of the above part is that now modeln=5 the model statement more variables)
# and the call for the list of variable names in the model changed slightly
modeln<-5

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_2:nlastvar_LUR_2){
  if (is.numeric(VGOB1_subsetD_staph_LUR2[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetD_staph_LUR2$staph_copiespm3.ln.diffmeth.mean~ VGOB1_subsetD_staph_LUR2[,models[[1]]$indexbestmodel]+ VGOB1_subsetD_staph_LUR2[,models[[2]]$indexbestmodel]+ VGOB1_subsetD_staph_LUR2[,models[[3]]$indexbestmodel]+ VGOB1_subsetD_staph_LUR2[,models[[4]]$indexbestmodel]+ VGOB1_subsetD_staph_LUR2[,i]) 
  
R2<-rbind(R2,summary(modeltry)$adj.r.squared)
# the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # All[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR2)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetD_staph_LUR2)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

#  this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetD_staph_LUR2)[models[[1]]$indexbestmodel], names(VGOB1_subsetD_staph_LUR2)[models[[2]]$indexbestmodel], names(VGOB1_subsetD_staph_LUR2)[models[[3]]$indexbestmodel], names(VGOB1_subsetD_staph_LUR2)[models[[4]]$indexbestmodel], names(VGOB1_subsetD_staph_LUR2)[models[[5]]$indexbestmodel])

#  this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetD_staph_LUR2$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetD_staph_LUR2[,models[[1]]$indexbestmodel]+VGOB1_subsetD_staph_LUR2[,models[[2]]$indexbestmodel]+VGOB1_subsetD_staph_LUR2[,models[[3]]$indexbestmodel]+ VGOB1_subsetD_staph_LUR2[,models[[4]]$indexbestmodel]+ VGOB1_subsetD_staph_LUR2[,models[[5]]$indexbestmodel]) 
models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[5]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[5]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel
models[[5]]$R2bestmodel

# 6 #  
# add sixth variable (the only difference of the above part is that now model n=6 the model statement more variables)
#  and the call for the list of variable names in the model changed slightly

modeln<-6

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_2 :nlastvar_LUR_2){
  if (is.numeric(VGOB1_subsetD_staph_LUR2[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetD_staph_LUR2$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetD_staph_LUR2[,models[[1]]$indexbestmodel]+VGOB1_subsetD_staph_LUR2[,models[[2]]$indexbestmodel]+VGOB1_subsetD_staph_LUR2[,models[[3]]$indexbestmodel]+VGOB1_subsetD_staph_LUR2[,models[[4]]$indexbestmodel]+VGOB1_subsetD_staph_LUR2[,models[[5]]$indexbestmodel]+ VGOB1_subsetD_staph_LUR2[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # All[,i] is the row that's being tried out now. the name of that row can be found in  names(All)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetD_staph_LUR2)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

# this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetD_staph_LUR2)[models[[1]]$indexbestmodel], names(VGOB1_subsetD_staph_LUR2)[models[[2]]$indexbestmodel] , names(VGOB1_subsetD_staph_LUR2)[models[[3]]$indexbestmodel], names(VGOB1_subsetD_staph_LUR2)[models[[4]]$indexbestmodel], names(VGOB1_subsetD_staph_LUR2)[models[[5]]$indexbestmodel], names(VGOB1_subsetD_staph_LUR2)[models[[6]]$indexbestmodel])

#  this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetD_staph_LUR2$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetD_staph_LUR2[,models[[1]]$indexbestmodel]+VGOB1_subsetD_staph_LUR2[,models[[2]]$indexbestmodel]+VGOB1_subsetD_staph_LUR2[,models[[3]]$indexbestmodel]+ VGOB1_subsetD_staph_LUR2[,models[[4]]$indexbestmodel]+ VGOB1_subsetD_staph_LUR2[,models[[5]]$indexbestmodel]+ VGOB1_subsetD_staph_LUR2[,models[[6]]$indexbestmodel]) 

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[5]]$summarybestmodel
models[[6]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[5]]$namesbestmodel
models[[6]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel
models[[5]]$R2bestmodel
models[[6]]$R2bestmodel


# 7 #  
# add seventh variable (the only difference of the above part is that now model n=7 the model statement more variables)
#  and the call for the list of variable names in the model changed slightly

modeln<-7

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_2 :nlastvar_LUR_2){
  if (is.numeric(VGOB1_subsetD_staph_LUR2[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetD_staph_LUR2$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetD_staph_LUR2[,models[[1]]$indexbestmodel]+VGOB1_subsetD_staph_LUR2[,models[[2]]$indexbestmodel]+VGOB1_subsetD_staph_LUR2[,models[[3]]$indexbestmodel]+VGOB1_subsetD_staph_LUR2[,models[[4]]$indexbestmodel]+VGOB1_subsetD_staph_LUR2[,models[[5]]$indexbestmodel]+VGOB1_subsetD_staph_LUR2[,models[[6]]$indexbestmodel]+ VGOB1_subsetD_staph_LUR2[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # Measurements_livestockpreds_LUR2[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR2)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetD_staph_LUR2)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

# this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetD_staph_LUR2)[models[[1]]$indexbestmodel], names(VGOB1_subsetD_staph_LUR2)[models[[2]]$indexbestmodel] , names(VGOB1_subsetD_staph_LUR2)[models[[3]]$indexbestmodel], names(VGOB1_subsetD_staph_LUR2)[models[[4]]$indexbestmodel], names(VGOB1_subsetD_staph_LUR2)[models[[5]]$indexbestmodel], names(VGOB1_subsetD_staph_LUR2)[models[[6]]$indexbestmodel], names(VGOB1_subsetD_staph_LUR2)[models[[7]]$indexbestmodel])

#  this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetD_staph_LUR2$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetD_staph_LUR2[,models[[1]]$indexbestmodel]+VGOB1_subsetD_staph_LUR2[,models[[2]]$indexbestmodel]+VGOB1_subsetD_staph_LUR2[,models[[3]]$indexbestmodel]+ VGOB1_subsetD_staph_LUR2[,models[[4]]$indexbestmodel]+ VGOB1_subsetD_staph_LUR2[,models[[5]]$indexbestmodel]+ VGOB1_subsetD_staph_LUR2[,models[[6]]$indexbestmodel]+ VGOB1_subsetD_staph_LUR2[,models[[7]]$indexbestmodel]) 

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[5]]$summarybestmodel
models[[6]]$summarybestmodel
models[[7]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[5]]$namesbestmodel
models[[6]]$namesbestmodel
models[[7]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel
models[[5]]$R2bestmodel
models[[6]]$R2bestmodel
models[[7]]$R2bestmodel

# 8 #  
# add eighth variable (the only difference of the above part is that now modeln=7 the model statement more variables)
# and the call for the list of variable names in the model changed slightly

modeln<-8

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_2 :nlastvar_LUR_2){
  if (is.numeric(VGOB1_subsetD_staph_LUR2[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetD_staph_LUR2$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetD_staph_LUR2[,models[[1]]$indexbestmodel]+VGOB1_subsetD_staph_LUR2[,models[[2]]$indexbestmodel]+VGOB1_subsetD_staph_LUR2[,models[[3]]$indexbestmodel]+VGOB1_subsetD_staph_LUR2[,models[[4]]$indexbestmodel]+VGOB1_subsetD_staph_LUR2[,models[[5]]$indexbestmodel]+VGOB1_subsetD_staph_LUR2[,models[[6]]$indexbestmodel]+ VGOB1_subsetD_staph_LUR2[,models[[7]]$indexbestmodel]+ VGOB1_subsetD_staph_LUR2[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # Measurements_livestockpreds_LUR2[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR2)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetD_staph_LUR2)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

# this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetD_staph_LUR2)[models[[1]]$indexbestmodel], names(VGOB1_subsetD_staph_LUR2)[models[[2]]$indexbestmodel] , names(VGOB1_subsetD_staph_LUR2)[models[[3]]$indexbestmodel], names(VGOB1_subsetD_staph_LUR2)[models[[4]]$indexbestmodel], names(VGOB1_subsetD_staph_LUR2)[models[[5]]$indexbestmodel], names(VGOB1_subsetD_staph_LUR2)[models[[6]]$indexbestmodel], names(VGOB1_subsetD_staph_LUR2)[models[[7]]$indexbestmodel], names(VGOB1_subsetD_staph_LUR2)[models[[8]]$indexbestmodel])

#  this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetD_staph_LUR2$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetD_staph_LUR2[,models[[1]]$indexbestmodel]+VGOB1_subsetD_staph_LUR2[,models[[2]]$indexbestmodel]+VGOB1_subsetD_staph_LUR2[,models[[3]]$indexbestmodel]+ VGOB1_subsetD_staph_LUR2[,models[[4]]$indexbestmodel]+ VGOB1_subsetD_staph_LUR2[,models[[5]]$indexbestmodel]+ VGOB1_subsetD_staph_LUR2[,models[[6]]$indexbestmodel]+ VGOB1_subsetD_staph_LUR2[,models[[7]]$indexbestmodel]+ VGOB1_subsetD_staph_LUR2[,models[[8]]$indexbestmodel]) 

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[5]]$summarybestmodel
models[[6]]$summarybestmodel
models[[7]]$summarybestmodel
models[[8]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[5]]$namesbestmodel
models[[6]]$namesbestmodel
models[[7]]$namesbestmodel
models[[8]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel
models[[5]]$R2bestmodel
models[[6]]$R2bestmodel
models[[7]]$R2bestmodel
models[[8]]$R2bestmodel

# 9 #  
# add ninth variable (the only difference of the above part is that now modeln=9 the model statement more variables)
# and the call for the list of variable names in the model changed slightly

modeln<-9

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_2 :nlastvar_LUR_2){
  if (is.numeric(VGOB1_subsetD_staph_LUR2[,i])==TRUE){
      modeltry<-lm(VGOB1_subsetD_staph_LUR2$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetD_staph_LUR2[,models[[1]]$indexbestmodel]+VGOB1_subsetD_staph_LUR2[,models[[2]]$indexbestmodel]+VGOB1_subsetD_staph_LUR2[,models[[3]]$indexbestmodel]+VGOB1_subsetD_staph_LUR2[,models[[4]]$indexbestmodel]+VGOB1_subsetD_staph_LUR2[,models[[5]]$indexbestmodel]+VGOB1_subsetD_staph_LUR2[,models[[6]]$indexbestmodel]+ VGOB1_subsetD_staph_LUR2[,models[[7]]$indexbestmodel]+ VGOB1_subsetD_staph_LUR2[,models[[8]]$indexbestmodel]+ VGOB1_subsetD_staph_LUR2[,i]) 
        R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # Measurements_livestockpreds_LUR2[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR2)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetD_staph_LUR2)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

# this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetD_staph_LUR2)[models[[1]]$indexbestmodel], names(VGOB1_subsetD_staph_LUR2)[models[[2]]$indexbestmodel] , names(VGOB1_subsetD_staph_LUR2)[models[[3]]$indexbestmodel], names(VGOB1_subsetD_staph_LUR2)[models[[4]]$indexbestmodel], names(VGOB1_subsetD_staph_LUR2)[models[[5]]$indexbestmodel], names(VGOB1_subsetD_staph_LUR2)[models[[6]]$indexbestmodel], names(VGOB1_subsetD_staph_LUR2)[models[[7]]$indexbestmodel], names(VGOB1_subsetD_staph_LUR2)[models[[8]]$indexbestmodel],  names(VGOB1_subsetD_staph_LUR2)[models[[9]]$indexbestmodel])

#  this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetD_staph_LUR2$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetD_staph_LUR2[,models[[1]]$indexbestmodel]+VGOB1_subsetD_staph_LUR2[,models[[2]]$indexbestmodel]+VGOB1_subsetD_staph_LUR2[,models[[3]]$indexbestmodel]+ VGOB1_subsetD_staph_LUR2[,models[[4]]$indexbestmodel]+ VGOB1_subsetD_staph_LUR2[,models[[5]]$indexbestmodel]+ VGOB1_subsetD_staph_LUR2[,models[[6]]$indexbestmodel]+ VGOB1_subsetD_staph_LUR2[,models[[7]]$indexbestmodel]+ VGOB1_subsetD_staph_LUR2[,models[[8]]$indexbestmodel]+ VGOB1_subsetD_staph_LUR2[,models[[9]]$indexbestmodel]) 

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[5]]$summarybestmodel
models[[6]]$summarybestmodel
models[[7]]$summarybestmodel
models[[8]]$summarybestmodel
models[[9]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[5]]$namesbestmodel
models[[6]]$namesbestmodel
models[[7]]$namesbestmodel
models[[8]]$namesbestmodel
models[[9]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel
models[[5]]$R2bestmodel
models[[6]]$R2bestmodel
models[[7]]$R2bestmodel
models[[8]]$R2bestmodel
models[[9]]$R2bestmodel

# 10 #  
#  add tenth variable (the only difference of the above part is that now model n=10 the model statement more variables)
#  and the call for the list of variable names in the model changed slightly

modeln<-10

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_2 :nlastvar_LUR_2){if (is.numeric(VGOB1_subsetD_staph_LUR2[,i])==TRUE){ modeltry<-lm(VGOB1_subsetD_staph_LUR2$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetD_staph_LUR2[,models[[1]]$indexbestmodel]+VGOB1_subsetD_staph_LUR2[,models[[2]]$indexbestmodel]+ VGOB1_subsetD_staph_LUR2[,models[[3]]$indexbestmodel]+VGOB1_subsetD_staph_LUR2[,models[[4]]$indexbestmodel]+ VGOB1_subsetD_staph_LUR2[,models[[5]]$indexbestmodel]+ VGOB1_subsetD_staph_LUR2[,models[[6]]$indexbestmodel]+ VGOB1_subsetD_staph_LUR2[,models[[7]]$indexbestmodel]+ VGOB1_subsetD_staph_LUR2[,models[[8]]$indexbestmodel]+ VGOB1_subsetD_staph_LUR2[,models[[9]]$indexbestmodel]+ VGOB1_subsetD_staph_LUR2[,i]) 

R2<-rbind(R2,summary(modeltry)$adj.r.squared)
# the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # Measurements_livestockpreds_LUR2[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR2)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetD_staph_LUR2)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

# this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

# here are the names
models[[modeln]]$namesbestmodel<-c( names(VGOB1_subsetD_staph_LUR2)[models[[1]]$indexbestmodel],                   names(VGOB1_subsetD_staph_LUR2)[models[[2]]$indexbestmodel] , names(VGOB1_subsetD_staph_LUR2)[models[[3]]$indexbestmodel], names(VGOB1_subsetD_staph_LUR2)[models[[4]]$indexbestmodel], names(VGOB1_subsetD_staph_LUR2)[models[[5]]$indexbestmodel], names(VGOB1_subsetD_staph_LUR2)[models[[6]]$indexbestmodel], names(VGOB1_subsetD_staph_LUR2)[models[[7]]$indexbestmodel], names(VGOB1_subsetD_staph_LUR2)[models[[8]]$indexbestmodel], names(VGOB1_subsetD_staph_LUR2)[models[[9]]$indexbestmodel], names(VGOB1_subsetD_staph_LUR2)[models[[10]]$indexbestmodel])

#  this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetD_staph_LUR2$staph_copiespm3.ln.diffmeth.mean~                                VGOB1_subsetD_staph_LUR2[,models[[1]]$indexbestmodel]+ VGOB1_subsetD_staph_LUR2[,models[[2]]$indexbestmodel]+                           VGOB1_subsetD_staph_LUR2[,models[[3]]$indexbestmodel]+ VGOB1_subsetD_staph_LUR2[,models[[4]]$indexbestmodel]+ VGOB1_subsetD_staph_LUR2[,models[[5]]$indexbestmodel]+ VGOB1_subsetD_staph_LUR2[,models[[6]]$indexbestmodel]+ VGOB1_subsetD_staph_LUR2[,models[[7]]$indexbestmodel]+ VGOB1_subsetD_staph_LUR2[,models[[8]]$indexbestmodel]+ VGOB1_subsetD_staph_LUR2[,models[[9]]$indexbestmodel]+ VGOB1_subsetD_staph_LUR2[,models[[10]]$indexbestmodel]) 

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[5]]$summarybestmodel
models[[6]]$summarybestmodel
models[[7]]$summarybestmodel
models[[8]]$summarybestmodel
models[[9]]$summarybestmodel
models[[10]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[5]]$namesbestmodel
models[[6]]$namesbestmodel
models[[7]]$namesbestmodel
models[[8]]$namesbestmodel
models[[9]]$namesbestmodel
models[[10]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel
models[[5]]$R2bestmodel
models[[6]]$R2bestmodel
models[[7]]$R2bestmodel
models[[8]]$R2bestmodel
models[[9]]$R2bestmodel
models[[10]]$R2bestmodel

#  at this point I always check whether the next model is more than 1% better than the one before and if not I end here

#   CODE FOR PICKING OUT THE BEST MODEL #   
temp <- 0
besti <- 0
for (i in 1:10){ #  think this runs the loop 10 times - not fully sure thought - but not to do with the number of models I don't think - as when I change to 3, I still get the model with 4 variables as best model
  print(models[[i]]$R2bestmodel)
  #       print(models[[i]]$summarybestmodel$coefficients=-1,4])
  #       if((models[[i]]$R2bestmodel-temp > 0.0) && (all(models[[i]]$summarybestmodel$coefficients[-1,4]<0.1))){
  #         temp <- models[[i]]$R2bestmodel
  #         besti <- i
  #         }
  if((models[[i]]$R2bestmodel-temp > 0.0) && (all(models[[i]]$summarybestmodel$coefficients[-1,4]<0.1))){
    temp <- models[[i]]$R2bestmodel
    besti <- i
  }else{
    finalBestModel_staph_LUR2_subsetD <- models[[besti]]$bestmodel
    finalBestModelNames_staph_subsetD <- models[[besti]]$namesbestmodel
    Sites <- 1:dim(VGOB1_subsetD_staph_LUR2)[1] # full original model
    #  CVaR2<-escCV_staph_LUR2(Sites)[2] # Cross Validation
    maxCD<-max(cooks.distance(finalBestModel_staph_LUR2_subsetD))
    if(length(finalBestModelNames_staph_subsetD)<2){ # vif fn doesnot work when only 1 variable...       # 
      maxVIF<-"NA"
    }else{
      maxVIF<-max(vif(finalBestModel_staph_LUR2_subsetD))
    }
    print(paste("This is the best staph model for subset D: ",besti,
                "(AdjR2: ",format(models[[besti]]$R2bestmodel,digits=3), "; MaxCD: ",format(maxCD,digits=3),"; MaxVIF: ",
                format(maxVIF,digits=3),")", sep=''))
    print(finalBestModelNames_staph_subsetD)
    break
  }
}

#  Overview of the final best model using the algorithm selection process (taking into account VIF, R^2, and p-values)
finalBestModel_staph_LUR2_subsetD
finalBestModelNames_staph_subsetD
models[[besti]]$summarybestmodel
models[[besti]]$R2bestmodel


#### E ####
# LUR model building process for subset E
#  This is the dataframe with the relevant predictor vars for LUR2 models for subset E (55 sites)
VGOB1_subsetE_staph_LUR2 # n.b. this dataframe only includes microbial marker concentrations for staph unlike the dataframe Measurements_livestockpreds_LUR2 as previously used for the model building. 

#  Now set the values of some variables that will be needed
nfirstvar_LUR_2 <- 3  
nlastvar_LUR_2 <- 71

# Function building to run the models 
# 1 #  

models<-list()
modeln<-1
models[[modeln]]<-list()

R2<-1
betaaddedvar<-1
addedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_2:nlastvar_LUR_2){
  if (is.numeric(VGOB1_subsetE_staph_LUR2[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetE_staph_LUR2$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetE_staph_LUR2[,i])                            
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    #  Measurements_livestockpreds_LUR2[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR2)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetE_staph_LUR2)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)
models[[modeln]]$results

#  this are the candidates models with the highest R2, not a negative beta for the new, nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)
models[[modeln]]$resultspos

#  rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))
models[[modeln]]$resultspos

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j
models[[modeln]]$indexbestmodel

subset(models[[modeln]]$resultspos, rank==1)
subset(models[[modeln]]$resultspos)

#  this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]
models[[modeln]]$summarybestmodel

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetE_staph_LUR2)[models[[1]]$indexbestmodel])
models[[modeln]]$namesbestmodel

#  this is the r2 of that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2
models[[modeln]]$R2bestmodel

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetE_staph_LUR2$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetE_staph_LUR2[,models[[1]]$indexbestmodel]) 
models[[modeln]]$bestmodel

summary(models[[modeln]]$bestmodel)

#  The first model includes the predictor: nPigMultipFarmWghtDist.3000m.sum.Tr.1P9 - meaning the number of multiplier pig farms weighted to distance in a 3000m buffer

# 2 #  
# Add 2nd variable (the only difference of the above part is that now modeln=2 the model statement has 2 variables)
# and the call for the list of variable names in the model changed slightly

modeln<-2

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_2:nlastvar_LUR_2){
  if (is.numeric(VGOB1_subsetE_staph_LUR2[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetE_staph_LUR2$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetE_staph_LUR2[,models[[1]]$indexbestmodel]+ VGOB1_subsetE_staph_LUR2[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # Measurements_livestockpreds_LUR2[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR2)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetE_staph_LUR2)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  these are the candidate models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)
models[[modeln]]$resultspos

#  rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))
models[[modeln]]$resultspos

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j
models[[modeln]]$indexbestmodel

subset(models[[modeln]]$resultspos, rank==1)

# this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]
models[[modeln]]$summarybestmodel

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetE_staph_LUR2)[models[[1]]$indexbestmodel], names(VGOB1_subsetE_staph_LUR2)[models[[2]]$indexbestmodel] )
models[[modeln]]$namesbestmodel

# this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2
models[[modeln]]$R2bestmodel

# this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetE_staph_LUR2$staph_copiespm3.ln.diffmeth.mean~                               VGOB1_subsetE_staph_LUR2[,models[[1]]$indexbestmodel]+                           VGOB1_subsetE_staph_LUR2[,models[[2]]$indexbestmodel]) 

models[[modeln]]$bestmodel

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel


# 3 #  
# add third variable (the only difference of the above part is that now modeln=3 the model statement has 3 variables)
# and the call for the list of variable names in the model changed slightly

modeln<-3

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_2:nlastvar_LUR_2){
  if (is.numeric(VGOB1_subsetE_staph_LUR2[,i])==TRUE){  
    modeltry<-lm(VGOB1_subsetE_staph_LUR2$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetE_staph_LUR2[,models[[1]]$indexbestmodel]+VGOB1_subsetE_staph_LUR2[,models[[2]]$indexbestmodel]+ VGOB1_subsetE_staph_LUR2[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # All[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR2)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetE_staph_LUR2)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

#  rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

#  this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

#  here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetE_staph_LUR2)[models[[1]]$indexbestmodel], names(VGOB1_subsetE_staph_LUR2)[models[[2]]$indexbestmodel], names(VGOB1_subsetE_staph_LUR2)[models[[3]]$indexbestmodel])

#  this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetE_staph_LUR2$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetE_staph_LUR2[,models[[1]]$indexbestmodel]+ VGOB1_subsetE_staph_LUR2[,models[[2]]$indexbestmodel]+ VGOB1_subsetE_staph_LUR2[,models[[3]]$indexbestmodel]) 

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel


# 4 #  
#  add forth variable (the only difference of the above part is that now model n=4 the model statement more variables)
#  and the call for the list of variable names in the model changed slightly
modeln<-4

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1


for (i in nfirstvar_LUR_2:nlastvar_LUR_2){
  if (is.numeric(VGOB1_subsetE_staph_LUR2[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetE_staph_LUR2$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetE_staph_LUR2[,models[[1]]$indexbestmodel]+VGOB1_subsetE_staph_LUR2[,models[[2]]$indexbestmodel]+VGOB1_subsetE_staph_LUR2[,models[[3]]$indexbestmodel]+VGOB1_subsetE_staph_LUR2[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    #  the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    #  All[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR2)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetE_staph_LUR2)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

#  this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

#  here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetE_staph_LUR2)[models[[1]]$indexbestmodel], names(VGOB1_subsetE_staph_LUR2)[models[[2]]$indexbestmodel], names(VGOB1_subsetE_staph_LUR2)[models[[3]]$indexbestmodel], names(VGOB1_subsetE_staph_LUR2)[models[[4]]$indexbestmodel])

#  this is the r2 of that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetE_staph_LUR2$staph_copiespm3.ln.diffmeth.mean~ VGOB1_subsetE_staph_LUR2[,models[[1]]$indexbestmodel]+ VGOB1_subsetE_staph_LUR2[,models[[2]]$indexbestmodel]+VGOB1_subsetE_staph_LUR2[,models[[3]]$indexbestmodel]+ VGOB1_subsetE_staph_LUR2[,models[[4]]$indexbestmodel]) 


models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel


# 5 #  
# add fifth variable (the only difference of the above part is that now modeln=5 the model statement more variables)
# and the call for the list of variable names in the model changed slightly
modeln<-5

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_2:nlastvar_LUR_2){
  if (is.numeric(VGOB1_subsetE_staph_LUR2[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetE_staph_LUR2$staph_copiespm3.ln.diffmeth.mean~ VGOB1_subsetE_staph_LUR2[,models[[1]]$indexbestmodel]+ VGOB1_subsetE_staph_LUR2[,models[[2]]$indexbestmodel]+ VGOB1_subsetE_staph_LUR2[,models[[3]]$indexbestmodel]+ VGOB1_subsetE_staph_LUR2[,models[[4]]$indexbestmodel]+ VGOB1_subsetE_staph_LUR2[,i]) 
  
R2<-rbind(R2,summary(modeltry)$adj.r.squared)
# the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # All[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR2)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetE_staph_LUR2)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

#  this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetE_staph_LUR2)[models[[1]]$indexbestmodel], names(VGOB1_subsetE_staph_LUR2)[models[[2]]$indexbestmodel], names(VGOB1_subsetE_staph_LUR2)[models[[3]]$indexbestmodel], names(VGOB1_subsetE_staph_LUR2)[models[[4]]$indexbestmodel], names(VGOB1_subsetE_staph_LUR2)[models[[5]]$indexbestmodel])

#  this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetE_staph_LUR2$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetE_staph_LUR2[,models[[1]]$indexbestmodel]+VGOB1_subsetE_staph_LUR2[,models[[2]]$indexbestmodel]+VGOB1_subsetE_staph_LUR2[,models[[3]]$indexbestmodel]+ VGOB1_subsetE_staph_LUR2[,models[[4]]$indexbestmodel]+ VGOB1_subsetE_staph_LUR2[,models[[5]]$indexbestmodel]) 
models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[5]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[5]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel
models[[5]]$R2bestmodel

# 6 #  
# add sixth variable (the only difference of the above part is that now model n=6 the model statement more variables)
#  and the call for the list of variable names in the model changed slightly

modeln<-6

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_2 :nlastvar_LUR_2){
  if (is.numeric(VGOB1_subsetE_staph_LUR2[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetE_staph_LUR2$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetE_staph_LUR2[,models[[1]]$indexbestmodel]+VGOB1_subsetE_staph_LUR2[,models[[2]]$indexbestmodel]+VGOB1_subsetE_staph_LUR2[,models[[3]]$indexbestmodel]+VGOB1_subsetE_staph_LUR2[,models[[4]]$indexbestmodel]+VGOB1_subsetE_staph_LUR2[,models[[5]]$indexbestmodel]+ VGOB1_subsetE_staph_LUR2[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # All[,i] is the row that's being tried out now. the name of that row can be found in  names(All)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetE_staph_LUR2)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

# this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetE_staph_LUR2)[models[[1]]$indexbestmodel], names(VGOB1_subsetE_staph_LUR2)[models[[2]]$indexbestmodel] , names(VGOB1_subsetE_staph_LUR2)[models[[3]]$indexbestmodel], names(VGOB1_subsetE_staph_LUR2)[models[[4]]$indexbestmodel], names(VGOB1_subsetE_staph_LUR2)[models[[5]]$indexbestmodel], names(VGOB1_subsetE_staph_LUR2)[models[[6]]$indexbestmodel])

#  this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetE_staph_LUR2$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetE_staph_LUR2[,models[[1]]$indexbestmodel]+VGOB1_subsetE_staph_LUR2[,models[[2]]$indexbestmodel]+VGOB1_subsetE_staph_LUR2[,models[[3]]$indexbestmodel]+ VGOB1_subsetE_staph_LUR2[,models[[4]]$indexbestmodel]+ VGOB1_subsetE_staph_LUR2[,models[[5]]$indexbestmodel]+ VGOB1_subsetE_staph_LUR2[,models[[6]]$indexbestmodel]) 

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[5]]$summarybestmodel
models[[6]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[5]]$namesbestmodel
models[[6]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel
models[[5]]$R2bestmodel
models[[6]]$R2bestmodel


# 7 #  
# add seventh variable (the only difference of the above part is that now model n=7 the model statement more variables)
#  and the call for the list of variable names in the model changed slightly

modeln<-7

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_2 :nlastvar_LUR_2){
  if (is.numeric(VGOB1_subsetE_staph_LUR2[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetE_staph_LUR2$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetE_staph_LUR2[,models[[1]]$indexbestmodel]+VGOB1_subsetE_staph_LUR2[,models[[2]]$indexbestmodel]+VGOB1_subsetE_staph_LUR2[,models[[3]]$indexbestmodel]+VGOB1_subsetE_staph_LUR2[,models[[4]]$indexbestmodel]+VGOB1_subsetE_staph_LUR2[,models[[5]]$indexbestmodel]+VGOB1_subsetE_staph_LUR2[,models[[6]]$indexbestmodel]+ VGOB1_subsetE_staph_LUR2[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # Measurements_livestockpreds_LUR2[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR2)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetE_staph_LUR2)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

# this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetE_staph_LUR2)[models[[1]]$indexbestmodel], names(VGOB1_subsetE_staph_LUR2)[models[[2]]$indexbestmodel] , names(VGOB1_subsetE_staph_LUR2)[models[[3]]$indexbestmodel], names(VGOB1_subsetE_staph_LUR2)[models[[4]]$indexbestmodel], names(VGOB1_subsetE_staph_LUR2)[models[[5]]$indexbestmodel], names(VGOB1_subsetE_staph_LUR2)[models[[6]]$indexbestmodel], names(VGOB1_subsetE_staph_LUR2)[models[[7]]$indexbestmodel])

#  this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetE_staph_LUR2$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetE_staph_LUR2[,models[[1]]$indexbestmodel]+VGOB1_subsetE_staph_LUR2[,models[[2]]$indexbestmodel]+VGOB1_subsetE_staph_LUR2[,models[[3]]$indexbestmodel]+ VGOB1_subsetE_staph_LUR2[,models[[4]]$indexbestmodel]+ VGOB1_subsetE_staph_LUR2[,models[[5]]$indexbestmodel]+ VGOB1_subsetE_staph_LUR2[,models[[6]]$indexbestmodel]+ VGOB1_subsetE_staph_LUR2[,models[[7]]$indexbestmodel]) 

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[5]]$summarybestmodel
models[[6]]$summarybestmodel
models[[7]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[5]]$namesbestmodel
models[[6]]$namesbestmodel
models[[7]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel
models[[5]]$R2bestmodel
models[[6]]$R2bestmodel
models[[7]]$R2bestmodel

# 8 #  
# add eighth variable (the only difference of the above part is that now modeln=7 the model statement more variables)
# and the call for the list of variable names in the model changed slightly

modeln<-8

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_2 :nlastvar_LUR_2){
  if (is.numeric(VGOB1_subsetE_staph_LUR2[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetE_staph_LUR2$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetE_staph_LUR2[,models[[1]]$indexbestmodel]+VGOB1_subsetE_staph_LUR2[,models[[2]]$indexbestmodel]+VGOB1_subsetE_staph_LUR2[,models[[3]]$indexbestmodel]+VGOB1_subsetE_staph_LUR2[,models[[4]]$indexbestmodel]+VGOB1_subsetE_staph_LUR2[,models[[5]]$indexbestmodel]+VGOB1_subsetE_staph_LUR2[,models[[6]]$indexbestmodel]+ VGOB1_subsetE_staph_LUR2[,models[[7]]$indexbestmodel]+ VGOB1_subsetE_staph_LUR2[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # Measurements_livestockpreds_LUR2[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR2)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetE_staph_LUR2)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

# this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetE_staph_LUR2)[models[[1]]$indexbestmodel], names(VGOB1_subsetE_staph_LUR2)[models[[2]]$indexbestmodel] , names(VGOB1_subsetE_staph_LUR2)[models[[3]]$indexbestmodel], names(VGOB1_subsetE_staph_LUR2)[models[[4]]$indexbestmodel], names(VGOB1_subsetE_staph_LUR2)[models[[5]]$indexbestmodel], names(VGOB1_subsetE_staph_LUR2)[models[[6]]$indexbestmodel], names(VGOB1_subsetE_staph_LUR2)[models[[7]]$indexbestmodel], names(VGOB1_subsetE_staph_LUR2)[models[[8]]$indexbestmodel])

#  this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetE_staph_LUR2$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetE_staph_LUR2[,models[[1]]$indexbestmodel]+VGOB1_subsetE_staph_LUR2[,models[[2]]$indexbestmodel]+VGOB1_subsetE_staph_LUR2[,models[[3]]$indexbestmodel]+ VGOB1_subsetE_staph_LUR2[,models[[4]]$indexbestmodel]+ VGOB1_subsetE_staph_LUR2[,models[[5]]$indexbestmodel]+ VGOB1_subsetE_staph_LUR2[,models[[6]]$indexbestmodel]+ VGOB1_subsetE_staph_LUR2[,models[[7]]$indexbestmodel]+ VGOB1_subsetE_staph_LUR2[,models[[8]]$indexbestmodel]) 

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[5]]$summarybestmodel
models[[6]]$summarybestmodel
models[[7]]$summarybestmodel
models[[8]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[5]]$namesbestmodel
models[[6]]$namesbestmodel
models[[7]]$namesbestmodel
models[[8]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel
models[[5]]$R2bestmodel
models[[6]]$R2bestmodel
models[[7]]$R2bestmodel
models[[8]]$R2bestmodel

# 9 #  
# add ninth variable (the only difference of the above part is that now modeln=9 the model statement more variables)
# and the call for the list of variable names in the model changed slightly

modeln<-9

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_2 :nlastvar_LUR_2){
  if (is.numeric(VGOB1_subsetE_staph_LUR2[,i])==TRUE){
      modeltry<-lm(VGOB1_subsetE_staph_LUR2$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetE_staph_LUR2[,models[[1]]$indexbestmodel]+VGOB1_subsetE_staph_LUR2[,models[[2]]$indexbestmodel]+VGOB1_subsetE_staph_LUR2[,models[[3]]$indexbestmodel]+VGOB1_subsetE_staph_LUR2[,models[[4]]$indexbestmodel]+VGOB1_subsetE_staph_LUR2[,models[[5]]$indexbestmodel]+VGOB1_subsetE_staph_LUR2[,models[[6]]$indexbestmodel]+ VGOB1_subsetE_staph_LUR2[,models[[7]]$indexbestmodel]+ VGOB1_subsetE_staph_LUR2[,models[[8]]$indexbestmodel]+ VGOB1_subsetE_staph_LUR2[,i]) 
        R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # Measurements_livestockpreds_LUR2[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR2)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetE_staph_LUR2)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

# this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetE_staph_LUR2)[models[[1]]$indexbestmodel], names(VGOB1_subsetE_staph_LUR2)[models[[2]]$indexbestmodel] , names(VGOB1_subsetE_staph_LUR2)[models[[3]]$indexbestmodel], names(VGOB1_subsetE_staph_LUR2)[models[[4]]$indexbestmodel], names(VGOB1_subsetE_staph_LUR2)[models[[5]]$indexbestmodel], names(VGOB1_subsetE_staph_LUR2)[models[[6]]$indexbestmodel], names(VGOB1_subsetE_staph_LUR2)[models[[7]]$indexbestmodel], names(VGOB1_subsetE_staph_LUR2)[models[[8]]$indexbestmodel],  names(VGOB1_subsetE_staph_LUR2)[models[[9]]$indexbestmodel])

#  this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetE_staph_LUR2$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetE_staph_LUR2[,models[[1]]$indexbestmodel]+VGOB1_subsetE_staph_LUR2[,models[[2]]$indexbestmodel]+VGOB1_subsetE_staph_LUR2[,models[[3]]$indexbestmodel]+ VGOB1_subsetE_staph_LUR2[,models[[4]]$indexbestmodel]+ VGOB1_subsetE_staph_LUR2[,models[[5]]$indexbestmodel]+ VGOB1_subsetE_staph_LUR2[,models[[6]]$indexbestmodel]+ VGOB1_subsetE_staph_LUR2[,models[[7]]$indexbestmodel]+ VGOB1_subsetE_staph_LUR2[,models[[8]]$indexbestmodel]+ VGOB1_subsetE_staph_LUR2[,models[[9]]$indexbestmodel]) 

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[5]]$summarybestmodel
models[[6]]$summarybestmodel
models[[7]]$summarybestmodel
models[[8]]$summarybestmodel
models[[9]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[5]]$namesbestmodel
models[[6]]$namesbestmodel
models[[7]]$namesbestmodel
models[[8]]$namesbestmodel
models[[9]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel
models[[5]]$R2bestmodel
models[[6]]$R2bestmodel
models[[7]]$R2bestmodel
models[[8]]$R2bestmodel
models[[9]]$R2bestmodel

# 10 #  
#  add tenth variable (the only difference of the above part is that now model n=10 the model statement more variables)
#  and the call for the list of variable names in the model changed slightly

modeln<-10

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_2 :nlastvar_LUR_2){if (is.numeric(VGOB1_subsetE_staph_LUR2[,i])==TRUE){ modeltry<-lm(VGOB1_subsetE_staph_LUR2$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetE_staph_LUR2[,models[[1]]$indexbestmodel]+VGOB1_subsetE_staph_LUR2[,models[[2]]$indexbestmodel]+ VGOB1_subsetE_staph_LUR2[,models[[3]]$indexbestmodel]+VGOB1_subsetE_staph_LUR2[,models[[4]]$indexbestmodel]+ VGOB1_subsetE_staph_LUR2[,models[[5]]$indexbestmodel]+ VGOB1_subsetE_staph_LUR2[,models[[6]]$indexbestmodel]+ VGOB1_subsetE_staph_LUR2[,models[[7]]$indexbestmodel]+ VGOB1_subsetE_staph_LUR2[,models[[8]]$indexbestmodel]+ VGOB1_subsetE_staph_LUR2[,models[[9]]$indexbestmodel]+ VGOB1_subsetE_staph_LUR2[,i]) 

R2<-rbind(R2,summary(modeltry)$adj.r.squared)
# the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # Measurements_livestockpreds_LUR2[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR2)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetE_staph_LUR2)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

# this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

# here are the names
models[[modeln]]$namesbestmodel<-c( names(VGOB1_subsetE_staph_LUR2)[models[[1]]$indexbestmodel],                   names(VGOB1_subsetE_staph_LUR2)[models[[2]]$indexbestmodel] , names(VGOB1_subsetE_staph_LUR2)[models[[3]]$indexbestmodel], names(VGOB1_subsetE_staph_LUR2)[models[[4]]$indexbestmodel], names(VGOB1_subsetE_staph_LUR2)[models[[5]]$indexbestmodel], names(VGOB1_subsetE_staph_LUR2)[models[[6]]$indexbestmodel], names(VGOB1_subsetE_staph_LUR2)[models[[7]]$indexbestmodel], names(VGOB1_subsetE_staph_LUR2)[models[[8]]$indexbestmodel], names(VGOB1_subsetE_staph_LUR2)[models[[9]]$indexbestmodel], names(VGOB1_subsetE_staph_LUR2)[models[[10]]$indexbestmodel])

#  this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetE_staph_LUR2$staph_copiespm3.ln.diffmeth.mean~                                VGOB1_subsetE_staph_LUR2[,models[[1]]$indexbestmodel]+ VGOB1_subsetE_staph_LUR2[,models[[2]]$indexbestmodel]+                           VGOB1_subsetE_staph_LUR2[,models[[3]]$indexbestmodel]+ VGOB1_subsetE_staph_LUR2[,models[[4]]$indexbestmodel]+ VGOB1_subsetE_staph_LUR2[,models[[5]]$indexbestmodel]+ VGOB1_subsetE_staph_LUR2[,models[[6]]$indexbestmodel]+ VGOB1_subsetE_staph_LUR2[,models[[7]]$indexbestmodel]+ VGOB1_subsetE_staph_LUR2[,models[[8]]$indexbestmodel]+ VGOB1_subsetE_staph_LUR2[,models[[9]]$indexbestmodel]+ VGOB1_subsetE_staph_LUR2[,models[[10]]$indexbestmodel]) 

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[5]]$summarybestmodel
models[[6]]$summarybestmodel
models[[7]]$summarybestmodel
models[[8]]$summarybestmodel
models[[9]]$summarybestmodel
models[[10]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[5]]$namesbestmodel
models[[6]]$namesbestmodel
models[[7]]$namesbestmodel
models[[8]]$namesbestmodel
models[[9]]$namesbestmodel
models[[10]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel
models[[5]]$R2bestmodel
models[[6]]$R2bestmodel
models[[7]]$R2bestmodel
models[[8]]$R2bestmodel
models[[9]]$R2bestmodel
models[[10]]$R2bestmodel

#  at this point I always check whether the next model is more than 1% better than the one before and if not I end here

#   CODE FOR PICKING OUT THE BEST MODEL #   
temp <- 0
besti <- 0
for (i in 1:10){ #  think this runs the loop 10 times - not fully sure thought - but not to do with the number of models I don't think - as when I change to 3, I still get the model with 4 variables as best model
  print(models[[i]]$R2bestmodel)
  #       print(models[[i]]$summarybestmodel$coefficients=-1,4])
  #       if((models[[i]]$R2bestmodel-temp > 0.0) && (all(models[[i]]$summarybestmodel$coefficients[-1,4]<0.1))){
  #         temp <- models[[i]]$R2bestmodel
  #         besti <- i
  #         }
  if((models[[i]]$R2bestmodel-temp > 0.0) && (all(models[[i]]$summarybestmodel$coefficients[-1,4]<0.1))){
    temp <- models[[i]]$R2bestmodel
    besti <- i
  }else{
    finalBestModel_staph_LUR2_subsetE <- models[[besti]]$bestmodel
    finalBestModelNames_staph_subsetE <- models[[besti]]$namesbestmodel
    Sites <- 1:dim(VGOB1_subsetE_staph_LUR2)[1] # full original model
    #  CVaR2<-escCV_staph_LUR2(Sites)[2] # Cross Validation
    maxCD<-max(cooks.distance(finalBestModel_staph_LUR2_subsetE))
    if(length(finalBestModelNames_staph_subsetE)<2){ # vif fn doesnot work when only 1 variable...       # 
      maxVIF<-"NA"
    }else{
      maxVIF<-max(vif(finalBestModel_staph_LUR2_subsetE))
    }
    print(paste("This is the best staph model for subset E: ",besti,
                "(AdjR2: ",format(models[[besti]]$R2bestmodel,digits=3), "; MaxCD: ",format(maxCD,digits=3),"; MaxVIF: ",
                format(maxVIF,digits=3),")", sep=''))
    print(finalBestModelNames_staph_subsetE)
    break
  }
}

#  Overview of the final best model using the algorithm selection process (taking into account VIF, R^2, and p-values)
finalBestModel_staph_LUR2_subsetE
finalBestModelNames_staph_subsetE
models[[besti]]$summarybestmodel
models[[besti]]$R2bestmodel

#### F ####
# LUR model building process for subset F
#  This is the dataframe with the relevant predictor vars for LUR2 models for subset F (55 sites)
VGOB1_subsetF_staph_LUR2 # n.b. this dataframe only includes microbial marker concentrations for staph unlike the dataframe Measurements_livestockpreds_LUR2 as previously used for the model building. 

#  Now set the values of some variables that will be needed
nfirstvar_LUR_2 <- 3  
nlastvar_LUR_2 <- 71

# Function building to run the models 
# 1 #  

models<-list()
modeln<-1
models[[modeln]]<-list()

R2<-1
betaaddedvar<-1
addedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_2:nlastvar_LUR_2){
  if (is.numeric(VGOB1_subsetF_staph_LUR2[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetF_staph_LUR2$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetF_staph_LUR2[,i])                            
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    #  Measurements_livestockpreds_LUR2[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR2)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetF_staph_LUR2)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)
models[[modeln]]$results

#  this are the candidates models with the highest R2, not a negative beta for the new, nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)
models[[modeln]]$resultspos

#  rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))
models[[modeln]]$resultspos

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j
models[[modeln]]$indexbestmodel

subset(models[[modeln]]$resultspos, rank==1)
subset(models[[modeln]]$resultspos)

#  this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]
models[[modeln]]$summarybestmodel

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetF_staph_LUR2)[models[[1]]$indexbestmodel])
models[[modeln]]$namesbestmodel

#  this is the r2 of that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2
models[[modeln]]$R2bestmodel

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetF_staph_LUR2$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetF_staph_LUR2[,models[[1]]$indexbestmodel]) 
models[[modeln]]$bestmodel

summary(models[[modeln]]$bestmodel)

#  The first model includes the predictor: nPigMultipFarmWghtDist.3000m.sum.Tr.1P9 - meaning the number of multiplier pig farms weighted to distance in a 3000m buffer

# 2 #  
# Add 2nd variable (the only difference of the above part is that now modeln=2 the model statement has 2 variables)
# and the call for the list of variable names in the model changed slightly

modeln<-2

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_2:nlastvar_LUR_2){
  if (is.numeric(VGOB1_subsetF_staph_LUR2[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetF_staph_LUR2$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetF_staph_LUR2[,models[[1]]$indexbestmodel]+ VGOB1_subsetF_staph_LUR2[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # Measurements_livestockpreds_LUR2[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR2)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetF_staph_LUR2)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  these are the candidate models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)
models[[modeln]]$resultspos

#  rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))
models[[modeln]]$resultspos

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j
models[[modeln]]$indexbestmodel

subset(models[[modeln]]$resultspos, rank==1)

# this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]
models[[modeln]]$summarybestmodel

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetF_staph_LUR2)[models[[1]]$indexbestmodel], names(VGOB1_subsetF_staph_LUR2)[models[[2]]$indexbestmodel] )
models[[modeln]]$namesbestmodel

# this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2
models[[modeln]]$R2bestmodel

# this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetF_staph_LUR2$staph_copiespm3.ln.diffmeth.mean~                               VGOB1_subsetF_staph_LUR2[,models[[1]]$indexbestmodel]+                           VGOB1_subsetF_staph_LUR2[,models[[2]]$indexbestmodel]) 

models[[modeln]]$bestmodel

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel


# 3 #  
# add third variable (the only difference of the above part is that now modeln=3 the model statement has 3 variables)
# and the call for the list of variable names in the model changed slightly

modeln<-3

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_2:nlastvar_LUR_2){
  if (is.numeric(VGOB1_subsetF_staph_LUR2[,i])==TRUE){  
    modeltry<-lm(VGOB1_subsetF_staph_LUR2$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetF_staph_LUR2[,models[[1]]$indexbestmodel]+VGOB1_subsetF_staph_LUR2[,models[[2]]$indexbestmodel]+ VGOB1_subsetF_staph_LUR2[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # All[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR2)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetF_staph_LUR2)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

#  rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

#  this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

#  here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetF_staph_LUR2)[models[[1]]$indexbestmodel], names(VGOB1_subsetF_staph_LUR2)[models[[2]]$indexbestmodel], names(VGOB1_subsetF_staph_LUR2)[models[[3]]$indexbestmodel])

#  this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetF_staph_LUR2$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetF_staph_LUR2[,models[[1]]$indexbestmodel]+ VGOB1_subsetF_staph_LUR2[,models[[2]]$indexbestmodel]+ VGOB1_subsetF_staph_LUR2[,models[[3]]$indexbestmodel]) 

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel


# 4 #  
#  add forth variable (the only difference of the above part is that now model n=4 the model statement more variables)
#  and the call for the list of variable names in the model changed slightly
modeln<-4

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1


for (i in nfirstvar_LUR_2:nlastvar_LUR_2){
  if (is.numeric(VGOB1_subsetF_staph_LUR2[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetF_staph_LUR2$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetF_staph_LUR2[,models[[1]]$indexbestmodel]+VGOB1_subsetF_staph_LUR2[,models[[2]]$indexbestmodel]+VGOB1_subsetF_staph_LUR2[,models[[3]]$indexbestmodel]+VGOB1_subsetF_staph_LUR2[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    #  the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    #  All[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR2)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetF_staph_LUR2)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

#  this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

#  here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetF_staph_LUR2)[models[[1]]$indexbestmodel], names(VGOB1_subsetF_staph_LUR2)[models[[2]]$indexbestmodel], names(VGOB1_subsetF_staph_LUR2)[models[[3]]$indexbestmodel], names(VGOB1_subsetF_staph_LUR2)[models[[4]]$indexbestmodel])

#  this is the r2 of that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetF_staph_LUR2$staph_copiespm3.ln.diffmeth.mean~ VGOB1_subsetF_staph_LUR2[,models[[1]]$indexbestmodel]+ VGOB1_subsetF_staph_LUR2[,models[[2]]$indexbestmodel]+VGOB1_subsetF_staph_LUR2[,models[[3]]$indexbestmodel]+ VGOB1_subsetF_staph_LUR2[,models[[4]]$indexbestmodel]) 


models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel


# 5 #  
# add fifth variable (the only difference of the above part is that now modeln=5 the model statement more variables)
# and the call for the list of variable names in the model changed slightly
modeln<-5

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_2:nlastvar_LUR_2){
  if (is.numeric(VGOB1_subsetF_staph_LUR2[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetF_staph_LUR2$staph_copiespm3.ln.diffmeth.mean~ VGOB1_subsetF_staph_LUR2[,models[[1]]$indexbestmodel]+ VGOB1_subsetF_staph_LUR2[,models[[2]]$indexbestmodel]+ VGOB1_subsetF_staph_LUR2[,models[[3]]$indexbestmodel]+ VGOB1_subsetF_staph_LUR2[,models[[4]]$indexbestmodel]+ VGOB1_subsetF_staph_LUR2[,i]) 
  
R2<-rbind(R2,summary(modeltry)$adj.r.squared)
# the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # All[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR2)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetF_staph_LUR2)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

#  this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetF_staph_LUR2)[models[[1]]$indexbestmodel], names(VGOB1_subsetF_staph_LUR2)[models[[2]]$indexbestmodel], names(VGOB1_subsetF_staph_LUR2)[models[[3]]$indexbestmodel], names(VGOB1_subsetF_staph_LUR2)[models[[4]]$indexbestmodel], names(VGOB1_subsetF_staph_LUR2)[models[[5]]$indexbestmodel])

#  this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetF_staph_LUR2$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetF_staph_LUR2[,models[[1]]$indexbestmodel]+VGOB1_subsetF_staph_LUR2[,models[[2]]$indexbestmodel]+VGOB1_subsetF_staph_LUR2[,models[[3]]$indexbestmodel]+ VGOB1_subsetF_staph_LUR2[,models[[4]]$indexbestmodel]+ VGOB1_subsetF_staph_LUR2[,models[[5]]$indexbestmodel]) 
models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[5]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[5]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel
models[[5]]$R2bestmodel

# 6 #  
# add sixth variable (the only difference of the above part is that now model n=6 the model statement more variables)
#  and the call for the list of variable names in the model changed slightly

modeln<-6

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_2 :nlastvar_LUR_2){
  if (is.numeric(VGOB1_subsetF_staph_LUR2[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetF_staph_LUR2$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetF_staph_LUR2[,models[[1]]$indexbestmodel]+VGOB1_subsetF_staph_LUR2[,models[[2]]$indexbestmodel]+VGOB1_subsetF_staph_LUR2[,models[[3]]$indexbestmodel]+VGOB1_subsetF_staph_LUR2[,models[[4]]$indexbestmodel]+VGOB1_subsetF_staph_LUR2[,models[[5]]$indexbestmodel]+ VGOB1_subsetF_staph_LUR2[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # All[,i] is the row that's being tried out now. the name of that row can be found in  names(All)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetF_staph_LUR2)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

# this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetF_staph_LUR2)[models[[1]]$indexbestmodel], names(VGOB1_subsetF_staph_LUR2)[models[[2]]$indexbestmodel] , names(VGOB1_subsetF_staph_LUR2)[models[[3]]$indexbestmodel], names(VGOB1_subsetF_staph_LUR2)[models[[4]]$indexbestmodel], names(VGOB1_subsetF_staph_LUR2)[models[[5]]$indexbestmodel], names(VGOB1_subsetF_staph_LUR2)[models[[6]]$indexbestmodel])

#  this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetF_staph_LUR2$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetF_staph_LUR2[,models[[1]]$indexbestmodel]+VGOB1_subsetF_staph_LUR2[,models[[2]]$indexbestmodel]+VGOB1_subsetF_staph_LUR2[,models[[3]]$indexbestmodel]+ VGOB1_subsetF_staph_LUR2[,models[[4]]$indexbestmodel]+ VGOB1_subsetF_staph_LUR2[,models[[5]]$indexbestmodel]+ VGOB1_subsetF_staph_LUR2[,models[[6]]$indexbestmodel]) 

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[5]]$summarybestmodel
models[[6]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[5]]$namesbestmodel
models[[6]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel
models[[5]]$R2bestmodel
models[[6]]$R2bestmodel


# 7 #  
# add seventh variable (the only difference of the above part is that now model n=7 the model statement more variables)
#  and the call for the list of variable names in the model changed slightly

modeln<-7

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_2 :nlastvar_LUR_2){
  if (is.numeric(VGOB1_subsetF_staph_LUR2[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetF_staph_LUR2$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetF_staph_LUR2[,models[[1]]$indexbestmodel]+VGOB1_subsetF_staph_LUR2[,models[[2]]$indexbestmodel]+VGOB1_subsetF_staph_LUR2[,models[[3]]$indexbestmodel]+VGOB1_subsetF_staph_LUR2[,models[[4]]$indexbestmodel]+VGOB1_subsetF_staph_LUR2[,models[[5]]$indexbestmodel]+VGOB1_subsetF_staph_LUR2[,models[[6]]$indexbestmodel]+ VGOB1_subsetF_staph_LUR2[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # Measurements_livestockpreds_LUR2[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR2)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetF_staph_LUR2)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

# this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetF_staph_LUR2)[models[[1]]$indexbestmodel], names(VGOB1_subsetF_staph_LUR2)[models[[2]]$indexbestmodel] , names(VGOB1_subsetF_staph_LUR2)[models[[3]]$indexbestmodel], names(VGOB1_subsetF_staph_LUR2)[models[[4]]$indexbestmodel], names(VGOB1_subsetF_staph_LUR2)[models[[5]]$indexbestmodel], names(VGOB1_subsetF_staph_LUR2)[models[[6]]$indexbestmodel], names(VGOB1_subsetF_staph_LUR2)[models[[7]]$indexbestmodel])

#  this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetF_staph_LUR2$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetF_staph_LUR2[,models[[1]]$indexbestmodel]+VGOB1_subsetF_staph_LUR2[,models[[2]]$indexbestmodel]+VGOB1_subsetF_staph_LUR2[,models[[3]]$indexbestmodel]+ VGOB1_subsetF_staph_LUR2[,models[[4]]$indexbestmodel]+ VGOB1_subsetF_staph_LUR2[,models[[5]]$indexbestmodel]+ VGOB1_subsetF_staph_LUR2[,models[[6]]$indexbestmodel]+ VGOB1_subsetF_staph_LUR2[,models[[7]]$indexbestmodel]) 

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[5]]$summarybestmodel
models[[6]]$summarybestmodel
models[[7]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[5]]$namesbestmodel
models[[6]]$namesbestmodel
models[[7]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel
models[[5]]$R2bestmodel
models[[6]]$R2bestmodel
models[[7]]$R2bestmodel

# 8 #  
# add eighth variable (the only difference of the above part is that now modeln=7 the model statement more variables)
# and the call for the list of variable names in the model changed slightly

modeln<-8

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_2 :nlastvar_LUR_2){
  if (is.numeric(VGOB1_subsetF_staph_LUR2[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetF_staph_LUR2$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetF_staph_LUR2[,models[[1]]$indexbestmodel]+VGOB1_subsetF_staph_LUR2[,models[[2]]$indexbestmodel]+VGOB1_subsetF_staph_LUR2[,models[[3]]$indexbestmodel]+VGOB1_subsetF_staph_LUR2[,models[[4]]$indexbestmodel]+VGOB1_subsetF_staph_LUR2[,models[[5]]$indexbestmodel]+VGOB1_subsetF_staph_LUR2[,models[[6]]$indexbestmodel]+ VGOB1_subsetF_staph_LUR2[,models[[7]]$indexbestmodel]+ VGOB1_subsetF_staph_LUR2[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # Measurements_livestockpreds_LUR2[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR2)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetF_staph_LUR2)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

# this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetF_staph_LUR2)[models[[1]]$indexbestmodel], names(VGOB1_subsetF_staph_LUR2)[models[[2]]$indexbestmodel] , names(VGOB1_subsetF_staph_LUR2)[models[[3]]$indexbestmodel], names(VGOB1_subsetF_staph_LUR2)[models[[4]]$indexbestmodel], names(VGOB1_subsetF_staph_LUR2)[models[[5]]$indexbestmodel], names(VGOB1_subsetF_staph_LUR2)[models[[6]]$indexbestmodel], names(VGOB1_subsetF_staph_LUR2)[models[[7]]$indexbestmodel], names(VGOB1_subsetF_staph_LUR2)[models[[8]]$indexbestmodel])

#  this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetF_staph_LUR2$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetF_staph_LUR2[,models[[1]]$indexbestmodel]+VGOB1_subsetF_staph_LUR2[,models[[2]]$indexbestmodel]+VGOB1_subsetF_staph_LUR2[,models[[3]]$indexbestmodel]+ VGOB1_subsetF_staph_LUR2[,models[[4]]$indexbestmodel]+ VGOB1_subsetF_staph_LUR2[,models[[5]]$indexbestmodel]+ VGOB1_subsetF_staph_LUR2[,models[[6]]$indexbestmodel]+ VGOB1_subsetF_staph_LUR2[,models[[7]]$indexbestmodel]+ VGOB1_subsetF_staph_LUR2[,models[[8]]$indexbestmodel]) 

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[5]]$summarybestmodel
models[[6]]$summarybestmodel
models[[7]]$summarybestmodel
models[[8]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[5]]$namesbestmodel
models[[6]]$namesbestmodel
models[[7]]$namesbestmodel
models[[8]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel
models[[5]]$R2bestmodel
models[[6]]$R2bestmodel
models[[7]]$R2bestmodel
models[[8]]$R2bestmodel

# 9 #  
# add ninth variable (the only difference of the above part is that now modeln=9 the model statement more variables)
# and the call for the list of variable names in the model changed slightly

modeln<-9

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_2 :nlastvar_LUR_2){
  if (is.numeric(VGOB1_subsetF_staph_LUR2[,i])==TRUE){
      modeltry<-lm(VGOB1_subsetF_staph_LUR2$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetF_staph_LUR2[,models[[1]]$indexbestmodel]+VGOB1_subsetF_staph_LUR2[,models[[2]]$indexbestmodel]+VGOB1_subsetF_staph_LUR2[,models[[3]]$indexbestmodel]+VGOB1_subsetF_staph_LUR2[,models[[4]]$indexbestmodel]+VGOB1_subsetF_staph_LUR2[,models[[5]]$indexbestmodel]+VGOB1_subsetF_staph_LUR2[,models[[6]]$indexbestmodel]+ VGOB1_subsetF_staph_LUR2[,models[[7]]$indexbestmodel]+ VGOB1_subsetF_staph_LUR2[,models[[8]]$indexbestmodel]+ VGOB1_subsetF_staph_LUR2[,i]) 
        R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # Measurements_livestockpreds_LUR2[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR2)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetF_staph_LUR2)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

# this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetF_staph_LUR2)[models[[1]]$indexbestmodel], names(VGOB1_subsetF_staph_LUR2)[models[[2]]$indexbestmodel] , names(VGOB1_subsetF_staph_LUR2)[models[[3]]$indexbestmodel], names(VGOB1_subsetF_staph_LUR2)[models[[4]]$indexbestmodel], names(VGOB1_subsetF_staph_LUR2)[models[[5]]$indexbestmodel], names(VGOB1_subsetF_staph_LUR2)[models[[6]]$indexbestmodel], names(VGOB1_subsetF_staph_LUR2)[models[[7]]$indexbestmodel], names(VGOB1_subsetF_staph_LUR2)[models[[8]]$indexbestmodel],  names(VGOB1_subsetF_staph_LUR2)[models[[9]]$indexbestmodel])

#  this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetF_staph_LUR2$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetF_staph_LUR2[,models[[1]]$indexbestmodel]+VGOB1_subsetF_staph_LUR2[,models[[2]]$indexbestmodel]+VGOB1_subsetF_staph_LUR2[,models[[3]]$indexbestmodel]+ VGOB1_subsetF_staph_LUR2[,models[[4]]$indexbestmodel]+ VGOB1_subsetF_staph_LUR2[,models[[5]]$indexbestmodel]+ VGOB1_subsetF_staph_LUR2[,models[[6]]$indexbestmodel]+ VGOB1_subsetF_staph_LUR2[,models[[7]]$indexbestmodel]+ VGOB1_subsetF_staph_LUR2[,models[[8]]$indexbestmodel]+ VGOB1_subsetF_staph_LUR2[,models[[9]]$indexbestmodel]) 

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[5]]$summarybestmodel
models[[6]]$summarybestmodel
models[[7]]$summarybestmodel
models[[8]]$summarybestmodel
models[[9]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[5]]$namesbestmodel
models[[6]]$namesbestmodel
models[[7]]$namesbestmodel
models[[8]]$namesbestmodel
models[[9]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel
models[[5]]$R2bestmodel
models[[6]]$R2bestmodel
models[[7]]$R2bestmodel
models[[8]]$R2bestmodel
models[[9]]$R2bestmodel

# 10 #  
#  add tenth variable (the only difference of the above part is that now model n=10 the model statement more variables)
#  and the call for the list of variable names in the model changed slightly

modeln<-10

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_2 :nlastvar_LUR_2){if (is.numeric(VGOB1_subsetF_staph_LUR2[,i])==TRUE){ modeltry<-lm(VGOB1_subsetF_staph_LUR2$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetF_staph_LUR2[,models[[1]]$indexbestmodel]+VGOB1_subsetF_staph_LUR2[,models[[2]]$indexbestmodel]+ VGOB1_subsetF_staph_LUR2[,models[[3]]$indexbestmodel]+VGOB1_subsetF_staph_LUR2[,models[[4]]$indexbestmodel]+ VGOB1_subsetF_staph_LUR2[,models[[5]]$indexbestmodel]+ VGOB1_subsetF_staph_LUR2[,models[[6]]$indexbestmodel]+ VGOB1_subsetF_staph_LUR2[,models[[7]]$indexbestmodel]+ VGOB1_subsetF_staph_LUR2[,models[[8]]$indexbestmodel]+ VGOB1_subsetF_staph_LUR2[,models[[9]]$indexbestmodel]+ VGOB1_subsetF_staph_LUR2[,i]) 

R2<-rbind(R2,summary(modeltry)$adj.r.squared)
# the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # Measurements_livestockpreds_LUR2[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR2)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetF_staph_LUR2)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

# this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

# here are the names
models[[modeln]]$namesbestmodel<-c( names(VGOB1_subsetF_staph_LUR2)[models[[1]]$indexbestmodel],                   names(VGOB1_subsetF_staph_LUR2)[models[[2]]$indexbestmodel] , names(VGOB1_subsetF_staph_LUR2)[models[[3]]$indexbestmodel], names(VGOB1_subsetF_staph_LUR2)[models[[4]]$indexbestmodel], names(VGOB1_subsetF_staph_LUR2)[models[[5]]$indexbestmodel], names(VGOB1_subsetF_staph_LUR2)[models[[6]]$indexbestmodel], names(VGOB1_subsetF_staph_LUR2)[models[[7]]$indexbestmodel], names(VGOB1_subsetF_staph_LUR2)[models[[8]]$indexbestmodel], names(VGOB1_subsetF_staph_LUR2)[models[[9]]$indexbestmodel], names(VGOB1_subsetF_staph_LUR2)[models[[10]]$indexbestmodel])

#  this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetF_staph_LUR2$staph_copiespm3.ln.diffmeth.mean~                                VGOB1_subsetF_staph_LUR2[,models[[1]]$indexbestmodel]+ VGOB1_subsetF_staph_LUR2[,models[[2]]$indexbestmodel]+                           VGOB1_subsetF_staph_LUR2[,models[[3]]$indexbestmodel]+ VGOB1_subsetF_staph_LUR2[,models[[4]]$indexbestmodel]+ VGOB1_subsetF_staph_LUR2[,models[[5]]$indexbestmodel]+ VGOB1_subsetF_staph_LUR2[,models[[6]]$indexbestmodel]+ VGOB1_subsetF_staph_LUR2[,models[[7]]$indexbestmodel]+ VGOB1_subsetF_staph_LUR2[,models[[8]]$indexbestmodel]+ VGOB1_subsetF_staph_LUR2[,models[[9]]$indexbestmodel]+ VGOB1_subsetF_staph_LUR2[,models[[10]]$indexbestmodel]) 

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[5]]$summarybestmodel
models[[6]]$summarybestmodel
models[[7]]$summarybestmodel
models[[8]]$summarybestmodel
models[[9]]$summarybestmodel
models[[10]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[5]]$namesbestmodel
models[[6]]$namesbestmodel
models[[7]]$namesbestmodel
models[[8]]$namesbestmodel
models[[9]]$namesbestmodel
models[[10]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel
models[[5]]$R2bestmodel
models[[6]]$R2bestmodel
models[[7]]$R2bestmodel
models[[8]]$R2bestmodel
models[[9]]$R2bestmodel
models[[10]]$R2bestmodel

#  at this point I always check whether the next model is more than 1% better than the one before and if not I end here

#   CODE FOR PICKING OUT THE BEST MODEL #   
temp <- 0
besti <- 0
for (i in 1:10){ #  think this runs the loop 10 times - not fully sure thought - but not to do with the number of models I don't think - as when I change to 3, I still get the model with 4 variables as best model
  print(models[[i]]$R2bestmodel)
  #       print(models[[i]]$summarybestmodel$coefficients=-1,4])
  #       if((models[[i]]$R2bestmodel-temp > 0.0) && (all(models[[i]]$summarybestmodel$coefficients[-1,4]<0.1))){
  #         temp <- models[[i]]$R2bestmodel
  #         besti <- i
  #         }
  if((models[[i]]$R2bestmodel-temp > 0.0) && (all(models[[i]]$summarybestmodel$coefficients[-1,4]<0.1))){
    temp <- models[[i]]$R2bestmodel
    besti <- i
  }else{
    finalBestModel_staph_LUR2_subsetF <- models[[besti]]$bestmodel
    finalBestModelNames_staph_subsetF <- models[[besti]]$namesbestmodel
    Sites <- 1:dim(VGOB1_subsetF_staph_LUR2)[1] # full original model
    #  CVaR2<-escCV_staph_LUR2(Sites)[2] # Cross Validation
    maxCD<-max(cooks.distance(finalBestModel_staph_LUR2_subsetF))
    if(length(finalBestModelNames_staph_subsetF)<2){ # vif fn doesnot work when only 1 variable...       # 
      maxVIF<-"NA"
    }else{
      maxVIF<-max(vif(finalBestModel_staph_LUR2_subsetF))
    }
    print(paste("This is the best staph model for subset F: ",besti,
                "(AdjR2: ",format(models[[besti]]$R2bestmodel,digits=3), "; MaxCD: ",format(maxCD,digits=3),"; MaxVIF: ",
                format(maxVIF,digits=3),")", sep=''))
    print(finalBestModelNames_staph_subsetF)
    break
  }
}

#  Overview of the final best model using the algorithm selection process (taking into account VIF, R^2, and p-values)
finalBestModel_staph_LUR2_subsetF
finalBestModelNames_staph_subsetF
models[[besti]]$summarybestmodel
models[[besti]]$R2bestmodel

#### G ####
# LUR model building process for subset G
#  This is the dataframe with the relevant predictor vars for LUR2 models for subset G (55 sites)
VGOB1_subsetG_staph_LUR2 # n.b. this dataframe only includes microbial marker concentrations for staph unlike the dataframe Measurements_livestockpreds_LUR2 as previously used for the model building. 

#  Now set the values of some variables that will be needed
nfirstvar_LUR_2 <- 3  
nlastvar_LUR_2 <- 71

# Function building to run the models 
# 1 #  

models<-list()
modeln<-1
models[[modeln]]<-list()

R2<-1
betaaddedvar<-1
addedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_2:nlastvar_LUR_2){
  if (is.numeric(VGOB1_subsetG_staph_LUR2[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetG_staph_LUR2$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetG_staph_LUR2[,i])                            
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    #  Measurements_livestockpreds_LUR2[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR2)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetG_staph_LUR2)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)
models[[modeln]]$results

#  this are the candidates models with the highest R2, not a negative beta for the new, nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)
models[[modeln]]$resultspos

#  rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))
models[[modeln]]$resultspos

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j
models[[modeln]]$indexbestmodel

subset(models[[modeln]]$resultspos, rank==1)
subset(models[[modeln]]$resultspos)

#  this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]
models[[modeln]]$summarybestmodel

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetG_staph_LUR2)[models[[1]]$indexbestmodel])
models[[modeln]]$namesbestmodel

#  this is the r2 of that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2
models[[modeln]]$R2bestmodel

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetG_staph_LUR2$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetG_staph_LUR2[,models[[1]]$indexbestmodel]) 
models[[modeln]]$bestmodel

summary(models[[modeln]]$bestmodel)

#  The first model includes the predictor: nPigMultipFarmWghtDist.3000m.sum.Tr.1P9 - meaning the number of multiplier pig farms weighted to distance in a 3000m buffer

# 2 #  
# Add 2nd variable (the only difference of the above part is that now modeln=2 the model statement has 2 variables)
# and the call for the list of variable names in the model changed slightly

modeln<-2

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_2:nlastvar_LUR_2){
  if (is.numeric(VGOB1_subsetG_staph_LUR2[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetG_staph_LUR2$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetG_staph_LUR2[,models[[1]]$indexbestmodel]+ VGOB1_subsetG_staph_LUR2[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # Measurements_livestockpreds_LUR2[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR2)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetG_staph_LUR2)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  these are the candidate models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)
models[[modeln]]$resultspos

#  rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))
models[[modeln]]$resultspos

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j
models[[modeln]]$indexbestmodel

subset(models[[modeln]]$resultspos, rank==1)

# this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]
models[[modeln]]$summarybestmodel

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetG_staph_LUR2)[models[[1]]$indexbestmodel], names(VGOB1_subsetG_staph_LUR2)[models[[2]]$indexbestmodel] )
models[[modeln]]$namesbestmodel

# this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2
models[[modeln]]$R2bestmodel

# this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetG_staph_LUR2$staph_copiespm3.ln.diffmeth.mean~                               VGOB1_subsetG_staph_LUR2[,models[[1]]$indexbestmodel]+                           VGOB1_subsetG_staph_LUR2[,models[[2]]$indexbestmodel]) 

models[[modeln]]$bestmodel

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel


# 3 #  
# add third variable (the only difference of the above part is that now modeln=3 the model statement has 3 variables)
# and the call for the list of variable names in the model changed slightly

modeln<-3

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_2:nlastvar_LUR_2){
  if (is.numeric(VGOB1_subsetG_staph_LUR2[,i])==TRUE){  
    modeltry<-lm(VGOB1_subsetG_staph_LUR2$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetG_staph_LUR2[,models[[1]]$indexbestmodel]+VGOB1_subsetG_staph_LUR2[,models[[2]]$indexbestmodel]+ VGOB1_subsetG_staph_LUR2[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # All[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR2)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetG_staph_LUR2)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

#  rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

#  this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

#  here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetG_staph_LUR2)[models[[1]]$indexbestmodel], names(VGOB1_subsetG_staph_LUR2)[models[[2]]$indexbestmodel], names(VGOB1_subsetG_staph_LUR2)[models[[3]]$indexbestmodel])

#  this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetG_staph_LUR2$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetG_staph_LUR2[,models[[1]]$indexbestmodel]+ VGOB1_subsetG_staph_LUR2[,models[[2]]$indexbestmodel]+ VGOB1_subsetG_staph_LUR2[,models[[3]]$indexbestmodel]) 

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel


# 4 #  
#  add forth variable (the only difference of the above part is that now model n=4 the model statement more variables)
#  and the call for the list of variable names in the model changed slightly
modeln<-4

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1


for (i in nfirstvar_LUR_2:nlastvar_LUR_2){
  if (is.numeric(VGOB1_subsetG_staph_LUR2[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetG_staph_LUR2$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetG_staph_LUR2[,models[[1]]$indexbestmodel]+VGOB1_subsetG_staph_LUR2[,models[[2]]$indexbestmodel]+VGOB1_subsetG_staph_LUR2[,models[[3]]$indexbestmodel]+VGOB1_subsetG_staph_LUR2[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    #  the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    #  All[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR2)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetG_staph_LUR2)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

#  this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

#  here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetG_staph_LUR2)[models[[1]]$indexbestmodel], names(VGOB1_subsetG_staph_LUR2)[models[[2]]$indexbestmodel], names(VGOB1_subsetG_staph_LUR2)[models[[3]]$indexbestmodel], names(VGOB1_subsetG_staph_LUR2)[models[[4]]$indexbestmodel])

#  this is the r2 of that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetG_staph_LUR2$staph_copiespm3.ln.diffmeth.mean~ VGOB1_subsetG_staph_LUR2[,models[[1]]$indexbestmodel]+ VGOB1_subsetG_staph_LUR2[,models[[2]]$indexbestmodel]+VGOB1_subsetG_staph_LUR2[,models[[3]]$indexbestmodel]+ VGOB1_subsetG_staph_LUR2[,models[[4]]$indexbestmodel]) 


models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel


# 5 #  
# add fifth variable (the only difference of the above part is that now modeln=5 the model statement more variables)
# and the call for the list of variable names in the model changed slightly
modeln<-5

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_2:nlastvar_LUR_2){
  if (is.numeric(VGOB1_subsetG_staph_LUR2[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetG_staph_LUR2$staph_copiespm3.ln.diffmeth.mean~ VGOB1_subsetG_staph_LUR2[,models[[1]]$indexbestmodel]+ VGOB1_subsetG_staph_LUR2[,models[[2]]$indexbestmodel]+ VGOB1_subsetG_staph_LUR2[,models[[3]]$indexbestmodel]+ VGOB1_subsetG_staph_LUR2[,models[[4]]$indexbestmodel]+ VGOB1_subsetG_staph_LUR2[,i]) 
  
R2<-rbind(R2,summary(modeltry)$adj.r.squared)
# the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # All[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR2)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetG_staph_LUR2)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

#  this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetG_staph_LUR2)[models[[1]]$indexbestmodel], names(VGOB1_subsetG_staph_LUR2)[models[[2]]$indexbestmodel], names(VGOB1_subsetG_staph_LUR2)[models[[3]]$indexbestmodel], names(VGOB1_subsetG_staph_LUR2)[models[[4]]$indexbestmodel], names(VGOB1_subsetG_staph_LUR2)[models[[5]]$indexbestmodel])

#  this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetG_staph_LUR2$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetG_staph_LUR2[,models[[1]]$indexbestmodel]+VGOB1_subsetG_staph_LUR2[,models[[2]]$indexbestmodel]+VGOB1_subsetG_staph_LUR2[,models[[3]]$indexbestmodel]+ VGOB1_subsetG_staph_LUR2[,models[[4]]$indexbestmodel]+ VGOB1_subsetG_staph_LUR2[,models[[5]]$indexbestmodel]) 
models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[5]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[5]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel
models[[5]]$R2bestmodel

# 6 #  
# add sixth variable (the only difference of the above part is that now model n=6 the model statement more variables)
#  and the call for the list of variable names in the model changed slightly

modeln<-6

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_2 :nlastvar_LUR_2){
  if (is.numeric(VGOB1_subsetG_staph_LUR2[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetG_staph_LUR2$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetG_staph_LUR2[,models[[1]]$indexbestmodel]+VGOB1_subsetG_staph_LUR2[,models[[2]]$indexbestmodel]+VGOB1_subsetG_staph_LUR2[,models[[3]]$indexbestmodel]+VGOB1_subsetG_staph_LUR2[,models[[4]]$indexbestmodel]+VGOB1_subsetG_staph_LUR2[,models[[5]]$indexbestmodel]+ VGOB1_subsetG_staph_LUR2[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # All[,i] is the row that's being tried out now. the name of that row can be found in  names(All)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetG_staph_LUR2)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

# this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetG_staph_LUR2)[models[[1]]$indexbestmodel], names(VGOB1_subsetG_staph_LUR2)[models[[2]]$indexbestmodel] , names(VGOB1_subsetG_staph_LUR2)[models[[3]]$indexbestmodel], names(VGOB1_subsetG_staph_LUR2)[models[[4]]$indexbestmodel], names(VGOB1_subsetG_staph_LUR2)[models[[5]]$indexbestmodel], names(VGOB1_subsetG_staph_LUR2)[models[[6]]$indexbestmodel])

#  this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetG_staph_LUR2$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetG_staph_LUR2[,models[[1]]$indexbestmodel]+VGOB1_subsetG_staph_LUR2[,models[[2]]$indexbestmodel]+VGOB1_subsetG_staph_LUR2[,models[[3]]$indexbestmodel]+ VGOB1_subsetG_staph_LUR2[,models[[4]]$indexbestmodel]+ VGOB1_subsetG_staph_LUR2[,models[[5]]$indexbestmodel]+ VGOB1_subsetG_staph_LUR2[,models[[6]]$indexbestmodel]) 

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[5]]$summarybestmodel
models[[6]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[5]]$namesbestmodel
models[[6]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel
models[[5]]$R2bestmodel
models[[6]]$R2bestmodel


# 7 #  
# add seventh variable (the only difference of the above part is that now model n=7 the model statement more variables)
#  and the call for the list of variable names in the model changed slightly

modeln<-7

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_2 :nlastvar_LUR_2){
  if (is.numeric(VGOB1_subsetG_staph_LUR2[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetG_staph_LUR2$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetG_staph_LUR2[,models[[1]]$indexbestmodel]+VGOB1_subsetG_staph_LUR2[,models[[2]]$indexbestmodel]+VGOB1_subsetG_staph_LUR2[,models[[3]]$indexbestmodel]+VGOB1_subsetG_staph_LUR2[,models[[4]]$indexbestmodel]+VGOB1_subsetG_staph_LUR2[,models[[5]]$indexbestmodel]+VGOB1_subsetG_staph_LUR2[,models[[6]]$indexbestmodel]+ VGOB1_subsetG_staph_LUR2[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # Measurements_livestockpreds_LUR2[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR2)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetG_staph_LUR2)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

# this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetG_staph_LUR2)[models[[1]]$indexbestmodel], names(VGOB1_subsetG_staph_LUR2)[models[[2]]$indexbestmodel] , names(VGOB1_subsetG_staph_LUR2)[models[[3]]$indexbestmodel], names(VGOB1_subsetG_staph_LUR2)[models[[4]]$indexbestmodel], names(VGOB1_subsetG_staph_LUR2)[models[[5]]$indexbestmodel], names(VGOB1_subsetG_staph_LUR2)[models[[6]]$indexbestmodel], names(VGOB1_subsetG_staph_LUR2)[models[[7]]$indexbestmodel])

#  this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetG_staph_LUR2$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetG_staph_LUR2[,models[[1]]$indexbestmodel]+VGOB1_subsetG_staph_LUR2[,models[[2]]$indexbestmodel]+VGOB1_subsetG_staph_LUR2[,models[[3]]$indexbestmodel]+ VGOB1_subsetG_staph_LUR2[,models[[4]]$indexbestmodel]+ VGOB1_subsetG_staph_LUR2[,models[[5]]$indexbestmodel]+ VGOB1_subsetG_staph_LUR2[,models[[6]]$indexbestmodel]+ VGOB1_subsetG_staph_LUR2[,models[[7]]$indexbestmodel]) 

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[5]]$summarybestmodel
models[[6]]$summarybestmodel
models[[7]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[5]]$namesbestmodel
models[[6]]$namesbestmodel
models[[7]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel
models[[5]]$R2bestmodel
models[[6]]$R2bestmodel
models[[7]]$R2bestmodel

# # 8 #  
# # add eighth variable (the only difference of the above part is that now modeln=7 the model statement more variables)
# # and the call for the list of variable names in the model changed slightly
# 
# modeln<-8
# 
# models[[modeln]]<-list()
# 
# R2<-1
# addedvar<-1
# betaaddedvar<-1
# minbetas<-1
# j<-1
# 
# for (i in nfirstvar_LUR_2 :nlastvar_LUR_2){
#   if (is.numeric(VGOB1_subsetG_staph_LUR2[,i])==TRUE){
#     modeltry<-lm(VGOB1_subsetG_staph_LUR2$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetG_staph_LUR2[,models[[1]]$indexbestmodel]+VGOB1_subsetG_staph_LUR2[,models[[2]]$indexbestmodel]+VGOB1_subsetG_staph_LUR2[,models[[3]]$indexbestmodel]+VGOB1_subsetG_staph_LUR2[,models[[4]]$indexbestmodel]+VGOB1_subsetG_staph_LUR2[,models[[5]]$indexbestmodel]+VGOB1_subsetG_staph_LUR2[,models[[6]]$indexbestmodel]+ VGOB1_subsetG_staph_LUR2[,models[[7]]$indexbestmodel]+ VGOB1_subsetG_staph_LUR2[,i]) 
#     R2<-rbind(R2,summary(modeltry)$adj.r.squared)
#     # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
#     betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
#     #  find out if there is a negative beta at All. The intercept does not count [-1]!
#     minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
#     # Measurements_livestockpreds_LUR2[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR2)[i]
#     addedvar<-rbind(addedvar,names(VGOB1_subsetG_staph_LUR2)[i])
#     j<-rbind(j, i)
#     models[[modeln]][[i]]<-summary(modeltry)
#   }
# }
# 
# models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)
# 
# #  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
# models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)
# 
# # rank the R2's of these models
# models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))
# 
# #  this is the index of the row with the highest R2 and  no negative betas in this subset
# models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j
# 
# subset(models[[modeln]]$resultspos, rank==1)
# 
# # this is the model
# models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]
# 
# # here are the names
# models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetG_staph_LUR2)[models[[1]]$indexbestmodel], names(VGOB1_subsetG_staph_LUR2)[models[[2]]$indexbestmodel] , names(VGOB1_subsetG_staph_LUR2)[models[[3]]$indexbestmodel], names(VGOB1_subsetG_staph_LUR2)[models[[4]]$indexbestmodel], names(VGOB1_subsetG_staph_LUR2)[models[[5]]$indexbestmodel], names(VGOB1_subsetG_staph_LUR2)[models[[6]]$indexbestmodel], names(VGOB1_subsetG_staph_LUR2)[models[[7]]$indexbestmodel], names(VGOB1_subsetG_staph_LUR2)[models[[8]]$indexbestmodel])
# 
# #  this is the r2 or that model
# models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2
# 
# #  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
# models[[modeln]]$bestmodel <- lm(VGOB1_subsetG_staph_LUR2$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetG_staph_LUR2[,models[[1]]$indexbestmodel]+VGOB1_subsetG_staph_LUR2[,models[[2]]$indexbestmodel]+VGOB1_subsetG_staph_LUR2[,models[[3]]$indexbestmodel]+ VGOB1_subsetG_staph_LUR2[,models[[4]]$indexbestmodel]+ VGOB1_subsetG_staph_LUR2[,models[[5]]$indexbestmodel]+ VGOB1_subsetG_staph_LUR2[,models[[6]]$indexbestmodel]+ VGOB1_subsetG_staph_LUR2[,models[[7]]$indexbestmodel]+ VGOB1_subsetG_staph_LUR2[,models[[8]]$indexbestmodel]) 
# 
# models[[1]]$summarybestmodel
# models[[2]]$summarybestmodel
# models[[3]]$summarybestmodel
# models[[4]]$summarybestmodel
# models[[5]]$summarybestmodel
# models[[6]]$summarybestmodel
# models[[7]]$summarybestmodel
# models[[8]]$summarybestmodel
# models[[1]]$namesbestmodel
# models[[2]]$namesbestmodel
# models[[3]]$namesbestmodel
# models[[4]]$namesbestmodel
# models[[5]]$namesbestmodel
# models[[6]]$namesbestmodel
# models[[7]]$namesbestmodel
# models[[8]]$namesbestmodel
# models[[1]]$R2bestmodel
# models[[2]]$R2bestmodel
# models[[3]]$R2bestmodel
# models[[4]]$R2bestmodel
# models[[5]]$R2bestmodel
# models[[6]]$R2bestmodel
# models[[7]]$R2bestmodel
# models[[8]]$R2bestmodel
# 
# # 9 #  
# # add ninth variable (the only difference of the above part is that now modeln=9 the model statement more variables)
# # and the call for the list of variable names in the model changed slightly
# 
# modeln<-9
# 
# models[[modeln]]<-list()
# 
# R2<-1
# addedvar<-1
# betaaddedvar<-1
# minbetas<-1
# j<-1
# 
# for (i in nfirstvar_LUR_2 :nlastvar_LUR_2){
#   if (is.numeric(VGOB1_subsetG_staph_LUR2[,i])==TRUE){
#       modeltry<-lm(VGOB1_subsetG_staph_LUR2$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetG_staph_LUR2[,models[[1]]$indexbestmodel]+VGOB1_subsetG_staph_LUR2[,models[[2]]$indexbestmodel]+VGOB1_subsetG_staph_LUR2[,models[[3]]$indexbestmodel]+VGOB1_subsetG_staph_LUR2[,models[[4]]$indexbestmodel]+VGOB1_subsetG_staph_LUR2[,models[[5]]$indexbestmodel]+VGOB1_subsetG_staph_LUR2[,models[[6]]$indexbestmodel]+ VGOB1_subsetG_staph_LUR2[,models[[7]]$indexbestmodel]+ VGOB1_subsetG_staph_LUR2[,models[[8]]$indexbestmodel]+ VGOB1_subsetG_staph_LUR2[,i]) 
#         R2<-rbind(R2,summary(modeltry)$adj.r.squared)
#     # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
#     betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
#     #  find out if there is a negative beta at All. The intercept does not count [-1]!
#     minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
#     # Measurements_livestockpreds_LUR2[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR2)[i]
#     addedvar<-rbind(addedvar,names(VGOB1_subsetG_staph_LUR2)[i])
#     j<-rbind(j, i)
#     models[[modeln]][[i]]<-summary(modeltry)
#   }
# }
# 
# models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)
# 
# #  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
# models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)
# 
# # rank the R2's of these models
# models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))
# 
# #  this is the index of the row with the highest R2 and  no negative betas in this subset
# models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j
# 
# subset(models[[modeln]]$resultspos, rank==1)
# 
# # this is the model
# models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]
# 
# # here are the names
# models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetG_staph_LUR2)[models[[1]]$indexbestmodel], names(VGOB1_subsetG_staph_LUR2)[models[[2]]$indexbestmodel] , names(VGOB1_subsetG_staph_LUR2)[models[[3]]$indexbestmodel], names(VGOB1_subsetG_staph_LUR2)[models[[4]]$indexbestmodel], names(VGOB1_subsetG_staph_LUR2)[models[[5]]$indexbestmodel], names(VGOB1_subsetG_staph_LUR2)[models[[6]]$indexbestmodel], names(VGOB1_subsetG_staph_LUR2)[models[[7]]$indexbestmodel], names(VGOB1_subsetG_staph_LUR2)[models[[8]]$indexbestmodel],  names(VGOB1_subsetG_staph_LUR2)[models[[9]]$indexbestmodel])
# 
# #  this is the r2 or that model
# models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2
# 
# #  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
# models[[modeln]]$bestmodel <- lm(VGOB1_subsetG_staph_LUR2$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetG_staph_LUR2[,models[[1]]$indexbestmodel]+VGOB1_subsetG_staph_LUR2[,models[[2]]$indexbestmodel]+VGOB1_subsetG_staph_LUR2[,models[[3]]$indexbestmodel]+ VGOB1_subsetG_staph_LUR2[,models[[4]]$indexbestmodel]+ VGOB1_subsetG_staph_LUR2[,models[[5]]$indexbestmodel]+ VGOB1_subsetG_staph_LUR2[,models[[6]]$indexbestmodel]+ VGOB1_subsetG_staph_LUR2[,models[[7]]$indexbestmodel]+ VGOB1_subsetG_staph_LUR2[,models[[8]]$indexbestmodel]+ VGOB1_subsetG_staph_LUR2[,models[[9]]$indexbestmodel]) 
# 
# models[[1]]$summarybestmodel
# models[[2]]$summarybestmodel
# models[[3]]$summarybestmodel
# models[[4]]$summarybestmodel
# models[[5]]$summarybestmodel
# models[[6]]$summarybestmodel
# models[[7]]$summarybestmodel
# models[[8]]$summarybestmodel
# models[[9]]$summarybestmodel
# models[[1]]$namesbestmodel
# models[[2]]$namesbestmodel
# models[[3]]$namesbestmodel
# models[[4]]$namesbestmodel
# models[[5]]$namesbestmodel
# models[[6]]$namesbestmodel
# models[[7]]$namesbestmodel
# models[[8]]$namesbestmodel
# models[[9]]$namesbestmodel
# models[[1]]$R2bestmodel
# models[[2]]$R2bestmodel
# models[[3]]$R2bestmodel
# models[[4]]$R2bestmodel
# models[[5]]$R2bestmodel
# models[[6]]$R2bestmodel
# models[[7]]$R2bestmodel
# models[[8]]$R2bestmodel
# models[[9]]$R2bestmodel
# 
# # 10 #  
# #  add tenth variable (the only difference of the above part is that now model n=10 the model statement more variables)
# #  and the call for the list of variable names in the model changed slightly
# 
# modeln<-10
# 
# models[[modeln]]<-list()
# 
# R2<-1
# addedvar<-1
# betaaddedvar<-1
# minbetas<-1
# j<-1
# 
# for (i in nfirstvar_LUR_2 :nlastvar_LUR_2){if (is.numeric(VGOB1_subsetG_staph_LUR2[,i])==TRUE){ modeltry<-lm(VGOB1_subsetG_staph_LUR2$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetG_staph_LUR2[,models[[1]]$indexbestmodel]+VGOB1_subsetG_staph_LUR2[,models[[2]]$indexbestmodel]+ VGOB1_subsetG_staph_LUR2[,models[[3]]$indexbestmodel]+VGOB1_subsetG_staph_LUR2[,models[[4]]$indexbestmodel]+ VGOB1_subsetG_staph_LUR2[,models[[5]]$indexbestmodel]+ VGOB1_subsetG_staph_LUR2[,models[[6]]$indexbestmodel]+ VGOB1_subsetG_staph_LUR2[,models[[7]]$indexbestmodel]+ VGOB1_subsetG_staph_LUR2[,models[[8]]$indexbestmodel]+ VGOB1_subsetG_staph_LUR2[,models[[9]]$indexbestmodel]+ VGOB1_subsetG_staph_LUR2[,i]) 
# 
# R2<-rbind(R2,summary(modeltry)$adj.r.squared)
# # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
#     betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
#     #  find out if there is a negative beta at All. The intercept does not count [-1]!
#     minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
#     # Measurements_livestockpreds_LUR2[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR2)[i]
#     addedvar<-rbind(addedvar,names(VGOB1_subsetG_staph_LUR2)[i])
#     j<-rbind(j, i)
#     models[[modeln]][[i]]<-summary(modeltry)
#   }
# }
# 
# models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)
# 
# #  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
# models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)
# 
# # rank the R2's of these models
# models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))
# 
# #  this is the index of the row with the highest R2 and  no negative betas in this subset
# models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j
# 
# subset(models[[modeln]]$resultspos, rank==1)
# 
# # this is the model
# models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]
# 
# # here are the names
# models[[modeln]]$namesbestmodel<-c( names(VGOB1_subsetG_staph_LUR2)[models[[1]]$indexbestmodel],                   names(VGOB1_subsetG_staph_LUR2)[models[[2]]$indexbestmodel] , names(VGOB1_subsetG_staph_LUR2)[models[[3]]$indexbestmodel], names(VGOB1_subsetG_staph_LUR2)[models[[4]]$indexbestmodel], names(VGOB1_subsetG_staph_LUR2)[models[[5]]$indexbestmodel], names(VGOB1_subsetG_staph_LUR2)[models[[6]]$indexbestmodel], names(VGOB1_subsetG_staph_LUR2)[models[[7]]$indexbestmodel], names(VGOB1_subsetG_staph_LUR2)[models[[8]]$indexbestmodel], names(VGOB1_subsetG_staph_LUR2)[models[[9]]$indexbestmodel], names(VGOB1_subsetG_staph_LUR2)[models[[10]]$indexbestmodel])
# 
# #  this is the r2 or that model
# models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2
# 
# #  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
# models[[modeln]]$bestmodel <- lm(VGOB1_subsetG_staph_LUR2$staph_copiespm3.ln.diffmeth.mean~                                VGOB1_subsetG_staph_LUR2[,models[[1]]$indexbestmodel]+ VGOB1_subsetG_staph_LUR2[,models[[2]]$indexbestmodel]+                           VGOB1_subsetG_staph_LUR2[,models[[3]]$indexbestmodel]+ VGOB1_subsetG_staph_LUR2[,models[[4]]$indexbestmodel]+ VGOB1_subsetG_staph_LUR2[,models[[5]]$indexbestmodel]+ VGOB1_subsetG_staph_LUR2[,models[[6]]$indexbestmodel]+ VGOB1_subsetG_staph_LUR2[,models[[7]]$indexbestmodel]+ VGOB1_subsetG_staph_LUR2[,models[[8]]$indexbestmodel]+ VGOB1_subsetG_staph_LUR2[,models[[9]]$indexbestmodel]+ VGOB1_subsetG_staph_LUR2[,models[[10]]$indexbestmodel]) 
# 
# models[[1]]$summarybestmodel
# models[[2]]$summarybestmodel
# models[[3]]$summarybestmodel
# models[[4]]$summarybestmodel
# models[[5]]$summarybestmodel
# models[[6]]$summarybestmodel
# models[[7]]$summarybestmodel
# models[[8]]$summarybestmodel
# models[[9]]$summarybestmodel
# models[[10]]$summarybestmodel
# models[[1]]$namesbestmodel
# models[[2]]$namesbestmodel
# models[[3]]$namesbestmodel
# models[[4]]$namesbestmodel
# models[[5]]$namesbestmodel
# models[[6]]$namesbestmodel
# models[[7]]$namesbestmodel
# models[[8]]$namesbestmodel
# models[[9]]$namesbestmodel
# models[[10]]$namesbestmodel
# models[[1]]$R2bestmodel
# models[[2]]$R2bestmodel
# models[[3]]$R2bestmodel
# models[[4]]$R2bestmodel
# models[[5]]$R2bestmodel
# models[[6]]$R2bestmodel
# models[[7]]$R2bestmodel
# models[[8]]$R2bestmodel
# models[[9]]$R2bestmodel
# models[[10]]$R2bestmodel

#   CODE FOR PICKING OUT THE BEST MODEL #   
temp <- 0
besti <- 0
for (i in 1:10){ #  think this runs the loop 10 times - not fully sure thought - but not to do with the number of models I don't think - as when I change to 3, I still get the model with 4 variables as best model
  print(models[[i]]$R2bestmodel)
  #       print(models[[i]]$summarybestmodel$coefficients=-1,4])
  #       if((models[[i]]$R2bestmodel-temp > 0.0) && (all(models[[i]]$summarybestmodel$coefficients[-1,4]<0.1))){
  #         temp <- models[[i]]$R2bestmodel
  #         besti <- i
  #         }
  if((models[[i]]$R2bestmodel-temp > 0.0) && (all(models[[i]]$summarybestmodel$coefficients[-1,4]<0.1))){
    temp <- models[[i]]$R2bestmodel
    besti <- i
  }else{
    finalBestModel_staph_LUR2_subsetG <- models[[besti]]$bestmodel
    finalBestModelNames_staph_subsetG <- models[[besti]]$namesbestmodel
    Sites <- 1:dim(VGOB1_subsetG_staph_LUR2)[1] # full original model
    #  CVaR2<-escCV_staph_LUR2(Sites)[2] # Cross Validation
    maxCD<-max(cooks.distance(finalBestModel_staph_LUR2_subsetG))
    if(length(finalBestModelNames_staph_subsetG)<2){ # vif fn doesnot work when only 1 variable...       # 
      maxVIF<-"NA"
    }else{
      maxVIF<-max(vif(finalBestModel_staph_LUR2_subsetG))
    }
    print(paste("This is the best staph model for subset G: ",besti,
                "(AdjR2: ",format(models[[besti]]$R2bestmodel,digits=3), "; MaxCD: ",format(maxCD,digits=3),"; MaxVIF: ",
                format(maxVIF,digits=3),")", sep=''))
    print(finalBestModelNames_staph_subsetG)
    break
  }
}

#  Overview of the final best model using the algorithm selection process (taking into account VIF, R^2, and p-values)
finalBestModel_staph_LUR2_subsetG
finalBestModelNames_staph_subsetG
models[[besti]]$summarybestmodel
models[[besti]]$R2bestmodel

#### H ####
# LUR model building process for subset H
#  This is the dataframe with the relevant predictor vars for LUR2 models for subset H (55 sites)
VGOB1_subsetH_staph_LUR2 # n.b. this dataframe only includes microbial marker concentrations for staph unlike the dataframe Measurements_livestockpreds_LUR2 as previously used for the model building. 

#  Now set the values of some variables that will be needed
nfirstvar_LUR_2 <- 3  
nlastvar_LUR_2 <- 71

# Function building to run the models 
# 1 #  

models<-list()
modeln<-1
models[[modeln]]<-list()

R2<-1
betaaddedvar<-1
addedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_2:nlastvar_LUR_2){
  if (is.numeric(VGOB1_subsetH_staph_LUR2[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetH_staph_LUR2$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetH_staph_LUR2[,i])                            
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    #  Measurements_livestockpreds_LUR2[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR2)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetH_staph_LUR2)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)
models[[modeln]]$results

#  this are the candidates models with the highest R2, not a negative beta for the new, nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)
models[[modeln]]$resultspos

#  rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))
models[[modeln]]$resultspos

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j
models[[modeln]]$indexbestmodel

subset(models[[modeln]]$resultspos, rank==1)
subset(models[[modeln]]$resultspos)

#  this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]
models[[modeln]]$summarybestmodel

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetH_staph_LUR2)[models[[1]]$indexbestmodel])
models[[modeln]]$namesbestmodel

#  this is the r2 of that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2
models[[modeln]]$R2bestmodel

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetH_staph_LUR2$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetH_staph_LUR2[,models[[1]]$indexbestmodel]) 
models[[modeln]]$bestmodel

summary(models[[modeln]]$bestmodel)

#  The first model includes the predictor: nPigMultipFarmWghtDist.3000m.sum.Tr.1P9 - meaning the number of multiplier pig farms weighted to distance in a 3000m buffer

# 2 #  
# Add 2nd variable (the only difference of the above part is that now modeln=2 the model statement has 2 variables)
# and the call for the list of variable names in the model changed slightly

modeln<-2

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_2:nlastvar_LUR_2){
  if (is.numeric(VGOB1_subsetH_staph_LUR2[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetH_staph_LUR2$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetH_staph_LUR2[,models[[1]]$indexbestmodel]+ VGOB1_subsetH_staph_LUR2[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # Measurements_livestockpreds_LUR2[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR2)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetH_staph_LUR2)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  these are the candidate models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)
models[[modeln]]$resultspos

#  rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))
models[[modeln]]$resultspos

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j
models[[modeln]]$indexbestmodel

subset(models[[modeln]]$resultspos, rank==1)

# this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]
models[[modeln]]$summarybestmodel

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetH_staph_LUR2)[models[[1]]$indexbestmodel], names(VGOB1_subsetH_staph_LUR2)[models[[2]]$indexbestmodel] )
models[[modeln]]$namesbestmodel

# this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2
models[[modeln]]$R2bestmodel

# this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetH_staph_LUR2$staph_copiespm3.ln.diffmeth.mean~                               VGOB1_subsetH_staph_LUR2[,models[[1]]$indexbestmodel]+                           VGOB1_subsetH_staph_LUR2[,models[[2]]$indexbestmodel]) 

models[[modeln]]$bestmodel

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel


# 3 #  
# add third variable (the only difference of the above part is that now modeln=3 the model statement has 3 variables)
# and the call for the list of variable names in the model changed slightly

modeln<-3

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_2:nlastvar_LUR_2){
  if (is.numeric(VGOB1_subsetH_staph_LUR2[,i])==TRUE){  
    modeltry<-lm(VGOB1_subsetH_staph_LUR2$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetH_staph_LUR2[,models[[1]]$indexbestmodel]+VGOB1_subsetH_staph_LUR2[,models[[2]]$indexbestmodel]+ VGOB1_subsetH_staph_LUR2[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # All[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR2)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetH_staph_LUR2)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

#  rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

#  this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

#  here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetH_staph_LUR2)[models[[1]]$indexbestmodel], names(VGOB1_subsetH_staph_LUR2)[models[[2]]$indexbestmodel], names(VGOB1_subsetH_staph_LUR2)[models[[3]]$indexbestmodel])

#  this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetH_staph_LUR2$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetH_staph_LUR2[,models[[1]]$indexbestmodel]+ VGOB1_subsetH_staph_LUR2[,models[[2]]$indexbestmodel]+ VGOB1_subsetH_staph_LUR2[,models[[3]]$indexbestmodel]) 

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel


# 4 #  
#  add forth variable (the only difference of the above part is that now model n=4 the model statement more variables)
#  and the call for the list of variable names in the model changed slightly
modeln<-4

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1


for (i in nfirstvar_LUR_2:nlastvar_LUR_2){
  if (is.numeric(VGOB1_subsetH_staph_LUR2[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetH_staph_LUR2$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetH_staph_LUR2[,models[[1]]$indexbestmodel]+VGOB1_subsetH_staph_LUR2[,models[[2]]$indexbestmodel]+VGOB1_subsetH_staph_LUR2[,models[[3]]$indexbestmodel]+VGOB1_subsetH_staph_LUR2[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    #  the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    #  All[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR2)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetH_staph_LUR2)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

#  this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

#  here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetH_staph_LUR2)[models[[1]]$indexbestmodel], names(VGOB1_subsetH_staph_LUR2)[models[[2]]$indexbestmodel], names(VGOB1_subsetH_staph_LUR2)[models[[3]]$indexbestmodel], names(VGOB1_subsetH_staph_LUR2)[models[[4]]$indexbestmodel])

#  this is the r2 of that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetH_staph_LUR2$staph_copiespm3.ln.diffmeth.mean~ VGOB1_subsetH_staph_LUR2[,models[[1]]$indexbestmodel]+ VGOB1_subsetH_staph_LUR2[,models[[2]]$indexbestmodel]+VGOB1_subsetH_staph_LUR2[,models[[3]]$indexbestmodel]+ VGOB1_subsetH_staph_LUR2[,models[[4]]$indexbestmodel]) 


models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel


# 5 #  
# add fifth variable (the only difference of the above part is that now modeln=5 the model statement more variables)
# and the call for the list of variable names in the model changed slightly
modeln<-5

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_2:nlastvar_LUR_2){
  if (is.numeric(VGOB1_subsetH_staph_LUR2[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetH_staph_LUR2$staph_copiespm3.ln.diffmeth.mean~ VGOB1_subsetH_staph_LUR2[,models[[1]]$indexbestmodel]+ VGOB1_subsetH_staph_LUR2[,models[[2]]$indexbestmodel]+ VGOB1_subsetH_staph_LUR2[,models[[3]]$indexbestmodel]+ VGOB1_subsetH_staph_LUR2[,models[[4]]$indexbestmodel]+ VGOB1_subsetH_staph_LUR2[,i]) 
  
R2<-rbind(R2,summary(modeltry)$adj.r.squared)
# the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # All[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR2)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetH_staph_LUR2)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

#  this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetH_staph_LUR2)[models[[1]]$indexbestmodel], names(VGOB1_subsetH_staph_LUR2)[models[[2]]$indexbestmodel], names(VGOB1_subsetH_staph_LUR2)[models[[3]]$indexbestmodel], names(VGOB1_subsetH_staph_LUR2)[models[[4]]$indexbestmodel], names(VGOB1_subsetH_staph_LUR2)[models[[5]]$indexbestmodel])

#  this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetH_staph_LUR2$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetH_staph_LUR2[,models[[1]]$indexbestmodel]+VGOB1_subsetH_staph_LUR2[,models[[2]]$indexbestmodel]+VGOB1_subsetH_staph_LUR2[,models[[3]]$indexbestmodel]+ VGOB1_subsetH_staph_LUR2[,models[[4]]$indexbestmodel]+ VGOB1_subsetH_staph_LUR2[,models[[5]]$indexbestmodel]) 
models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[5]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[5]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel
models[[5]]$R2bestmodel

# 6 #  
# add sixth variable (the only difference of the above part is that now model n=6 the model statement more variables)
#  and the call for the list of variable names in the model changed slightly

modeln<-6

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_2 :nlastvar_LUR_2){
  if (is.numeric(VGOB1_subsetH_staph_LUR2[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetH_staph_LUR2$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetH_staph_LUR2[,models[[1]]$indexbestmodel]+VGOB1_subsetH_staph_LUR2[,models[[2]]$indexbestmodel]+VGOB1_subsetH_staph_LUR2[,models[[3]]$indexbestmodel]+VGOB1_subsetH_staph_LUR2[,models[[4]]$indexbestmodel]+VGOB1_subsetH_staph_LUR2[,models[[5]]$indexbestmodel]+ VGOB1_subsetH_staph_LUR2[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # All[,i] is the row that's being tried out now. the name of that row can be found in  names(All)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetH_staph_LUR2)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

# this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetH_staph_LUR2)[models[[1]]$indexbestmodel], names(VGOB1_subsetH_staph_LUR2)[models[[2]]$indexbestmodel] , names(VGOB1_subsetH_staph_LUR2)[models[[3]]$indexbestmodel], names(VGOB1_subsetH_staph_LUR2)[models[[4]]$indexbestmodel], names(VGOB1_subsetH_staph_LUR2)[models[[5]]$indexbestmodel], names(VGOB1_subsetH_staph_LUR2)[models[[6]]$indexbestmodel])

#  this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetH_staph_LUR2$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetH_staph_LUR2[,models[[1]]$indexbestmodel]+VGOB1_subsetH_staph_LUR2[,models[[2]]$indexbestmodel]+VGOB1_subsetH_staph_LUR2[,models[[3]]$indexbestmodel]+ VGOB1_subsetH_staph_LUR2[,models[[4]]$indexbestmodel]+ VGOB1_subsetH_staph_LUR2[,models[[5]]$indexbestmodel]+ VGOB1_subsetH_staph_LUR2[,models[[6]]$indexbestmodel]) 

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[5]]$summarybestmodel
models[[6]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[5]]$namesbestmodel
models[[6]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel
models[[5]]$R2bestmodel
models[[6]]$R2bestmodel


# 7 #  
# add seventh variable (the only difference of the above part is that now model n=7 the model statement more variables)
#  and the call for the list of variable names in the model changed slightly

modeln<-7

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_2 :nlastvar_LUR_2){
  if (is.numeric(VGOB1_subsetH_staph_LUR2[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetH_staph_LUR2$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetH_staph_LUR2[,models[[1]]$indexbestmodel]+VGOB1_subsetH_staph_LUR2[,models[[2]]$indexbestmodel]+VGOB1_subsetH_staph_LUR2[,models[[3]]$indexbestmodel]+VGOB1_subsetH_staph_LUR2[,models[[4]]$indexbestmodel]+VGOB1_subsetH_staph_LUR2[,models[[5]]$indexbestmodel]+VGOB1_subsetH_staph_LUR2[,models[[6]]$indexbestmodel]+ VGOB1_subsetH_staph_LUR2[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # Measurements_livestockpreds_LUR2[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR2)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetH_staph_LUR2)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

# this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetH_staph_LUR2)[models[[1]]$indexbestmodel], names(VGOB1_subsetH_staph_LUR2)[models[[2]]$indexbestmodel] , names(VGOB1_subsetH_staph_LUR2)[models[[3]]$indexbestmodel], names(VGOB1_subsetH_staph_LUR2)[models[[4]]$indexbestmodel], names(VGOB1_subsetH_staph_LUR2)[models[[5]]$indexbestmodel], names(VGOB1_subsetH_staph_LUR2)[models[[6]]$indexbestmodel], names(VGOB1_subsetH_staph_LUR2)[models[[7]]$indexbestmodel])

#  this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetH_staph_LUR2$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetH_staph_LUR2[,models[[1]]$indexbestmodel]+VGOB1_subsetH_staph_LUR2[,models[[2]]$indexbestmodel]+VGOB1_subsetH_staph_LUR2[,models[[3]]$indexbestmodel]+ VGOB1_subsetH_staph_LUR2[,models[[4]]$indexbestmodel]+ VGOB1_subsetH_staph_LUR2[,models[[5]]$indexbestmodel]+ VGOB1_subsetH_staph_LUR2[,models[[6]]$indexbestmodel]+ VGOB1_subsetH_staph_LUR2[,models[[7]]$indexbestmodel]) 

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[5]]$summarybestmodel
models[[6]]$summarybestmodel
models[[7]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[5]]$namesbestmodel
models[[6]]$namesbestmodel
models[[7]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel
models[[5]]$R2bestmodel
models[[6]]$R2bestmodel
models[[7]]$R2bestmodel

# 8 #  
# add eighth variable (the only difference of the above part is that now modeln=7 the model statement more variables)
# and the call for the list of variable names in the model changed slightly

modeln<-8

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_2 :nlastvar_LUR_2){
  if (is.numeric(VGOB1_subsetH_staph_LUR2[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetH_staph_LUR2$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetH_staph_LUR2[,models[[1]]$indexbestmodel]+VGOB1_subsetH_staph_LUR2[,models[[2]]$indexbestmodel]+VGOB1_subsetH_staph_LUR2[,models[[3]]$indexbestmodel]+VGOB1_subsetH_staph_LUR2[,models[[4]]$indexbestmodel]+VGOB1_subsetH_staph_LUR2[,models[[5]]$indexbestmodel]+VGOB1_subsetH_staph_LUR2[,models[[6]]$indexbestmodel]+ VGOB1_subsetH_staph_LUR2[,models[[7]]$indexbestmodel]+ VGOB1_subsetH_staph_LUR2[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # Measurements_livestockpreds_LUR2[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR2)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetH_staph_LUR2)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

# this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetH_staph_LUR2)[models[[1]]$indexbestmodel], names(VGOB1_subsetH_staph_LUR2)[models[[2]]$indexbestmodel] , names(VGOB1_subsetH_staph_LUR2)[models[[3]]$indexbestmodel], names(VGOB1_subsetH_staph_LUR2)[models[[4]]$indexbestmodel], names(VGOB1_subsetH_staph_LUR2)[models[[5]]$indexbestmodel], names(VGOB1_subsetH_staph_LUR2)[models[[6]]$indexbestmodel], names(VGOB1_subsetH_staph_LUR2)[models[[7]]$indexbestmodel], names(VGOB1_subsetH_staph_LUR2)[models[[8]]$indexbestmodel])

#  this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetH_staph_LUR2$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetH_staph_LUR2[,models[[1]]$indexbestmodel]+VGOB1_subsetH_staph_LUR2[,models[[2]]$indexbestmodel]+VGOB1_subsetH_staph_LUR2[,models[[3]]$indexbestmodel]+ VGOB1_subsetH_staph_LUR2[,models[[4]]$indexbestmodel]+ VGOB1_subsetH_staph_LUR2[,models[[5]]$indexbestmodel]+ VGOB1_subsetH_staph_LUR2[,models[[6]]$indexbestmodel]+ VGOB1_subsetH_staph_LUR2[,models[[7]]$indexbestmodel]+ VGOB1_subsetH_staph_LUR2[,models[[8]]$indexbestmodel]) 

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[5]]$summarybestmodel
models[[6]]$summarybestmodel
models[[7]]$summarybestmodel
models[[8]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[5]]$namesbestmodel
models[[6]]$namesbestmodel
models[[7]]$namesbestmodel
models[[8]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel
models[[5]]$R2bestmodel
models[[6]]$R2bestmodel
models[[7]]$R2bestmodel
models[[8]]$R2bestmodel

# 9 #  
# add ninth variable (the only difference of the above part is that now modeln=9 the model statement more variables)
# and the call for the list of variable names in the model changed slightly

modeln<-9

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_2 :nlastvar_LUR_2){
  if (is.numeric(VGOB1_subsetH_staph_LUR2[,i])==TRUE){
      modeltry<-lm(VGOB1_subsetH_staph_LUR2$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetH_staph_LUR2[,models[[1]]$indexbestmodel]+VGOB1_subsetH_staph_LUR2[,models[[2]]$indexbestmodel]+VGOB1_subsetH_staph_LUR2[,models[[3]]$indexbestmodel]+VGOB1_subsetH_staph_LUR2[,models[[4]]$indexbestmodel]+VGOB1_subsetH_staph_LUR2[,models[[5]]$indexbestmodel]+VGOB1_subsetH_staph_LUR2[,models[[6]]$indexbestmodel]+ VGOB1_subsetH_staph_LUR2[,models[[7]]$indexbestmodel]+ VGOB1_subsetH_staph_LUR2[,models[[8]]$indexbestmodel]+ VGOB1_subsetH_staph_LUR2[,i]) 
        R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # Measurements_livestockpreds_LUR2[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR2)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetH_staph_LUR2)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

# this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetH_staph_LUR2)[models[[1]]$indexbestmodel], names(VGOB1_subsetH_staph_LUR2)[models[[2]]$indexbestmodel] , names(VGOB1_subsetH_staph_LUR2)[models[[3]]$indexbestmodel], names(VGOB1_subsetH_staph_LUR2)[models[[4]]$indexbestmodel], names(VGOB1_subsetH_staph_LUR2)[models[[5]]$indexbestmodel], names(VGOB1_subsetH_staph_LUR2)[models[[6]]$indexbestmodel], names(VGOB1_subsetH_staph_LUR2)[models[[7]]$indexbestmodel], names(VGOB1_subsetH_staph_LUR2)[models[[8]]$indexbestmodel],  names(VGOB1_subsetH_staph_LUR2)[models[[9]]$indexbestmodel])

#  this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetH_staph_LUR2$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetH_staph_LUR2[,models[[1]]$indexbestmodel]+VGOB1_subsetH_staph_LUR2[,models[[2]]$indexbestmodel]+VGOB1_subsetH_staph_LUR2[,models[[3]]$indexbestmodel]+ VGOB1_subsetH_staph_LUR2[,models[[4]]$indexbestmodel]+ VGOB1_subsetH_staph_LUR2[,models[[5]]$indexbestmodel]+ VGOB1_subsetH_staph_LUR2[,models[[6]]$indexbestmodel]+ VGOB1_subsetH_staph_LUR2[,models[[7]]$indexbestmodel]+ VGOB1_subsetH_staph_LUR2[,models[[8]]$indexbestmodel]+ VGOB1_subsetH_staph_LUR2[,models[[9]]$indexbestmodel]) 

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[5]]$summarybestmodel
models[[6]]$summarybestmodel
models[[7]]$summarybestmodel
models[[8]]$summarybestmodel
models[[9]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[5]]$namesbestmodel
models[[6]]$namesbestmodel
models[[7]]$namesbestmodel
models[[8]]$namesbestmodel
models[[9]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel
models[[5]]$R2bestmodel
models[[6]]$R2bestmodel
models[[7]]$R2bestmodel
models[[8]]$R2bestmodel
models[[9]]$R2bestmodel

# The next part of the code (n=10) does not work
# This is because one of the coefficients included in the model with 6 variables is negative, the code does not allow for this. I can stop here. 

# # 10 #  
# #  add tenth variable (the only difference of the above part is that now model n=10 the model statement more variables)
# #  and the call for the list of variable names in the model changed slightly
# 
# modeln<-10
# 
# models[[modeln]]<-list()
# 
# R2<-1
# addedvar<-1
# betaaddedvar<-1
# minbetas<-1
# j<-1
# 
# for (i in nfirstvar_LUR_2 :nlastvar_LUR_2){if (is.numeric(VGOB1_subsetH_staph_LUR2[,i])==TRUE){ modeltry<-lm(VGOB1_subsetH_staph_LUR2$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetH_staph_LUR2[,models[[1]]$indexbestmodel]+VGOB1_subsetH_staph_LUR2[,models[[2]]$indexbestmodel]+ VGOB1_subsetH_staph_LUR2[,models[[3]]$indexbestmodel]+VGOB1_subsetH_staph_LUR2[,models[[4]]$indexbestmodel]+ VGOB1_subsetH_staph_LUR2[,models[[5]]$indexbestmodel]+ VGOB1_subsetH_staph_LUR2[,models[[6]]$indexbestmodel]+ VGOB1_subsetH_staph_LUR2[,models[[7]]$indexbestmodel]+ VGOB1_subsetH_staph_LUR2[,models[[8]]$indexbestmodel]+ VGOB1_subsetH_staph_LUR2[,models[[9]]$indexbestmodel]+ VGOB1_subsetH_staph_LUR2[,i]) 
# 
# R2<-rbind(R2,summary(modeltry)$adj.r.squared)
# # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
#     betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
#     #  find out if there is a negative beta at All. The intercept does not count [-1]!
#     minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
#     # Measurements_livestockpreds_LUR2[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR2)[i]
#     addedvar<-rbind(addedvar,names(VGOB1_subsetH_staph_LUR2)[i])
#     j<-rbind(j, i)
#     models[[modeln]][[i]]<-summary(modeltry)
#   }
# }
# 
# models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)
# 
# #  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
# models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)
# 
# # rank the R2's of these models
# models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))
# 
# #  this is the index of the row with the highest R2 and  no negative betas in this subset
# models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j
# 
# subset(models[[modeln]]$resultspos, rank==1)
# 
# # this is the model
# models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]
# 
# # here are the names
# models[[modeln]]$namesbestmodel<-c( names(VGOB1_subsetH_staph_LUR2)[models[[1]]$indexbestmodel],                   names(VGOB1_subsetH_staph_LUR2)[models[[2]]$indexbestmodel] , names(VGOB1_subsetH_staph_LUR2)[models[[3]]$indexbestmodel], names(VGOB1_subsetH_staph_LUR2)[models[[4]]$indexbestmodel], names(VGOB1_subsetH_staph_LUR2)[models[[5]]$indexbestmodel], names(VGOB1_subsetH_staph_LUR2)[models[[6]]$indexbestmodel], names(VGOB1_subsetH_staph_LUR2)[models[[7]]$indexbestmodel], names(VGOB1_subsetH_staph_LUR2)[models[[8]]$indexbestmodel], names(VGOB1_subsetH_staph_LUR2)[models[[9]]$indexbestmodel], names(VGOB1_subsetH_staph_LUR2)[models[[10]]$indexbestmodel])
# 
# #  this is the r2 or that model
# models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2
# 
# #  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
# models[[modeln]]$bestmodel <- lm(VGOB1_subsetH_staph_LUR2$staph_copiespm3.ln.diffmeth.mean~                                VGOB1_subsetH_staph_LUR2[,models[[1]]$indexbestmodel]+ VGOB1_subsetH_staph_LUR2[,models[[2]]$indexbestmodel]+                           VGOB1_subsetH_staph_LUR2[,models[[3]]$indexbestmodel]+ VGOB1_subsetH_staph_LUR2[,models[[4]]$indexbestmodel]+ VGOB1_subsetH_staph_LUR2[,models[[5]]$indexbestmodel]+ VGOB1_subsetH_staph_LUR2[,models[[6]]$indexbestmodel]+ VGOB1_subsetH_staph_LUR2[,models[[7]]$indexbestmodel]+ VGOB1_subsetH_staph_LUR2[,models[[8]]$indexbestmodel]+ VGOB1_subsetH_staph_LUR2[,models[[9]]$indexbestmodel]+ VGOB1_subsetH_staph_LUR2[,models[[10]]$indexbestmodel]) 
# 
# models[[1]]$summarybestmodel
# models[[2]]$summarybestmodel
# models[[3]]$summarybestmodel
# models[[4]]$summarybestmodel
# models[[5]]$summarybestmodel
# models[[6]]$summarybestmodel
# models[[7]]$summarybestmodel
# models[[8]]$summarybestmodel
# models[[9]]$summarybestmodel
# models[[10]]$summarybestmodel
# models[[1]]$namesbestmodel
# models[[2]]$namesbestmodel
# models[[3]]$namesbestmodel
# models[[4]]$namesbestmodel
# models[[5]]$namesbestmodel
# models[[6]]$namesbestmodel
# models[[7]]$namesbestmodel
# models[[8]]$namesbestmodel
# models[[9]]$namesbestmodel
# models[[10]]$namesbestmodel
# models[[1]]$R2bestmodel
# models[[2]]$R2bestmodel
# models[[3]]$R2bestmodel
# models[[4]]$R2bestmodel
# models[[5]]$R2bestmodel
# models[[6]]$R2bestmodel
# models[[7]]$R2bestmodel
# models[[8]]$R2bestmodel
# models[[9]]$R2bestmodel
# models[[10]]$R2bestmodel

#   CODE FOR PICKING OUT THE BEST MODEL #   
temp <- 0
besti <- 0
for (i in 1:10){ #  think this runs the loop 10 times - not fully sure thought - but not to do with the number of models I don't think - as when I change to 3, I still get the model with 4 variables as best model
  print(models[[i]]$R2bestmodel)
  #       print(models[[i]]$summarybestmodel$coefficients=-1,4])
  #       if((models[[i]]$R2bestmodel-temp > 0.0) && (all(models[[i]]$summarybestmodel$coefficients[-1,4]<0.1))){
  #         temp <- models[[i]]$R2bestmodel
  #         besti <- i
  #         }
  if((models[[i]]$R2bestmodel-temp > 0.0) && (all(models[[i]]$summarybestmodel$coefficients[-1,4]<0.1))){
    temp <- models[[i]]$R2bestmodel
    besti <- i
  }else{
    finalBestModel_staph_LUR2_subsetH <- models[[besti]]$bestmodel
    finalBestModelNames_staph_subsetH <- models[[besti]]$namesbestmodel
    Sites <- 1:dim(VGOB1_subsetH_staph_LUR2)[1] # full original model
    #  CVaR2<-escCV_staph_LUR2(Sites)[2] # Cross Validation
    maxCD<-max(cooks.distance(finalBestModel_staph_LUR2_subsetH))
    if(length(finalBestModelNames_staph_subsetH)<2){ # vif fn doesnot work when only 1 variable...       # 
      maxVIF<-"NA"
    }else{
      maxVIF<-max(vif(finalBestModel_staph_LUR2_subsetH))
    }
    print(paste("This is the best staph model for subset H: ",besti,
                "(AdjR2: ",format(models[[besti]]$R2bestmodel,digits=3), "; MaxCD: ",format(maxCD,digits=3),"; MaxVIF: ",
                format(maxVIF,digits=3),")", sep=''))
    print(finalBestModelNames_staph_subsetH)
    break
  }
}

#  Overview of the final best model using the algorithm selection process (taking into account VIF, R^2, and p-values)
finalBestModel_staph_LUR2_subsetH
finalBestModelNames_staph_subsetH
models[[besti]]$summarybestmodel
models[[besti]]$R2bestmodel


#### I ####
# LUR model building process for subset I
#  This is the dataframe with the relevant predictor vars for LUR2 models for subset I (55 sites)
VGOB1_subsetI_staph_LUR2 # n.b. this dataframe only includes microbial marker concentrations for staph unlike the dataframe Measurements_livestockpreds_LUR2 as previously used for the model building. 

#  Now set the values of some variables that will be needed
nfirstvar_LUR_2 <- 3  
nlastvar_LUR_2 <- 71

# Function building to run the models 
# 1 #  

models<-list()
modeln<-1
models[[modeln]]<-list()

R2<-1
betaaddedvar<-1
addedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_2:nlastvar_LUR_2){
  if (is.numeric(VGOB1_subsetI_staph_LUR2[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetI_staph_LUR2$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetI_staph_LUR2[,i])                            
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    #  Measurements_livestockpreds_LUR2[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR2)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetI_staph_LUR2)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)
models[[modeln]]$results

#  this are the candidates models with the highest R2, not a negative beta for the new, nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)
models[[modeln]]$resultspos

#  rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))
models[[modeln]]$resultspos

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j
models[[modeln]]$indexbestmodel

subset(models[[modeln]]$resultspos, rank==1)
subset(models[[modeln]]$resultspos)

#  this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]
models[[modeln]]$summarybestmodel

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetI_staph_LUR2)[models[[1]]$indexbestmodel])
models[[modeln]]$namesbestmodel

#  this is the r2 of that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2
models[[modeln]]$R2bestmodel

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetI_staph_LUR2$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetI_staph_LUR2[,models[[1]]$indexbestmodel]) 
models[[modeln]]$bestmodel

summary(models[[modeln]]$bestmodel)

#  The first model includes the predictor: nPigMultipFarmWghtDist.3000m.sum.Tr.1P9 - meaning the number of multiplier pig farms weighted to distance in a 3000m buffer

# 2 #  
# Add 2nd variable (the only difference of the above part is that now modeln=2 the model statement has 2 variables)
# and the call for the list of variable names in the model changed slightly

modeln<-2

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_2:nlastvar_LUR_2){
  if (is.numeric(VGOB1_subsetI_staph_LUR2[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetI_staph_LUR2$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetI_staph_LUR2[,models[[1]]$indexbestmodel]+ VGOB1_subsetI_staph_LUR2[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # Measurements_livestockpreds_LUR2[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR2)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetI_staph_LUR2)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  these are the candidate models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)
models[[modeln]]$resultspos

#  rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))
models[[modeln]]$resultspos

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j
models[[modeln]]$indexbestmodel

subset(models[[modeln]]$resultspos, rank==1)

# this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]
models[[modeln]]$summarybestmodel

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetI_staph_LUR2)[models[[1]]$indexbestmodel], names(VGOB1_subsetI_staph_LUR2)[models[[2]]$indexbestmodel] )
models[[modeln]]$namesbestmodel

# this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2
models[[modeln]]$R2bestmodel

# this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetI_staph_LUR2$staph_copiespm3.ln.diffmeth.mean~                               VGOB1_subsetI_staph_LUR2[,models[[1]]$indexbestmodel]+                           VGOB1_subsetI_staph_LUR2[,models[[2]]$indexbestmodel]) 

models[[modeln]]$bestmodel

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel


# 3 #  
# add third variable (the only difference of the above part is that now modeln=3 the model statement has 3 variables)
# and the call for the list of variable names in the model changed slightly

modeln<-3

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_2:nlastvar_LUR_2){
  if (is.numeric(VGOB1_subsetI_staph_LUR2[,i])==TRUE){  
    modeltry<-lm(VGOB1_subsetI_staph_LUR2$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetI_staph_LUR2[,models[[1]]$indexbestmodel]+VGOB1_subsetI_staph_LUR2[,models[[2]]$indexbestmodel]+ VGOB1_subsetI_staph_LUR2[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # All[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR2)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetI_staph_LUR2)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

#  rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

#  this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

#  here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetI_staph_LUR2)[models[[1]]$indexbestmodel], names(VGOB1_subsetI_staph_LUR2)[models[[2]]$indexbestmodel], names(VGOB1_subsetI_staph_LUR2)[models[[3]]$indexbestmodel])

#  this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetI_staph_LUR2$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetI_staph_LUR2[,models[[1]]$indexbestmodel]+ VGOB1_subsetI_staph_LUR2[,models[[2]]$indexbestmodel]+ VGOB1_subsetI_staph_LUR2[,models[[3]]$indexbestmodel]) 

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel


# 4 #  
#  add forth variable (the only difference of the above part is that now model n=4 the model statement more variables)
#  and the call for the list of variable names in the model changed slightly
modeln<-4

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1


for (i in nfirstvar_LUR_2:nlastvar_LUR_2){
  if (is.numeric(VGOB1_subsetI_staph_LUR2[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetI_staph_LUR2$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetI_staph_LUR2[,models[[1]]$indexbestmodel]+VGOB1_subsetI_staph_LUR2[,models[[2]]$indexbestmodel]+VGOB1_subsetI_staph_LUR2[,models[[3]]$indexbestmodel]+VGOB1_subsetI_staph_LUR2[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    #  the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    #  All[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR2)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetI_staph_LUR2)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

#  this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

#  here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetI_staph_LUR2)[models[[1]]$indexbestmodel], names(VGOB1_subsetI_staph_LUR2)[models[[2]]$indexbestmodel], names(VGOB1_subsetI_staph_LUR2)[models[[3]]$indexbestmodel], names(VGOB1_subsetI_staph_LUR2)[models[[4]]$indexbestmodel])

#  this is the r2 of that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetI_staph_LUR2$staph_copiespm3.ln.diffmeth.mean~ VGOB1_subsetI_staph_LUR2[,models[[1]]$indexbestmodel]+ VGOB1_subsetI_staph_LUR2[,models[[2]]$indexbestmodel]+VGOB1_subsetI_staph_LUR2[,models[[3]]$indexbestmodel]+ VGOB1_subsetI_staph_LUR2[,models[[4]]$indexbestmodel]) 


models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel


# 5 #  
# add fifth variable (the only difference of the above part is that now modeln=5 the model statement more variables)
# and the call for the list of variable names in the model changed slightly
modeln<-5

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_2:nlastvar_LUR_2){
  if (is.numeric(VGOB1_subsetI_staph_LUR2[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetI_staph_LUR2$staph_copiespm3.ln.diffmeth.mean~ VGOB1_subsetI_staph_LUR2[,models[[1]]$indexbestmodel]+ VGOB1_subsetI_staph_LUR2[,models[[2]]$indexbestmodel]+ VGOB1_subsetI_staph_LUR2[,models[[3]]$indexbestmodel]+ VGOB1_subsetI_staph_LUR2[,models[[4]]$indexbestmodel]+ VGOB1_subsetI_staph_LUR2[,i]) 
  
R2<-rbind(R2,summary(modeltry)$adj.r.squared)
# the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # All[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR2)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetI_staph_LUR2)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

#  this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetI_staph_LUR2)[models[[1]]$indexbestmodel], names(VGOB1_subsetI_staph_LUR2)[models[[2]]$indexbestmodel], names(VGOB1_subsetI_staph_LUR2)[models[[3]]$indexbestmodel], names(VGOB1_subsetI_staph_LUR2)[models[[4]]$indexbestmodel], names(VGOB1_subsetI_staph_LUR2)[models[[5]]$indexbestmodel])

#  this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetI_staph_LUR2$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetI_staph_LUR2[,models[[1]]$indexbestmodel]+VGOB1_subsetI_staph_LUR2[,models[[2]]$indexbestmodel]+VGOB1_subsetI_staph_LUR2[,models[[3]]$indexbestmodel]+ VGOB1_subsetI_staph_LUR2[,models[[4]]$indexbestmodel]+ VGOB1_subsetI_staph_LUR2[,models[[5]]$indexbestmodel]) 
models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[5]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[5]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel
models[[5]]$R2bestmodel

# 6 #  
# add sixth variable (the only difference of the above part is that now model n=6 the model statement more variables)
#  and the call for the list of variable names in the model changed slightly

modeln<-6

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_2 :nlastvar_LUR_2){
  if (is.numeric(VGOB1_subsetI_staph_LUR2[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetI_staph_LUR2$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetI_staph_LUR2[,models[[1]]$indexbestmodel]+VGOB1_subsetI_staph_LUR2[,models[[2]]$indexbestmodel]+VGOB1_subsetI_staph_LUR2[,models[[3]]$indexbestmodel]+VGOB1_subsetI_staph_LUR2[,models[[4]]$indexbestmodel]+VGOB1_subsetI_staph_LUR2[,models[[5]]$indexbestmodel]+ VGOB1_subsetI_staph_LUR2[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # All[,i] is the row that's being tried out now. the name of that row can be found in  names(All)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetI_staph_LUR2)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

# this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetI_staph_LUR2)[models[[1]]$indexbestmodel], names(VGOB1_subsetI_staph_LUR2)[models[[2]]$indexbestmodel] , names(VGOB1_subsetI_staph_LUR2)[models[[3]]$indexbestmodel], names(VGOB1_subsetI_staph_LUR2)[models[[4]]$indexbestmodel], names(VGOB1_subsetI_staph_LUR2)[models[[5]]$indexbestmodel], names(VGOB1_subsetI_staph_LUR2)[models[[6]]$indexbestmodel])

#  this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetI_staph_LUR2$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetI_staph_LUR2[,models[[1]]$indexbestmodel]+VGOB1_subsetI_staph_LUR2[,models[[2]]$indexbestmodel]+VGOB1_subsetI_staph_LUR2[,models[[3]]$indexbestmodel]+ VGOB1_subsetI_staph_LUR2[,models[[4]]$indexbestmodel]+ VGOB1_subsetI_staph_LUR2[,models[[5]]$indexbestmodel]+ VGOB1_subsetI_staph_LUR2[,models[[6]]$indexbestmodel]) 

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[5]]$summarybestmodel
models[[6]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[5]]$namesbestmodel
models[[6]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel
models[[5]]$R2bestmodel
models[[6]]$R2bestmodel


# 7 #  
# add seventh variable (the only difference of the above part is that now model n=7 the model statement more variables)
#  and the call for the list of variable names in the model changed slightly

modeln<-7

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_2 :nlastvar_LUR_2){
  if (is.numeric(VGOB1_subsetI_staph_LUR2[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetI_staph_LUR2$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetI_staph_LUR2[,models[[1]]$indexbestmodel]+VGOB1_subsetI_staph_LUR2[,models[[2]]$indexbestmodel]+VGOB1_subsetI_staph_LUR2[,models[[3]]$indexbestmodel]+VGOB1_subsetI_staph_LUR2[,models[[4]]$indexbestmodel]+VGOB1_subsetI_staph_LUR2[,models[[5]]$indexbestmodel]+VGOB1_subsetI_staph_LUR2[,models[[6]]$indexbestmodel]+ VGOB1_subsetI_staph_LUR2[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # Measurements_livestockpreds_LUR2[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR2)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetI_staph_LUR2)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

# this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetI_staph_LUR2)[models[[1]]$indexbestmodel], names(VGOB1_subsetI_staph_LUR2)[models[[2]]$indexbestmodel] , names(VGOB1_subsetI_staph_LUR2)[models[[3]]$indexbestmodel], names(VGOB1_subsetI_staph_LUR2)[models[[4]]$indexbestmodel], names(VGOB1_subsetI_staph_LUR2)[models[[5]]$indexbestmodel], names(VGOB1_subsetI_staph_LUR2)[models[[6]]$indexbestmodel], names(VGOB1_subsetI_staph_LUR2)[models[[7]]$indexbestmodel])

#  this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetI_staph_LUR2$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetI_staph_LUR2[,models[[1]]$indexbestmodel]+VGOB1_subsetI_staph_LUR2[,models[[2]]$indexbestmodel]+VGOB1_subsetI_staph_LUR2[,models[[3]]$indexbestmodel]+ VGOB1_subsetI_staph_LUR2[,models[[4]]$indexbestmodel]+ VGOB1_subsetI_staph_LUR2[,models[[5]]$indexbestmodel]+ VGOB1_subsetI_staph_LUR2[,models[[6]]$indexbestmodel]+ VGOB1_subsetI_staph_LUR2[,models[[7]]$indexbestmodel]) 

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[5]]$summarybestmodel
models[[6]]$summarybestmodel
models[[7]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[5]]$namesbestmodel
models[[6]]$namesbestmodel
models[[7]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel
models[[5]]$R2bestmodel
models[[6]]$R2bestmodel
models[[7]]$R2bestmodel

# 8 #  
# add eighth variable (the only difference of the above part is that now modeln=7 the model statement more variables)
# and the call for the list of variable names in the model changed slightly

modeln<-8

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_2 :nlastvar_LUR_2){
  if (is.numeric(VGOB1_subsetI_staph_LUR2[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetI_staph_LUR2$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetI_staph_LUR2[,models[[1]]$indexbestmodel]+VGOB1_subsetI_staph_LUR2[,models[[2]]$indexbestmodel]+VGOB1_subsetI_staph_LUR2[,models[[3]]$indexbestmodel]+VGOB1_subsetI_staph_LUR2[,models[[4]]$indexbestmodel]+VGOB1_subsetI_staph_LUR2[,models[[5]]$indexbestmodel]+VGOB1_subsetI_staph_LUR2[,models[[6]]$indexbestmodel]+ VGOB1_subsetI_staph_LUR2[,models[[7]]$indexbestmodel]+ VGOB1_subsetI_staph_LUR2[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # Measurements_livestockpreds_LUR2[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR2)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetI_staph_LUR2)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

# this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetI_staph_LUR2)[models[[1]]$indexbestmodel], names(VGOB1_subsetI_staph_LUR2)[models[[2]]$indexbestmodel] , names(VGOB1_subsetI_staph_LUR2)[models[[3]]$indexbestmodel], names(VGOB1_subsetI_staph_LUR2)[models[[4]]$indexbestmodel], names(VGOB1_subsetI_staph_LUR2)[models[[5]]$indexbestmodel], names(VGOB1_subsetI_staph_LUR2)[models[[6]]$indexbestmodel], names(VGOB1_subsetI_staph_LUR2)[models[[7]]$indexbestmodel], names(VGOB1_subsetI_staph_LUR2)[models[[8]]$indexbestmodel])

#  this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetI_staph_LUR2$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetI_staph_LUR2[,models[[1]]$indexbestmodel]+VGOB1_subsetI_staph_LUR2[,models[[2]]$indexbestmodel]+VGOB1_subsetI_staph_LUR2[,models[[3]]$indexbestmodel]+ VGOB1_subsetI_staph_LUR2[,models[[4]]$indexbestmodel]+ VGOB1_subsetI_staph_LUR2[,models[[5]]$indexbestmodel]+ VGOB1_subsetI_staph_LUR2[,models[[6]]$indexbestmodel]+ VGOB1_subsetI_staph_LUR2[,models[[7]]$indexbestmodel]+ VGOB1_subsetI_staph_LUR2[,models[[8]]$indexbestmodel]) 

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[5]]$summarybestmodel
models[[6]]$summarybestmodel
models[[7]]$summarybestmodel
models[[8]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[5]]$namesbestmodel
models[[6]]$namesbestmodel
models[[7]]$namesbestmodel
models[[8]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel
models[[5]]$R2bestmodel
models[[6]]$R2bestmodel
models[[7]]$R2bestmodel
models[[8]]$R2bestmodel

# 9 #  
# add ninth variable (the only difference of the above part is that now modeln=9 the model statement more variables)
# and the call for the list of variable names in the model changed slightly

modeln<-9

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_2 :nlastvar_LUR_2){
  if (is.numeric(VGOB1_subsetI_staph_LUR2[,i])==TRUE){
      modeltry<-lm(VGOB1_subsetI_staph_LUR2$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetI_staph_LUR2[,models[[1]]$indexbestmodel]+VGOB1_subsetI_staph_LUR2[,models[[2]]$indexbestmodel]+VGOB1_subsetI_staph_LUR2[,models[[3]]$indexbestmodel]+VGOB1_subsetI_staph_LUR2[,models[[4]]$indexbestmodel]+VGOB1_subsetI_staph_LUR2[,models[[5]]$indexbestmodel]+VGOB1_subsetI_staph_LUR2[,models[[6]]$indexbestmodel]+ VGOB1_subsetI_staph_LUR2[,models[[7]]$indexbestmodel]+ VGOB1_subsetI_staph_LUR2[,models[[8]]$indexbestmodel]+ VGOB1_subsetI_staph_LUR2[,i]) 
        R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # Measurements_livestockpreds_LUR2[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR2)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetI_staph_LUR2)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

# this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetI_staph_LUR2)[models[[1]]$indexbestmodel], names(VGOB1_subsetI_staph_LUR2)[models[[2]]$indexbestmodel] , names(VGOB1_subsetI_staph_LUR2)[models[[3]]$indexbestmodel], names(VGOB1_subsetI_staph_LUR2)[models[[4]]$indexbestmodel], names(VGOB1_subsetI_staph_LUR2)[models[[5]]$indexbestmodel], names(VGOB1_subsetI_staph_LUR2)[models[[6]]$indexbestmodel], names(VGOB1_subsetI_staph_LUR2)[models[[7]]$indexbestmodel], names(VGOB1_subsetI_staph_LUR2)[models[[8]]$indexbestmodel],  names(VGOB1_subsetI_staph_LUR2)[models[[9]]$indexbestmodel])

#  this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetI_staph_LUR2$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetI_staph_LUR2[,models[[1]]$indexbestmodel]+VGOB1_subsetI_staph_LUR2[,models[[2]]$indexbestmodel]+VGOB1_subsetI_staph_LUR2[,models[[3]]$indexbestmodel]+ VGOB1_subsetI_staph_LUR2[,models[[4]]$indexbestmodel]+ VGOB1_subsetI_staph_LUR2[,models[[5]]$indexbestmodel]+ VGOB1_subsetI_staph_LUR2[,models[[6]]$indexbestmodel]+ VGOB1_subsetI_staph_LUR2[,models[[7]]$indexbestmodel]+ VGOB1_subsetI_staph_LUR2[,models[[8]]$indexbestmodel]+ VGOB1_subsetI_staph_LUR2[,models[[9]]$indexbestmodel]) 

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[5]]$summarybestmodel
models[[6]]$summarybestmodel
models[[7]]$summarybestmodel
models[[8]]$summarybestmodel
models[[9]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[5]]$namesbestmodel
models[[6]]$namesbestmodel
models[[7]]$namesbestmodel
models[[8]]$namesbestmodel
models[[9]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel
models[[5]]$R2bestmodel
models[[6]]$R2bestmodel
models[[7]]$R2bestmodel
models[[8]]$R2bestmodel
models[[9]]$R2bestmodel

# The next part of the code (n=10) does not work
# This is because one of the coefficients included in the model with 6 variables is negative, the code does not allow for this. I can stop here. 

# # 10 #  
# #  add tenth variable (the only difference of the above part is that now model n=10 the model statement more variables)
# #  and the call for the list of variable names in the model changed slightly
# 
# modeln<-10
# 
# models[[modeln]]<-list()
# 
# R2<-1
# addedvar<-1
# betaaddedvar<-1
# minbetas<-1
# j<-1
# 
# for (i in nfirstvar_LUR_2 :nlastvar_LUR_2){if (is.numeric(VGOB1_subsetI_staph_LUR2[,i])==TRUE){ modeltry<-lm(VGOB1_subsetI_staph_LUR2$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetI_staph_LUR2[,models[[1]]$indexbestmodel]+VGOB1_subsetI_staph_LUR2[,models[[2]]$indexbestmodel]+ VGOB1_subsetI_staph_LUR2[,models[[3]]$indexbestmodel]+VGOB1_subsetI_staph_LUR2[,models[[4]]$indexbestmodel]+ VGOB1_subsetI_staph_LUR2[,models[[5]]$indexbestmodel]+ VGOB1_subsetI_staph_LUR2[,models[[6]]$indexbestmodel]+ VGOB1_subsetI_staph_LUR2[,models[[7]]$indexbestmodel]+ VGOB1_subsetI_staph_LUR2[,models[[8]]$indexbestmodel]+ VGOB1_subsetI_staph_LUR2[,models[[9]]$indexbestmodel]+ VGOB1_subsetI_staph_LUR2[,i]) 
# 
# R2<-rbind(R2,summary(modeltry)$adj.r.squared)
# # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
#     betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
#     #  find out if there is a negative beta at All. The intercept does not count [-1]!
#     minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
#     # Measurements_livestockpreds_LUR2[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR2)[i]
#     addedvar<-rbind(addedvar,names(VGOB1_subsetI_staph_LUR2)[i])
#     j<-rbind(j, i)
#     models[[modeln]][[i]]<-summary(modeltry)
#   }
# }
# 
# models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)
# 
# #  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
# models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)
# 
# # rank the R2's of these models
# models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))
# 
# #  this is the index of the row with the highest R2 and  no negative betas in this subset
# models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j
# 
# subset(models[[modeln]]$resultspos, rank==1)
# 
# # this is the model
# models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]
# 
# # here are the names
# models[[modeln]]$namesbestmodel<-c( names(VGOB1_subsetI_staph_LUR2)[models[[1]]$indexbestmodel],                   names(VGOB1_subsetI_staph_LUR2)[models[[2]]$indexbestmodel] , names(VGOB1_subsetI_staph_LUR2)[models[[3]]$indexbestmodel], names(VGOB1_subsetI_staph_LUR2)[models[[4]]$indexbestmodel], names(VGOB1_subsetI_staph_LUR2)[models[[5]]$indexbestmodel], names(VGOB1_subsetI_staph_LUR2)[models[[6]]$indexbestmodel], names(VGOB1_subsetI_staph_LUR2)[models[[7]]$indexbestmodel], names(VGOB1_subsetI_staph_LUR2)[models[[8]]$indexbestmodel], names(VGOB1_subsetI_staph_LUR2)[models[[9]]$indexbestmodel], names(VGOB1_subsetI_staph_LUR2)[models[[10]]$indexbestmodel])
# 
# #  this is the r2 or that model
# models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2
# 
# #  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
# models[[modeln]]$bestmodel <- lm(VGOB1_subsetI_staph_LUR2$staph_copiespm3.ln.diffmeth.mean~                                VGOB1_subsetI_staph_LUR2[,models[[1]]$indexbestmodel]+ VGOB1_subsetI_staph_LUR2[,models[[2]]$indexbestmodel]+                           VGOB1_subsetI_staph_LUR2[,models[[3]]$indexbestmodel]+ VGOB1_subsetI_staph_LUR2[,models[[4]]$indexbestmodel]+ VGOB1_subsetI_staph_LUR2[,models[[5]]$indexbestmodel]+ VGOB1_subsetI_staph_LUR2[,models[[6]]$indexbestmodel]+ VGOB1_subsetI_staph_LUR2[,models[[7]]$indexbestmodel]+ VGOB1_subsetI_staph_LUR2[,models[[8]]$indexbestmodel]+ VGOB1_subsetI_staph_LUR2[,models[[9]]$indexbestmodel]+ VGOB1_subsetI_staph_LUR2[,models[[10]]$indexbestmodel]) 
# 
# models[[1]]$summarybestmodel
# models[[2]]$summarybestmodel
# models[[3]]$summarybestmodel
# models[[4]]$summarybestmodel
# models[[5]]$summarybestmodel
# models[[6]]$summarybestmodel
# models[[7]]$summarybestmodel
# models[[8]]$summarybestmodel
# models[[9]]$summarybestmodel
# models[[10]]$summarybestmodel
# models[[1]]$namesbestmodel
# models[[2]]$namesbestmodel
# models[[3]]$namesbestmodel
# models[[4]]$namesbestmodel
# models[[5]]$namesbestmodel
# models[[6]]$namesbestmodel
# models[[7]]$namesbestmodel
# models[[8]]$namesbestmodel
# models[[9]]$namesbestmodel
# models[[10]]$namesbestmodel
# models[[1]]$R2bestmodel
# models[[2]]$R2bestmodel
# models[[3]]$R2bestmodel
# models[[4]]$R2bestmodel
# models[[5]]$R2bestmodel
# models[[6]]$R2bestmodel
# models[[7]]$R2bestmodel
# models[[8]]$R2bestmodel
# models[[9]]$R2bestmodel
# models[[10]]$R2bestmodel

#   CODE FOR PICKING OUT THE BEST MODEL #   
temp <- 0
besti <- 0
for (i in 1:10){ #  think this runs the loop 10 times - not fully sure thought - but not to do with the number of models I don't think - as when I change to 3, I still get the model with 4 variables as best model
  print(models[[i]]$R2bestmodel)
  #       print(models[[i]]$summarybestmodel$coefficients=-1,4])
  #       if((models[[i]]$R2bestmodel-temp > 0.0) && (all(models[[i]]$summarybestmodel$coefficients[-1,4]<0.1))){
  #         temp <- models[[i]]$R2bestmodel
  #         besti <- i
  #         }
  if((models[[i]]$R2bestmodel-temp > 0.0) && (all(models[[i]]$summarybestmodel$coefficients[-1,4]<0.1))){
    temp <- models[[i]]$R2bestmodel
    besti <- i
  }else{
    finalBestModel_staph_LUR2_subsetI <- models[[besti]]$bestmodel
    finalBestModelNames_staph_subsetI <- models[[besti]]$namesbestmodel
    Sites <- 1:dim(VGOB1_subsetI_staph_LUR2)[1] # full original model
    #  CVaR2<-escCV_staph_LUR2(Sites)[2] # Cross Validation
    maxCD<-max(cooks.distance(finalBestModel_staph_LUR2_subsetI))
    if(length(finalBestModelNames_staph_subsetI)<2){ # vif fn doesnot work when only 1 variable...       # 
      maxVIF<-"NA"
    }else{
      maxVIF<-max(vif(finalBestModel_staph_LUR2_subsetI))
    }
    print(paste("This is the best staph model for subset I: ",besti,
                "(AdjR2: ",format(models[[besti]]$R2bestmodel,digits=3), "; MaxCD: ",format(maxCD,digits=3),"; MaxVIF: ",
                format(maxVIF,digits=3),")", sep=''))
    print(finalBestModelNames_staph_subsetI)
    break
  }
}

#  Overview of the final best model using the algorithm selection process (taking into account VIF, R^2, and p-values)
finalBestModel_staph_LUR2_subsetI
finalBestModelNames_staph_subsetI
models[[besti]]$summarybestmodel
models[[besti]]$R2bestmodel

#### J ####
# LUR model building process for subset J
#  This is the dataframe with the relevant predictor vars for LUR2 models for subset J (55 sites)
VGOB1_subsetJ_staph_LUR2 # n.b. this dataframe only includes microbial marker concentrations for staph unlike the dataframe Measurements_livestockpreds_LUR2 as previously used for the model building. 

#  Now set the values of some variables that will be needed
nfirstvar_LUR_2 <- 3  
nlastvar_LUR_2 <- 71

# Function building to run the models 
# 1 #  

models<-list()
modeln<-1
models[[modeln]]<-list()

R2<-1
betaaddedvar<-1
addedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_2:nlastvar_LUR_2){
  if (is.numeric(VGOB1_subsetJ_staph_LUR2[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetJ_staph_LUR2$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetJ_staph_LUR2[,i])                            
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    #  Measurements_livestockpreds_LUR2[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR2)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetJ_staph_LUR2)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)
models[[modeln]]$results

#  this are the candidates models with the highest R2, not a negative beta for the new, nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)
models[[modeln]]$resultspos

#  rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))
models[[modeln]]$resultspos

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j
models[[modeln]]$indexbestmodel

subset(models[[modeln]]$resultspos, rank==1)
subset(models[[modeln]]$resultspos)

#  this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]
models[[modeln]]$summarybestmodel

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetJ_staph_LUR2)[models[[1]]$indexbestmodel])
models[[modeln]]$namesbestmodel

#  this is the r2 of that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2
models[[modeln]]$R2bestmodel

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetJ_staph_LUR2$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetJ_staph_LUR2[,models[[1]]$indexbestmodel]) 
models[[modeln]]$bestmodel

summary(models[[modeln]]$bestmodel)

#  The first model includes the predictor: nPigMultipFarmWghtDist.3000m.sum.Tr.1P9 - meaning the number of multiplier pig farms weighted to distance in a 3000m buffer

# 2 #  
# Add 2nd variable (the only difference of the above part is that now modeln=2 the model statement has 2 variables)
# and the call for the list of variable names in the model changed slightly

modeln<-2

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_2:nlastvar_LUR_2){
  if (is.numeric(VGOB1_subsetJ_staph_LUR2[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetJ_staph_LUR2$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetJ_staph_LUR2[,models[[1]]$indexbestmodel]+ VGOB1_subsetJ_staph_LUR2[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # Measurements_livestockpreds_LUR2[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR2)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetJ_staph_LUR2)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  these are the candidate models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)
models[[modeln]]$resultspos

#  rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))
models[[modeln]]$resultspos

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j
models[[modeln]]$indexbestmodel

subset(models[[modeln]]$resultspos, rank==1)

# this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]
models[[modeln]]$summarybestmodel

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetJ_staph_LUR2)[models[[1]]$indexbestmodel], names(VGOB1_subsetJ_staph_LUR2)[models[[2]]$indexbestmodel] )
models[[modeln]]$namesbestmodel

# this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2
models[[modeln]]$R2bestmodel

# this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetJ_staph_LUR2$staph_copiespm3.ln.diffmeth.mean~                               VGOB1_subsetJ_staph_LUR2[,models[[1]]$indexbestmodel]+                           VGOB1_subsetJ_staph_LUR2[,models[[2]]$indexbestmodel]) 

models[[modeln]]$bestmodel

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel


# 3 #  
# add third variable (the only difference of the above part is that now modeln=3 the model statement has 3 variables)
# and the call for the list of variable names in the model changed slightly

modeln<-3

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_2:nlastvar_LUR_2){
  if (is.numeric(VGOB1_subsetJ_staph_LUR2[,i])==TRUE){  
    modeltry<-lm(VGOB1_subsetJ_staph_LUR2$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetJ_staph_LUR2[,models[[1]]$indexbestmodel]+VGOB1_subsetJ_staph_LUR2[,models[[2]]$indexbestmodel]+ VGOB1_subsetJ_staph_LUR2[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # All[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR2)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetJ_staph_LUR2)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

#  rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

#  this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

#  here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetJ_staph_LUR2)[models[[1]]$indexbestmodel], names(VGOB1_subsetJ_staph_LUR2)[models[[2]]$indexbestmodel], names(VGOB1_subsetJ_staph_LUR2)[models[[3]]$indexbestmodel])

#  this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetJ_staph_LUR2$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetJ_staph_LUR2[,models[[1]]$indexbestmodel]+ VGOB1_subsetJ_staph_LUR2[,models[[2]]$indexbestmodel]+ VGOB1_subsetJ_staph_LUR2[,models[[3]]$indexbestmodel]) 

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel


# 4 #  
#  add forth variable (the only difference of the above part is that now model n=4 the model statement more variables)
#  and the call for the list of variable names in the model changed slightly
modeln<-4

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1


for (i in nfirstvar_LUR_2:nlastvar_LUR_2){
  if (is.numeric(VGOB1_subsetJ_staph_LUR2[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetJ_staph_LUR2$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetJ_staph_LUR2[,models[[1]]$indexbestmodel]+VGOB1_subsetJ_staph_LUR2[,models[[2]]$indexbestmodel]+VGOB1_subsetJ_staph_LUR2[,models[[3]]$indexbestmodel]+VGOB1_subsetJ_staph_LUR2[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    #  the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    #  All[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR2)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetJ_staph_LUR2)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

#  this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

#  here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetJ_staph_LUR2)[models[[1]]$indexbestmodel], names(VGOB1_subsetJ_staph_LUR2)[models[[2]]$indexbestmodel], names(VGOB1_subsetJ_staph_LUR2)[models[[3]]$indexbestmodel], names(VGOB1_subsetJ_staph_LUR2)[models[[4]]$indexbestmodel])

#  this is the r2 of that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetJ_staph_LUR2$staph_copiespm3.ln.diffmeth.mean~ VGOB1_subsetJ_staph_LUR2[,models[[1]]$indexbestmodel]+ VGOB1_subsetJ_staph_LUR2[,models[[2]]$indexbestmodel]+VGOB1_subsetJ_staph_LUR2[,models[[3]]$indexbestmodel]+ VGOB1_subsetJ_staph_LUR2[,models[[4]]$indexbestmodel]) 


models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel


# 5 #  
# add fifth variable (the only difference of the above part is that now modeln=5 the model statement more variables)
# and the call for the list of variable names in the model changed slightly
modeln<-5

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_2:nlastvar_LUR_2){
  if (is.numeric(VGOB1_subsetJ_staph_LUR2[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetJ_staph_LUR2$staph_copiespm3.ln.diffmeth.mean~ VGOB1_subsetJ_staph_LUR2[,models[[1]]$indexbestmodel]+ VGOB1_subsetJ_staph_LUR2[,models[[2]]$indexbestmodel]+ VGOB1_subsetJ_staph_LUR2[,models[[3]]$indexbestmodel]+ VGOB1_subsetJ_staph_LUR2[,models[[4]]$indexbestmodel]+ VGOB1_subsetJ_staph_LUR2[,i]) 
  
R2<-rbind(R2,summary(modeltry)$adj.r.squared)
# the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # All[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR2)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetJ_staph_LUR2)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

#  this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetJ_staph_LUR2)[models[[1]]$indexbestmodel], names(VGOB1_subsetJ_staph_LUR2)[models[[2]]$indexbestmodel], names(VGOB1_subsetJ_staph_LUR2)[models[[3]]$indexbestmodel], names(VGOB1_subsetJ_staph_LUR2)[models[[4]]$indexbestmodel], names(VGOB1_subsetJ_staph_LUR2)[models[[5]]$indexbestmodel])

#  this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetJ_staph_LUR2$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetJ_staph_LUR2[,models[[1]]$indexbestmodel]+VGOB1_subsetJ_staph_LUR2[,models[[2]]$indexbestmodel]+VGOB1_subsetJ_staph_LUR2[,models[[3]]$indexbestmodel]+ VGOB1_subsetJ_staph_LUR2[,models[[4]]$indexbestmodel]+ VGOB1_subsetJ_staph_LUR2[,models[[5]]$indexbestmodel]) 
models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[5]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[5]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel
models[[5]]$R2bestmodel

# 6 #  
# add sixth variable (the only difference of the above part is that now model n=6 the model statement more variables)
#  and the call for the list of variable names in the model changed slightly

modeln<-6

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_2 :nlastvar_LUR_2){
  if (is.numeric(VGOB1_subsetJ_staph_LUR2[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetJ_staph_LUR2$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetJ_staph_LUR2[,models[[1]]$indexbestmodel]+VGOB1_subsetJ_staph_LUR2[,models[[2]]$indexbestmodel]+VGOB1_subsetJ_staph_LUR2[,models[[3]]$indexbestmodel]+VGOB1_subsetJ_staph_LUR2[,models[[4]]$indexbestmodel]+VGOB1_subsetJ_staph_LUR2[,models[[5]]$indexbestmodel]+ VGOB1_subsetJ_staph_LUR2[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # All[,i] is the row that's being tried out now. the name of that row can be found in  names(All)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetJ_staph_LUR2)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

# this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetJ_staph_LUR2)[models[[1]]$indexbestmodel], names(VGOB1_subsetJ_staph_LUR2)[models[[2]]$indexbestmodel] , names(VGOB1_subsetJ_staph_LUR2)[models[[3]]$indexbestmodel], names(VGOB1_subsetJ_staph_LUR2)[models[[4]]$indexbestmodel], names(VGOB1_subsetJ_staph_LUR2)[models[[5]]$indexbestmodel], names(VGOB1_subsetJ_staph_LUR2)[models[[6]]$indexbestmodel])

#  this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetJ_staph_LUR2$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetJ_staph_LUR2[,models[[1]]$indexbestmodel]+VGOB1_subsetJ_staph_LUR2[,models[[2]]$indexbestmodel]+VGOB1_subsetJ_staph_LUR2[,models[[3]]$indexbestmodel]+ VGOB1_subsetJ_staph_LUR2[,models[[4]]$indexbestmodel]+ VGOB1_subsetJ_staph_LUR2[,models[[5]]$indexbestmodel]+ VGOB1_subsetJ_staph_LUR2[,models[[6]]$indexbestmodel]) 

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[5]]$summarybestmodel
models[[6]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[5]]$namesbestmodel
models[[6]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel
models[[5]]$R2bestmodel
models[[6]]$R2bestmodel


# 7 #  
# add seventh variable (the only difference of the above part is that now model n=7 the model statement more variables)
#  and the call for the list of variable names in the model changed slightly

modeln<-7

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_2 :nlastvar_LUR_2){
  if (is.numeric(VGOB1_subsetJ_staph_LUR2[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetJ_staph_LUR2$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetJ_staph_LUR2[,models[[1]]$indexbestmodel]+VGOB1_subsetJ_staph_LUR2[,models[[2]]$indexbestmodel]+VGOB1_subsetJ_staph_LUR2[,models[[3]]$indexbestmodel]+VGOB1_subsetJ_staph_LUR2[,models[[4]]$indexbestmodel]+VGOB1_subsetJ_staph_LUR2[,models[[5]]$indexbestmodel]+VGOB1_subsetJ_staph_LUR2[,models[[6]]$indexbestmodel]+ VGOB1_subsetJ_staph_LUR2[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # Measurements_livestockpreds_LUR2[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR2)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetJ_staph_LUR2)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

# this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetJ_staph_LUR2)[models[[1]]$indexbestmodel], names(VGOB1_subsetJ_staph_LUR2)[models[[2]]$indexbestmodel] , names(VGOB1_subsetJ_staph_LUR2)[models[[3]]$indexbestmodel], names(VGOB1_subsetJ_staph_LUR2)[models[[4]]$indexbestmodel], names(VGOB1_subsetJ_staph_LUR2)[models[[5]]$indexbestmodel], names(VGOB1_subsetJ_staph_LUR2)[models[[6]]$indexbestmodel], names(VGOB1_subsetJ_staph_LUR2)[models[[7]]$indexbestmodel])

#  this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetJ_staph_LUR2$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetJ_staph_LUR2[,models[[1]]$indexbestmodel]+VGOB1_subsetJ_staph_LUR2[,models[[2]]$indexbestmodel]+VGOB1_subsetJ_staph_LUR2[,models[[3]]$indexbestmodel]+ VGOB1_subsetJ_staph_LUR2[,models[[4]]$indexbestmodel]+ VGOB1_subsetJ_staph_LUR2[,models[[5]]$indexbestmodel]+ VGOB1_subsetJ_staph_LUR2[,models[[6]]$indexbestmodel]+ VGOB1_subsetJ_staph_LUR2[,models[[7]]$indexbestmodel]) 

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[5]]$summarybestmodel
models[[6]]$summarybestmodel
models[[7]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[5]]$namesbestmodel
models[[6]]$namesbestmodel
models[[7]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel
models[[5]]$R2bestmodel
models[[6]]$R2bestmodel
models[[7]]$R2bestmodel

# 8 #  
# add eighth variable (the only difference of the above part is that now modeln=7 the model statement more variables)
# and the call for the list of variable names in the model changed slightly

modeln<-8

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_2 :nlastvar_LUR_2){
  if (is.numeric(VGOB1_subsetJ_staph_LUR2[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetJ_staph_LUR2$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetJ_staph_LUR2[,models[[1]]$indexbestmodel]+VGOB1_subsetJ_staph_LUR2[,models[[2]]$indexbestmodel]+VGOB1_subsetJ_staph_LUR2[,models[[3]]$indexbestmodel]+VGOB1_subsetJ_staph_LUR2[,models[[4]]$indexbestmodel]+VGOB1_subsetJ_staph_LUR2[,models[[5]]$indexbestmodel]+VGOB1_subsetJ_staph_LUR2[,models[[6]]$indexbestmodel]+ VGOB1_subsetJ_staph_LUR2[,models[[7]]$indexbestmodel]+ VGOB1_subsetJ_staph_LUR2[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # Measurements_livestockpreds_LUR2[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR2)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetJ_staph_LUR2)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

# this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetJ_staph_LUR2)[models[[1]]$indexbestmodel], names(VGOB1_subsetJ_staph_LUR2)[models[[2]]$indexbestmodel] , names(VGOB1_subsetJ_staph_LUR2)[models[[3]]$indexbestmodel], names(VGOB1_subsetJ_staph_LUR2)[models[[4]]$indexbestmodel], names(VGOB1_subsetJ_staph_LUR2)[models[[5]]$indexbestmodel], names(VGOB1_subsetJ_staph_LUR2)[models[[6]]$indexbestmodel], names(VGOB1_subsetJ_staph_LUR2)[models[[7]]$indexbestmodel], names(VGOB1_subsetJ_staph_LUR2)[models[[8]]$indexbestmodel])

#  this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetJ_staph_LUR2$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetJ_staph_LUR2[,models[[1]]$indexbestmodel]+VGOB1_subsetJ_staph_LUR2[,models[[2]]$indexbestmodel]+VGOB1_subsetJ_staph_LUR2[,models[[3]]$indexbestmodel]+ VGOB1_subsetJ_staph_LUR2[,models[[4]]$indexbestmodel]+ VGOB1_subsetJ_staph_LUR2[,models[[5]]$indexbestmodel]+ VGOB1_subsetJ_staph_LUR2[,models[[6]]$indexbestmodel]+ VGOB1_subsetJ_staph_LUR2[,models[[7]]$indexbestmodel]+ VGOB1_subsetJ_staph_LUR2[,models[[8]]$indexbestmodel]) 

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[5]]$summarybestmodel
models[[6]]$summarybestmodel
models[[7]]$summarybestmodel
models[[8]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[5]]$namesbestmodel
models[[6]]$namesbestmodel
models[[7]]$namesbestmodel
models[[8]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel
models[[5]]$R2bestmodel
models[[6]]$R2bestmodel
models[[7]]$R2bestmodel
models[[8]]$R2bestmodel

# 9 #  
# add ninth variable (the only difference of the above part is that now modeln=9 the model statement more variables)
# and the call for the list of variable names in the model changed slightly

modeln<-9

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_2 :nlastvar_LUR_2){
  if (is.numeric(VGOB1_subsetJ_staph_LUR2[,i])==TRUE){
      modeltry<-lm(VGOB1_subsetJ_staph_LUR2$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetJ_staph_LUR2[,models[[1]]$indexbestmodel]+VGOB1_subsetJ_staph_LUR2[,models[[2]]$indexbestmodel]+VGOB1_subsetJ_staph_LUR2[,models[[3]]$indexbestmodel]+VGOB1_subsetJ_staph_LUR2[,models[[4]]$indexbestmodel]+VGOB1_subsetJ_staph_LUR2[,models[[5]]$indexbestmodel]+VGOB1_subsetJ_staph_LUR2[,models[[6]]$indexbestmodel]+ VGOB1_subsetJ_staph_LUR2[,models[[7]]$indexbestmodel]+ VGOB1_subsetJ_staph_LUR2[,models[[8]]$indexbestmodel]+ VGOB1_subsetJ_staph_LUR2[,i]) 
        R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # Measurements_livestockpreds_LUR2[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR2)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetJ_staph_LUR2)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

# this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetJ_staph_LUR2)[models[[1]]$indexbestmodel], names(VGOB1_subsetJ_staph_LUR2)[models[[2]]$indexbestmodel] , names(VGOB1_subsetJ_staph_LUR2)[models[[3]]$indexbestmodel], names(VGOB1_subsetJ_staph_LUR2)[models[[4]]$indexbestmodel], names(VGOB1_subsetJ_staph_LUR2)[models[[5]]$indexbestmodel], names(VGOB1_subsetJ_staph_LUR2)[models[[6]]$indexbestmodel], names(VGOB1_subsetJ_staph_LUR2)[models[[7]]$indexbestmodel], names(VGOB1_subsetJ_staph_LUR2)[models[[8]]$indexbestmodel],  names(VGOB1_subsetJ_staph_LUR2)[models[[9]]$indexbestmodel])

#  this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetJ_staph_LUR2$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetJ_staph_LUR2[,models[[1]]$indexbestmodel]+VGOB1_subsetJ_staph_LUR2[,models[[2]]$indexbestmodel]+VGOB1_subsetJ_staph_LUR2[,models[[3]]$indexbestmodel]+ VGOB1_subsetJ_staph_LUR2[,models[[4]]$indexbestmodel]+ VGOB1_subsetJ_staph_LUR2[,models[[5]]$indexbestmodel]+ VGOB1_subsetJ_staph_LUR2[,models[[6]]$indexbestmodel]+ VGOB1_subsetJ_staph_LUR2[,models[[7]]$indexbestmodel]+ VGOB1_subsetJ_staph_LUR2[,models[[8]]$indexbestmodel]+ VGOB1_subsetJ_staph_LUR2[,models[[9]]$indexbestmodel]) 

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[5]]$summarybestmodel
models[[6]]$summarybestmodel
models[[7]]$summarybestmodel
models[[8]]$summarybestmodel
models[[9]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[5]]$namesbestmodel
models[[6]]$namesbestmodel
models[[7]]$namesbestmodel
models[[8]]$namesbestmodel
models[[9]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel
models[[5]]$R2bestmodel
models[[6]]$R2bestmodel
models[[7]]$R2bestmodel
models[[8]]$R2bestmodel
models[[9]]$R2bestmodel

# 10 #  
#  add tenth variable (the only difference of the above part is that now model n=10 the model statement more variables)
#  and the call for the list of variable names in the model changed slightly

modeln<-10

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_2 :nlastvar_LUR_2){if (is.numeric(VGOB1_subsetJ_staph_LUR2[,i])==TRUE){ modeltry<-lm(VGOB1_subsetJ_staph_LUR2$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetJ_staph_LUR2[,models[[1]]$indexbestmodel]+VGOB1_subsetJ_staph_LUR2[,models[[2]]$indexbestmodel]+ VGOB1_subsetJ_staph_LUR2[,models[[3]]$indexbestmodel]+VGOB1_subsetJ_staph_LUR2[,models[[4]]$indexbestmodel]+ VGOB1_subsetJ_staph_LUR2[,models[[5]]$indexbestmodel]+ VGOB1_subsetJ_staph_LUR2[,models[[6]]$indexbestmodel]+ VGOB1_subsetJ_staph_LUR2[,models[[7]]$indexbestmodel]+ VGOB1_subsetJ_staph_LUR2[,models[[8]]$indexbestmodel]+ VGOB1_subsetJ_staph_LUR2[,models[[9]]$indexbestmodel]+ VGOB1_subsetJ_staph_LUR2[,i]) 

R2<-rbind(R2,summary(modeltry)$adj.r.squared)
# the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # Measurements_livestockpreds_LUR2[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR2)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetJ_staph_LUR2)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

# this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

# here are the names
models[[modeln]]$namesbestmodel<-c( names(VGOB1_subsetJ_staph_LUR2)[models[[1]]$indexbestmodel],                   names(VGOB1_subsetJ_staph_LUR2)[models[[2]]$indexbestmodel] , names(VGOB1_subsetJ_staph_LUR2)[models[[3]]$indexbestmodel], names(VGOB1_subsetJ_staph_LUR2)[models[[4]]$indexbestmodel], names(VGOB1_subsetJ_staph_LUR2)[models[[5]]$indexbestmodel], names(VGOB1_subsetJ_staph_LUR2)[models[[6]]$indexbestmodel], names(VGOB1_subsetJ_staph_LUR2)[models[[7]]$indexbestmodel], names(VGOB1_subsetJ_staph_LUR2)[models[[8]]$indexbestmodel], names(VGOB1_subsetJ_staph_LUR2)[models[[9]]$indexbestmodel], names(VGOB1_subsetJ_staph_LUR2)[models[[10]]$indexbestmodel])

#  this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetJ_staph_LUR2$staph_copiespm3.ln.diffmeth.mean~                                VGOB1_subsetJ_staph_LUR2[,models[[1]]$indexbestmodel]+ VGOB1_subsetJ_staph_LUR2[,models[[2]]$indexbestmodel]+                           VGOB1_subsetJ_staph_LUR2[,models[[3]]$indexbestmodel]+ VGOB1_subsetJ_staph_LUR2[,models[[4]]$indexbestmodel]+ VGOB1_subsetJ_staph_LUR2[,models[[5]]$indexbestmodel]+ VGOB1_subsetJ_staph_LUR2[,models[[6]]$indexbestmodel]+ VGOB1_subsetJ_staph_LUR2[,models[[7]]$indexbestmodel]+ VGOB1_subsetJ_staph_LUR2[,models[[8]]$indexbestmodel]+ VGOB1_subsetJ_staph_LUR2[,models[[9]]$indexbestmodel]+ VGOB1_subsetJ_staph_LUR2[,models[[10]]$indexbestmodel]) 

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[5]]$summarybestmodel
models[[6]]$summarybestmodel
models[[7]]$summarybestmodel
models[[8]]$summarybestmodel
models[[9]]$summarybestmodel
models[[10]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[5]]$namesbestmodel
models[[6]]$namesbestmodel
models[[7]]$namesbestmodel
models[[8]]$namesbestmodel
models[[9]]$namesbestmodel
models[[10]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel
models[[5]]$R2bestmodel
models[[6]]$R2bestmodel
models[[7]]$R2bestmodel
models[[8]]$R2bestmodel
models[[9]]$R2bestmodel
models[[10]]$R2bestmodel

#   CODE FOR PICKING OUT THE BEST MODEL #   
temp <- 0
besti <- 0
for (i in 1:10){ #  think this runs the loop 10 times - not fully sure thought - but not to do with the number of models I don't think - as when I change to 3, I still get the model with 4 variables as best model
  print(models[[i]]$R2bestmodel)
  #       print(models[[i]]$summarybestmodel$coefficients=-1,4])
  #       if((models[[i]]$R2bestmodel-temp > 0.0) && (all(models[[i]]$summarybestmodel$coefficients[-1,4]<0.1))){
  #         temp <- models[[i]]$R2bestmodel
  #         besti <- i
  #         }
  if((models[[i]]$R2bestmodel-temp > 0.0) && (all(models[[i]]$summarybestmodel$coefficients[-1,4]<0.1))){
    temp <- models[[i]]$R2bestmodel
    besti <- i
  }else{
    finalBestModel_staph_LUR2_subsetJ <- models[[besti]]$bestmodel
    finalBestModelNames_staph_subsetJ <- models[[besti]]$namesbestmodel
    Sites <- 1:dim(VGOB1_subsetJ_staph_LUR2)[1] # full original model
    #  CVaR2<-escCV_staph_LUR2(Sites)[2] # Cross Validation
    maxCD<-max(cooks.distance(finalBestModel_staph_LUR2_subsetJ))
    if(length(finalBestModelNames_staph_subsetJ)<2){ # vif fn doesnot work when only 1 variable...       # 
      maxVIF<-"NA"
    }else{
      maxVIF<-max(vif(finalBestModel_staph_LUR2_subsetJ))
    }
    print(paste("This is the best staph model for subset J: ",besti,
                "(AdjR2: ",format(models[[besti]]$R2bestmodel,digits=3), "; MaxCD: ",format(maxCD,digits=3),"; MaxVIF: ",
                format(maxVIF,digits=3),")", sep=''))
    print(finalBestModelNames_staph_subsetJ)
    break
  }
}

#  Overview of the final best model using the algorithm selection process (taking into account VIF, R^2, and p-values)
finalBestModel_staph_LUR2_subsetJ
finalBestModelNames_staph_subsetJ
models[[besti]]$summarybestmodel
models[[besti]]$R2bestmodel

#### Predicting hold out sites ####
# These are the models from the 10 subsets: 
finalBestModel_staph_LUR2_subsetA
finalBestModel_staph_LUR2_subsetB
finalBestModel_staph_LUR2_subsetC
finalBestModel_staph_LUR2_subsetD
finalBestModel_staph_LUR2_subsetE
finalBestModel_staph_LUR2_subsetF
finalBestModel_staph_LUR2_subsetG
finalBestModel_staph_LUR2_subsetH
finalBestModel_staph_LUR2_subsetI
finalBestModel_staph_LUR2_subsetJ

#  Selecting of test sets
#  valID 1 to 10
VGOB1_subsetvalID1_staph_LUR2 <- subset(VGOB1_FINAL_staph_LUR2, valID == 1)
VGOB1_subsetvalID2_staph_LUR2 <- subset(VGOB1_FINAL_staph_LUR2, valID == 2)
VGOB1_subsetvalID3_staph_LUR2 <- subset(VGOB1_FINAL_staph_LUR2, valID == 3)
VGOB1_subsetvalID4_staph_LUR2 <- subset(VGOB1_FINAL_staph_LUR2, valID == 4)
VGOB1_subsetvalID5_staph_LUR2 <- subset(VGOB1_FINAL_staph_LUR2, valID == 5)
VGOB1_subsetvalID6_staph_LUR2 <- subset(VGOB1_FINAL_staph_LUR2, valID == 6)
VGOB1_subsetvalID7_staph_LUR2 <- subset(VGOB1_FINAL_staph_LUR2, valID == 7)
VGOB1_subsetvalID8_staph_LUR2 <- subset(VGOB1_FINAL_staph_LUR2, valID == 8)
VGOB1_subsetvalID9_staph_LUR2 <- subset(VGOB1_FINAL_staph_LUR2, valID == 9)
VGOB1_subsetvalID10_staph_LUR2 <- subset(VGOB1_FINAL_staph_LUR2, valID == 10)

#  For every subset predict (based on LUR model for that subset, so the training sites) the concentrations at the sites left out (test sites) to enable comparisons observed vs predicted 

#  Set 1
finalBestModel_staph_LUR2_subsetA
finalBestModelNames_staph_subsetA
summary(finalBestModel_staph_LUR2_subsetA)

# write the model out
finalBestModel_staph_LUR2_subsetA_lm <- lm(staph_copiespm3.ln.diffmeth.mean~ PoultryFarm.3000m.95Win.10to90scaled + nhorses.1000m.95Win.10to90scaled+ HorseFarm.3000m.95Win.10to90scaled, data = VGOB1_subsetA_staph_LUR2)
VGOB1_subsetvalID1_staph_LUR2$staph_PRED_HV <- predict(finalBestModel_staph_LUR2_subsetA_lm,VGOB1_subsetvalID1_staph_LUR2)
summary(VGOB1_subsetvalID1_staph_LUR2$staph_PRED_HV)
plot(VGOB1_subsetvalID1_staph_LUR2$staph_PRED_HV, VGOB1_subsetvalID1_staph_LUR2$staph_copiespm3.ln.diffmeth.mean, xlab="staph predicted (HV)", ylab="staph concentration observed")
VGOB1_subsetvalID1_staph_LUR2_lm <- lm(staph_copiespm3.ln.diffmeth.mean~staph_PRED_HV, data=VGOB1_subsetvalID1_staph_LUR2 )
summary(VGOB1_subsetvalID1_staph_LUR2_lm)

#  Set 2
finalBestModel_staph_LUR2_subsetB
finalBestModelNames_staph_subsetB
summary(finalBestModel_staph_LUR2_subsetB)
# write the model out
finalBestModel_staph_LUR2_subsetB_lm <- lm(staph_copiespm3.ln.diffmeth.mean~ nAnyFarmWghtDist.3000m.sum.95Win.10to90scaled+HorseFarm.3000m.95Win.10to90scaled, data = VGOB1_subsetB_staph_LUR2)
VGOB1_subsetvalID2_staph_LUR2$staph_PRED_HV <- predict(finalBestModel_staph_LUR2_subsetB_lm,VGOB1_subsetvalID2_staph_LUR2)
summary(VGOB1_subsetvalID2_staph_LUR2$staph_PRED_HV)
plot(VGOB1_subsetvalID2_staph_LUR2$staph_PRED_HV, VGOB1_subsetvalID2_staph_LUR2$staph_copiespm3.ln.diffmeth.mean, xlab="staph predicted (HV)", ylab="staph concentration observed")
VGOB1_subsetvalID2_staph_LUR2_lm <- lm(staph_copiespm3.ln.diffmeth.mean~staph_PRED_HV, data=VGOB1_subsetvalID2_staph_LUR2)
summary(VGOB1_subsetvalID2_staph_LUR2_lm)

#  Set 3
finalBestModel_staph_LUR2_subsetC
finalBestModelNames_staph_subsetC
summary(finalBestModel_staph_LUR2_subsetC)
# write the model out
finalBestModel_staph_LUR2_subsetC_lm <- lm(staph_copiespm3.ln.diffmeth.mean~ PoultryFarm.3000m.95Win.10to90scaled+nhorses.1000m.95Win.10to90scaled+ HorseFarm.3000m.95Win.10to90scaled , data = VGOB1_subsetC_staph_LUR2)
VGOB1_subsetvalID3_staph_LUR2$staph_PRED_HV <- predict(finalBestModel_staph_LUR2_subsetC_lm,VGOB1_subsetvalID3_staph_LUR2)
summary(VGOB1_subsetvalID3_staph_LUR2$staph_PRED_HV)
plot(VGOB1_subsetvalID3_staph_LUR2$staph_PRED_HV, VGOB1_subsetvalID3_staph_LUR2$staph_copiespm3.ln.diffmeth.mean, xlab="staph predicted (HV)", ylab="staph concentration observed")
VGOB1_subsetvalID3_staph_LUR2_lm <- lm(staph_copiespm3.ln.diffmeth.mean~staph_PRED_HV, data=VGOB1_subsetvalID3_staph_LUR2 )
summary(VGOB1_subsetvalID3_staph_LUR2_lm)

#  Set 4
finalBestModel_staph_LUR2_subsetD
finalBestModelNames_staph_subsetD
summary(finalBestModel_staph_LUR2_subsetD)
# write the model out
finalBestModel_staph_LUR2_subsetD_lm <- lm(staph_copiespm3.ln.diffmeth.mean~ PoultryFarm.3000m.95Win.10to90scaled + nhorses.1000m.95Win.10to90scaled, data = VGOB1_subsetD_staph_LUR2)
VGOB1_subsetvalID4_staph_LUR2$staph_PRED_HV <- predict(finalBestModel_staph_LUR2_subsetD_lm,VGOB1_subsetvalID4_staph_LUR2)
summary(VGOB1_subsetvalID4_staph_LUR2$staph_PRED_HV)
plot(VGOB1_subsetvalID4_staph_LUR2$staph_PRED_HV, VGOB1_subsetvalID4_staph_LUR2$staph_copiespm3.ln.diffmeth.mean, xlab="staph predicted (HV)", ylab="staph concentration observed")
VGOB1_subsetvalID4_staph_LUR2_lm <- lm(staph_copiespm3.ln.diffmeth.mean~staph_PRED_HV, data=VGOB1_subsetvalID4_staph_LUR2 )
summary(VGOB1_subsetvalID4_staph_LUR2_lm)

#  Set 5
finalBestModel_staph_LUR2_subsetE
finalBestModelNames_staph_subsetE
summary(finalBestModel_staph_LUR2_subsetE)
# write the model out
finalBestModel_staph_LUR2_subsetE_lm <- lm(staph_copiespm3.ln.diffmeth.mean~ PoultryFarm.3000m.95Win.10to90scaled + nhorses.1000m.95Win.10to90scaled + HorseFarm.3000m.95Win.10to90scaled, data = VGOB1_subsetE_staph_LUR2)
VGOB1_subsetvalID5_staph_LUR2$staph_PRED_HV <- predict(finalBestModel_staph_LUR2_subsetE_lm,VGOB1_subsetvalID5_staph_LUR2)
summary(VGOB1_subsetvalID5_staph_LUR2$staph_PRED_HV)
plot(VGOB1_subsetvalID5_staph_LUR2$staph_PRED_HV, VGOB1_subsetvalID5_staph_LUR2$staph_copiespm3.ln.diffmeth.mean, xlab="staph predicted (HV)", ylab="staph concentration observed")
VGOB1_subsetvalID5_staph_LUR2_lm <- lm(staph_copiespm3.ln.diffmeth.mean~staph_PRED_HV, data=VGOB1_subsetvalID5_staph_LUR2)
summary(VGOB1_subsetvalID5_staph_LUR2_lm)

#  Set 6
finalBestModel_staph_LUR2_subsetF
finalBestModelNames_staph_subsetF
summary(finalBestModel_staph_LUR2_subsetF)
# write the model out
finalBestModel_staph_LUR2_subsetF_lm <- lm(staph_copiespm3.ln.diffmeth.mean~PoultryFarm.3000m.95Win.10to90scaled + HorseFarm.3000m.95Win.10to90scaled + nCattleFarmWghtDist.1000m.sum.95Win.10to90scaled, data = VGOB1_subsetF_staph_LUR2)
VGOB1_subsetvalID6_staph_LUR2$staph_PRED_HV <- predict(finalBestModel_staph_LUR2_subsetF_lm,VGOB1_subsetvalID1_staph_LUR2)
summary(VGOB1_subsetvalID6_staph_LUR2$staph_PRED_HV)
plot(VGOB1_subsetvalID6_staph_LUR2$staph_PRED_HV, VGOB1_subsetvalID6_staph_LUR2$staph_copiespm3.ln.diffmeth.mean, xlab="staph predicted (HV)", ylab="staph concentration observed")
VGOB1_subsetvalID6_staph_LUR2_lm <- lm(staph_copiespm3.ln.diffmeth.mean~staph_PRED_HV, data=VGOB1_subsetvalID6_staph_LUR2 )
summary(VGOB1_subsetvalID6_staph_LUR2_lm)

#  Set 7
finalBestModel_staph_LUR2_subsetG
finalBestModelNames_staph_subsetG
summary(finalBestModel_staph_LUR2_subsetG)
# write the model out
finalBestModel_staph_LUR2_subsetG_lm <- lm(staph_copiespm3.ln.diffmeth.mean~ nAnyFarmWghtDist.3000m.sum.95Win.10to90scaled + npoultry.3000m.95Win.10to90scaled, data = VGOB1_subsetG_staph_LUR2)
VGOB1_subsetvalID7_staph_LUR2$staph_PRED_HV <- predict(finalBestModel_staph_LUR2_subsetG_lm,VGOB1_subsetvalID7_staph_LUR2)
summary(VGOB1_subsetvalID7_staph_LUR2$staph_PRED_HV)
plot(VGOB1_subsetvalID7_staph_LUR2$staph_PRED_HV, VGOB1_subsetvalID7_staph_LUR2$staph_copiespm3.ln.diffmeth.mean, xlab="staph predicted (HV)", ylab="staph concentration observed")
VGOB1_subsetvalID7_staph_LUR2_lm <- lm(staph_copiespm3.ln.diffmeth.mean~staph_PRED_HV, data=VGOB1_subsetvalID7_staph_LUR2)
summary(VGOB1_subsetvalID7_staph_LUR2_lm)

#  Set 8
finalBestModel_staph_LUR2_subsetH
finalBestModelNames_staph_subsetH
summary(finalBestModel_staph_LUR2_subsetH)
# write the model out
finalBestModel_staph_LUR2_subsetH_lm <- lm(staph_copiespm3.ln.diffmeth.mean~ nAnyFarmWghtDist.3000m.sum.95Win.10to90scaled + HorseFarm.3000m.95Win.10to90scaled, data = VGOB1_subsetH_staph_LUR2)
VGOB1_subsetvalID8_staph_LUR2$staph_PRED_HV <- predict(finalBestModel_staph_LUR2_subsetH_lm,VGOB1_subsetvalID8_staph_LUR2)
summary(VGOB1_subsetvalID8_staph_LUR2$staph_PRED_HV)
plot(VGOB1_subsetvalID8_staph_LUR2$staph_PRED_HV, VGOB1_subsetvalID8_staph_LUR2$staph_copiespm3.ln.diffmeth.mean, xlab="staph predicted (HV)", ylab="staph concentration observed")
VGOB1_subsetvalID8_staph_LUR2_lm <- lm(staph_copiespm3.ln.diffmeth.mean~staph_PRED_HV, data=VGOB1_subsetvalID8_staph_LUR2)
summary(VGOB1_subsetvalID8_staph_LUR2_lm)

#  Set 9
finalBestModel_staph_LUR2_subsetI
finalBestModelNames_staph_subsetI
summary(finalBestModel_staph_LUR2_subsetI)
# write the model out
finalBestModel_staph_LUR2_subsetI_lm <- lm(staph_copiespm3.ln.diffmeth.mean~ PoultryFarm.3000m.95Win.10to90scaled + npigsWghtDist.3000m.sum.95Win.10to90scaled, data = VGOB1_subsetI_staph_LUR2)
VGOB1_subsetvalID9_staph_LUR2$staph_PRED_HV <- predict(finalBestModel_staph_LUR2_subsetI_lm,VGOB1_subsetvalID9_staph_LUR2)
summary(VGOB1_subsetvalID9_staph_LUR2$staph_PRED_HV)
plot(VGOB1_subsetvalID9_staph_LUR2$staph_PRED_HV, VGOB1_subsetvalID9_staph_LUR2$staph_copiespm3.ln.diffmeth.mean, xlab="staph predicted (HV)", ylab="staph concentration observed")
VGOB1_subsetvalID9_staph_LUR2_lm <- lm(staph_copiespm3.ln.diffmeth.mean~staph_PRED_HV, data=VGOB1_subsetvalID9_staph_LUR2 )
summary(VGOB1_subsetvalID9_staph_LUR2_lm)

#  Set 10
finalBestModel_staph_LUR2_subsetJ
finalBestModelNames_staph_subsetJ
summary(finalBestModel_staph_LUR2_subsetJ)
# write the model out
finalBestModel_staph_LUR2_subsetJ_lm <- lm(staph_copiespm3.ln.diffmeth.mean~ PoultryFarm.3000m.95Win.10to90scaled + HorseFarm.3000m.95Win.10to90scaled + nhorsesWghtDist.1000m.sum.95Win.10to90scaled, data = VGOB1_subsetJ_staph_LUR2)
VGOB1_subsetvalID10_staph_LUR2$staph_PRED_HV <- predict(finalBestModel_staph_LUR2_subsetJ_lm,VGOB1_subsetvalID10_staph_LUR2)
summary(VGOB1_subsetvalID10_staph_LUR2$staph_PRED_HV)
plot(VGOB1_subsetvalID10_staph_LUR2$staph_PRED_HV, VGOB1_subsetvalID10_staph_LUR2$staph_copiespm3.ln.diffmeth.mean, xlab="staph predicted (HV)", ylab="staph concentration observed")
VGOB1_subsetvalID10_staph_LUR2_lm <- lm(staph_copiespm3.ln.diffmeth.mean~staph_PRED_HV, data=VGOB1_subsetvalID10_staph_LUR2)
summary(VGOB1_subsetvalID10_staph_LUR2_lm)

# Calculate max VIF and cook's distnace of each subset (each fold of the 10-fold CV)
# Since all models only include 1 variable, VIF is not possible to calculate
maxVIF_staph_LUR2_subsetA <- max(vif(finalBestModel_staph_LUR2_subsetA))
maxVIF_staph_LUR2_subsetB <- max(vif(finalBestModel_staph_LUR2_subsetB))
maxVIF_staph_LUR2_subsetC <- max(vif(finalBestModel_staph_LUR2_subsetC))
maxVIF_staph_LUR2_subsetD <- max(vif(finalBestModel_staph_LUR2_subsetD))
maxVIF_staph_LUR2_subsetE <- max(vif(finalBestModel_staph_LUR2_subsetE))
maxVIF_staph_LUR2_subsetF <- max(vif(finalBestModel_staph_LUR2_subsetF))
maxVIF_staph_LUR2_subsetG <- max(vif(finalBestModel_staph_LUR2_subsetG))
maxVIF_staph_LUR2_subsetH <- max(vif(finalBestModel_staph_LUR2_subsetH))
maxVIF_staph_LUR2_subsetI <- max(vif(finalBestModel_staph_LUR2_subsetI))
maxVIF_staph_LUR2_subsetJ <- max(vif(finalBestModel_staph_LUR2_subsetJ))

maxCD_staph_LUR2_subsetA <- max(cooks.distance(finalBestModel_staph_LUR2_subsetA))
maxCD_staph_LUR2_subsetB <- max(cooks.distance(finalBestModel_staph_LUR2_subsetB))
maxCD_staph_LUR2_subsetC <- max(cooks.distance(finalBestModel_staph_LUR2_subsetC))
maxCD_staph_LUR2_subsetD <- max(cooks.distance(finalBestModel_staph_LUR2_subsetD))
maxCD_staph_LUR2_subsetE <- max(cooks.distance(finalBestModel_staph_LUR2_subsetE))
maxCD_staph_LUR2_subsetF <- max(cooks.distance(finalBestModel_staph_LUR2_subsetF))
maxCD_staph_LUR2_subsetG <- max(cooks.distance(finalBestModel_staph_LUR2_subsetG))
maxCD_staph_LUR2_subsetH <- max(cooks.distance(finalBestModel_staph_LUR2_subsetH))
maxCD_staph_LUR2_subsetI <- max(cooks.distance(finalBestModel_staph_LUR2_subsetI))
maxCD_staph_LUR2_subsetJ <- max(cooks.distance(finalBestModel_staph_LUR2_subsetJ))

# Write out the max VIF and cook's distance figures for each of the 10 folds, and create a dataframe 

staph_LUR2_maxVIF_subsetvalID1to10 <- c(maxVIF_staph_LUR2_subsetA, maxVIF_staph_LUR2_subsetB, maxVIF_staph_LUR2_subsetC, maxVIF_staph_LUR2_subsetD, maxVIF_staph_LUR2_subsetE, maxVIF_staph_LUR2_subsetF, maxVIF_staph_LUR2_subsetG, maxVIF_staph_LUR2_subsetH, maxVIF_staph_LUR2_subsetI, maxVIF_staph_LUR2_subsetJ)

staph_LUR2_maxCD_maxCD_subsetvalID1to10 <- c(maxCD_staph_LUR2_subsetA, maxCD_staph_LUR2_subsetB, maxCD_staph_LUR2_subsetC, maxCD_staph_LUR2_subsetD, maxCD_staph_LUR2_subsetE, maxCD_staph_LUR2_subsetF, maxCD_staph_LUR2_subsetG, maxCD_staph_LUR2_subsetH, maxCD_staph_LUR2_subsetI, maxCD_staph_LUR2_subsetJ)

staph_LUR2_maxVIF_maxCD_matrix <- cbind(staph_LUR2_maxVIF_subsetvalID1to10, staph_LUR2_maxCD_maxCD_subsetvalID1to10)
staph_LUR2_maxVIF_maxCD_df <- as.data.frame(staph_LUR2_maxVIF_maxCD_matrix)

row.names(staph_LUR2_maxVIF_maxCD_df) <- c("SubsetA", "SubsetB", "SubsetC", "SubsetD", "SubsetE", "SubsetF", "SubsetG", "SubsetH", "SubsetI", "SubsetJ")

write_xlsx(staph_LUR2_maxVIF_maxCD_df,"Output_files\\staph_LUR2_maxVIF_maxCD_df.xlsx")

#  Merging of all test sets to make overall comparisons of predicted vs observed
VGOB1_subsetvalID1to10_staph_LUR2_10foldCV <- rbind(VGOB1_subsetvalID1_staph_LUR2, VGOB1_subsetvalID2_staph_LUR2, VGOB1_subsetvalID3_staph_LUR2, VGOB1_subsetvalID4_staph_LUR2, VGOB1_subsetvalID5_staph_LUR2, VGOB1_subsetvalID6_staph_LUR2, VGOB1_subsetvalID7_staph_LUR2, VGOB1_subsetvalID8_staph_LUR2, VGOB1_subsetvalID9_staph_LUR2, VGOB1_subsetvalID10_staph_LUR2)

#  Overall comparison of predicted vs observed
plot(VGOB1_subsetvalID1to10_staph_LUR2_10foldCV$staph_PRED_HV, VGOB1_subsetvalID1to10_staph_LUR2_10foldCV$staph_copiespm3.ln.diffmeth.mean, xlab="LUR2-predicted staph DNA concentration (ln copies/m^3)", ylab="Observed staph DNA concentration (ln copies/m^3)", cex.lab=0.85)
abline(lm(VGOB1_subsetvalID1to10_staph_LUR2_10foldCV$staph_copiespm3.ln.diffmeth.mean ~ VGOB1_subsetvalID1to10_staph_LUR2_10foldCV$staph_PRED_HV))

VGOB1_subsetvalID1to10_staph_LUR2_10foldCV_lm <- lm(staph_copiespm3.ln.diffmeth.mean ~ staph_PRED_HV, data=VGOB1_subsetvalID1to10_staph_LUR2_10foldCV)
summary(VGOB1_subsetvalID1to10_staph_LUR2_10foldCV_lm)

# Check cook's distance
# Calculate Cook's distance
cooks_d <- cooks.distance(VGOB1_subsetvalID1to10_staph_LUR2_10foldCV_lm)

# Plot Cook's distance
plot(cooks_d, pch=19, main="Cook's distance plot", xlab="Observation index", ylab="Cook's distance")
abline(h = 1, col="red")
# no CD scores are > 1

# 10-fold CV multiple R2 for Staph LUR2 = 0.1002

#  Calculate RMSE
RMSE_staph_LUR2_10foldCV <- sqrt(mean((VGOB1_subsetvalID1to10_staph_LUR2_10foldCV$staph_copiespm3.ln.diffmeth.mean - VGOB1_subsetvalID1to10_staph_LUR2_10foldCV$staph_PRED_HV)^2))
RMSE_staph_LUR2_10foldCV

# 10-fold CV RMSE = 1.170213

#  Save these predicted concentrations as an excel file along with the actual measured concentrations of staph at each of the measurement sites 
#  These are the predicted concentrations for the sites that were left out of the model training procedure in 10-fold cross validation 
staph_LUR2_10foldCV_preds <- VGOB1_subsetvalID1to10_staph_LUR2_10foldCV$staph_PRED_HV 
#  These are the actual measured concentrations at the 61 measurement sites - these are in the same order as the above sites in order to match the predicted concentrations (i.e. not in order 1-61)
VGOB1_subsetvalID1to10_staph_LUR2_10foldCV$staph_copiespm3.ln.diffmeth.mean

VGOB1_subsetvalID1to10_staph_LUR2_10foldCV$Loc_ID

#  Create a dataframe 
staph_SLR_10foldCVpreds_observed <- data.frame(VGOB1_subsetvalID1to10_staph_LUR2_10foldCV$Loc_ID,VGOB1_subsetvalID1to10_staph_LUR2_10foldCV$staph_copiespm3.ln.diffmeth.mean, VGOB1_subsetvalID1to10_staph_LUR2_10foldCV$staph_PRED_HV)
print(staph_SLR_10foldCVpreds_observed)

#  Save as xls file 
write_xlsx(staph_SLR_10foldCVpreds_observed,"Output_files//staph_LUR2_10foldCV_observed_predicted.xlsx")
```
#  Staph LUR3 - training model
```{r}
#  This is the df with the predictors to be entered into model 3
Measurements_livestockpreds_LUR3 <- read.csv("Input_files//Measurements_livestockpreds_LUR3.csv")
Measurements_livestockpreds_LUR3 

#  Now set the values of some variables that will be needed
nfirstvar_LUR_3 <- 6  #  given that the list of explanatory variables is at the end of the table: specify in which row the first explanatory variable is
nlastvar_LUR_3 <- 138

#  Function building to run the models
models<-list()
#
modeln<-1
models[[modeln]]<-list()

R2<-1
betaaddedvar<-1
addedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_3:nlastvar_LUR_3){
  if (is.numeric(Measurements_livestockpreds_LUR3[,i])==TRUE){
    modeltry<-lm(staph~Measurements_livestockpreds_LUR3[,i])
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])#
    # find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # Measurements_livestockpreds_LUR3[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR3)[i]
    addedvar<-rbind(addedvar,names(Measurements_livestockpreds_LUR3)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)
models[[modeln]]$results

#  this are the candidates models with the highest R2, not a negative beta for the new, nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)
models[[modeln]]$resultspos

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))
models[[modeln]]$resultspos

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j
models[[modeln]]$indexbestmodel

subset(models[[modeln]]$resultspos, rank==1)
subset(models[[modeln]]$resultspos)

#  this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]
models[[modeln]]$summarybestmodel

# here are the names
models[[modeln]]$namesbestmodel<-c(names(Measurements_livestockpreds_LUR3)[models[[1]]$indexbestmodel])
models[[modeln]]$namesbestmodel

# this is the r2 of that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2
models[[modeln]]$R2bestmodel

# this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(staph~Measurements_livestockpreds_LUR3[,models[[1]]$indexbestmodel])
models[[modeln]]$bestmodel

summary(models[[modeln]]$bestmodel)

#  The first model includes the predictor: nPigMultipFarmWghtDist.3000m.sum.Tr.1P9 - meaning the number of multiplier pig farms weighted to distance in a 3000m buffer

#  2 #

#  Add 2nd variable (the only difference of the above part is that now modeln=2 the model statement has 2 variables)
#  and the cAll for the list of variable names in the model changed slightly

modeln<-2

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_3:nlastvar_LUR_3){
  if (is.numeric(Measurements_livestockpreds_LUR3[,i])==TRUE){
    modeltry<-lm(staph~Measurements_livestockpreds_LUR3[,models[[1]]$indexbestmodel]+ Measurements_livestockpreds_LUR3[,i])
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])#
    # find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # Measurements_livestockpreds_LUR3[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR3)[i]
    addedvar<-rbind(addedvar,names(Measurements_livestockpreds_LUR3)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  these are the candidate models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)
models[[modeln]]$resultspos

#  rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))
models[[modeln]]$resultspos

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j
models[[modeln]]$indexbestmodel

subset(models[[modeln]]$resultspos, rank==1)

# this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]
models[[modeln]]$summarybestmodel

# here are the names
models[[modeln]]$namesbestmodel<-c(names(Measurements_livestockpreds_LUR3)[models[[1]]$indexbestmodel], names(Measurements_livestockpreds_LUR3)[models[[2]]$indexbestmodel] )
models[[modeln]]$namesbestmodel

# this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2
models[[modeln]]$R2bestmodel

# this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(staph~Measurements_livestockpreds_LUR3[,models[[1]]$indexbestmodel]+Measurements_livestockpreds_LUR3[,models[[2]]$indexbestmodel])
models[[modeln]]$bestmodel

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel

models[[1]]$namesbestmodel
models[[2]]$namesbestmodel

models[[1]]$R2bestmodel
models[[2]]$R2bestmodel

#  at this point I always check whether the next model (with 2 variables) is more than 1% better than the one before and if not I end here
#  R2 of the second model is higher than the 1st model, so 2nd is better

#  3 #
#  add third variable (the only difference of the above part is that now modeln=3 the model statement has 3 variables)
#  and the cAll for the list of variable names in the model changed slightly

modeln<-3

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_3:nlastvar_LUR_3){
  if (is.numeric(Measurements_livestockpreds_LUR3[,i])==TRUE){
    modeltry<-lm(staph~Measurements_livestockpreds_LUR3[,models[[1]]$indexbestmodel]+Measurements_livestockpreds_LUR3[,models[[2]]$indexbestmodel]+ Measurements_livestockpreds_LUR3[,i])
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    #  the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    #  All[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR3)[i]
    addedvar<-rbind(addedvar,names(Measurements_livestockpreds_LUR3)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

#  rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))


#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

#  this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

#  here are the names
models[[modeln]]$namesbestmodel<-c(names(Measurements_livestockpreds_LUR3)[models[[1]]$indexbestmodel], names(Measurements_livestockpreds_LUR3)[models[[2]]$indexbestmodel] , names(Measurements_livestockpreds_LUR3)[models[[3]]$indexbestmodel])

#  this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(staph~Measurements_livestockpreds_LUR3[,models[[1]]$indexbestmodel]+Measurements_livestockpreds_LUR3[,models[[2]]$indexbestmodel]+Measurements_livestockpreds_LUR3[,models[[3]]$indexbestmodel])

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel

models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel

models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel

#  Yes R^2 increases >1%

#  4 #

#  add forth variable (the only difference of the above part is that now model n=4 the model statement more variables)
#  and the cAll for the list of variable names in the model changed slightly
modeln<-4

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1


for (i in nfirstvar_LUR_3:nlastvar_LUR_3){
  if (is.numeric(Measurements_livestockpreds_LUR3[,i])==TRUE){
    modeltry<-lm(staph~Measurements_livestockpreds_LUR3[,models[[1]]$indexbestmodel]+Measurements_livestockpreds_LUR3[,models[[2]]$indexbestmodel]+Measurements_livestockpreds_LUR3[,models[[3]]$indexbestmodel]+Measurements_livestockpreds_LUR3[,i])
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])#
    # find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # All[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR3)[i]
    addedvar<-rbind(addedvar,names(Measurements_livestockpreds_LUR3)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

# this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

# here are the names
models[[modeln]]$namesbestmodel<-c(names(Measurements_livestockpreds_LUR3)[models[[1]]$indexbestmodel], names(Measurements_livestockpreds_LUR3)[models[[2]]$indexbestmodel] , names(Measurements_livestockpreds_LUR3)[models[[3]]$indexbestmodel], names(Measurements_livestockpreds_LUR3)[models[[4]]$indexbestmodel])

# this is the r2 of that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

# this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(staph~Measurements_livestockpreds_LUR3[,models[[1]]$indexbestmodel]+Measurements_livestockpreds_LUR3[,models[[2]]$indexbestmodel]+Measurements_livestockpreds_LUR3[,models[[3]]$indexbestmodel]+ Measurements_livestockpreds_LUR3[,models[[4]]$indexbestmodel])


models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel

#  at this point I always check whether the next model is more than 1% better than the one before and if not I end here
#  Yes model 4 is 5.51514% better than model 3 therefore I continue


#  5 #
#  add fifth variable (the only difference of the above part is that now modeln=5 the model statement more variables)
#  and the cAll for the list of variable names in the model changed slightly
modeln<-5

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_3:nlastvar_LUR_3){
  if (is.numeric(Measurements_livestockpreds_LUR3[,i])==TRUE){
    modeltry<-lm(staph~Measurements_livestockpreds_LUR3[,models[[1]]$indexbestmodel]+Measurements_livestockpreds_LUR3[,models[[2]]$indexbestmodel]+Measurements_livestockpreds_LUR3[,models[[3]]$indexbestmodel]+Measurements_livestockpreds_LUR3[,models[[4]]$indexbestmodel]+ Measurements_livestockpreds_LUR3[,i])
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])#
    # find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # All[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR3)[i]
    addedvar<-rbind(addedvar,names(Measurements_livestockpreds_LUR3)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

#  this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

# here are the names
models[[modeln]]$namesbestmodel<-c(names(Measurements_livestockpreds_LUR3)[models[[1]]$indexbestmodel], names(Measurements_livestockpreds_LUR3)[models[[2]]$indexbestmodel] , names(Measurements_livestockpreds_LUR3)[models[[3]]$indexbestmodel], names(Measurements_livestockpreds_LUR3)[models[[4]]$indexbestmodel], names(Measurements_livestockpreds_LUR3)[models[[5]]$indexbestmodel])


# this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

# this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(staph~Measurements_livestockpreds_LUR3[,models[[1]]$indexbestmodel]+Measurements_livestockpreds_LUR3[,models[[2]]$indexbestmodel]+Measurements_livestockpreds_LUR3[,models[[3]]$indexbestmodel]+ Measurements_livestockpreds_LUR3[,models[[4]]$indexbestmodel]+ Measurements_livestockpreds_LUR3[,models[[5]]$indexbestmodel])


models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[5]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[5]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel
models[[5]]$R2bestmodel

#  at this point I always check whether the next model is more than 1% better than the one before and if not I end here
#  Yes model 5 is 1.41754% better than model 4 therefore I continue

#  6 #
#  add sixth variable (the only difference of the above part is that now modeln=6 the modelstatement more variables)
#  and the cAll for the list of variable names in the model changed slightly

modeln<-6

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_3 :nlastvar_LUR_3){
  if (is.numeric(Measurements_livestockpreds_LUR3[,i])==TRUE){
    modeltry<-lm(staph~Measurements_livestockpreds_LUR3[,models[[1]]$indexbestmodel]+Measurements_livestockpreds_LUR3[,models[[2]]$indexbestmodel]+Measurements_livestockpreds_LUR3[,models[[3]]$indexbestmodel]+Measurements_livestockpreds_LUR3[,models[[4]]$indexbestmodel]+Measurements_livestockpreds_LUR3[,models[[5]]$indexbestmodel]+ Measurements_livestockpreds_LUR3[,i])
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])#
    # find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # All[,i] is the row that's being tried out now. the name of that row can be found in  names(All)[i]
    addedvar<-rbind(addedvar,names(Measurements_livestockpreds_LUR3)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

# this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

# here are the names
models[[modeln]]$namesbestmodel<-c(names(Measurements_livestockpreds_LUR3)[models[[1]]$indexbestmodel], names(Measurements_livestockpreds_LUR3)[models[[2]]$indexbestmodel] , names(Measurements_livestockpreds_LUR3)[models[[3]]$indexbestmodel], names(Measurements_livestockpreds_LUR3)[models[[4]]$indexbestmodel], names(Measurements_livestockpreds_LUR3)[models[[5]]$indexbestmodel], names(Measurements_livestockpreds_LUR3)[models[[6]]$indexbestmodel])

# this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

# this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(staph~Measurements_livestockpreds_LUR3[,models[[1]]$indexbestmodel]+Measurements_livestockpreds_LUR3[,models[[2]]$indexbestmodel]+Measurements_livestockpreds_LUR3[,models[[3]]$indexbestmodel]+ Measurements_livestockpreds_LUR3[,models[[4]]$indexbestmodel]+ Measurements_livestockpreds_LUR3[,models[[5]]$indexbestmodel]+ Measurements_livestockpreds_LUR3[,models[[6]]$indexbestmodel])

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[5]]$summarybestmodel
models[[6]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[5]]$namesbestmodel
models[[6]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel
models[[5]]$R2bestmodel
models[[6]]$R2bestmodel

#  at this point I always check whether the next model is more than 1% better than the one before and if not I end here
#  Yes R^2 increases by 3.18123% from model 5 to model 6
#  Therefore I will continue and add another variable!

#  7 #
#  add seventh variable (the only difference of the above part is that now modeln=7 the modelstatement more variables)
#  and the cAll for the list of variable names in the model changed slightly

modeln<-7

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_3 :nlastvar_LUR_3){
  if (is.numeric(Measurements_livestockpreds_LUR3[,i])==TRUE){
    modeltry<-lm(staph~Measurements_livestockpreds_LUR3[,models[[1]]$indexbestmodel]+Measurements_livestockpreds_LUR3[,models[[2]]$indexbestmodel]+Measurements_livestockpreds_LUR3[,models[[3]]$indexbestmodel]+Measurements_livestockpreds_LUR3[,models[[4]]$indexbestmodel]+Measurements_livestockpreds_LUR3[,models[[5]]$indexbestmodel]+Measurements_livestockpreds_LUR3[,models[[6]]$indexbestmodel]+ Measurements_livestockpreds_LUR3[,i])
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])#
    # find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # Measurements_livestockpreds_LUR3[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR3)[i]
    addedvar<-rbind(addedvar,names(Measurements_livestockpreds_LUR3)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

# this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

# here are the names
models[[modeln]]$namesbestmodel<-c(names(Measurements_livestockpreds_LUR3)[models[[1]]$indexbestmodel], names(Measurements_livestockpreds_LUR3)[models[[2]]$indexbestmodel] , names(Measurements_livestockpreds_LUR3)[models[[3]]$indexbestmodel], names(Measurements_livestockpreds_LUR3)[models[[4]]$indexbestmodel], names(Measurements_livestockpreds_LUR3)[models[[5]]$indexbestmodel], names(Measurements_livestockpreds_LUR3)[models[[6]]$indexbestmodel],
names(Measurements_livestockpreds_LUR3)[models[[7]]$indexbestmodel])

# this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

# this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(staph~Measurements_livestockpreds_LUR3[,models[[1]]$indexbestmodel]+Measurements_livestockpreds_LUR3[,models[[2]]$indexbestmodel]+Measurements_livestockpreds_LUR3[,models[[3]]$indexbestmodel]+ Measurements_livestockpreds_LUR3[,models[[4]]$indexbestmodel]+ Measurements_livestockpreds_LUR3[,models[[5]]$indexbestmodel]+ Measurements_livestockpreds_LUR3[,models[[6]]$indexbestmodel]+
Measurements_livestockpreds_LUR3[,models[[7]]$indexbestmodel])

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[5]]$summarybestmodel
models[[6]]$summarybestmodel
models[[7]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[5]]$namesbestmodel
models[[6]]$namesbestmodel
models[[7]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel
models[[5]]$R2bestmodel
models[[6]]$R2bestmodel
models[[7]]$R2bestmodel

#  R^2 increases again by  3.69523%
#  I continue!


#  8 #
#  add eighth variable (the only difference of the above part is that now modeln=8 the modelstatement more variables)
#  and the cAll for the list of variable names in the model changed slightly

modeln<-8

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_3 :nlastvar_LUR_3){
  if (is.numeric(Measurements_livestockpreds_LUR3[,i])==TRUE){
    modeltry<-lm(staph~Measurements_livestockpreds_LUR3[,models[[1]]$indexbestmodel]+Measurements_livestockpreds_LUR3[,models[[2]]$indexbestmodel]+Measurements_livestockpreds_LUR3[,models[[3]]$indexbestmodel]+Measurements_livestockpreds_LUR3[,models[[4]]$indexbestmodel]+Measurements_livestockpreds_LUR3[,models[[5]]$indexbestmodel]+Measurements_livestockpreds_LUR3[,models[[6]]$indexbestmodel]+ Measurements_livestockpreds_LUR3[,models[[7]]$indexbestmodel]+ Measurements_livestockpreds_LUR3[,i])
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])#
    # find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # Measurements_livestockpreds_LUR3[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR3)[i]
    addedvar<-rbind(addedvar,names(Measurements_livestockpreds_LUR3)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

# this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

# here are the names
models[[modeln]]$namesbestmodel<-c(names(Measurements_livestockpreds_LUR3)[models[[1]]$indexbestmodel], names(Measurements_livestockpreds_LUR3)[models[[2]]$indexbestmodel] , names(Measurements_livestockpreds_LUR3)[models[[3]]$indexbestmodel], names(Measurements_livestockpreds_LUR3)[models[[4]]$indexbestmodel], names(Measurements_livestockpreds_LUR3)[models[[5]]$indexbestmodel], names(Measurements_livestockpreds_LUR3)[models[[6]]$indexbestmodel],
names(Measurements_livestockpreds_LUR3)[models[[7]]$indexbestmodel],
names(Measurements_livestockpreds_LUR3)[models[[8]]$indexbestmodel] )

# this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

# this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(staph~Measurements_livestockpreds_LUR3[,models[[1]]$indexbestmodel]+Measurements_livestockpreds_LUR3[,models[[2]]$indexbestmodel]+Measurements_livestockpreds_LUR3[,models[[3]]$indexbestmodel]+ Measurements_livestockpreds_LUR3[,models[[4]]$indexbestmodel]+ Measurements_livestockpreds_LUR3[,models[[5]]$indexbestmodel]+ Measurements_livestockpreds_LUR3[,models[[6]]$indexbestmodel]+
Measurements_livestockpreds_LUR3[,models[[7]]$indexbestmodel] +Measurements_livestockpreds_LUR3[,models[[8]]$indexbestmodel])

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[5]]$summarybestmodel
models[[6]]$summarybestmodel
models[[7]]$summarybestmodel
models[[8]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[5]]$namesbestmodel
models[[6]]$namesbestmodel
models[[7]]$namesbestmodel
models[[8]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel
models[[5]]$R2bestmodel
models[[6]]$R2bestmodel
models[[7]]$R2bestmodel
models[[8]]$R2bestmodel

#  R^2 decreases from model 7 to 8 now
#  I will try a few more models for the algorithm

#  9 #

modeln<-9

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_3 :nlastvar_LUR_3){
  if (is.numeric(Measurements_livestockpreds_LUR3[,i])==TRUE){
    modeltry<-lm(staph~Measurements_livestockpreds_LUR3[,models[[1]]$indexbestmodel]+Measurements_livestockpreds_LUR3[,models[[2]]$indexbestmodel]+Measurements_livestockpreds_LUR3[,models[[3]]$indexbestmodel]+Measurements_livestockpreds_LUR3[,models[[4]]$indexbestmodel]+Measurements_livestockpreds_LUR3[,models[[5]]$indexbestmodel]+ Measurements_livestockpreds_LUR3[,models[[6]]$indexbestmodel]+ Measurements_livestockpreds_LUR3[,models[[7]]$indexbestmodel]+ Measurements_livestockpreds_LUR3[,models[[8]]$indexbestmodel]+ Measurements_livestockpreds_LUR3[,i])
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])#
    # find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # Measurements_livestockpreds_LUR2[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR2)[i]
    addedvar<-rbind(addedvar,names(Measurements_livestockpreds_LUR3)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

# this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

# here are the names
models[[modeln]]$namesbestmodel<-c(names(Measurements_livestockpreds_LUR3)[models[[1]]$indexbestmodel], names(Measurements_livestockpreds_LUR3)[models[[2]]$indexbestmodel] , names(Measurements_livestockpreds_LUR3)[models[[3]]$indexbestmodel], names(Measurements_livestockpreds_LUR3)[models[[4]]$indexbestmodel], names(Measurements_livestockpreds_LUR3)[models[[5]]$indexbestmodel], names(Measurements_livestockpreds_LUR3)[models[[6]]$indexbestmodel], names(Measurements_livestockpreds_LUR3)[models[[7]]$indexbestmodel], names(Measurements_livestockpreds_LUR3)[models[[8]]$indexbestmodel], names(Measurements_livestockpreds_LUR3)[models[[9]]$indexbestmodel])

# this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

# this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(staph~Measurements_livestockpreds_LUR3[,models[[1]]$indexbestmodel]+Measurements_livestockpreds_LUR3[,models[[2]]$indexbestmodel]+Measurements_livestockpreds_LUR3[,models[[3]]$indexbestmodel]+ Measurements_livestockpreds_LUR3[,models[[4]]$indexbestmodel]+ Measurements_livestockpreds_LUR3[,models[[5]]$indexbestmodel]+ Measurements_livestockpreds_LUR3[,models[[6]]$indexbestmodel]+ Measurements_livestockpreds_LUR3[,models[[7]]$indexbestmodel]+ Measurements_livestockpreds_LUR3[,models[[8]]$indexbestmodel]+ Measurements_livestockpreds_LUR3[,models[[9]]$indexbestmodel])

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[5]]$summarybestmodel
models[[6]]$summarybestmodel
models[[7]]$summarybestmodel
models[[8]]$summarybestmodel
models[[9]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[5]]$namesbestmodel
models[[6]]$namesbestmodel
models[[7]]$namesbestmodel
models[[8]]$namesbestmodel
models[[9]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel
models[[5]]$R2bestmodel
models[[6]]$R2bestmodel
models[[7]]$R2bestmodel
models[[8]]$R2bestmodel
models[[9]]$R2bestmodel


#  at this point I always check wether the nextmodel is more than 1%better than the one before and if not I end here
#  last step is to exclude All var with p>0.1 one by one with the lowest p first, until All <0.1.

#  10 #
modeln<-10

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_3 :nlastvar_LUR_3){
  if (is.numeric(Measurements_livestockpreds_LUR3[,i])==TRUE){
    modeltry<-lm(staph~Measurements_livestockpreds_LUR3[,models[[1]]$indexbestmodel]+Measurements_livestockpreds_LUR3[,models[[2]]$indexbestmodel]+Measurements_livestockpreds_LUR3[,models[[3]]$indexbestmodel]+Measurements_livestockpreds_LUR3[,models[[4]]$indexbestmodel]+Measurements_livestockpreds_LUR3[,models[[5]]$indexbestmodel]+ Measurements_livestockpreds_LUR3[,models[[6]]$indexbestmodel]+ Measurements_livestockpreds_LUR3[,models[[7]]$indexbestmodel]+ Measurements_livestockpreds_LUR3[,models[[8]]$indexbestmodel]+ Measurements_livestockpreds_LUR3[,models[[9]]$indexbestmodel]+ Measurements_livestockpreds_LUR3[,i])
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])#
    # find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # Measurements_livestockpreds_LUR2[,i] is the row that's being tried out now. the name of that row can be found in  names(All)[i]
    addedvar<-rbind(addedvar,names(Measurements_livestockpreds_LUR3)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

# this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

# here are the names
models[[modeln]]$namesbestmodel<-c(names(Measurements_livestockpreds_LUR2)[models[[1]]$indexbestmodel], names(Measurements_livestockpreds_LUR3)[models[[2]]$indexbestmodel] , names(Measurements_livestockpreds_LUR3)[models[[3]]$indexbestmodel], names(Measurements_livestockpreds_LUR3)[models[[4]]$indexbestmodel], names(Measurements_livestockpreds_LUR3)[models[[5]]$indexbestmodel], names(Measurements_livestockpreds_LUR3)[models[[6]]$indexbestmodel], names(Measurements_livestockpreds_LUR3)[models[[7]]$indexbestmodel], names(Measurements_livestockpreds_LUR3)[models[[8]]$indexbestmodel], names(Measurements_livestockpreds_LUR3)[models[[9]]$indexbestmodel], names(Measurements_livestockpreds_LUR3)[models[[10]]$indexbestmodel])

# this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

# this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(staph~Measurements_livestockpreds_LUR3[,models[[1]]$indexbestmodel]+Measurements_livestockpreds_LUR3[,models[[2]]$indexbestmodel]+Measurements_livestockpreds_LUR3[,models[[3]]$indexbestmodel]+ Measurements_livestockpreds_LUR3[,models[[4]]$indexbestmodel]+ Measurements_livestockpreds_LUR3[,models[[5]]$indexbestmodel]+ Measurements_livestockpreds_LUR3[,models[[6]]$indexbestmodel]+ Measurements_livestockpreds_LUR3[,models[[7]]$indexbestmodel]+ Measurements_livestockpreds_LUR3[,models[[8]]$indexbestmodel]+ Measurements_livestockpreds_LUR3[,models[[9]]$indexbestmodel]+ Measurements_livestockpreds_LUR3[,models[[10]]$indexbestmodel])

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[5]]$summarybestmodel
models[[6]]$summarybestmodel
models[[7]]$summarybestmodel
models[[8]]$summarybestmodel
models[[9]]$summarybestmodel
models[[10]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[5]]$namesbestmodel
models[[6]]$namesbestmodel
models[[7]]$namesbestmodel
models[[8]]$namesbestmodel
models[[9]]$namesbestmodel
models[[10]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel
models[[5]]$R2bestmodel
models[[6]]$R2bestmodel
models[[7]]$R2bestmodel
models[[8]]$R2bestmodel
models[[9]]$R2bestmodel
models[[10]]$R2bestmodel


#  CODE FOR PICKING OUT THE BEST MODEL #
temp <- 0
besti <- 0
for (i in 1:10){ #  think this runs the loop 10 times - not fully sure thought - but not to do with the number of models I don't think - as when I change to 3, I still get the model with 4 variables as best model
  print(models[[i]]$R2bestmodel)
  #       print(models[[i]]$summarybestmodel$coefficients=-1,4])
  #       if((models[[i]]$R2bestmodel-temp > 0.0) && (all(models[[i]]$summarybestmodel$coefficients[-1,4]<0.1))){
  #         temp <- models[[i]]$R2bestmodel
  #         besti <- i
  #         }
  if((models[[i]]$R2bestmodel-temp > 0.0) && (all(models[[i]]$summarybestmodel$coefficients[-1,4]<0.1))){
    temp <- models[[i]]$R2bestmodel
    besti <- i
  }else{
    finalBestModel_staph_LUR3 <- models[[besti]]$bestmodel
    finalBestModelNames_staph_LUR3 <- models[[besti]]$namesbestmodel
    Sites <- 1:dim(Measurements_livestockpreds_LUR3)[1] # full original model
    #  CVaR2<-escCV_staph_LUR3(Sites)[2] # Cross Validation
    maxCD<-max(cooks.distance(finalBestModel_staph_LUR3))
    if(length(finalBestModelNames_staph_LUR3)<2){ # vif fn doesnot work when only 1 variable...       #
      maxVIF<-"NA"
    }else{
      maxVIF<-max(vif(finalBestModel_staph_LUR3))
    }
    print(paste("This is the best staph LUR model 3: ",besti,
                "(AdjR2: ",format(models[[besti]]$R2bestmodel,digits=3), "; MaxCD: ",format(maxCD,digits=3),"; MaxVIF: ",
                format(maxVIF,digits=3),")", sep=''))
    print(finalBestModelNames_staph_LUR3)
    break
  }
}


#  This is the model
staph_LUR3_algorithmmethod <- lm(staph_copiespm3.ln.diffmeth.mean~ PoultryFarm.3000m.95Win.10to90scaled + nsowsWghtDist.1000m.sum.95Win.10to90scaled + HorseFarm.3000m.95Win.10to90scaled + notherpoultryanimWghtDist.3000m.sum.95Win.10to90scaled, data = Measurements_livestockpreds_LUR3) 

summary(staph_LUR3_algorithmmethod)

# Calculate RMSE
predicted_staph_LUR3 <- predict(staph_LUR3_algorithmmethod, Measurements_livestockpreds_LUR3)
RMSE_staph_LUR3 <- sqrt(mean((Measurements_livestockpreds_LUR3$staph_copiespm3.ln.diffmeth.mean - predicted_staph_LUR3)^2))
RMSE_staph_LUR3

#  Save these predicted concentrations along with the measured concentrations as an excel file 
#  Create a dataframe 
staph_LUR3_preds_observed <- data.frame(Measurements_livestockpreds_LUR3$Loc_ID,Measurements_livestockpreds_LUR3$staph_copiespm3.ln.diffmeth.mean, predicted_staph_LUR3)
print(staph_LUR3_preds_observed)

#  Save as xls file 
write_xlsx(staph_LUR3_preds_observed,"Output_files//staph_LUR3_preds_observed.xlsx")


#  MODEL CHECKING #
#  1)Check normality of residuals
#  2)Check residuals for linearity, independence and homoscedasticity
#  3)Check multicollinearity (VIF)
#  4)Check influential points (Cook's Distance)

#  1) Normality of residuals
boxplot(residuals(staph_LUR3_algorithmmethod),main="boxplot of residuals - staph LUR model 3",xlab="LUR2 model residuals")
qqnorm(residuals(staph_LUR3_algorithmmethod),main="QQ-plot of residuals - staph LUR model 3",xlab="LUR2 model residuals")

#  2)Check residuals for linearity, independence and homoscedasticity
plot(fitted(staph_LUR3_algorithmmethod),residuals(staph_LUR3_algorithmmethod))

#  3)Check multicollinearity (VIF)
maxvif_staph_LUR3 <- max(vif(staph_LUR3_algorithmmethod))
maxvif_staph_LUR3

#  4)Check influential points (Cook's Distance)
ols_plot_cooksd_bar(staph_LUR3_algorithmmethod, print_plot = TRUE)
maxCD_staph_LUR3<-max(cooks.distance(staph_LUR3_algorithmmethod))
maxCD_staph_LUR3
#  won't remove any outliers - none with cook's d > 1

```

# Staph LUR3 model - LOOCV
```{r}
#  LOOCV - LUR3 model for staph
#  Leave one out cross validation - the goal of cross validation is to get a generalized score of the model. The reason for this generalization is to, hopefully, improve the model’s effectiveness in predicting on future data inputs.
#  It is a type of 'internal' cross validation
Measurements_livestockpreds_LUR3_LOOCV <- Measurements_livestockpreds_LUR3
set.seed(123)
Measurements_livestockpreds_LUR3_LOOCV$Staph_LUR3_LOOCV_preds <- unlist(lapply(1:nrow(Measurements_livestockpreds_LUR3_LOOCV),function(inx){
  train <- Measurements_livestockpreds_LUR3_LOOCV[-inx,,drop=FALSE]
  test <- Measurements_livestockpreds_LUR3_LOOCV[inx,,drop=FALSE]
  cvm <- lm(staph_copiespm3.ln.diffmeth.mean ~ PoultryFarm.3000m.95Win.10to90scaled + nsowsWghtDist.1000m.sum.95Win.10to90scaled + HorseFarm.3000m.95Win.10to90scaled + notherpoultryanimWghtDist.3000m.sum.95Win.10to90scaled, data=train)
  pred <- predict(cvm,newdata=test)
  return(pred)
}))

predicted_staph_LUR3_LOOCV <- Measurements_livestockpreds_LUR3_LOOCV$staph_LUR3_LOOCV_PRED

#  Save these predicted concentrations along with the measured concentrations as an excel file 
#  Create a dataframe 
staph_LUR3_LOOCV_preds_observed <- data.frame(Measurements_livestockpreds_LUR3_LOOCV$Loc_ID, Measurements_livestockpreds_LUR3_LOOCV$staph_copiespm3.ln.diffmeth.mean, Measurements_livestockpreds_LUR3_LOOCV$Staph_LUR3_LOOCV_preds)
print(staph_LUR3_LOOCV_preds_observed)

#  Save as xls file 
write_xlsx(staph_LUR3_LOOCV_preds_observed,"Output_files//staph_LUR3_LOOCV_preds_observed.xlsx")

# Compute the LOOCV model R2
staph_LUR3_LOOCV_lm <- lm(staph_copiespm3.ln.diffmeth.mean ~ Staph_LUR3_LOOCV_preds, data=Measurements_livestockpreds_LUR3_LOOCV)
summary(staph_LUR3_LOOCV_lm)
#  Staph LUR3 model LOOCV multiple R^2 = 0.3203\

# Calculate RMSE
preds_staph_LUR3_LOOCV <- predict(staph_LUR3_LOOCV_lm, Measurements_livestockpreds_LUR3_LOOCV)
RMSE_staph_LUR3_LOOCV <- sqrt(mean((Measurements_livestockpreds_LUR3_LOOCV$staph_copiespm3.ln.diffmeth.mean - preds_staph_LUR3_LOOCV)^2))
RMSE_staph_LUR3_LOOCV

#  Plot LOOCV estimations vs. observed concentrations
plot(Measurements_livestockpreds_LUR3_LOOCV$Staph_LUR3_LOOCV_preds, Measurements_livestockpreds_LUR3_LOOCV$staph_copiespm3.ln.diffmeth.mean)
abline(lm(Measurements_livestockpreds_LUR3_LOOCV$staph_copiespm3.ln.diffmeth.mean ~ Measurements_livestockpreds_LUR3_LOOCV$Staph_LUR3_LOOCV_preds))
```
# Staph LUR3 - 10-fold CV
```{r}
options(stringsAsFactors = FALSE) # so that dataframes are not opened in new tabs
# This is the required dataset
Measurements_livestockpreds_LUR3  

#  10-fold hold-out validation is done to assess model robustness. This is done using a random selection of 90% of the measurement sites. 
#  Part 1. Each measurement site gets randomly allocated number out of range 1-10
#  Completely randomly pulling sites
staph_HV_LUR3_df <- Measurements_livestockpreds_LUR3[c(1,3,6:138)] #  new df created with only staph values 
#  Create valID variable 
staph_HV_LUR3_df$valID <- 0
#  Draw 10 samples, thus on average 6 sites per test set (i.e 6 sites are removed from each model and then the model is tested on these 6 sites )
set.seed(123)
VGOB1_FINAL_staph_LUR3 <- c()
for (s in 1:1){
  if (s==1) set <- staph_HV_LUR3_df
  draws <- c(1:nrow(set))
  chosen <- c()
  tempdraws <- draws
  for (d in 1:10){
    list <- sample(tempdraws, length(tempdraws)/(11-d), FALSE)
    set[list,]$valID <- d
    chosen <- c(chosen, list)
    tempdraws <- draws[-chosen]
  }

#  Combine datasets to 1
VGOB1_FINAL_staph_LUR3 <- set
}

summary(set)
rm(set)

#  View the df created
str(VGOB1_FINAL_staph_LUR3, list.len=ncol(VGOB1_FINAL_staph_LUR3))
names(VGOB1_FINAL_staph_LUR3)
summary(VGOB1_FINAL_staph_LUR3)

#  Part 2: Make 10 subsets of dataset based on randomly allocated number (so these are the training datasets) 
#  Then create 10 subsets, each excluding 1 set of 10 sites
VGOB1_subsetA_staph_LUR3 <- subset(VGOB1_FINAL_staph_LUR3, valID != 1)
VGOB1_subsetB_staph_LUR3 <- subset(VGOB1_FINAL_staph_LUR3, valID != 2)  
VGOB1_subsetC_staph_LUR3 <- subset(VGOB1_FINAL_staph_LUR3, valID != 3)
VGOB1_subsetD_staph_LUR3 <- subset(VGOB1_FINAL_staph_LUR3, valID != 4)
VGOB1_subsetE_staph_LUR3 <- subset(VGOB1_FINAL_staph_LUR3, valID != 5)
VGOB1_subsetF_staph_LUR3 <- subset(VGOB1_FINAL_staph_LUR3, valID != 6)
VGOB1_subsetG_staph_LUR3 <- subset(VGOB1_FINAL_staph_LUR3, valID != 7)
VGOB1_subsetH_staph_LUR3 <- subset(VGOB1_FINAL_staph_LUR3, valID != 8)
VGOB1_subsetI_staph_LUR3 <- subset(VGOB1_FINAL_staph_LUR3, valID != 9)
VGOB1_subsetJ_staph_LUR3 <- subset(VGOB1_FINAL_staph_LUR3, valID != 10)

#  Part 3: Build for each subset a LUR model (i.e. go through the whole LUR model script for each subset (so each training set). Start with subset A, until final LUR model. Then subset B, until final LUR model etc.) 

#### A ####
# LUR model building process for subset A
#  This is the dataframe with the relevant predictor vars for LUR3 models for subset A (55 sites)
VGOB1_subsetA_staph_LUR3 # n.b. this dataframe only includes microbial marker concentrations for staph unlike the dataframe Measurements_livestockpreds_LUR3 as previously used for the model building. 
names(VGOB1_subsetA_staph_LUR3)
#  Now set the values of some variables that will be needed
nfirstvar_LUR_3 <- 3  
nlastvar_LUR_3 <- 135

# Function building to run the models 
# 1 #  

models<-list()
modeln<-1
models[[modeln]]<-list()

R2<-1
betaaddedvar<-1
addedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_3:nlastvar_LUR_3){
  if (is.numeric(VGOB1_subsetA_staph_LUR3[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetA_staph_LUR3$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetA_staph_LUR3[,i])                            
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    #  Measurements_livestockpreds_LUR3[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR3)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetA_staph_LUR3)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)
models[[modeln]]$results

#  this are the candidates models with the highest R2, not a negative beta for the new, nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)
models[[modeln]]$resultspos

#  rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))
models[[modeln]]$resultspos

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j
models[[modeln]]$indexbestmodel

subset(models[[modeln]]$resultspos, rank==1)
subset(models[[modeln]]$resultspos)

#  this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]
models[[modeln]]$summarybestmodel

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetA_staph_LUR3)[models[[1]]$indexbestmodel])
models[[modeln]]$namesbestmodel

#  this is the r2 of that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2
models[[modeln]]$R2bestmodel

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetA_staph_LUR3$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetA_staph_LUR3[,models[[1]]$indexbestmodel]) 
models[[modeln]]$bestmodel

summary(models[[modeln]]$bestmodel)

#  The first model includes the predictor: nPigMultipFarmWghtDist.3000m.sum.Tr.1P9 - meaning the number of multiplier pig farms weighted to distance in a 3000m buffer

# 2 #  
# Add 2nd variable (the only difference of the above part is that now modeln=2 the model statement has 2 variables)
# and the call for the list of variable names in the model changed slightly

modeln<-2

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_3:nlastvar_LUR_3){
  if (is.numeric(VGOB1_subsetA_staph_LUR3[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetA_staph_LUR3$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetA_staph_LUR3[,models[[1]]$indexbestmodel]+ VGOB1_subsetA_staph_LUR3[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # Measurements_livestockpreds_LUR3[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR3)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetA_staph_LUR3)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  these are the candidate models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)
models[[modeln]]$resultspos

#  rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))
models[[modeln]]$resultspos

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j
models[[modeln]]$indexbestmodel

subset(models[[modeln]]$resultspos, rank==1)

# this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]
models[[modeln]]$summarybestmodel

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetA_staph_LUR3)[models[[1]]$indexbestmodel], names(VGOB1_subsetA_staph_LUR3)[models[[2]]$indexbestmodel] )
models[[modeln]]$namesbestmodel

# this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2
models[[modeln]]$R2bestmodel

# this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetA_staph_LUR3$staph_copiespm3.ln.diffmeth.mean~                               VGOB1_subsetA_staph_LUR3[,models[[1]]$indexbestmodel]+                           VGOB1_subsetA_staph_LUR3[,models[[2]]$indexbestmodel]) 

models[[modeln]]$bestmodel

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel


# 3 #  
# add third variable (the only difference of the above part is that now modeln=3 the model statement has 3 variables)
# and the call for the list of variable names in the model changed slightly

modeln<-3

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_3:nlastvar_LUR_3){
  if (is.numeric(VGOB1_subsetA_staph_LUR3[,i])==TRUE){  
    modeltry<-lm(VGOB1_subsetA_staph_LUR3$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetA_staph_LUR3[,models[[1]]$indexbestmodel]+VGOB1_subsetA_staph_LUR3[,models[[2]]$indexbestmodel]+ VGOB1_subsetA_staph_LUR3[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # All[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR3)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetA_staph_LUR3)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

#  rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

#  this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

#  here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetA_staph_LUR3)[models[[1]]$indexbestmodel], names(VGOB1_subsetA_staph_LUR3)[models[[2]]$indexbestmodel], names(VGOB1_subsetA_staph_LUR3)[models[[3]]$indexbestmodel])

#  this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetA_staph_LUR3$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetA_staph_LUR3[,models[[1]]$indexbestmodel]+ VGOB1_subsetA_staph_LUR3[,models[[2]]$indexbestmodel]+ VGOB1_subsetA_staph_LUR3[,models[[3]]$indexbestmodel]) 

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel


# 4 #  
#  add forth variable (the only difference of the above part is that now model n=4 the model statement more variables)
#  and the call for the list of variable names in the model changed slightly
modeln<-4

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1


for (i in nfirstvar_LUR_3:nlastvar_LUR_3){
  if (is.numeric(VGOB1_subsetA_staph_LUR3[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetA_staph_LUR3$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetA_staph_LUR3[,models[[1]]$indexbestmodel]+VGOB1_subsetA_staph_LUR3[,models[[2]]$indexbestmodel]+VGOB1_subsetA_staph_LUR3[,models[[3]]$indexbestmodel]+VGOB1_subsetA_staph_LUR3[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    #  the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    #  All[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR3)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetA_staph_LUR3)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

#  this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

#  here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetA_staph_LUR3)[models[[1]]$indexbestmodel], names(VGOB1_subsetA_staph_LUR3)[models[[2]]$indexbestmodel], names(VGOB1_subsetA_staph_LUR3)[models[[3]]$indexbestmodel], names(VGOB1_subsetA_staph_LUR3)[models[[4]]$indexbestmodel])

#  this is the r2 of that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetA_staph_LUR3$staph_copiespm3.ln.diffmeth.mean~ VGOB1_subsetA_staph_LUR3[,models[[1]]$indexbestmodel]+ VGOB1_subsetA_staph_LUR3[,models[[2]]$indexbestmodel]+VGOB1_subsetA_staph_LUR3[,models[[3]]$indexbestmodel]+ VGOB1_subsetA_staph_LUR3[,models[[4]]$indexbestmodel]) 


models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel


# 5 #  
# add fifth variable (the only difference of the above part is that now modeln=5 the model statement more variables)
# and the call for the list of variable names in the model changed slightly
modeln<-5

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_3:nlastvar_LUR_3){
  if (is.numeric(VGOB1_subsetA_staph_LUR3[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetA_staph_LUR3$staph_copiespm3.ln.diffmeth.mean~ VGOB1_subsetA_staph_LUR3[,models[[1]]$indexbestmodel]+ VGOB1_subsetA_staph_LUR3[,models[[2]]$indexbestmodel]+ VGOB1_subsetA_staph_LUR3[,models[[3]]$indexbestmodel]+ VGOB1_subsetA_staph_LUR3[,models[[4]]$indexbestmodel]+ VGOB1_subsetA_staph_LUR3[,i]) 
  
R2<-rbind(R2,summary(modeltry)$adj.r.squared)
# the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # All[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR3)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetA_staph_LUR3)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

#  this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetA_staph_LUR3)[models[[1]]$indexbestmodel], names(VGOB1_subsetA_staph_LUR3)[models[[2]]$indexbestmodel], names(VGOB1_subsetA_staph_LUR3)[models[[3]]$indexbestmodel], names(VGOB1_subsetA_staph_LUR3)[models[[4]]$indexbestmodel], names(VGOB1_subsetA_staph_LUR3)[models[[5]]$indexbestmodel])

#  this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetA_staph_LUR3$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetA_staph_LUR3[,models[[1]]$indexbestmodel]+VGOB1_subsetA_staph_LUR3[,models[[2]]$indexbestmodel]+VGOB1_subsetA_staph_LUR3[,models[[3]]$indexbestmodel]+ VGOB1_subsetA_staph_LUR3[,models[[4]]$indexbestmodel]+ VGOB1_subsetA_staph_LUR3[,models[[5]]$indexbestmodel]) 
models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[5]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[5]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel
models[[5]]$R2bestmodel

# 6 #  
# add sixth variable (the only difference of the above part is that now model n=6 the model statement more variables)
#  and the call for the list of variable names in the model changed slightly

modeln<-6

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_3 :nlastvar_LUR_3){
  if (is.numeric(VGOB1_subsetA_staph_LUR3[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetA_staph_LUR3$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetA_staph_LUR3[,models[[1]]$indexbestmodel]+VGOB1_subsetA_staph_LUR3[,models[[2]]$indexbestmodel]+VGOB1_subsetA_staph_LUR3[,models[[3]]$indexbestmodel]+VGOB1_subsetA_staph_LUR3[,models[[4]]$indexbestmodel]+VGOB1_subsetA_staph_LUR3[,models[[5]]$indexbestmodel]+ VGOB1_subsetA_staph_LUR3[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # All[,i] is the row that's being tried out now. the name of that row can be found in  names(All)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetA_staph_LUR3)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

# this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetA_staph_LUR3)[models[[1]]$indexbestmodel], names(VGOB1_subsetA_staph_LUR3)[models[[2]]$indexbestmodel] , names(VGOB1_subsetA_staph_LUR3)[models[[3]]$indexbestmodel], names(VGOB1_subsetA_staph_LUR3)[models[[4]]$indexbestmodel], names(VGOB1_subsetA_staph_LUR3)[models[[5]]$indexbestmodel], names(VGOB1_subsetA_staph_LUR3)[models[[6]]$indexbestmodel])

#  this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetA_staph_LUR3$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetA_staph_LUR3[,models[[1]]$indexbestmodel]+VGOB1_subsetA_staph_LUR3[,models[[2]]$indexbestmodel]+VGOB1_subsetA_staph_LUR3[,models[[3]]$indexbestmodel]+ VGOB1_subsetA_staph_LUR3[,models[[4]]$indexbestmodel]+ VGOB1_subsetA_staph_LUR3[,models[[5]]$indexbestmodel]+ VGOB1_subsetA_staph_LUR3[,models[[6]]$indexbestmodel]) 

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[5]]$summarybestmodel
models[[6]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[5]]$namesbestmodel
models[[6]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel
models[[5]]$R2bestmodel
models[[6]]$R2bestmodel


# 7 #  
# add seventh variable (the only difference of the above part is that now model n=7 the model statement more variables)
#  and the call for the list of variable names in the model changed slightly

modeln<-7

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_3 :nlastvar_LUR_3){
  if (is.numeric(VGOB1_subsetA_staph_LUR3[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetA_staph_LUR3$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetA_staph_LUR3[,models[[1]]$indexbestmodel]+VGOB1_subsetA_staph_LUR3[,models[[2]]$indexbestmodel]+VGOB1_subsetA_staph_LUR3[,models[[3]]$indexbestmodel]+VGOB1_subsetA_staph_LUR3[,models[[4]]$indexbestmodel]+VGOB1_subsetA_staph_LUR3[,models[[5]]$indexbestmodel]+VGOB1_subsetA_staph_LUR3[,models[[6]]$indexbestmodel]+ VGOB1_subsetA_staph_LUR3[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # Measurements_livestockpreds_LUR3[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR3)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetA_staph_LUR3)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

# this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetA_staph_LUR3)[models[[1]]$indexbestmodel], names(VGOB1_subsetA_staph_LUR3)[models[[2]]$indexbestmodel] , names(VGOB1_subsetA_staph_LUR3)[models[[3]]$indexbestmodel], names(VGOB1_subsetA_staph_LUR3)[models[[4]]$indexbestmodel], names(VGOB1_subsetA_staph_LUR3)[models[[5]]$indexbestmodel], names(VGOB1_subsetA_staph_LUR3)[models[[6]]$indexbestmodel], names(VGOB1_subsetA_staph_LUR3)[models[[7]]$indexbestmodel])

#  this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetA_staph_LUR3$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetA_staph_LUR3[,models[[1]]$indexbestmodel]+VGOB1_subsetA_staph_LUR3[,models[[2]]$indexbestmodel]+VGOB1_subsetA_staph_LUR3[,models[[3]]$indexbestmodel]+ VGOB1_subsetA_staph_LUR3[,models[[4]]$indexbestmodel]+ VGOB1_subsetA_staph_LUR3[,models[[5]]$indexbestmodel]+ VGOB1_subsetA_staph_LUR3[,models[[6]]$indexbestmodel]+ VGOB1_subsetA_staph_LUR3[,models[[7]]$indexbestmodel]) 

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[5]]$summarybestmodel
models[[6]]$summarybestmodel
models[[7]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[5]]$namesbestmodel
models[[6]]$namesbestmodel
models[[7]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel
models[[5]]$R2bestmodel
models[[6]]$R2bestmodel
models[[7]]$R2bestmodel

# 8 #  
# add eighth variable (the only difference of the above part is that now modeln=7 the model statement more variables)
# and the call for the list of variable names in the model changed slightly

modeln<-8

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_3 :nlastvar_LUR_3){
  if (is.numeric(VGOB1_subsetA_staph_LUR3[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetA_staph_LUR3$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetA_staph_LUR3[,models[[1]]$indexbestmodel]+VGOB1_subsetA_staph_LUR3[,models[[2]]$indexbestmodel]+VGOB1_subsetA_staph_LUR3[,models[[3]]$indexbestmodel]+VGOB1_subsetA_staph_LUR3[,models[[4]]$indexbestmodel]+VGOB1_subsetA_staph_LUR3[,models[[5]]$indexbestmodel]+VGOB1_subsetA_staph_LUR3[,models[[6]]$indexbestmodel]+ VGOB1_subsetA_staph_LUR3[,models[[7]]$indexbestmodel]+ VGOB1_subsetA_staph_LUR3[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # Measurements_livestockpreds_LUR3[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR3)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetA_staph_LUR3)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

# this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetA_staph_LUR3)[models[[1]]$indexbestmodel], names(VGOB1_subsetA_staph_LUR3)[models[[2]]$indexbestmodel] , names(VGOB1_subsetA_staph_LUR3)[models[[3]]$indexbestmodel], names(VGOB1_subsetA_staph_LUR3)[models[[4]]$indexbestmodel], names(VGOB1_subsetA_staph_LUR3)[models[[5]]$indexbestmodel], names(VGOB1_subsetA_staph_LUR3)[models[[6]]$indexbestmodel], names(VGOB1_subsetA_staph_LUR3)[models[[7]]$indexbestmodel], names(VGOB1_subsetA_staph_LUR3)[models[[8]]$indexbestmodel])

#  this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetA_staph_LUR3$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetA_staph_LUR3[,models[[1]]$indexbestmodel]+VGOB1_subsetA_staph_LUR3[,models[[2]]$indexbestmodel]+VGOB1_subsetA_staph_LUR3[,models[[3]]$indexbestmodel]+ VGOB1_subsetA_staph_LUR3[,models[[4]]$indexbestmodel]+ VGOB1_subsetA_staph_LUR3[,models[[5]]$indexbestmodel]+ VGOB1_subsetA_staph_LUR3[,models[[6]]$indexbestmodel]+ VGOB1_subsetA_staph_LUR3[,models[[7]]$indexbestmodel]+ VGOB1_subsetA_staph_LUR3[,models[[8]]$indexbestmodel]) 

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[5]]$summarybestmodel
models[[6]]$summarybestmodel
models[[7]]$summarybestmodel
models[[8]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[5]]$namesbestmodel
models[[6]]$namesbestmodel
models[[7]]$namesbestmodel
models[[8]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel
models[[5]]$R2bestmodel
models[[6]]$R2bestmodel
models[[7]]$R2bestmodel
models[[8]]$R2bestmodel

# 9 #  
# add ninth variable (the only difference of the above part is that now modeln=9 the model statement more variables)
# and the call for the list of variable names in the model changed slightly

modeln<-9

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_3 :nlastvar_LUR_3){
  if (is.numeric(VGOB1_subsetA_staph_LUR3[,i])==TRUE){
      modeltry<-lm(VGOB1_subsetA_staph_LUR3$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetA_staph_LUR3[,models[[1]]$indexbestmodel]+VGOB1_subsetA_staph_LUR3[,models[[2]]$indexbestmodel]+VGOB1_subsetA_staph_LUR3[,models[[3]]$indexbestmodel]+VGOB1_subsetA_staph_LUR3[,models[[4]]$indexbestmodel]+VGOB1_subsetA_staph_LUR3[,models[[5]]$indexbestmodel]+VGOB1_subsetA_staph_LUR3[,models[[6]]$indexbestmodel]+ VGOB1_subsetA_staph_LUR3[,models[[7]]$indexbestmodel]+ VGOB1_subsetA_staph_LUR3[,models[[8]]$indexbestmodel]+ VGOB1_subsetA_staph_LUR3[,i]) 
        R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # Measurements_livestockpreds_LUR3[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR3)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetA_staph_LUR3)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

# this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetA_staph_LUR3)[models[[1]]$indexbestmodel], names(VGOB1_subsetA_staph_LUR3)[models[[2]]$indexbestmodel] , names(VGOB1_subsetA_staph_LUR3)[models[[3]]$indexbestmodel], names(VGOB1_subsetA_staph_LUR3)[models[[4]]$indexbestmodel], names(VGOB1_subsetA_staph_LUR3)[models[[5]]$indexbestmodel], names(VGOB1_subsetA_staph_LUR3)[models[[6]]$indexbestmodel], names(VGOB1_subsetA_staph_LUR3)[models[[7]]$indexbestmodel], names(VGOB1_subsetA_staph_LUR3)[models[[8]]$indexbestmodel],  names(VGOB1_subsetA_staph_LUR3)[models[[9]]$indexbestmodel])

#  this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetA_staph_LUR3$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetA_staph_LUR3[,models[[1]]$indexbestmodel]+VGOB1_subsetA_staph_LUR3[,models[[2]]$indexbestmodel]+VGOB1_subsetA_staph_LUR3[,models[[3]]$indexbestmodel]+ VGOB1_subsetA_staph_LUR3[,models[[4]]$indexbestmodel]+ VGOB1_subsetA_staph_LUR3[,models[[5]]$indexbestmodel]+ VGOB1_subsetA_staph_LUR3[,models[[6]]$indexbestmodel]+ VGOB1_subsetA_staph_LUR3[,models[[7]]$indexbestmodel]+ VGOB1_subsetA_staph_LUR3[,models[[8]]$indexbestmodel]+ VGOB1_subsetA_staph_LUR3[,models[[9]]$indexbestmodel]) 

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[5]]$summarybestmodel
models[[6]]$summarybestmodel
models[[7]]$summarybestmodel
models[[8]]$summarybestmodel
models[[9]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[5]]$namesbestmodel
models[[6]]$namesbestmodel
models[[7]]$namesbestmodel
models[[8]]$namesbestmodel
models[[9]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel
models[[5]]$R2bestmodel
models[[6]]$R2bestmodel
models[[7]]$R2bestmodel
models[[8]]$R2bestmodel
models[[9]]$R2bestmodel

# 10 #  
#  add tenth variable (the only difference of the above part is that now model n=10 the model statement more variables)
#  and the call for the list of variable names in the model changed slightly

modeln<-10

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_3 :nlastvar_LUR_3){if (is.numeric(VGOB1_subsetA_staph_LUR3[,i])==TRUE){ modeltry<-lm(VGOB1_subsetA_staph_LUR3$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetA_staph_LUR3[,models[[1]]$indexbestmodel]+VGOB1_subsetA_staph_LUR3[,models[[2]]$indexbestmodel]+ VGOB1_subsetA_staph_LUR3[,models[[3]]$indexbestmodel]+VGOB1_subsetA_staph_LUR3[,models[[4]]$indexbestmodel]+ VGOB1_subsetA_staph_LUR3[,models[[5]]$indexbestmodel]+ VGOB1_subsetA_staph_LUR3[,models[[6]]$indexbestmodel]+ VGOB1_subsetA_staph_LUR3[,models[[7]]$indexbestmodel]+ VGOB1_subsetA_staph_LUR3[,models[[8]]$indexbestmodel]+ VGOB1_subsetA_staph_LUR3[,models[[9]]$indexbestmodel]+ VGOB1_subsetA_staph_LUR3[,i]) 

R2<-rbind(R2,summary(modeltry)$adj.r.squared)
# the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # Measurements_livestockpreds_LUR3[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR3)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetA_staph_LUR3)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

# this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

# here are the names
models[[modeln]]$namesbestmodel<-c( names(VGOB1_subsetA_staph_LUR3)[models[[1]]$indexbestmodel],                   names(VGOB1_subsetA_staph_LUR3)[models[[2]]$indexbestmodel] , names(VGOB1_subsetA_staph_LUR3)[models[[3]]$indexbestmodel], names(VGOB1_subsetA_staph_LUR3)[models[[4]]$indexbestmodel], names(VGOB1_subsetA_staph_LUR3)[models[[5]]$indexbestmodel], names(VGOB1_subsetA_staph_LUR3)[models[[6]]$indexbestmodel], names(VGOB1_subsetA_staph_LUR3)[models[[7]]$indexbestmodel], names(VGOB1_subsetA_staph_LUR3)[models[[8]]$indexbestmodel], names(VGOB1_subsetA_staph_LUR3)[models[[9]]$indexbestmodel], names(VGOB1_subsetA_staph_LUR3)[models[[10]]$indexbestmodel])

#  this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetA_staph_LUR3$staph_copiespm3.ln.diffmeth.mean~                                VGOB1_subsetA_staph_LUR3[,models[[1]]$indexbestmodel]+ VGOB1_subsetA_staph_LUR3[,models[[2]]$indexbestmodel]+                           VGOB1_subsetA_staph_LUR3[,models[[3]]$indexbestmodel]+ VGOB1_subsetA_staph_LUR3[,models[[4]]$indexbestmodel]+ VGOB1_subsetA_staph_LUR3[,models[[5]]$indexbestmodel]+ VGOB1_subsetA_staph_LUR3[,models[[6]]$indexbestmodel]+ VGOB1_subsetA_staph_LUR3[,models[[7]]$indexbestmodel]+ VGOB1_subsetA_staph_LUR3[,models[[8]]$indexbestmodel]+ VGOB1_subsetA_staph_LUR3[,models[[9]]$indexbestmodel]+ VGOB1_subsetA_staph_LUR3[,models[[10]]$indexbestmodel]) 

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[5]]$summarybestmodel
models[[6]]$summarybestmodel
models[[7]]$summarybestmodel
models[[8]]$summarybestmodel
models[[9]]$summarybestmodel
models[[10]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[5]]$namesbestmodel
models[[6]]$namesbestmodel
models[[7]]$namesbestmodel
models[[8]]$namesbestmodel
models[[9]]$namesbestmodel
models[[10]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel
models[[5]]$R2bestmodel
models[[6]]$R2bestmodel
models[[7]]$R2bestmodel
models[[8]]$R2bestmodel
models[[9]]$R2bestmodel
models[[10]]$R2bestmodel

#  at this point I always check whether the next model is more than 1% better than the one before and if not I end here

#   CODE FOR PICKING OUT THE BEST MODEL #   
temp <- 0
besti <- 0
for (i in 1:10){ #  think this runs the loop 10 times - not fully sure thought - but not to do with the number of models I don't think - as when I change to 3, I still get the model with 4 variables as best model
  print(models[[i]]$R2bestmodel)
  #       print(models[[i]]$summarybestmodel$coefficients=-1,4])
  #       if((models[[i]]$R2bestmodel-temp > 0.0) && (all(models[[i]]$summarybestmodel$coefficients[-1,4]<0.1))){
  #         temp <- models[[i]]$R2bestmodel
  #         besti <- i
  #         }
  if((models[[i]]$R2bestmodel-temp > 0.0) && (all(models[[i]]$summarybestmodel$coefficients[-1,4]<0.1))){
    temp <- models[[i]]$R2bestmodel
    besti <- i
  }else{
    finalBestModel_staph_LUR3_subsetA <- models[[besti]]$bestmodel
    finalBestModelNames_staph_subsetA <- models[[besti]]$namesbestmodel
    Sites <- 1:dim(VGOB1_subsetA_staph_LUR3)[1] # full original model
    #  CVaR2<-escCV_staph_LUR3(Sites)[2] # Cross Validation
    maxCD<-max(cooks.distance(finalBestModel_staph_LUR3_subsetA))
    if(length(finalBestModelNames_staph_subsetA)<2){ # vif fn doesnot work when only 1 variable...       # 
      maxVIF<-"NA"
    }else{
      maxVIF<-max(vif(finalBestModel_staph_LUR3_subsetA))
    }
    print(paste("This is the best staph model for subset A: ",besti,
                "(AdjR2: ",format(models[[besti]]$R2bestmodel,digits=3), "; MaxCD: ",format(maxCD,digits=3),"; MaxVIF: ",
                format(maxVIF,digits=3),")", sep=''))
    print(finalBestModelNames_staph_subsetA)
    break
  }
}

#  Overview of the final best model using the algorithm selection process (taking into account VIF, R^2, and p-values)
finalBestModel_staph_LUR3_subsetA 
finalBestModelNames_staph_subsetA
models[[besti]]$summarybestmodel
models[[besti]]$R2bestmodel

#### B ####
# LUR model building process for subset B
# This is the dataframe with the relevant predictor vars for LUR3 models for subset B (55 sites)
VGOB1_subsetB_staph_LUR3 # n.b. this dataframe only includes microbial marker concentrations for staph unlike the dataframe Measurements_livestockpreds_LUR3 as previously used for the model building. 

#  Now set the values of some variables that will be needed
nfirstvar_LUR_3 <- 3  
nlastvar_LUR_3 <- 135

# Function building to run the models 
# 1 #  

models<-list()
modeln<-1
models[[modeln]]<-list()

R2<-1
betaaddedvar<-1
addedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_3:nlastvar_LUR_3){
  if (is.numeric(VGOB1_subsetB_staph_LUR3[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetB_staph_LUR3$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetB_staph_LUR3[,i])                            
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    #  Measurements_livestockpreds_LUR3[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR3)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetB_staph_LUR3)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)
models[[modeln]]$results

#  this are the candidates models with the highest R2, not a negative beta for the new, nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)
models[[modeln]]$resultspos

#  rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))
models[[modeln]]$resultspos

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j
models[[modeln]]$indexbestmodel

subset(models[[modeln]]$resultspos, rank==1)
subset(models[[modeln]]$resultspos)

#  this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]
models[[modeln]]$summarybestmodel

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetB_staph_LUR3)[models[[1]]$indexbestmodel])
models[[modeln]]$namesbestmodel

#  this is the r2 of that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2
models[[modeln]]$R2bestmodel

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetB_staph_LUR3$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetB_staph_LUR3[,models[[1]]$indexbestmodel]) 
models[[modeln]]$bestmodel

summary(models[[modeln]]$bestmodel)

#  The first model includes the predictor: nPigMultipFarmWghtDist.3000m.sum.Tr.1P9 - meaning the number of multiplier pig farms weighted to distance in a 3000m buffer

# 2 #  
# Add 2nd variable (the only difference of the above part is that now modeln=2 the model statement has 2 variables)
# and the call for the list of variable names in the model changed slightly

modeln<-2

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_3:nlastvar_LUR_3){
  if (is.numeric(VGOB1_subsetB_staph_LUR3[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetB_staph_LUR3$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetB_staph_LUR3[,models[[1]]$indexbestmodel]+ VGOB1_subsetB_staph_LUR3[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # Measurements_livestockpreds_LUR3[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR3)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetB_staph_LUR3)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  these are the candidate models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)
models[[modeln]]$resultspos

#  rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))
models[[modeln]]$resultspos

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j
models[[modeln]]$indexbestmodel

subset(models[[modeln]]$resultspos, rank==1)

# this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]
models[[modeln]]$summarybestmodel

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetB_staph_LUR3)[models[[1]]$indexbestmodel], names(VGOB1_subsetB_staph_LUR3)[models[[2]]$indexbestmodel] )
models[[modeln]]$namesbestmodel

# this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2
models[[modeln]]$R2bestmodel

# this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetB_staph_LUR3$staph_copiespm3.ln.diffmeth.mean~                               VGOB1_subsetB_staph_LUR3[,models[[1]]$indexbestmodel]+                           VGOB1_subsetB_staph_LUR3[,models[[2]]$indexbestmodel]) 

models[[modeln]]$bestmodel

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel


# 3 #  
# add third variable (the only difference of the above part is that now modeln=3 the model statement has 3 variables)
# and the call for the list of variable names in the model changed slightly

modeln<-3

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_3:nlastvar_LUR_3){
  if (is.numeric(VGOB1_subsetB_staph_LUR3[,i])==TRUE){  
    modeltry<-lm(VGOB1_subsetB_staph_LUR3$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetB_staph_LUR3[,models[[1]]$indexbestmodel]+VGOB1_subsetB_staph_LUR3[,models[[2]]$indexbestmodel]+ VGOB1_subsetB_staph_LUR3[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # All[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR3)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetB_staph_LUR3)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

#  rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

#  this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

#  here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetB_staph_LUR3)[models[[1]]$indexbestmodel], names(VGOB1_subsetB_staph_LUR3)[models[[2]]$indexbestmodel], names(VGOB1_subsetB_staph_LUR3)[models[[3]]$indexbestmodel])

#  this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetB_staph_LUR3$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetB_staph_LUR3[,models[[1]]$indexbestmodel]+ VGOB1_subsetB_staph_LUR3[,models[[2]]$indexbestmodel]+ VGOB1_subsetB_staph_LUR3[,models[[3]]$indexbestmodel]) 

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel


# 4 #  
#  add forth variable (the only difference of the above part is that now model n=4 the model statement more variables)
#  and the call for the list of variable names in the model changed slightly
modeln<-4

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1


for (i in nfirstvar_LUR_3:nlastvar_LUR_3){
  if (is.numeric(VGOB1_subsetB_staph_LUR3[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetB_staph_LUR3$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetB_staph_LUR3[,models[[1]]$indexbestmodel]+VGOB1_subsetB_staph_LUR3[,models[[2]]$indexbestmodel]+VGOB1_subsetB_staph_LUR3[,models[[3]]$indexbestmodel]+VGOB1_subsetB_staph_LUR3[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    #  the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    #  All[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR3)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetB_staph_LUR3)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

#  this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

#  here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetB_staph_LUR3)[models[[1]]$indexbestmodel], names(VGOB1_subsetB_staph_LUR3)[models[[2]]$indexbestmodel], names(VGOB1_subsetB_staph_LUR3)[models[[3]]$indexbestmodel], names(VGOB1_subsetB_staph_LUR3)[models[[4]]$indexbestmodel])

#  this is the r2 of that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetB_staph_LUR3$staph_copiespm3.ln.diffmeth.mean~ VGOB1_subsetB_staph_LUR3[,models[[1]]$indexbestmodel]+ VGOB1_subsetB_staph_LUR3[,models[[2]]$indexbestmodel]+ VGOB1_subsetB_staph_LUR3[,models[[3]]$indexbestmodel]+ VGOB1_subsetB_staph_LUR3[,models[[4]]$indexbestmodel]) 


models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel


# 5 #  
# add fifth variable (the only difference of the above part is that now modeln=5 the model statement more variables)
# and the call for the list of variable names in the model changed slightly
modeln<-5

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_3:nlastvar_LUR_3){
  if (is.numeric(VGOB1_subsetB_staph_LUR3[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetB_staph_LUR3$staph_copiespm3.ln.diffmeth.mean~ VGOB1_subsetB_staph_LUR3[,models[[1]]$indexbestmodel]+ VGOB1_subsetB_staph_LUR3[,models[[2]]$indexbestmodel]+ VGOB1_subsetB_staph_LUR3[,models[[3]]$indexbestmodel]+ VGOB1_subsetB_staph_LUR3[,models[[4]]$indexbestmodel]+ VGOB1_subsetB_staph_LUR3[,i]) 
  
R2<-rbind(R2,summary(modeltry)$adj.r.squared)
# the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # All[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR3)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetB_staph_LUR3)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

#  this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetB_staph_LUR3)[models[[1]]$indexbestmodel], names(VGOB1_subsetB_staph_LUR3)[models[[2]]$indexbestmodel], names(VGOB1_subsetB_staph_LUR3)[models[[3]]$indexbestmodel], names(VGOB1_subsetB_staph_LUR3)[models[[4]]$indexbestmodel], names(VGOB1_subsetB_staph_LUR3)[models[[5]]$indexbestmodel])

#  this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetB_staph_LUR3$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetB_staph_LUR3[,models[[1]]$indexbestmodel]+VGOB1_subsetB_staph_LUR3[,models[[2]]$indexbestmodel]+VGOB1_subsetB_staph_LUR3[,models[[3]]$indexbestmodel]+ VGOB1_subsetB_staph_LUR3[,models[[4]]$indexbestmodel]+ VGOB1_subsetB_staph_LUR3[,models[[5]]$indexbestmodel]) 
models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[5]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[5]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel
models[[5]]$R2bestmodel

# 6 #  
# add sixth variable (the only difference of the above part is that now model n=6 the model statement more variables)
#  and the call for the list of variable names in the model changed slightly

modeln<-6

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_3 :nlastvar_LUR_3){
  if (is.numeric(VGOB1_subsetB_staph_LUR3[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetB_staph_LUR3$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetB_staph_LUR3[,models[[1]]$indexbestmodel]+VGOB1_subsetB_staph_LUR3[,models[[2]]$indexbestmodel]+VGOB1_subsetB_staph_LUR3[,models[[3]]$indexbestmodel]+VGOB1_subsetB_staph_LUR3[,models[[4]]$indexbestmodel]+VGOB1_subsetB_staph_LUR3[,models[[5]]$indexbestmodel]+ VGOB1_subsetB_staph_LUR3[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # All[,i] is the row that's being tried out now. the name of that row can be found in  names(All)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetB_staph_LUR3)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

# this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetB_staph_LUR3)[models[[1]]$indexbestmodel], names(VGOB1_subsetB_staph_LUR3)[models[[2]]$indexbestmodel] , names(VGOB1_subsetB_staph_LUR3)[models[[3]]$indexbestmodel], names(VGOB1_subsetB_staph_LUR3)[models[[4]]$indexbestmodel], names(VGOB1_subsetB_staph_LUR3)[models[[5]]$indexbestmodel], names(VGOB1_subsetB_staph_LUR3)[models[[6]]$indexbestmodel])

#  this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetB_staph_LUR3$staph_copiespm3.ln.diffmeth.mean~ VGOB1_subsetB_staph_LUR3[,models[[1]]$indexbestmodel]+ VGOB1_subsetB_staph_LUR3[,models[[2]]$indexbestmodel]+ VGOB1_subsetB_staph_LUR3[,models[[3]]$indexbestmodel]+ VGOB1_subsetB_staph_LUR3[,models[[4]]$indexbestmodel]+ VGOB1_subsetB_staph_LUR3[,models[[5]]$indexbestmodel]+ VGOB1_subsetB_staph_LUR3[,models[[6]]$indexbestmodel]) 

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[5]]$summarybestmodel
models[[6]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[5]]$namesbestmodel
models[[6]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel
models[[5]]$R2bestmodel
models[[6]]$R2bestmodel


# 7 #  
# add seventh variable (the only difference of the above part is that now model n=7 the model statement more variables)
#  and the call for the list of variable names in the model changed slightly

modeln<-7

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_3 :nlastvar_LUR_3){
  if (is.numeric(VGOB1_subsetB_staph_LUR3[,i])==TRUE){
    modeltry<- lm(VGOB1_subsetB_staph_LUR3$staph_copiespm3.ln.diffmeth.mean~ VGOB1_subsetB_staph_LUR3[,models[[1]]$indexbestmodel]+ VGOB1_subsetB_staph_LUR3[,models[[2]]$indexbestmodel]+ VGOB1_subsetB_staph_LUR3[,models[[3]]$indexbestmodel]+ VGOB1_subsetB_staph_LUR3[,models[[4]]$indexbestmodel]+ VGOB1_subsetB_staph_LUR3[,models[[5]]$indexbestmodel]+ VGOB1_subsetB_staph_LUR3[,models[[6]]$indexbestmodel]+ VGOB1_subsetB_staph_LUR3[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # Measurements_livestockpreds_LUR3[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR3)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetB_staph_LUR3)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

# this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetB_staph_LUR3)[models[[1]]$indexbestmodel], names(VGOB1_subsetB_staph_LUR3)[models[[2]]$indexbestmodel] , names(VGOB1_subsetB_staph_LUR3)[models[[3]]$indexbestmodel], names(VGOB1_subsetB_staph_LUR3)[models[[4]]$indexbestmodel], names(VGOB1_subsetB_staph_LUR3)[models[[5]]$indexbestmodel], names(VGOB1_subsetB_staph_LUR3)[models[[6]]$indexbestmodel], names(VGOB1_subsetB_staph_LUR3)[models[[7]]$indexbestmodel])

#  this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetB_staph_LUR3$staph_copiespm3.ln.diffmeth.mean~ VGOB1_subsetB_staph_LUR3[,models[[1]]$indexbestmodel]+ VGOB1_subsetB_staph_LUR3[,models[[2]]$indexbestmodel]+ VGOB1_subsetB_staph_LUR3[,models[[3]]$indexbestmodel]+ VGOB1_subsetB_staph_LUR3[,models[[4]]$indexbestmodel]+ VGOB1_subsetB_staph_LUR3[,models[[5]]$indexbestmodel]+ VGOB1_subsetB_staph_LUR3[,models[[6]]$indexbestmodel]+ VGOB1_subsetB_staph_LUR3[,models[[7]]$indexbestmodel]) 

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[5]]$summarybestmodel
models[[6]]$summarybestmodel
models[[7]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[5]]$namesbestmodel
models[[6]]$namesbestmodel
models[[7]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel
models[[5]]$R2bestmodel
models[[6]]$R2bestmodel
models[[7]]$R2bestmodel

# 8 #  
# add eighth variable (the only difference of the above part is that now modeln=7 the model statement more variables)
# and the call for the list of variable names in the model changed slightly

modeln<-8

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_3 :nlastvar_LUR_3){
  if (is.numeric(VGOB1_subsetB_staph_LUR3[,i])==TRUE){
    modeltry<- lm(VGOB1_subsetB_staph_LUR3$staph_copiespm3.ln.diffmeth.mean~ VGOB1_subsetB_staph_LUR3[,models[[1]]$indexbestmodel]+ VGOB1_subsetB_staph_LUR3[,models[[2]]$indexbestmodel]+ VGOB1_subsetB_staph_LUR3[,models[[3]]$indexbestmodel]+ VGOB1_subsetB_staph_LUR3[,models[[4]]$indexbestmodel]+ VGOB1_subsetB_staph_LUR3[,models[[5]]$indexbestmodel]+ VGOB1_subsetB_staph_LUR3[,models[[6]]$indexbestmodel]+ VGOB1_subsetB_staph_LUR3[,models[[7]]$indexbestmodel]+ VGOB1_subsetB_staph_LUR3[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # Measurements_livestockpreds_LUR3[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR3)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetB_staph_LUR3)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

# this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetB_staph_LUR3)[models[[1]]$indexbestmodel], names(VGOB1_subsetB_staph_LUR3)[models[[2]]$indexbestmodel] , names(VGOB1_subsetB_staph_LUR3)[models[[3]]$indexbestmodel], names(VGOB1_subsetB_staph_LUR3)[models[[4]]$indexbestmodel], names(VGOB1_subsetB_staph_LUR3)[models[[5]]$indexbestmodel], names(VGOB1_subsetB_staph_LUR3)[models[[6]]$indexbestmodel], names(VGOB1_subsetB_staph_LUR3)[models[[7]]$indexbestmodel], names(VGOB1_subsetB_staph_LUR3)[models[[8]]$indexbestmodel])

#  this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetB_staph_LUR3$staph_copiespm3.ln.diffmeth.mean~ VGOB1_subsetB_staph_LUR3[,models[[1]]$indexbestmodel]+ VGOB1_subsetB_staph_LUR3[,models[[2]]$indexbestmodel]+ VGOB1_subsetB_staph_LUR3[,models[[3]]$indexbestmodel]+ VGOB1_subsetB_staph_LUR3[,models[[4]]$indexbestmodel]+ VGOB1_subsetB_staph_LUR3[,models[[5]]$indexbestmodel]+ VGOB1_subsetB_staph_LUR3[,models[[6]]$indexbestmodel]+ VGOB1_subsetB_staph_LUR3[,models[[7]]$indexbestmodel]+ VGOB1_subsetB_staph_LUR3[,models[[8]]$indexbestmodel]) 

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[5]]$summarybestmodel
models[[6]]$summarybestmodel
models[[7]]$summarybestmodel
models[[8]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[5]]$namesbestmodel
models[[6]]$namesbestmodel
models[[7]]$namesbestmodel
models[[8]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel
models[[5]]$R2bestmodel
models[[6]]$R2bestmodel
models[[7]]$R2bestmodel
models[[8]]$R2bestmodel

# 9 #  
# add ninth variable (the only difference of the above part is that now modeln=9 the model statement more variables)
# and the call for the list of variable names in the model changed slightly

modeln<-9

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_3 :nlastvar_LUR_3){
  if (is.numeric(VGOB1_subsetB_staph_LUR3[,i])==TRUE){
      modeltry<-lm(VGOB1_subsetB_staph_LUR3$staph_copiespm3.ln.diffmeth.mean~ VGOB1_subsetB_staph_LUR3[,models[[1]]$indexbestmodel]+ VGOB1_subsetB_staph_LUR3[,models[[2]]$indexbestmodel]+ VGOB1_subsetB_staph_LUR3[,models[[3]]$indexbestmodel]+ VGOB1_subsetB_staph_LUR3[,models[[4]]$indexbestmodel]+ VGOB1_subsetB_staph_LUR3[,models[[5]]$indexbestmodel]+ VGOB1_subsetB_staph_LUR3[,models[[6]]$indexbestmodel]+ VGOB1_subsetB_staph_LUR3[,models[[7]]$indexbestmodel]+ VGOB1_subsetB_staph_LUR3[,models[[8]]$indexbestmodel]+ VGOB1_subsetB_staph_LUR3[,i]) 
        R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # Measurements_livestockpreds_LUR3[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR3)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetB_staph_LUR3)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

# this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetB_staph_LUR3)[models[[1]]$indexbestmodel], names(VGOB1_subsetB_staph_LUR3)[models[[2]]$indexbestmodel] , names(VGOB1_subsetB_staph_LUR3)[models[[3]]$indexbestmodel], names(VGOB1_subsetB_staph_LUR3)[models[[4]]$indexbestmodel], names(VGOB1_subsetB_staph_LUR3)[models[[5]]$indexbestmodel], names(VGOB1_subsetB_staph_LUR3)[models[[6]]$indexbestmodel], names(VGOB1_subsetB_staph_LUR3)[models[[7]]$indexbestmodel], names(VGOB1_subsetB_staph_LUR3)[models[[8]]$indexbestmodel],  names(VGOB1_subsetB_staph_LUR3)[models[[9]]$indexbestmodel])

#  this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetB_staph_LUR3$staph_copiespm3.ln.diffmeth.mean~ VGOB1_subsetB_staph_LUR3[,models[[1]]$indexbestmodel]+ VGOB1_subsetB_staph_LUR3[,models[[2]]$indexbestmodel]+ VGOB1_subsetB_staph_LUR3[,models[[3]]$indexbestmodel]+ VGOB1_subsetB_staph_LUR3[,models[[4]]$indexbestmodel]+ VGOB1_subsetB_staph_LUR3[,models[[5]]$indexbestmodel]+ VGOB1_subsetB_staph_LUR3[,models[[6]]$indexbestmodel]+ VGOB1_subsetB_staph_LUR3[,models[[7]]$indexbestmodel]+ VGOB1_subsetB_staph_LUR3[,models[[8]]$indexbestmodel]+ VGOB1_subsetB_staph_LUR3[,models[[9]]$indexbestmodel]) 

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[5]]$summarybestmodel
models[[6]]$summarybestmodel
models[[7]]$summarybestmodel
models[[8]]$summarybestmodel
models[[9]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[5]]$namesbestmodel
models[[6]]$namesbestmodel
models[[7]]$namesbestmodel
models[[8]]$namesbestmodel
models[[9]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel
models[[5]]$R2bestmodel
models[[6]]$R2bestmodel
models[[7]]$R2bestmodel
models[[8]]$R2bestmodel
models[[9]]$R2bestmodel

# the code doesn't work from here (n=10)
# When the 10th variable is added, we end up with a negative beta value in the model, so the code stops working. 

# # 10 #  
# #  add tenth variable (the only difference of the above part is that now model n=10 the model statement more variables)
# #  and the call for the list of variable names in the model changed slightly
# 
# modeln<-10
# 
# models[[modeln]]<-list()
# 
# R2<-1
# addedvar<-1
# betaaddedvar<-1
# minbetas<-1
# j<-1
# 
# for (i in nfirstvar_LUR_3 :nlastvar_LUR_3){if (is.numeric(VGOB1_subsetB_staph_LUR3[,i])==TRUE){ modeltry<-lm(VGOB1_subsetB_staph_LUR3$staph_copiespm3.ln.diffmeth.mean~ VGOB1_subsetB_staph_LUR3[,models[[1]]$indexbestmodel]+ VGOB1_subsetB_staph_LUR3[,models[[2]]$indexbestmodel]+ VGOB1_subsetB_staph_LUR3[,models[[3]]$indexbestmodel]+ VGOB1_subsetB_staph_LUR3[,models[[4]]$indexbestmodel]+ VGOB1_subsetB_staph_LUR3[,models[[5]]$indexbestmodel]+ VGOB1_subsetB_staph_LUR3[,models[[6]]$indexbestmodel]+ VGOB1_subsetB_staph_LUR3[,models[[7]]$indexbestmodel]+ VGOB1_subsetB_staph_LUR3[,models[[8]]$indexbestmodel]+ VGOB1_subsetB_staph_LUR3[,models[[9]]$indexbestmodel]+ VGOB1_subsetB_staph_LUR3[,i]) 
# 
# R2<-rbind(R2,summary(modeltry)$adj.r.squared)
# # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
#     betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
#     #  find out if there is a negative beta at All. The intercept does not count [-1]!
#     minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
#     # Measurements_livestockpreds_LUR3[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR3)[i]
#     addedvar<-rbind(addedvar,names(VGOB1_subsetB_staph_LUR3)[i])
#     j<-rbind(j, i)
#     models[[modeln]][[i]]<-summary(modeltry)
#   }
# }
# 
# models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)
# 
# #  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
# models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)
# 
# # rank the R2's of these models
# models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))
# 
# #  this is the index of the row with the highest R2 and  no negative betas in this subset
# models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j
# 
# subset(models[[modeln]]$resultspos, rank==1)
# 
# # this is the model
# models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]
# 
# # here are the names
# models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetB_staph_LUR3)[models[[1]]$indexbestmodel],    names(VGOB1_subsetB_staph_LUR3)[models[[2]]$indexbestmodel], names(VGOB1_subsetB_staph_LUR3)[models[[3]]$indexbestmodel], names(VGOB1_subsetB_staph_LUR3)[models[[4]]$indexbestmodel], names(VGOB1_subsetB_staph_LUR3)[models[[5]]$indexbestmodel], names(VGOB1_subsetB_staph_LUR3)[models[[6]]$indexbestmodel], names(VGOB1_subsetB_staph_LUR3)[models[[7]]$indexbestmodel], names(VGOB1_subsetB_staph_LUR3)[models[[8]]$indexbestmodel], names(VGOB1_subsetB_staph_LUR3)[models[[9]]$indexbestmodel], names(VGOB1_subsetB_staph_LUR3)[models[[10]]$indexbestmodel])
# 
# #  this is the r2 or that model
# models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2
# 
# #  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
# models[[modeln]]$bestmodel <- lm(VGOB1_subsetB_staph_LUR3$staph_copiespm3.ln.diffmeth.mean~        VGOB1_subsetB_staph_LUR3[,models[[1]]$indexbestmodel]+ VGOB1_subsetB_staph_LUR3[,models[[2]]$indexbestmodel]+  VGOB1_subsetB_staph_LUR3[,models[[3]]$indexbestmodel]+ VGOB1_subsetB_staph_LUR3[,models[[4]]$indexbestmodel]+ VGOB1_subsetB_staph_LUR3[,models[[5]]$indexbestmodel]+ VGOB1_subsetB_staph_LUR3[,models[[6]]$indexbestmodel]+ VGOB1_subsetB_staph_LUR3[,models[[7]]$indexbestmodel]+ VGOB1_subsetB_staph_LUR3[,models[[8]]$indexbestmodel]+ VGOB1_subsetB_staph_LUR3[,models[[9]]$indexbestmodel]+ VGOB1_subsetB_staph_LUR3[,models[[10]]$indexbestmodel]) 
# 
# models[[1]]$summarybestmodel
# models[[2]]$summarybestmodel
# models[[3]]$summarybestmodel
# models[[4]]$summarybestmodel
# models[[5]]$summarybestmodel
# models[[6]]$summarybestmodel
# models[[7]]$summarybestmodel
# models[[8]]$summarybestmodel
# models[[9]]$summarybestmodel
# models[[10]]$summarybestmodel
# models[[1]]$namesbestmodel
# models[[2]]$namesbestmodel
# models[[3]]$namesbestmodel
# models[[4]]$namesbestmodel
# models[[5]]$namesbestmodel
# models[[6]]$namesbestmodel
# models[[7]]$namesbestmodel
# models[[8]]$namesbestmodel
# models[[9]]$namesbestmodel
# models[[10]]$namesbestmodel
# models[[1]]$R2bestmodel
# models[[2]]$R2bestmodel
# models[[3]]$R2bestmodel
# models[[4]]$R2bestmodel
# models[[5]]$R2bestmodel
# models[[6]]$R2bestmodel
# models[[7]]$R2bestmodel
# models[[8]]$R2bestmodel
# models[[9]]$R2bestmodel
# models[[10]]$R2bestmodel


#   CODE FOR PICKING OUT THE BEST MODEL #   
temp <- 0
besti <- 0
for (i in 1:10){ #  think this runs the loop 10 times - not fully sure thought - but not to do with the number of models I don't think - as when I change to 3, I still get the model with 4 variables as best model
  print(models[[i]]$R2bestmodel)
  #       print(models[[i]]$summarybestmodel$coefficients=-1,4])
  #       if((models[[i]]$R2bestmodel-temp > 0.0) && (all(models[[i]]$summarybestmodel$coefficients[-1,4]<0.1))){
  #         temp <- models[[i]]$R2bestmodel
  #         besti <- i
  #         }
  if((models[[i]]$R2bestmodel-temp > 0.0) && (all(models[[i]]$summarybestmodel$coefficients[-1,4]<0.1))){
    temp <- models[[i]]$R2bestmodel
    besti <- i
  }else{
    finalBestModel_staph_LUR3_subsetB <- models[[besti]]$bestmodel
    finalBestModelNames_staph_subsetB <- models[[besti]]$namesbestmodel
    Sites <- 1:dim(VGOB1_subsetB_staph_LUR3)[1] # full original model
    #  CVaR2<-escCV_staph_LUR3(Sites)[2] # Cross Validation
    maxCD<-max(cooks.distance(finalBestModel_staph_LUR3_subsetB))
    if(length(finalBestModelNames_staph_subsetB)<2){ # vif fn doesnot work when only 1 variable...       # 
      maxVIF<-"NA"
    }else{
      maxVIF<-max(vif(finalBestModel_staph_LUR3_subsetB))
    }
    print(paste("This is the best staph model for subset B of 10-fold CV: ",besti,
                "(AdjR2: ",format(models[[besti]]$R2bestmodel,digits=3), "; MaxCD: ",format(maxCD,digits=3),"; MaxVIF: ",
                format(maxVIF,digits=3),")", sep=''))
    print(finalBestModelNames_staph_subsetB)
    break
  }
}

#  Overview of the final best model using the algorithm selection process (taking into account VIF, R^2, and p-values)
finalBestModel_staph_LUR3_subsetB 
finalBestModelNames_staph_subsetB 
models[[besti]]$summarybestmodel
models[[besti]]$R2bestmodel

#### C ####
# LUR model building process for subset C
#  This is the dataframe with the relevant predictor vars for LUR3 models for subset C (55 sites)
VGOB1_subsetC_staph_LUR3 # n.b. this dataframe only includes microbial marker concentrations for staph unlike the dataframe Measurements_livestockpreds_LUR3 as previously used for the model building. 

#  Now set the values of some variables that will be needed
nfirstvar_LUR_3 <- 3  
nlastvar_LUR_3 <- 135

# Function building to run the models 
# 1 #  

models<-list()
modeln<-1
models[[modeln]]<-list()

R2<-1
betaaddedvar<-1
addedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_3:nlastvar_LUR_3){
  if (is.numeric(VGOB1_subsetC_staph_LUR3[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetC_staph_LUR3$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetC_staph_LUR3[,i])                            
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    #  Measurements_livestockpreds_LUR3[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR3)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetC_staph_LUR3)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)
models[[modeln]]$results

#  this are the candidates models with the highest R2, not a negative beta for the new, nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)
models[[modeln]]$resultspos

#  rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))
models[[modeln]]$resultspos

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j
models[[modeln]]$indexbestmodel

subset(models[[modeln]]$resultspos, rank==1)
subset(models[[modeln]]$resultspos)

#  this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]
models[[modeln]]$summarybestmodel

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetC_staph_LUR3)[models[[1]]$indexbestmodel])
models[[modeln]]$namesbestmodel

#  this is the r2 of that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2
models[[modeln]]$R2bestmodel

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetC_staph_LUR3$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetC_staph_LUR3[,models[[1]]$indexbestmodel]) 
models[[modeln]]$bestmodel

summary(models[[modeln]]$bestmodel)

#  The first model includes the predictor: nPigMultipFarmWghtDist.3000m.sum.Tr.1P9 - meaning the number of multiplier pig farms weighted to distance in a 3000m buffer

# 2 #  
# Add 2nd variable (the only difference of the above part is that now modeln=2 the model statement has 2 variables)
# and the call for the list of variable names in the model changed slightly

modeln<-2

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_3:nlastvar_LUR_3){
  if (is.numeric(VGOB1_subsetC_staph_LUR3[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetC_staph_LUR3$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetC_staph_LUR3[,models[[1]]$indexbestmodel]+ VGOB1_subsetC_staph_LUR3[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # Measurements_livestockpreds_LUR3[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR3)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetC_staph_LUR3)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  these are the candidate models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)
models[[modeln]]$resultspos

#  rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))
models[[modeln]]$resultspos

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j
models[[modeln]]$indexbestmodel

subset(models[[modeln]]$resultspos, rank==1)

# this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]
models[[modeln]]$summarybestmodel

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetC_staph_LUR3)[models[[1]]$indexbestmodel], names(VGOB1_subsetC_staph_LUR3)[models[[2]]$indexbestmodel] )
models[[modeln]]$namesbestmodel

# this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2
models[[modeln]]$R2bestmodel

# this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetC_staph_LUR3$staph_copiespm3.ln.diffmeth.mean~                               VGOB1_subsetC_staph_LUR3[,models[[1]]$indexbestmodel]+                           VGOB1_subsetC_staph_LUR3[,models[[2]]$indexbestmodel]) 

models[[modeln]]$bestmodel

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel


# 3 #  
# add third variable (the only difference of the above part is that now modeln=3 the model statement has 3 variables)
# and the call for the list of variable names in the model changed slightly

modeln<-3

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_3:nlastvar_LUR_3){
  if (is.numeric(VGOB1_subsetC_staph_LUR3[,i])==TRUE){  
    modeltry<-lm(VGOB1_subsetC_staph_LUR3$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetC_staph_LUR3[,models[[1]]$indexbestmodel]+VGOB1_subsetC_staph_LUR3[,models[[2]]$indexbestmodel]+ VGOB1_subsetC_staph_LUR3[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # All[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR3)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetC_staph_LUR3)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

#  rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

#  this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

#  here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetC_staph_LUR3)[models[[1]]$indexbestmodel], names(VGOB1_subsetC_staph_LUR3)[models[[2]]$indexbestmodel], names(VGOB1_subsetC_staph_LUR3)[models[[3]]$indexbestmodel])

#  this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetC_staph_LUR3$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetC_staph_LUR3[,models[[1]]$indexbestmodel]+ VGOB1_subsetC_staph_LUR3[,models[[2]]$indexbestmodel]+ VGOB1_subsetC_staph_LUR3[,models[[3]]$indexbestmodel]) 

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel


# 4 #  
#  add forth variable (the only difference of the above part is that now model n=4 the model statement more variables)
#  and the call for the list of variable names in the model changed slightly
modeln<-4

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1


for (i in nfirstvar_LUR_3:nlastvar_LUR_3){
  if (is.numeric(VGOB1_subsetC_staph_LUR3[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetC_staph_LUR3$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetC_staph_LUR3[,models[[1]]$indexbestmodel]+VGOB1_subsetC_staph_LUR3[,models[[2]]$indexbestmodel]+VGOB1_subsetC_staph_LUR3[,models[[3]]$indexbestmodel]+VGOB1_subsetC_staph_LUR3[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    #  the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    #  All[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR3)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetC_staph_LUR3)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

#  this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

#  here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetC_staph_LUR3)[models[[1]]$indexbestmodel], names(VGOB1_subsetC_staph_LUR3)[models[[2]]$indexbestmodel], names(VGOB1_subsetC_staph_LUR3)[models[[3]]$indexbestmodel], names(VGOB1_subsetC_staph_LUR3)[models[[4]]$indexbestmodel])

#  this is the r2 of that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetC_staph_LUR3$staph_copiespm3.ln.diffmeth.mean~ VGOB1_subsetC_staph_LUR3[,models[[1]]$indexbestmodel]+ VGOB1_subsetC_staph_LUR3[,models[[2]]$indexbestmodel]+VGOB1_subsetC_staph_LUR3[,models[[3]]$indexbestmodel]+ VGOB1_subsetC_staph_LUR3[,models[[4]]$indexbestmodel]) 


models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel


# 5 #  
# add fifth variable (the only difference of the above part is that now modeln=5 the model statement more variables)
# and the call for the list of variable names in the model changed slightly
modeln<-5

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_3:nlastvar_LUR_3){
  if (is.numeric(VGOB1_subsetC_staph_LUR3[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetC_staph_LUR3$staph_copiespm3.ln.diffmeth.mean~ VGOB1_subsetC_staph_LUR3[,models[[1]]$indexbestmodel]+ VGOB1_subsetC_staph_LUR3[,models[[2]]$indexbestmodel]+ VGOB1_subsetC_staph_LUR3[,models[[3]]$indexbestmodel]+ VGOB1_subsetC_staph_LUR3[,models[[4]]$indexbestmodel]+ VGOB1_subsetC_staph_LUR3[,i]) 
  
R2<-rbind(R2,summary(modeltry)$adj.r.squared)
# the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # All[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR3)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetC_staph_LUR3)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

#  this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetC_staph_LUR3)[models[[1]]$indexbestmodel], names(VGOB1_subsetC_staph_LUR3)[models[[2]]$indexbestmodel], names(VGOB1_subsetC_staph_LUR3)[models[[3]]$indexbestmodel], names(VGOB1_subsetC_staph_LUR3)[models[[4]]$indexbestmodel], names(VGOB1_subsetC_staph_LUR3)[models[[5]]$indexbestmodel])

#  this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetC_staph_LUR3$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetC_staph_LUR3[,models[[1]]$indexbestmodel]+VGOB1_subsetC_staph_LUR3[,models[[2]]$indexbestmodel]+VGOB1_subsetC_staph_LUR3[,models[[3]]$indexbestmodel]+ VGOB1_subsetC_staph_LUR3[,models[[4]]$indexbestmodel]+ VGOB1_subsetC_staph_LUR3[,models[[5]]$indexbestmodel]) 
models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[5]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[5]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel
models[[5]]$R2bestmodel

# 6 #  
# add sixth variable (the only difference of the above part is that now model n=6 the model statement more variables)
#  and the call for the list of variable names in the model changed slightly

modeln<-6

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_3 :nlastvar_LUR_3){
  if (is.numeric(VGOB1_subsetC_staph_LUR3[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetC_staph_LUR3$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetC_staph_LUR3[,models[[1]]$indexbestmodel]+VGOB1_subsetC_staph_LUR3[,models[[2]]$indexbestmodel]+VGOB1_subsetC_staph_LUR3[,models[[3]]$indexbestmodel]+VGOB1_subsetC_staph_LUR3[,models[[4]]$indexbestmodel]+VGOB1_subsetC_staph_LUR3[,models[[5]]$indexbestmodel]+ VGOB1_subsetC_staph_LUR3[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # All[,i] is the row that's being tried out now. the name of that row can be found in  names(All)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetC_staph_LUR3)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

# this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetC_staph_LUR3)[models[[1]]$indexbestmodel], names(VGOB1_subsetC_staph_LUR3)[models[[2]]$indexbestmodel] , names(VGOB1_subsetC_staph_LUR3)[models[[3]]$indexbestmodel], names(VGOB1_subsetC_staph_LUR3)[models[[4]]$indexbestmodel], names(VGOB1_subsetC_staph_LUR3)[models[[5]]$indexbestmodel], names(VGOB1_subsetC_staph_LUR3)[models[[6]]$indexbestmodel])

#  this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetC_staph_LUR3$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetC_staph_LUR3[,models[[1]]$indexbestmodel]+VGOB1_subsetC_staph_LUR3[,models[[2]]$indexbestmodel]+VGOB1_subsetC_staph_LUR3[,models[[3]]$indexbestmodel]+ VGOB1_subsetC_staph_LUR3[,models[[4]]$indexbestmodel]+ VGOB1_subsetC_staph_LUR3[,models[[5]]$indexbestmodel]+ VGOB1_subsetC_staph_LUR3[,models[[6]]$indexbestmodel]) 

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[5]]$summarybestmodel
models[[6]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[5]]$namesbestmodel
models[[6]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel
models[[5]]$R2bestmodel
models[[6]]$R2bestmodel


# 7 #  
# add seventh variable (the only difference of the above part is that now model n=7 the model statement more variables)
#  and the call for the list of variable names in the model changed slightly

modeln<-7

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_3 :nlastvar_LUR_3){
  if (is.numeric(VGOB1_subsetC_staph_LUR3[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetC_staph_LUR3$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetC_staph_LUR3[,models[[1]]$indexbestmodel]+VGOB1_subsetC_staph_LUR3[,models[[2]]$indexbestmodel]+VGOB1_subsetC_staph_LUR3[,models[[3]]$indexbestmodel]+VGOB1_subsetC_staph_LUR3[,models[[4]]$indexbestmodel]+VGOB1_subsetC_staph_LUR3[,models[[5]]$indexbestmodel]+VGOB1_subsetC_staph_LUR3[,models[[6]]$indexbestmodel]+ VGOB1_subsetC_staph_LUR3[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # Measurements_livestockpreds_LUR3[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR3)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetC_staph_LUR3)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

# this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetC_staph_LUR3)[models[[1]]$indexbestmodel], names(VGOB1_subsetC_staph_LUR3)[models[[2]]$indexbestmodel] , names(VGOB1_subsetC_staph_LUR3)[models[[3]]$indexbestmodel], names(VGOB1_subsetC_staph_LUR3)[models[[4]]$indexbestmodel], names(VGOB1_subsetC_staph_LUR3)[models[[5]]$indexbestmodel], names(VGOB1_subsetC_staph_LUR3)[models[[6]]$indexbestmodel], names(VGOB1_subsetC_staph_LUR3)[models[[7]]$indexbestmodel])

#  this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetC_staph_LUR3$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetC_staph_LUR3[,models[[1]]$indexbestmodel]+VGOB1_subsetC_staph_LUR3[,models[[2]]$indexbestmodel]+VGOB1_subsetC_staph_LUR3[,models[[3]]$indexbestmodel]+ VGOB1_subsetC_staph_LUR3[,models[[4]]$indexbestmodel]+ VGOB1_subsetC_staph_LUR3[,models[[5]]$indexbestmodel]+ VGOB1_subsetC_staph_LUR3[,models[[6]]$indexbestmodel]+ VGOB1_subsetC_staph_LUR3[,models[[7]]$indexbestmodel]) 

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[5]]$summarybestmodel
models[[6]]$summarybestmodel
models[[7]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[5]]$namesbestmodel
models[[6]]$namesbestmodel
models[[7]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel
models[[5]]$R2bestmodel
models[[6]]$R2bestmodel
models[[7]]$R2bestmodel

# 8 #  
# add eighth variable (the only difference of the above part is that now modeln=7 the model statement more variables)
# and the call for the list of variable names in the model changed slightly

modeln<-8

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_3 :nlastvar_LUR_3){
  if (is.numeric(VGOB1_subsetC_staph_LUR3[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetC_staph_LUR3$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetC_staph_LUR3[,models[[1]]$indexbestmodel]+VGOB1_subsetC_staph_LUR3[,models[[2]]$indexbestmodel]+VGOB1_subsetC_staph_LUR3[,models[[3]]$indexbestmodel]+VGOB1_subsetC_staph_LUR3[,models[[4]]$indexbestmodel]+VGOB1_subsetC_staph_LUR3[,models[[5]]$indexbestmodel]+VGOB1_subsetC_staph_LUR3[,models[[6]]$indexbestmodel]+ VGOB1_subsetC_staph_LUR3[,models[[7]]$indexbestmodel]+ VGOB1_subsetC_staph_LUR3[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # Measurements_livestockpreds_LUR3[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR3)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetC_staph_LUR3)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

# this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetC_staph_LUR3)[models[[1]]$indexbestmodel], names(VGOB1_subsetC_staph_LUR3)[models[[2]]$indexbestmodel] , names(VGOB1_subsetC_staph_LUR3)[models[[3]]$indexbestmodel], names(VGOB1_subsetC_staph_LUR3)[models[[4]]$indexbestmodel], names(VGOB1_subsetC_staph_LUR3)[models[[5]]$indexbestmodel], names(VGOB1_subsetC_staph_LUR3)[models[[6]]$indexbestmodel], names(VGOB1_subsetC_staph_LUR3)[models[[7]]$indexbestmodel], names(VGOB1_subsetC_staph_LUR3)[models[[8]]$indexbestmodel])

#  this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetC_staph_LUR3$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetC_staph_LUR3[,models[[1]]$indexbestmodel]+VGOB1_subsetC_staph_LUR3[,models[[2]]$indexbestmodel]+VGOB1_subsetC_staph_LUR3[,models[[3]]$indexbestmodel]+ VGOB1_subsetC_staph_LUR3[,models[[4]]$indexbestmodel]+ VGOB1_subsetC_staph_LUR3[,models[[5]]$indexbestmodel]+ VGOB1_subsetC_staph_LUR3[,models[[6]]$indexbestmodel]+ VGOB1_subsetC_staph_LUR3[,models[[7]]$indexbestmodel]+ VGOB1_subsetC_staph_LUR3[,models[[8]]$indexbestmodel]) 

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[5]]$summarybestmodel
models[[6]]$summarybestmodel
models[[7]]$summarybestmodel
models[[8]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[5]]$namesbestmodel
models[[6]]$namesbestmodel
models[[7]]$namesbestmodel
models[[8]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel
models[[5]]$R2bestmodel
models[[6]]$R2bestmodel
models[[7]]$R2bestmodel
models[[8]]$R2bestmodel

# 9 #  
# add ninth variable (the only difference of the above part is that now modeln=9 the model statement more variables)
# and the call for the list of variable names in the model changed slightly

modeln<-9

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_3 :nlastvar_LUR_3){
  if (is.numeric(VGOB1_subsetC_staph_LUR3[,i])==TRUE){
      modeltry<-lm(VGOB1_subsetC_staph_LUR3$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetC_staph_LUR3[,models[[1]]$indexbestmodel]+VGOB1_subsetC_staph_LUR3[,models[[2]]$indexbestmodel]+VGOB1_subsetC_staph_LUR3[,models[[3]]$indexbestmodel]+VGOB1_subsetC_staph_LUR3[,models[[4]]$indexbestmodel]+VGOB1_subsetC_staph_LUR3[,models[[5]]$indexbestmodel]+VGOB1_subsetC_staph_LUR3[,models[[6]]$indexbestmodel]+ VGOB1_subsetC_staph_LUR3[,models[[7]]$indexbestmodel]+ VGOB1_subsetC_staph_LUR3[,models[[8]]$indexbestmodel]+ VGOB1_subsetC_staph_LUR3[,i]) 
        R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # Measurements_livestockpreds_LUR3[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR3)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetC_staph_LUR3)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

# this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetC_staph_LUR3)[models[[1]]$indexbestmodel], names(VGOB1_subsetC_staph_LUR3)[models[[2]]$indexbestmodel] , names(VGOB1_subsetC_staph_LUR3)[models[[3]]$indexbestmodel], names(VGOB1_subsetC_staph_LUR3)[models[[4]]$indexbestmodel], names(VGOB1_subsetC_staph_LUR3)[models[[5]]$indexbestmodel], names(VGOB1_subsetC_staph_LUR3)[models[[6]]$indexbestmodel], names(VGOB1_subsetC_staph_LUR3)[models[[7]]$indexbestmodel], names(VGOB1_subsetC_staph_LUR3)[models[[8]]$indexbestmodel],  names(VGOB1_subsetC_staph_LUR3)[models[[9]]$indexbestmodel])

#  this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetC_staph_LUR3$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetC_staph_LUR3[,models[[1]]$indexbestmodel]+VGOB1_subsetC_staph_LUR3[,models[[2]]$indexbestmodel]+VGOB1_subsetC_staph_LUR3[,models[[3]]$indexbestmodel]+ VGOB1_subsetC_staph_LUR3[,models[[4]]$indexbestmodel]+ VGOB1_subsetC_staph_LUR3[,models[[5]]$indexbestmodel]+ VGOB1_subsetC_staph_LUR3[,models[[6]]$indexbestmodel]+ VGOB1_subsetC_staph_LUR3[,models[[7]]$indexbestmodel]+ VGOB1_subsetC_staph_LUR3[,models[[8]]$indexbestmodel]+ VGOB1_subsetC_staph_LUR3[,models[[9]]$indexbestmodel]) 

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[5]]$summarybestmodel
models[[6]]$summarybestmodel
models[[7]]$summarybestmodel
models[[8]]$summarybestmodel
models[[9]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[5]]$namesbestmodel
models[[6]]$namesbestmodel
models[[7]]$namesbestmodel
models[[8]]$namesbestmodel
models[[9]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel
models[[5]]$R2bestmodel
models[[6]]$R2bestmodel
models[[7]]$R2bestmodel
models[[8]]$R2bestmodel
models[[9]]$R2bestmodel

# 10 #  
#  add tenth variable (the only difference of the above part is that now model n=10 the model statement more variables)
#  and the call for the list of variable names in the model changed slightly

modeln<-10

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_3 :nlastvar_LUR_3){if (is.numeric(VGOB1_subsetC_staph_LUR3[,i])==TRUE){ modeltry<-lm(VGOB1_subsetC_staph_LUR3$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetC_staph_LUR3[,models[[1]]$indexbestmodel]+VGOB1_subsetC_staph_LUR3[,models[[2]]$indexbestmodel]+ VGOB1_subsetC_staph_LUR3[,models[[3]]$indexbestmodel]+VGOB1_subsetC_staph_LUR3[,models[[4]]$indexbestmodel]+ VGOB1_subsetC_staph_LUR3[,models[[5]]$indexbestmodel]+ VGOB1_subsetC_staph_LUR3[,models[[6]]$indexbestmodel]+ VGOB1_subsetC_staph_LUR3[,models[[7]]$indexbestmodel]+ VGOB1_subsetC_staph_LUR3[,models[[8]]$indexbestmodel]+ VGOB1_subsetC_staph_LUR3[,models[[9]]$indexbestmodel]+ VGOB1_subsetC_staph_LUR3[,i]) 

R2<-rbind(R2,summary(modeltry)$adj.r.squared)
# the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # Measurements_livestockpreds_LUR3[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR3)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetC_staph_LUR3)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

# this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

# here are the names
models[[modeln]]$namesbestmodel<-c( names(VGOB1_subsetC_staph_LUR3)[models[[1]]$indexbestmodel],                   names(VGOB1_subsetC_staph_LUR3)[models[[2]]$indexbestmodel] , names(VGOB1_subsetC_staph_LUR3)[models[[3]]$indexbestmodel], names(VGOB1_subsetC_staph_LUR3)[models[[4]]$indexbestmodel], names(VGOB1_subsetC_staph_LUR3)[models[[5]]$indexbestmodel], names(VGOB1_subsetC_staph_LUR3)[models[[6]]$indexbestmodel], names(VGOB1_subsetC_staph_LUR3)[models[[7]]$indexbestmodel], names(VGOB1_subsetC_staph_LUR3)[models[[8]]$indexbestmodel], names(VGOB1_subsetC_staph_LUR3)[models[[9]]$indexbestmodel], names(VGOB1_subsetC_staph_LUR3)[models[[10]]$indexbestmodel])

#  this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetC_staph_LUR3$staph_copiespm3.ln.diffmeth.mean~                                VGOB1_subsetC_staph_LUR3[,models[[1]]$indexbestmodel]+ VGOB1_subsetC_staph_LUR3[,models[[2]]$indexbestmodel]+                           VGOB1_subsetC_staph_LUR3[,models[[3]]$indexbestmodel]+ VGOB1_subsetC_staph_LUR3[,models[[4]]$indexbestmodel]+ VGOB1_subsetC_staph_LUR3[,models[[5]]$indexbestmodel]+ VGOB1_subsetC_staph_LUR3[,models[[6]]$indexbestmodel]+ VGOB1_subsetC_staph_LUR3[,models[[7]]$indexbestmodel]+ VGOB1_subsetC_staph_LUR3[,models[[8]]$indexbestmodel]+ VGOB1_subsetC_staph_LUR3[,models[[9]]$indexbestmodel]+ VGOB1_subsetC_staph_LUR3[,models[[10]]$indexbestmodel]) 

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[5]]$summarybestmodel
models[[6]]$summarybestmodel
models[[7]]$summarybestmodel
models[[8]]$summarybestmodel
models[[9]]$summarybestmodel
models[[10]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[5]]$namesbestmodel
models[[6]]$namesbestmodel
models[[7]]$namesbestmodel
models[[8]]$namesbestmodel
models[[9]]$namesbestmodel
models[[10]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel
models[[5]]$R2bestmodel
models[[6]]$R2bestmodel
models[[7]]$R2bestmodel
models[[8]]$R2bestmodel
models[[9]]$R2bestmodel
models[[10]]$R2bestmodel

#  at this point I always check whether the next model is more than 1% better than the one before and if not I end here

#   CODE FOR PICKING OUT THE BEST MODEL #   
temp <- 0
besti <- 0
for (i in 1:10){ #  think this runs the loop 10 times - not fully sure thought - but not to do with the number of models I don't think - as when I change to 3, I still get the model with 4 variables as best model
  print(models[[i]]$R2bestmodel)
  #       print(models[[i]]$summarybestmodel$coefficients=-1,4])
  #       if((models[[i]]$R2bestmodel-temp > 0.0) && (all(models[[i]]$summarybestmodel$coefficients[-1,4]<0.1))){
  #         temp <- models[[i]]$R2bestmodel
  #         besti <- i
  #         }
  if((models[[i]]$R2bestmodel-temp > 0.0) && (all(models[[i]]$summarybestmodel$coefficients[-1,4]<0.1))){
    temp <- models[[i]]$R2bestmodel
    besti <- i
  }else{
    finalBestModel_staph_LUR3_subsetC <- models[[besti]]$bestmodel
    finalBestModelNames_staph_subsetC <- models[[besti]]$namesbestmodel
    Sites <- 1:dim(VGOB1_subsetC_staph_LUR3)[1] # full original model
    #  CVaR2<-escCV_staph_LUR3(Sites)[2] # Cross Validation
    maxCD<-max(cooks.distance(finalBestModel_staph_LUR3_subsetC))
    if(length(finalBestModelNames_staph_subsetC)<2){ # vif fn doesnot work when only 1 variable...       # 
      maxVIF<-"NA"
    }else{
      maxVIF<-max(vif(finalBestModel_staph_LUR3_subsetC))
    }
    print(paste("This is the best staph model for subset C: ",besti,
                "(AdjR2: ",format(models[[besti]]$R2bestmodel,digits=3), "; MaxCD: ",format(maxCD,digits=3),"; MaxVIF: ",
                format(maxVIF,digits=3),")", sep=''))
    print(finalBestModelNames_staph_subsetC)
    break
  }
}

#  Overview of the final best model using the algorithm selection process (taking into account VIF, R^2, and p-values)
finalBestModel_staph_LUR3_subsetC
finalBestModelNames_staph_subsetC
models[[besti]]$summarybestmodel
models[[besti]]$R2bestmodel

#### D ####
# LUR model building process for subset D
#  This is the dataframe with the relevant predictor vars for LUR3 models for subset D (55 sites)
VGOB1_subsetD_staph_LUR3 # n.b. this dataframe only includes microbial marker concentrations for staph unlike the dataframe Measurements_livestockpreds_LUR3 as previously used for the model building. 

#  Now set the values of some variables that will be needed
nfirstvar_LUR_3 <- 3  
nlastvar_LUR_3 <- 135

# Function building to run the models 
# 1 #  

models<-list()
modeln<-1
models[[modeln]]<-list()

R2<-1
betaaddedvar<-1
addedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_3:nlastvar_LUR_3){
  if (is.numeric(VGOB1_subsetD_staph_LUR3[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetD_staph_LUR3$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetD_staph_LUR3[,i])                            
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    #  Measurements_livestockpreds_LUR3[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR3)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetD_staph_LUR3)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)
models[[modeln]]$results

#  this are the candidates models with the highest R2, not a negative beta for the new, nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)
models[[modeln]]$resultspos

#  rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))
models[[modeln]]$resultspos

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j
models[[modeln]]$indexbestmodel

subset(models[[modeln]]$resultspos, rank==1)
subset(models[[modeln]]$resultspos)

#  this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]
models[[modeln]]$summarybestmodel

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetD_staph_LUR3)[models[[1]]$indexbestmodel])
models[[modeln]]$namesbestmodel

#  this is the r2 of that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2
models[[modeln]]$R2bestmodel

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetD_staph_LUR3$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetD_staph_LUR3[,models[[1]]$indexbestmodel]) 
models[[modeln]]$bestmodel

summary(models[[modeln]]$bestmodel)

#  The first model includes the predictor: nPigMultipFarmWghtDist.3000m.sum.Tr.1P9 - meaning the number of multiplier pig farms weighted to distance in a 3000m buffer

# 2 #  
# Add 2nd variable (the only difference of the above part is that now modeln=2 the model statement has 2 variables)
# and the call for the list of variable names in the model changed slightly

modeln<-2

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_3:nlastvar_LUR_3){
  if (is.numeric(VGOB1_subsetD_staph_LUR3[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetD_staph_LUR3$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetD_staph_LUR3[,models[[1]]$indexbestmodel]+ VGOB1_subsetD_staph_LUR3[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # Measurements_livestockpreds_LUR3[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR3)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetD_staph_LUR3)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  these are the candidate models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)
models[[modeln]]$resultspos

#  rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))
models[[modeln]]$resultspos

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j
models[[modeln]]$indexbestmodel

subset(models[[modeln]]$resultspos, rank==1)

# this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]
models[[modeln]]$summarybestmodel

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetD_staph_LUR3)[models[[1]]$indexbestmodel], names(VGOB1_subsetD_staph_LUR3)[models[[2]]$indexbestmodel] )
models[[modeln]]$namesbestmodel

# this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2
models[[modeln]]$R2bestmodel

# this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetD_staph_LUR3$staph_copiespm3.ln.diffmeth.mean~                               VGOB1_subsetD_staph_LUR3[,models[[1]]$indexbestmodel]+                           VGOB1_subsetD_staph_LUR3[,models[[2]]$indexbestmodel]) 

models[[modeln]]$bestmodel

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel


# 3 #  
# add third variable (the only difference of the above part is that now modeln=3 the model statement has 3 variables)
# and the call for the list of variable names in the model changed slightly

modeln<-3

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_3:nlastvar_LUR_3){
  if (is.numeric(VGOB1_subsetD_staph_LUR3[,i])==TRUE){  
    modeltry<-lm(VGOB1_subsetD_staph_LUR3$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetD_staph_LUR3[,models[[1]]$indexbestmodel]+VGOB1_subsetD_staph_LUR3[,models[[2]]$indexbestmodel]+ VGOB1_subsetD_staph_LUR3[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # All[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR3)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetD_staph_LUR3)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

#  rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

#  this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

#  here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetD_staph_LUR3)[models[[1]]$indexbestmodel], names(VGOB1_subsetD_staph_LUR3)[models[[2]]$indexbestmodel], names(VGOB1_subsetD_staph_LUR3)[models[[3]]$indexbestmodel])

#  this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetD_staph_LUR3$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetD_staph_LUR3[,models[[1]]$indexbestmodel]+ VGOB1_subsetD_staph_LUR3[,models[[2]]$indexbestmodel]+ VGOB1_subsetD_staph_LUR3[,models[[3]]$indexbestmodel]) 

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel


# 4 #  
#  add forth variable (the only difference of the above part is that now model n=4 the model statement more variables)
#  and the call for the list of variable names in the model changed slightly
modeln<-4

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1


for (i in nfirstvar_LUR_3:nlastvar_LUR_3){
  if (is.numeric(VGOB1_subsetD_staph_LUR3[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetD_staph_LUR3$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetD_staph_LUR3[,models[[1]]$indexbestmodel]+VGOB1_subsetD_staph_LUR3[,models[[2]]$indexbestmodel]+VGOB1_subsetD_staph_LUR3[,models[[3]]$indexbestmodel]+VGOB1_subsetD_staph_LUR3[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    #  the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    #  All[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR3)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetD_staph_LUR3)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

#  this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

#  here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetD_staph_LUR3)[models[[1]]$indexbestmodel], names(VGOB1_subsetD_staph_LUR3)[models[[2]]$indexbestmodel], names(VGOB1_subsetD_staph_LUR3)[models[[3]]$indexbestmodel], names(VGOB1_subsetD_staph_LUR3)[models[[4]]$indexbestmodel])

#  this is the r2 of that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetD_staph_LUR3$staph_copiespm3.ln.diffmeth.mean~ VGOB1_subsetD_staph_LUR3[,models[[1]]$indexbestmodel]+ VGOB1_subsetD_staph_LUR3[,models[[2]]$indexbestmodel]+VGOB1_subsetD_staph_LUR3[,models[[3]]$indexbestmodel]+ VGOB1_subsetD_staph_LUR3[,models[[4]]$indexbestmodel]) 


models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel


# 5 #  
# add fifth variable (the only difference of the above part is that now modeln=5 the model statement more variables)
# and the call for the list of variable names in the model changed slightly
modeln<-5

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_3:nlastvar_LUR_3){
  if (is.numeric(VGOB1_subsetD_staph_LUR3[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetD_staph_LUR3$staph_copiespm3.ln.diffmeth.mean~ VGOB1_subsetD_staph_LUR3[,models[[1]]$indexbestmodel]+ VGOB1_subsetD_staph_LUR3[,models[[2]]$indexbestmodel]+ VGOB1_subsetD_staph_LUR3[,models[[3]]$indexbestmodel]+ VGOB1_subsetD_staph_LUR3[,models[[4]]$indexbestmodel]+ VGOB1_subsetD_staph_LUR3[,i]) 
  
R2<-rbind(R2,summary(modeltry)$adj.r.squared)
# the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # All[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR3)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetD_staph_LUR3)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

#  this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetD_staph_LUR3)[models[[1]]$indexbestmodel], names(VGOB1_subsetD_staph_LUR3)[models[[2]]$indexbestmodel], names(VGOB1_subsetD_staph_LUR3)[models[[3]]$indexbestmodel], names(VGOB1_subsetD_staph_LUR3)[models[[4]]$indexbestmodel], names(VGOB1_subsetD_staph_LUR3)[models[[5]]$indexbestmodel])

#  this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetD_staph_LUR3$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetD_staph_LUR3[,models[[1]]$indexbestmodel]+VGOB1_subsetD_staph_LUR3[,models[[2]]$indexbestmodel]+VGOB1_subsetD_staph_LUR3[,models[[3]]$indexbestmodel]+ VGOB1_subsetD_staph_LUR3[,models[[4]]$indexbestmodel]+ VGOB1_subsetD_staph_LUR3[,models[[5]]$indexbestmodel]) 
models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[5]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[5]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel
models[[5]]$R2bestmodel

# 6 #  
# add sixth variable (the only difference of the above part is that now model n=6 the model statement more variables)
#  and the call for the list of variable names in the model changed slightly

modeln<-6

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_3 :nlastvar_LUR_3){
  if (is.numeric(VGOB1_subsetD_staph_LUR3[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetD_staph_LUR3$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetD_staph_LUR3[,models[[1]]$indexbestmodel]+VGOB1_subsetD_staph_LUR3[,models[[2]]$indexbestmodel]+VGOB1_subsetD_staph_LUR3[,models[[3]]$indexbestmodel]+VGOB1_subsetD_staph_LUR3[,models[[4]]$indexbestmodel]+VGOB1_subsetD_staph_LUR3[,models[[5]]$indexbestmodel]+ VGOB1_subsetD_staph_LUR3[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # All[,i] is the row that's being tried out now. the name of that row can be found in  names(All)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetD_staph_LUR3)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

# this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetD_staph_LUR3)[models[[1]]$indexbestmodel], names(VGOB1_subsetD_staph_LUR3)[models[[2]]$indexbestmodel] , names(VGOB1_subsetD_staph_LUR3)[models[[3]]$indexbestmodel], names(VGOB1_subsetD_staph_LUR3)[models[[4]]$indexbestmodel], names(VGOB1_subsetD_staph_LUR3)[models[[5]]$indexbestmodel], names(VGOB1_subsetD_staph_LUR3)[models[[6]]$indexbestmodel])

#  this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetD_staph_LUR3$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetD_staph_LUR3[,models[[1]]$indexbestmodel]+VGOB1_subsetD_staph_LUR3[,models[[2]]$indexbestmodel]+VGOB1_subsetD_staph_LUR3[,models[[3]]$indexbestmodel]+ VGOB1_subsetD_staph_LUR3[,models[[4]]$indexbestmodel]+ VGOB1_subsetD_staph_LUR3[,models[[5]]$indexbestmodel]+ VGOB1_subsetD_staph_LUR3[,models[[6]]$indexbestmodel]) 

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[5]]$summarybestmodel
models[[6]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[5]]$namesbestmodel
models[[6]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel
models[[5]]$R2bestmodel
models[[6]]$R2bestmodel


# 7 #  
# add seventh variable (the only difference of the above part is that now model n=7 the model statement more variables)
#  and the call for the list of variable names in the model changed slightly

modeln<-7

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_3 :nlastvar_LUR_3){
  if (is.numeric(VGOB1_subsetD_staph_LUR3[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetD_staph_LUR3$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetD_staph_LUR3[,models[[1]]$indexbestmodel]+VGOB1_subsetD_staph_LUR3[,models[[2]]$indexbestmodel]+VGOB1_subsetD_staph_LUR3[,models[[3]]$indexbestmodel]+VGOB1_subsetD_staph_LUR3[,models[[4]]$indexbestmodel]+VGOB1_subsetD_staph_LUR3[,models[[5]]$indexbestmodel]+VGOB1_subsetD_staph_LUR3[,models[[6]]$indexbestmodel]+ VGOB1_subsetD_staph_LUR3[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # Measurements_livestockpreds_LUR3[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR3)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetD_staph_LUR3)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

# this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetD_staph_LUR3)[models[[1]]$indexbestmodel], names(VGOB1_subsetD_staph_LUR3)[models[[2]]$indexbestmodel] , names(VGOB1_subsetD_staph_LUR3)[models[[3]]$indexbestmodel], names(VGOB1_subsetD_staph_LUR3)[models[[4]]$indexbestmodel], names(VGOB1_subsetD_staph_LUR3)[models[[5]]$indexbestmodel], names(VGOB1_subsetD_staph_LUR3)[models[[6]]$indexbestmodel], names(VGOB1_subsetD_staph_LUR3)[models[[7]]$indexbestmodel])

#  this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetD_staph_LUR3$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetD_staph_LUR3[,models[[1]]$indexbestmodel]+VGOB1_subsetD_staph_LUR3[,models[[2]]$indexbestmodel]+VGOB1_subsetD_staph_LUR3[,models[[3]]$indexbestmodel]+ VGOB1_subsetD_staph_LUR3[,models[[4]]$indexbestmodel]+ VGOB1_subsetD_staph_LUR3[,models[[5]]$indexbestmodel]+ VGOB1_subsetD_staph_LUR3[,models[[6]]$indexbestmodel]+ VGOB1_subsetD_staph_LUR3[,models[[7]]$indexbestmodel]) 

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[5]]$summarybestmodel
models[[6]]$summarybestmodel
models[[7]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[5]]$namesbestmodel
models[[6]]$namesbestmodel
models[[7]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel
models[[5]]$R2bestmodel
models[[6]]$R2bestmodel
models[[7]]$R2bestmodel

# 8 #  
# add eighth variable (the only difference of the above part is that now modeln=7 the model statement more variables)
# and the call for the list of variable names in the model changed slightly

modeln<-8

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_3 :nlastvar_LUR_3){
  if (is.numeric(VGOB1_subsetD_staph_LUR3[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetD_staph_LUR3$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetD_staph_LUR3[,models[[1]]$indexbestmodel]+VGOB1_subsetD_staph_LUR3[,models[[2]]$indexbestmodel]+VGOB1_subsetD_staph_LUR3[,models[[3]]$indexbestmodel]+VGOB1_subsetD_staph_LUR3[,models[[4]]$indexbestmodel]+VGOB1_subsetD_staph_LUR3[,models[[5]]$indexbestmodel]+VGOB1_subsetD_staph_LUR3[,models[[6]]$indexbestmodel]+ VGOB1_subsetD_staph_LUR3[,models[[7]]$indexbestmodel]+ VGOB1_subsetD_staph_LUR3[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # Measurements_livestockpreds_LUR3[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR3)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetD_staph_LUR3)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

# this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetD_staph_LUR3)[models[[1]]$indexbestmodel], names(VGOB1_subsetD_staph_LUR3)[models[[2]]$indexbestmodel] , names(VGOB1_subsetD_staph_LUR3)[models[[3]]$indexbestmodel], names(VGOB1_subsetD_staph_LUR3)[models[[4]]$indexbestmodel], names(VGOB1_subsetD_staph_LUR3)[models[[5]]$indexbestmodel], names(VGOB1_subsetD_staph_LUR3)[models[[6]]$indexbestmodel], names(VGOB1_subsetD_staph_LUR3)[models[[7]]$indexbestmodel], names(VGOB1_subsetD_staph_LUR3)[models[[8]]$indexbestmodel])

#  this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetD_staph_LUR3$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetD_staph_LUR3[,models[[1]]$indexbestmodel]+VGOB1_subsetD_staph_LUR3[,models[[2]]$indexbestmodel]+VGOB1_subsetD_staph_LUR3[,models[[3]]$indexbestmodel]+ VGOB1_subsetD_staph_LUR3[,models[[4]]$indexbestmodel]+ VGOB1_subsetD_staph_LUR3[,models[[5]]$indexbestmodel]+ VGOB1_subsetD_staph_LUR3[,models[[6]]$indexbestmodel]+ VGOB1_subsetD_staph_LUR3[,models[[7]]$indexbestmodel]+ VGOB1_subsetD_staph_LUR3[,models[[8]]$indexbestmodel]) 

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[5]]$summarybestmodel
models[[6]]$summarybestmodel
models[[7]]$summarybestmodel
models[[8]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[5]]$namesbestmodel
models[[6]]$namesbestmodel
models[[7]]$namesbestmodel
models[[8]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel
models[[5]]$R2bestmodel
models[[6]]$R2bestmodel
models[[7]]$R2bestmodel
models[[8]]$R2bestmodel

# 9 #  
# add ninth variable (the only difference of the above part is that now modeln=9 the model statement more variables)
# and the call for the list of variable names in the model changed slightly

modeln<-9

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_3 :nlastvar_LUR_3){
  if (is.numeric(VGOB1_subsetD_staph_LUR3[,i])==TRUE){
      modeltry<-lm(VGOB1_subsetD_staph_LUR3$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetD_staph_LUR3[,models[[1]]$indexbestmodel]+VGOB1_subsetD_staph_LUR3[,models[[2]]$indexbestmodel]+VGOB1_subsetD_staph_LUR3[,models[[3]]$indexbestmodel]+VGOB1_subsetD_staph_LUR3[,models[[4]]$indexbestmodel]+VGOB1_subsetD_staph_LUR3[,models[[5]]$indexbestmodel]+VGOB1_subsetD_staph_LUR3[,models[[6]]$indexbestmodel]+ VGOB1_subsetD_staph_LUR3[,models[[7]]$indexbestmodel]+ VGOB1_subsetD_staph_LUR3[,models[[8]]$indexbestmodel]+ VGOB1_subsetD_staph_LUR3[,i]) 
        R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # Measurements_livestockpreds_LUR3[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR3)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetD_staph_LUR3)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

# this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetD_staph_LUR3)[models[[1]]$indexbestmodel], names(VGOB1_subsetD_staph_LUR3)[models[[2]]$indexbestmodel] , names(VGOB1_subsetD_staph_LUR3)[models[[3]]$indexbestmodel], names(VGOB1_subsetD_staph_LUR3)[models[[4]]$indexbestmodel], names(VGOB1_subsetD_staph_LUR3)[models[[5]]$indexbestmodel], names(VGOB1_subsetD_staph_LUR3)[models[[6]]$indexbestmodel], names(VGOB1_subsetD_staph_LUR3)[models[[7]]$indexbestmodel], names(VGOB1_subsetD_staph_LUR3)[models[[8]]$indexbestmodel],  names(VGOB1_subsetD_staph_LUR3)[models[[9]]$indexbestmodel])

#  this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetD_staph_LUR3$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetD_staph_LUR3[,models[[1]]$indexbestmodel]+VGOB1_subsetD_staph_LUR3[,models[[2]]$indexbestmodel]+VGOB1_subsetD_staph_LUR3[,models[[3]]$indexbestmodel]+ VGOB1_subsetD_staph_LUR3[,models[[4]]$indexbestmodel]+ VGOB1_subsetD_staph_LUR3[,models[[5]]$indexbestmodel]+ VGOB1_subsetD_staph_LUR3[,models[[6]]$indexbestmodel]+ VGOB1_subsetD_staph_LUR3[,models[[7]]$indexbestmodel]+ VGOB1_subsetD_staph_LUR3[,models[[8]]$indexbestmodel]+ VGOB1_subsetD_staph_LUR3[,models[[9]]$indexbestmodel]) 

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[5]]$summarybestmodel
models[[6]]$summarybestmodel
models[[7]]$summarybestmodel
models[[8]]$summarybestmodel
models[[9]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[5]]$namesbestmodel
models[[6]]$namesbestmodel
models[[7]]$namesbestmodel
models[[8]]$namesbestmodel
models[[9]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel
models[[5]]$R2bestmodel
models[[6]]$R2bestmodel
models[[7]]$R2bestmodel
models[[8]]$R2bestmodel
models[[9]]$R2bestmodel

# 10 #  
#  add tenth variable (the only difference of the above part is that now model n=10 the model statement more variables)
#  and the call for the list of variable names in the model changed slightly

modeln<-10

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_3 :nlastvar_LUR_3){if (is.numeric(VGOB1_subsetD_staph_LUR3[,i])==TRUE){ modeltry<-lm(VGOB1_subsetD_staph_LUR3$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetD_staph_LUR3[,models[[1]]$indexbestmodel]+VGOB1_subsetD_staph_LUR3[,models[[2]]$indexbestmodel]+ VGOB1_subsetD_staph_LUR3[,models[[3]]$indexbestmodel]+VGOB1_subsetD_staph_LUR3[,models[[4]]$indexbestmodel]+ VGOB1_subsetD_staph_LUR3[,models[[5]]$indexbestmodel]+ VGOB1_subsetD_staph_LUR3[,models[[6]]$indexbestmodel]+ VGOB1_subsetD_staph_LUR3[,models[[7]]$indexbestmodel]+ VGOB1_subsetD_staph_LUR3[,models[[8]]$indexbestmodel]+ VGOB1_subsetD_staph_LUR3[,models[[9]]$indexbestmodel]+ VGOB1_subsetD_staph_LUR3[,i]) 

R2<-rbind(R2,summary(modeltry)$adj.r.squared)
# the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # Measurements_livestockpreds_LUR3[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR3)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetD_staph_LUR3)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

# this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

# here are the names
models[[modeln]]$namesbestmodel<-c( names(VGOB1_subsetD_staph_LUR3)[models[[1]]$indexbestmodel],                   names(VGOB1_subsetD_staph_LUR3)[models[[2]]$indexbestmodel] , names(VGOB1_subsetD_staph_LUR3)[models[[3]]$indexbestmodel], names(VGOB1_subsetD_staph_LUR3)[models[[4]]$indexbestmodel], names(VGOB1_subsetD_staph_LUR3)[models[[5]]$indexbestmodel], names(VGOB1_subsetD_staph_LUR3)[models[[6]]$indexbestmodel], names(VGOB1_subsetD_staph_LUR3)[models[[7]]$indexbestmodel], names(VGOB1_subsetD_staph_LUR3)[models[[8]]$indexbestmodel], names(VGOB1_subsetD_staph_LUR3)[models[[9]]$indexbestmodel], names(VGOB1_subsetD_staph_LUR3)[models[[10]]$indexbestmodel])

#  this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetD_staph_LUR3$staph_copiespm3.ln.diffmeth.mean~                                VGOB1_subsetD_staph_LUR3[,models[[1]]$indexbestmodel]+ VGOB1_subsetD_staph_LUR3[,models[[2]]$indexbestmodel]+                           VGOB1_subsetD_staph_LUR3[,models[[3]]$indexbestmodel]+ VGOB1_subsetD_staph_LUR3[,models[[4]]$indexbestmodel]+ VGOB1_subsetD_staph_LUR3[,models[[5]]$indexbestmodel]+ VGOB1_subsetD_staph_LUR3[,models[[6]]$indexbestmodel]+ VGOB1_subsetD_staph_LUR3[,models[[7]]$indexbestmodel]+ VGOB1_subsetD_staph_LUR3[,models[[8]]$indexbestmodel]+ VGOB1_subsetD_staph_LUR3[,models[[9]]$indexbestmodel]+ VGOB1_subsetD_staph_LUR3[,models[[10]]$indexbestmodel]) 

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[5]]$summarybestmodel
models[[6]]$summarybestmodel
models[[7]]$summarybestmodel
models[[8]]$summarybestmodel
models[[9]]$summarybestmodel
models[[10]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[5]]$namesbestmodel
models[[6]]$namesbestmodel
models[[7]]$namesbestmodel
models[[8]]$namesbestmodel
models[[9]]$namesbestmodel
models[[10]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel
models[[5]]$R2bestmodel
models[[6]]$R2bestmodel
models[[7]]$R2bestmodel
models[[8]]$R2bestmodel
models[[9]]$R2bestmodel
models[[10]]$R2bestmodel

#  at this point I always check whether the next model is more than 1% better than the one before and if not I end here

#   CODE FOR PICKING OUT THE BEST MODEL #   
temp <- 0
besti <- 0
for (i in 1:10){ #  think this runs the loop 10 times - not fully sure thought - but not to do with the number of models I don't think - as when I change to 3, I still get the model with 4 variables as best model
  print(models[[i]]$R2bestmodel)
  #       print(models[[i]]$summarybestmodel$coefficients=-1,4])
  #       if((models[[i]]$R2bestmodel-temp > 0.0) && (all(models[[i]]$summarybestmodel$coefficients[-1,4]<0.1))){
  #         temp <- models[[i]]$R2bestmodel
  #         besti <- i
  #         }
  if((models[[i]]$R2bestmodel-temp > 0.0) && (all(models[[i]]$summarybestmodel$coefficients[-1,4]<0.1))){
    temp <- models[[i]]$R2bestmodel
    besti <- i
  }else{
    finalBestModel_staph_LUR3_subsetD <- models[[besti]]$bestmodel
    finalBestModelNames_staph_subsetD <- models[[besti]]$namesbestmodel
    Sites <- 1:dim(VGOB1_subsetD_staph_LUR3)[1] # full original model
    #  CVaR2<-escCV_staph_LUR3(Sites)[2] # Cross Validation
    maxCD<-max(cooks.distance(finalBestModel_staph_LUR3_subsetD))
    if(length(finalBestModelNames_staph_subsetD)<2){ # vif fn doesnot work when only 1 variable...       # 
      maxVIF<-"NA"
    }else{
      maxVIF<-max(vif(finalBestModel_staph_LUR3_subsetD))
    }
    print(paste("This is the best staph model for subset D: ",besti,
                "(AdjR2: ",format(models[[besti]]$R2bestmodel,digits=3), "; MaxCD: ",format(maxCD,digits=3),"; MaxVIF: ",
                format(maxVIF,digits=3),")", sep=''))
    print(finalBestModelNames_staph_subsetD)
    break
  }
}

#  Overview of the final best model using the algorithm selection process (taking into account VIF, R^2, and p-values)
finalBestModel_staph_LUR3_subsetD
finalBestModelNames_staph_subsetD
models[[besti]]$summarybestmodel
models[[besti]]$R2bestmodel


#### E ####
# LUR model building process for subset E
#  This is the dataframe with the relevant predictor vars for LUR3 models for subset E (55 sites)
VGOB1_subsetE_staph_LUR3 # n.b. this dataframe only includes microbial marker concentrations for staph unlike the dataframe Measurements_livestockpreds_LUR3 as previously used for the model building. 

#  Now set the values of some variables that will be needed
nfirstvar_LUR_3 <- 3  
nlastvar_LUR_3 <- 135

# Function building to run the models 
# 1 #  

models<-list()
modeln<-1
models[[modeln]]<-list()

R2<-1
betaaddedvar<-1
addedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_3:nlastvar_LUR_3){
  if (is.numeric(VGOB1_subsetE_staph_LUR3[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetE_staph_LUR3$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetE_staph_LUR3[,i])                            
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    #  Measurements_livestockpreds_LUR3[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR3)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetE_staph_LUR3)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)
models[[modeln]]$results

#  this are the candidates models with the highest R2, not a negative beta for the new, nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)
models[[modeln]]$resultspos

#  rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))
models[[modeln]]$resultspos

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j
models[[modeln]]$indexbestmodel

subset(models[[modeln]]$resultspos, rank==1)
subset(models[[modeln]]$resultspos)

#  this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]
models[[modeln]]$summarybestmodel

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetE_staph_LUR3)[models[[1]]$indexbestmodel])
models[[modeln]]$namesbestmodel

#  this is the r2 of that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2
models[[modeln]]$R2bestmodel

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetE_staph_LUR3$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetE_staph_LUR3[,models[[1]]$indexbestmodel]) 
models[[modeln]]$bestmodel

summary(models[[modeln]]$bestmodel)

#  The first model includes the predictor: nPigMultipFarmWghtDist.3000m.sum.Tr.1P9 - meaning the number of multiplier pig farms weighted to distance in a 3000m buffer

# 2 #  
# Add 2nd variable (the only difference of the above part is that now modeln=2 the model statement has 2 variables)
# and the call for the list of variable names in the model changed slightly

modeln<-2

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_3:nlastvar_LUR_3){
  if (is.numeric(VGOB1_subsetE_staph_LUR3[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetE_staph_LUR3$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetE_staph_LUR3[,models[[1]]$indexbestmodel]+ VGOB1_subsetE_staph_LUR3[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # Measurements_livestockpreds_LUR3[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR3)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetE_staph_LUR3)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  these are the candidate models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)
models[[modeln]]$resultspos

#  rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))
models[[modeln]]$resultspos

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j
models[[modeln]]$indexbestmodel

subset(models[[modeln]]$resultspos, rank==1)

# this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]
models[[modeln]]$summarybestmodel

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetE_staph_LUR3)[models[[1]]$indexbestmodel], names(VGOB1_subsetE_staph_LUR3)[models[[2]]$indexbestmodel] )
models[[modeln]]$namesbestmodel

# this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2
models[[modeln]]$R2bestmodel

# this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetE_staph_LUR3$staph_copiespm3.ln.diffmeth.mean~                               VGOB1_subsetE_staph_LUR3[,models[[1]]$indexbestmodel]+                           VGOB1_subsetE_staph_LUR3[,models[[2]]$indexbestmodel]) 

models[[modeln]]$bestmodel

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel


# 3 #  
# add third variable (the only difference of the above part is that now modeln=3 the model statement has 3 variables)
# and the call for the list of variable names in the model changed slightly

modeln<-3

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_3:nlastvar_LUR_3){
  if (is.numeric(VGOB1_subsetE_staph_LUR3[,i])==TRUE){  
    modeltry<-lm(VGOB1_subsetE_staph_LUR3$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetE_staph_LUR3[,models[[1]]$indexbestmodel]+VGOB1_subsetE_staph_LUR3[,models[[2]]$indexbestmodel]+ VGOB1_subsetE_staph_LUR3[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # All[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR3)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetE_staph_LUR3)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

#  rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

#  this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

#  here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetE_staph_LUR3)[models[[1]]$indexbestmodel], names(VGOB1_subsetE_staph_LUR3)[models[[2]]$indexbestmodel], names(VGOB1_subsetE_staph_LUR3)[models[[3]]$indexbestmodel])

#  this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetE_staph_LUR3$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetE_staph_LUR3[,models[[1]]$indexbestmodel]+ VGOB1_subsetE_staph_LUR3[,models[[2]]$indexbestmodel]+ VGOB1_subsetE_staph_LUR3[,models[[3]]$indexbestmodel]) 

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel


# 4 #  
#  add forth variable (the only difference of the above part is that now model n=4 the model statement more variables)
#  and the call for the list of variable names in the model changed slightly
modeln<-4

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1


for (i in nfirstvar_LUR_3:nlastvar_LUR_3){
  if (is.numeric(VGOB1_subsetE_staph_LUR3[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetE_staph_LUR3$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetE_staph_LUR3[,models[[1]]$indexbestmodel]+VGOB1_subsetE_staph_LUR3[,models[[2]]$indexbestmodel]+VGOB1_subsetE_staph_LUR3[,models[[3]]$indexbestmodel]+VGOB1_subsetE_staph_LUR3[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    #  the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    #  All[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR3)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetE_staph_LUR3)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

#  this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

#  here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetE_staph_LUR3)[models[[1]]$indexbestmodel], names(VGOB1_subsetE_staph_LUR3)[models[[2]]$indexbestmodel], names(VGOB1_subsetE_staph_LUR3)[models[[3]]$indexbestmodel], names(VGOB1_subsetE_staph_LUR3)[models[[4]]$indexbestmodel])

#  this is the r2 of that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetE_staph_LUR3$staph_copiespm3.ln.diffmeth.mean~ VGOB1_subsetE_staph_LUR3[,models[[1]]$indexbestmodel]+ VGOB1_subsetE_staph_LUR3[,models[[2]]$indexbestmodel]+VGOB1_subsetE_staph_LUR3[,models[[3]]$indexbestmodel]+ VGOB1_subsetE_staph_LUR3[,models[[4]]$indexbestmodel]) 


models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel


# 5 #  
# add fifth variable (the only difference of the above part is that now modeln=5 the model statement more variables)
# and the call for the list of variable names in the model changed slightly
modeln<-5

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_3:nlastvar_LUR_3){
  if (is.numeric(VGOB1_subsetE_staph_LUR3[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetE_staph_LUR3$staph_copiespm3.ln.diffmeth.mean~ VGOB1_subsetE_staph_LUR3[,models[[1]]$indexbestmodel]+ VGOB1_subsetE_staph_LUR3[,models[[2]]$indexbestmodel]+ VGOB1_subsetE_staph_LUR3[,models[[3]]$indexbestmodel]+ VGOB1_subsetE_staph_LUR3[,models[[4]]$indexbestmodel]+ VGOB1_subsetE_staph_LUR3[,i]) 
  
R2<-rbind(R2,summary(modeltry)$adj.r.squared)
# the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # All[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR3)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetE_staph_LUR3)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

#  this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetE_staph_LUR3)[models[[1]]$indexbestmodel], names(VGOB1_subsetE_staph_LUR3)[models[[2]]$indexbestmodel], names(VGOB1_subsetE_staph_LUR3)[models[[3]]$indexbestmodel], names(VGOB1_subsetE_staph_LUR3)[models[[4]]$indexbestmodel], names(VGOB1_subsetE_staph_LUR3)[models[[5]]$indexbestmodel])

#  this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetE_staph_LUR3$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetE_staph_LUR3[,models[[1]]$indexbestmodel]+VGOB1_subsetE_staph_LUR3[,models[[2]]$indexbestmodel]+VGOB1_subsetE_staph_LUR3[,models[[3]]$indexbestmodel]+ VGOB1_subsetE_staph_LUR3[,models[[4]]$indexbestmodel]+ VGOB1_subsetE_staph_LUR3[,models[[5]]$indexbestmodel]) 
models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[5]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[5]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel
models[[5]]$R2bestmodel

# 6 #  
# add sixth variable (the only difference of the above part is that now model n=6 the model statement more variables)
#  and the call for the list of variable names in the model changed slightly

modeln<-6

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_3 :nlastvar_LUR_3){
  if (is.numeric(VGOB1_subsetE_staph_LUR3[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetE_staph_LUR3$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetE_staph_LUR3[,models[[1]]$indexbestmodel]+VGOB1_subsetE_staph_LUR3[,models[[2]]$indexbestmodel]+VGOB1_subsetE_staph_LUR3[,models[[3]]$indexbestmodel]+VGOB1_subsetE_staph_LUR3[,models[[4]]$indexbestmodel]+VGOB1_subsetE_staph_LUR3[,models[[5]]$indexbestmodel]+ VGOB1_subsetE_staph_LUR3[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # All[,i] is the row that's being tried out now. the name of that row can be found in  names(All)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetE_staph_LUR3)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

# this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetE_staph_LUR3)[models[[1]]$indexbestmodel], names(VGOB1_subsetE_staph_LUR3)[models[[2]]$indexbestmodel] , names(VGOB1_subsetE_staph_LUR3)[models[[3]]$indexbestmodel], names(VGOB1_subsetE_staph_LUR3)[models[[4]]$indexbestmodel], names(VGOB1_subsetE_staph_LUR3)[models[[5]]$indexbestmodel], names(VGOB1_subsetE_staph_LUR3)[models[[6]]$indexbestmodel])

#  this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetE_staph_LUR3$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetE_staph_LUR3[,models[[1]]$indexbestmodel]+VGOB1_subsetE_staph_LUR3[,models[[2]]$indexbestmodel]+VGOB1_subsetE_staph_LUR3[,models[[3]]$indexbestmodel]+ VGOB1_subsetE_staph_LUR3[,models[[4]]$indexbestmodel]+ VGOB1_subsetE_staph_LUR3[,models[[5]]$indexbestmodel]+ VGOB1_subsetE_staph_LUR3[,models[[6]]$indexbestmodel]) 

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[5]]$summarybestmodel
models[[6]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[5]]$namesbestmodel
models[[6]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel
models[[5]]$R2bestmodel
models[[6]]$R2bestmodel


# 7 #  
# add seventh variable (the only difference of the above part is that now model n=7 the model statement more variables)
#  and the call for the list of variable names in the model changed slightly

modeln<-7

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_3 :nlastvar_LUR_3){
  if (is.numeric(VGOB1_subsetE_staph_LUR3[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetE_staph_LUR3$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetE_staph_LUR3[,models[[1]]$indexbestmodel]+VGOB1_subsetE_staph_LUR3[,models[[2]]$indexbestmodel]+VGOB1_subsetE_staph_LUR3[,models[[3]]$indexbestmodel]+VGOB1_subsetE_staph_LUR3[,models[[4]]$indexbestmodel]+VGOB1_subsetE_staph_LUR3[,models[[5]]$indexbestmodel]+VGOB1_subsetE_staph_LUR3[,models[[6]]$indexbestmodel]+ VGOB1_subsetE_staph_LUR3[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # Measurements_livestockpreds_LUR3[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR3)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetE_staph_LUR3)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

# this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetE_staph_LUR3)[models[[1]]$indexbestmodel], names(VGOB1_subsetE_staph_LUR3)[models[[2]]$indexbestmodel] , names(VGOB1_subsetE_staph_LUR3)[models[[3]]$indexbestmodel], names(VGOB1_subsetE_staph_LUR3)[models[[4]]$indexbestmodel], names(VGOB1_subsetE_staph_LUR3)[models[[5]]$indexbestmodel], names(VGOB1_subsetE_staph_LUR3)[models[[6]]$indexbestmodel], names(VGOB1_subsetE_staph_LUR3)[models[[7]]$indexbestmodel])

#  this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetE_staph_LUR3$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetE_staph_LUR3[,models[[1]]$indexbestmodel]+VGOB1_subsetE_staph_LUR3[,models[[2]]$indexbestmodel]+VGOB1_subsetE_staph_LUR3[,models[[3]]$indexbestmodel]+ VGOB1_subsetE_staph_LUR3[,models[[4]]$indexbestmodel]+ VGOB1_subsetE_staph_LUR3[,models[[5]]$indexbestmodel]+ VGOB1_subsetE_staph_LUR3[,models[[6]]$indexbestmodel]+ VGOB1_subsetE_staph_LUR3[,models[[7]]$indexbestmodel]) 

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[5]]$summarybestmodel
models[[6]]$summarybestmodel
models[[7]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[5]]$namesbestmodel
models[[6]]$namesbestmodel
models[[7]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel
models[[5]]$R2bestmodel
models[[6]]$R2bestmodel
models[[7]]$R2bestmodel

# 8 #  
# add eighth variable (the only difference of the above part is that now modeln=7 the model statement more variables)
# and the call for the list of variable names in the model changed slightly

modeln<-8

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_3 :nlastvar_LUR_3){
  if (is.numeric(VGOB1_subsetE_staph_LUR3[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetE_staph_LUR3$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetE_staph_LUR3[,models[[1]]$indexbestmodel]+VGOB1_subsetE_staph_LUR3[,models[[2]]$indexbestmodel]+VGOB1_subsetE_staph_LUR3[,models[[3]]$indexbestmodel]+VGOB1_subsetE_staph_LUR3[,models[[4]]$indexbestmodel]+VGOB1_subsetE_staph_LUR3[,models[[5]]$indexbestmodel]+VGOB1_subsetE_staph_LUR3[,models[[6]]$indexbestmodel]+ VGOB1_subsetE_staph_LUR3[,models[[7]]$indexbestmodel]+ VGOB1_subsetE_staph_LUR3[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # Measurements_livestockpreds_LUR3[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR3)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetE_staph_LUR3)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

# this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetE_staph_LUR3)[models[[1]]$indexbestmodel], names(VGOB1_subsetE_staph_LUR3)[models[[2]]$indexbestmodel] , names(VGOB1_subsetE_staph_LUR3)[models[[3]]$indexbestmodel], names(VGOB1_subsetE_staph_LUR3)[models[[4]]$indexbestmodel], names(VGOB1_subsetE_staph_LUR3)[models[[5]]$indexbestmodel], names(VGOB1_subsetE_staph_LUR3)[models[[6]]$indexbestmodel], names(VGOB1_subsetE_staph_LUR3)[models[[7]]$indexbestmodel], names(VGOB1_subsetE_staph_LUR3)[models[[8]]$indexbestmodel])

#  this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetE_staph_LUR3$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetE_staph_LUR3[,models[[1]]$indexbestmodel]+VGOB1_subsetE_staph_LUR3[,models[[2]]$indexbestmodel]+VGOB1_subsetE_staph_LUR3[,models[[3]]$indexbestmodel]+ VGOB1_subsetE_staph_LUR3[,models[[4]]$indexbestmodel]+ VGOB1_subsetE_staph_LUR3[,models[[5]]$indexbestmodel]+ VGOB1_subsetE_staph_LUR3[,models[[6]]$indexbestmodel]+ VGOB1_subsetE_staph_LUR3[,models[[7]]$indexbestmodel]+ VGOB1_subsetE_staph_LUR3[,models[[8]]$indexbestmodel]) 

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[5]]$summarybestmodel
models[[6]]$summarybestmodel
models[[7]]$summarybestmodel
models[[8]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[5]]$namesbestmodel
models[[6]]$namesbestmodel
models[[7]]$namesbestmodel
models[[8]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel
models[[5]]$R2bestmodel
models[[6]]$R2bestmodel
models[[7]]$R2bestmodel
models[[8]]$R2bestmodel

# 9 #  
# add ninth variable (the only difference of the above part is that now modeln=9 the model statement more variables)
# and the call for the list of variable names in the model changed slightly

modeln<-9

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_3 :nlastvar_LUR_3){
  if (is.numeric(VGOB1_subsetE_staph_LUR3[,i])==TRUE){
      modeltry<-lm(VGOB1_subsetE_staph_LUR3$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetE_staph_LUR3[,models[[1]]$indexbestmodel]+VGOB1_subsetE_staph_LUR3[,models[[2]]$indexbestmodel]+VGOB1_subsetE_staph_LUR3[,models[[3]]$indexbestmodel]+VGOB1_subsetE_staph_LUR3[,models[[4]]$indexbestmodel]+VGOB1_subsetE_staph_LUR3[,models[[5]]$indexbestmodel]+VGOB1_subsetE_staph_LUR3[,models[[6]]$indexbestmodel]+ VGOB1_subsetE_staph_LUR3[,models[[7]]$indexbestmodel]+ VGOB1_subsetE_staph_LUR3[,models[[8]]$indexbestmodel]+ VGOB1_subsetE_staph_LUR3[,i]) 
        R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # Measurements_livestockpreds_LUR3[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR3)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetE_staph_LUR3)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

# this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetE_staph_LUR3)[models[[1]]$indexbestmodel], names(VGOB1_subsetE_staph_LUR3)[models[[2]]$indexbestmodel] , names(VGOB1_subsetE_staph_LUR3)[models[[3]]$indexbestmodel], names(VGOB1_subsetE_staph_LUR3)[models[[4]]$indexbestmodel], names(VGOB1_subsetE_staph_LUR3)[models[[5]]$indexbestmodel], names(VGOB1_subsetE_staph_LUR3)[models[[6]]$indexbestmodel], names(VGOB1_subsetE_staph_LUR3)[models[[7]]$indexbestmodel], names(VGOB1_subsetE_staph_LUR3)[models[[8]]$indexbestmodel],  names(VGOB1_subsetE_staph_LUR3)[models[[9]]$indexbestmodel])

#  this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetE_staph_LUR3$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetE_staph_LUR3[,models[[1]]$indexbestmodel]+VGOB1_subsetE_staph_LUR3[,models[[2]]$indexbestmodel]+VGOB1_subsetE_staph_LUR3[,models[[3]]$indexbestmodel]+ VGOB1_subsetE_staph_LUR3[,models[[4]]$indexbestmodel]+ VGOB1_subsetE_staph_LUR3[,models[[5]]$indexbestmodel]+ VGOB1_subsetE_staph_LUR3[,models[[6]]$indexbestmodel]+ VGOB1_subsetE_staph_LUR3[,models[[7]]$indexbestmodel]+ VGOB1_subsetE_staph_LUR3[,models[[8]]$indexbestmodel]+ VGOB1_subsetE_staph_LUR3[,models[[9]]$indexbestmodel]) 

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[5]]$summarybestmodel
models[[6]]$summarybestmodel
models[[7]]$summarybestmodel
models[[8]]$summarybestmodel
models[[9]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[5]]$namesbestmodel
models[[6]]$namesbestmodel
models[[7]]$namesbestmodel
models[[8]]$namesbestmodel
models[[9]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel
models[[5]]$R2bestmodel
models[[6]]$R2bestmodel
models[[7]]$R2bestmodel
models[[8]]$R2bestmodel
models[[9]]$R2bestmodel

# 10 #  
#  add tenth variable (the only difference of the above part is that now model n=10 the model statement more variables)
#  and the call for the list of variable names in the model changed slightly

modeln<-10

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_3 :nlastvar_LUR_3){if (is.numeric(VGOB1_subsetE_staph_LUR3[,i])==TRUE){ modeltry<-lm(VGOB1_subsetE_staph_LUR3$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetE_staph_LUR3[,models[[1]]$indexbestmodel]+VGOB1_subsetE_staph_LUR3[,models[[2]]$indexbestmodel]+ VGOB1_subsetE_staph_LUR3[,models[[3]]$indexbestmodel]+VGOB1_subsetE_staph_LUR3[,models[[4]]$indexbestmodel]+ VGOB1_subsetE_staph_LUR3[,models[[5]]$indexbestmodel]+ VGOB1_subsetE_staph_LUR3[,models[[6]]$indexbestmodel]+ VGOB1_subsetE_staph_LUR3[,models[[7]]$indexbestmodel]+ VGOB1_subsetE_staph_LUR3[,models[[8]]$indexbestmodel]+ VGOB1_subsetE_staph_LUR3[,models[[9]]$indexbestmodel]+ VGOB1_subsetE_staph_LUR3[,i]) 

R2<-rbind(R2,summary(modeltry)$adj.r.squared)
# the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # Measurements_livestockpreds_LUR3[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR3)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetE_staph_LUR3)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

# this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

# here are the names
models[[modeln]]$namesbestmodel<-c( names(VGOB1_subsetE_staph_LUR3)[models[[1]]$indexbestmodel],                   names(VGOB1_subsetE_staph_LUR3)[models[[2]]$indexbestmodel] , names(VGOB1_subsetE_staph_LUR3)[models[[3]]$indexbestmodel], names(VGOB1_subsetE_staph_LUR3)[models[[4]]$indexbestmodel], names(VGOB1_subsetE_staph_LUR3)[models[[5]]$indexbestmodel], names(VGOB1_subsetE_staph_LUR3)[models[[6]]$indexbestmodel], names(VGOB1_subsetE_staph_LUR3)[models[[7]]$indexbestmodel], names(VGOB1_subsetE_staph_LUR3)[models[[8]]$indexbestmodel], names(VGOB1_subsetE_staph_LUR3)[models[[9]]$indexbestmodel], names(VGOB1_subsetE_staph_LUR3)[models[[10]]$indexbestmodel])

#  this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetE_staph_LUR3$staph_copiespm3.ln.diffmeth.mean~                                VGOB1_subsetE_staph_LUR3[,models[[1]]$indexbestmodel]+ VGOB1_subsetE_staph_LUR3[,models[[2]]$indexbestmodel]+                           VGOB1_subsetE_staph_LUR3[,models[[3]]$indexbestmodel]+ VGOB1_subsetE_staph_LUR3[,models[[4]]$indexbestmodel]+ VGOB1_subsetE_staph_LUR3[,models[[5]]$indexbestmodel]+ VGOB1_subsetE_staph_LUR3[,models[[6]]$indexbestmodel]+ VGOB1_subsetE_staph_LUR3[,models[[7]]$indexbestmodel]+ VGOB1_subsetE_staph_LUR3[,models[[8]]$indexbestmodel]+ VGOB1_subsetE_staph_LUR3[,models[[9]]$indexbestmodel]+ VGOB1_subsetE_staph_LUR3[,models[[10]]$indexbestmodel]) 

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[5]]$summarybestmodel
models[[6]]$summarybestmodel
models[[7]]$summarybestmodel
models[[8]]$summarybestmodel
models[[9]]$summarybestmodel
models[[10]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[5]]$namesbestmodel
models[[6]]$namesbestmodel
models[[7]]$namesbestmodel
models[[8]]$namesbestmodel
models[[9]]$namesbestmodel
models[[10]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel
models[[5]]$R2bestmodel
models[[6]]$R2bestmodel
models[[7]]$R2bestmodel
models[[8]]$R2bestmodel
models[[9]]$R2bestmodel
models[[10]]$R2bestmodel

#  at this point I always check whether the next model is more than 1% better than the one before and if not I end here

#   CODE FOR PICKING OUT THE BEST MODEL #   
temp <- 0
besti <- 0
for (i in 1:10){ #  think this runs the loop 10 times - not fully sure thought - but not to do with the number of models I don't think - as when I change to 3, I still get the model with 4 variables as best model
  print(models[[i]]$R2bestmodel)
  #       print(models[[i]]$summarybestmodel$coefficients=-1,4])
  #       if((models[[i]]$R2bestmodel-temp > 0.0) && (all(models[[i]]$summarybestmodel$coefficients[-1,4]<0.1))){
  #         temp <- models[[i]]$R2bestmodel
  #         besti <- i
  #         }
  if((models[[i]]$R2bestmodel-temp > 0.0) && (all(models[[i]]$summarybestmodel$coefficients[-1,4]<0.1))){
    temp <- models[[i]]$R2bestmodel
    besti <- i
  }else{
    finalBestModel_staph_LUR3_subsetE <- models[[besti]]$bestmodel
    finalBestModelNames_staph_subsetE <- models[[besti]]$namesbestmodel
    Sites <- 1:dim(VGOB1_subsetE_staph_LUR3)[1] # full original model
    #  CVaR2<-escCV_staph_LUR3(Sites)[2] # Cross Validation
    maxCD<-max(cooks.distance(finalBestModel_staph_LUR3_subsetE))
    if(length(finalBestModelNames_staph_subsetE)<2){ # vif fn doesnot work when only 1 variable...       # 
      maxVIF<-"NA"
    }else{
      maxVIF<-max(vif(finalBestModel_staph_LUR3_subsetE))
    }
    print(paste("This is the best staph model for subset E: ",besti,
                "(AdjR2: ",format(models[[besti]]$R2bestmodel,digits=3), "; MaxCD: ",format(maxCD,digits=3),"; MaxVIF: ",
                format(maxVIF,digits=3),")", sep=''))
    print(finalBestModelNames_staph_subsetE)
    break
  }
}

#  Overview of the final best model using the algorithm selection process (taking into account VIF, R^2, and p-values)
finalBestModel_staph_LUR3_subsetE
finalBestModelNames_staph_subsetE
models[[besti]]$summarybestmodel
models[[besti]]$R2bestmodel

#### F ####
# LUR model building process for subset F
#  This is the dataframe with the relevant predictor vars for LUR3 models for subset F (55 sites)
VGOB1_subsetF_staph_LUR3 # n.b. this dataframe only includes microbial marker concentrations for staph unlike the dataframe Measurements_livestockpreds_LUR3 as previously used for the model building. 

#  Now set the values of some variables that will be needed
nfirstvar_LUR_3 <- 3  
nlastvar_LUR_3 <- 135

# Function building to run the models 
# 1 #  

models<-list()
modeln<-1
models[[modeln]]<-list()

R2<-1
betaaddedvar<-1
addedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_3:nlastvar_LUR_3){
  if (is.numeric(VGOB1_subsetF_staph_LUR3[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetF_staph_LUR3$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetF_staph_LUR3[,i])                            
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    #  Measurements_livestockpreds_LUR3[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR3)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetF_staph_LUR3)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)
models[[modeln]]$results

#  this are the candidates models with the highest R2, not a negative beta for the new, nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)
models[[modeln]]$resultspos

#  rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))
models[[modeln]]$resultspos

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j
models[[modeln]]$indexbestmodel

subset(models[[modeln]]$resultspos, rank==1)
subset(models[[modeln]]$resultspos)

#  this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]
models[[modeln]]$summarybestmodel

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetF_staph_LUR3)[models[[1]]$indexbestmodel])
models[[modeln]]$namesbestmodel

#  this is the r2 of that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2
models[[modeln]]$R2bestmodel

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetF_staph_LUR3$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetF_staph_LUR3[,models[[1]]$indexbestmodel]) 
models[[modeln]]$bestmodel

summary(models[[modeln]]$bestmodel)

#  The first model includes the predictor: nPigMultipFarmWghtDist.3000m.sum.Tr.1P9 - meaning the number of multiplier pig farms weighted to distance in a 3000m buffer

# 2 #  
# Add 2nd variable (the only difference of the above part is that now modeln=2 the model statement has 2 variables)
# and the call for the list of variable names in the model changed slightly

modeln<-2

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_3:nlastvar_LUR_3){
  if (is.numeric(VGOB1_subsetF_staph_LUR3[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetF_staph_LUR3$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetF_staph_LUR3[,models[[1]]$indexbestmodel]+ VGOB1_subsetF_staph_LUR3[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # Measurements_livestockpreds_LUR3[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR3)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetF_staph_LUR3)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  these are the candidate models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)
models[[modeln]]$resultspos

#  rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))
models[[modeln]]$resultspos

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j
models[[modeln]]$indexbestmodel

subset(models[[modeln]]$resultspos, rank==1)

# this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]
models[[modeln]]$summarybestmodel

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetF_staph_LUR3)[models[[1]]$indexbestmodel], names(VGOB1_subsetF_staph_LUR3)[models[[2]]$indexbestmodel] )
models[[modeln]]$namesbestmodel

# this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2
models[[modeln]]$R2bestmodel

# this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetF_staph_LUR3$staph_copiespm3.ln.diffmeth.mean~                               VGOB1_subsetF_staph_LUR3[,models[[1]]$indexbestmodel]+                           VGOB1_subsetF_staph_LUR3[,models[[2]]$indexbestmodel]) 

models[[modeln]]$bestmodel

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel


# 3 #  
# add third variable (the only difference of the above part is that now modeln=3 the model statement has 3 variables)
# and the call for the list of variable names in the model changed slightly

modeln<-3

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_3:nlastvar_LUR_3){
  if (is.numeric(VGOB1_subsetF_staph_LUR3[,i])==TRUE){  
    modeltry<-lm(VGOB1_subsetF_staph_LUR3$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetF_staph_LUR3[,models[[1]]$indexbestmodel]+VGOB1_subsetF_staph_LUR3[,models[[2]]$indexbestmodel]+ VGOB1_subsetF_staph_LUR3[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # All[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR3)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetF_staph_LUR3)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

#  rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

#  this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

#  here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetF_staph_LUR3)[models[[1]]$indexbestmodel], names(VGOB1_subsetF_staph_LUR3)[models[[2]]$indexbestmodel], names(VGOB1_subsetF_staph_LUR3)[models[[3]]$indexbestmodel])

#  this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetF_staph_LUR3$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetF_staph_LUR3[,models[[1]]$indexbestmodel]+ VGOB1_subsetF_staph_LUR3[,models[[2]]$indexbestmodel]+ VGOB1_subsetF_staph_LUR3[,models[[3]]$indexbestmodel]) 

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel


# 4 #  
#  add forth variable (the only difference of the above part is that now model n=4 the model statement more variables)
#  and the call for the list of variable names in the model changed slightly
modeln<-4

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1


for (i in nfirstvar_LUR_3:nlastvar_LUR_3){
  if (is.numeric(VGOB1_subsetF_staph_LUR3[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetF_staph_LUR3$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetF_staph_LUR3[,models[[1]]$indexbestmodel]+VGOB1_subsetF_staph_LUR3[,models[[2]]$indexbestmodel]+VGOB1_subsetF_staph_LUR3[,models[[3]]$indexbestmodel]+VGOB1_subsetF_staph_LUR3[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    #  the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    #  All[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR3)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetF_staph_LUR3)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

#  this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

#  here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetF_staph_LUR3)[models[[1]]$indexbestmodel], names(VGOB1_subsetF_staph_LUR3)[models[[2]]$indexbestmodel], names(VGOB1_subsetF_staph_LUR3)[models[[3]]$indexbestmodel], names(VGOB1_subsetF_staph_LUR3)[models[[4]]$indexbestmodel])

#  this is the r2 of that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetF_staph_LUR3$staph_copiespm3.ln.diffmeth.mean~ VGOB1_subsetF_staph_LUR3[,models[[1]]$indexbestmodel]+ VGOB1_subsetF_staph_LUR3[,models[[2]]$indexbestmodel]+VGOB1_subsetF_staph_LUR3[,models[[3]]$indexbestmodel]+ VGOB1_subsetF_staph_LUR3[,models[[4]]$indexbestmodel]) 


models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel


# 5 #  
# add fifth variable (the only difference of the above part is that now modeln=5 the model statement more variables)
# and the call for the list of variable names in the model changed slightly
modeln<-5

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_3:nlastvar_LUR_3){
  if (is.numeric(VGOB1_subsetF_staph_LUR3[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetF_staph_LUR3$staph_copiespm3.ln.diffmeth.mean~ VGOB1_subsetF_staph_LUR3[,models[[1]]$indexbestmodel]+ VGOB1_subsetF_staph_LUR3[,models[[2]]$indexbestmodel]+ VGOB1_subsetF_staph_LUR3[,models[[3]]$indexbestmodel]+ VGOB1_subsetF_staph_LUR3[,models[[4]]$indexbestmodel]+ VGOB1_subsetF_staph_LUR3[,i]) 
  
R2<-rbind(R2,summary(modeltry)$adj.r.squared)
# the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # All[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR3)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetF_staph_LUR3)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

#  this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetF_staph_LUR3)[models[[1]]$indexbestmodel], names(VGOB1_subsetF_staph_LUR3)[models[[2]]$indexbestmodel], names(VGOB1_subsetF_staph_LUR3)[models[[3]]$indexbestmodel], names(VGOB1_subsetF_staph_LUR3)[models[[4]]$indexbestmodel], names(VGOB1_subsetF_staph_LUR3)[models[[5]]$indexbestmodel])

#  this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetF_staph_LUR3$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetF_staph_LUR3[,models[[1]]$indexbestmodel]+VGOB1_subsetF_staph_LUR3[,models[[2]]$indexbestmodel]+VGOB1_subsetF_staph_LUR3[,models[[3]]$indexbestmodel]+ VGOB1_subsetF_staph_LUR3[,models[[4]]$indexbestmodel]+ VGOB1_subsetF_staph_LUR3[,models[[5]]$indexbestmodel]) 
models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[5]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[5]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel
models[[5]]$R2bestmodel

# 6 #  
# add sixth variable (the only difference of the above part is that now model n=6 the model statement more variables)
#  and the call for the list of variable names in the model changed slightly

modeln<-6

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_3 :nlastvar_LUR_3){
  if (is.numeric(VGOB1_subsetF_staph_LUR3[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetF_staph_LUR3$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetF_staph_LUR3[,models[[1]]$indexbestmodel]+VGOB1_subsetF_staph_LUR3[,models[[2]]$indexbestmodel]+VGOB1_subsetF_staph_LUR3[,models[[3]]$indexbestmodel]+VGOB1_subsetF_staph_LUR3[,models[[4]]$indexbestmodel]+VGOB1_subsetF_staph_LUR3[,models[[5]]$indexbestmodel]+ VGOB1_subsetF_staph_LUR3[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # All[,i] is the row that's being tried out now. the name of that row can be found in  names(All)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetF_staph_LUR3)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

# this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetF_staph_LUR3)[models[[1]]$indexbestmodel], names(VGOB1_subsetF_staph_LUR3)[models[[2]]$indexbestmodel] , names(VGOB1_subsetF_staph_LUR3)[models[[3]]$indexbestmodel], names(VGOB1_subsetF_staph_LUR3)[models[[4]]$indexbestmodel], names(VGOB1_subsetF_staph_LUR3)[models[[5]]$indexbestmodel], names(VGOB1_subsetF_staph_LUR3)[models[[6]]$indexbestmodel])

#  this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetF_staph_LUR3$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetF_staph_LUR3[,models[[1]]$indexbestmodel]+VGOB1_subsetF_staph_LUR3[,models[[2]]$indexbestmodel]+VGOB1_subsetF_staph_LUR3[,models[[3]]$indexbestmodel]+ VGOB1_subsetF_staph_LUR3[,models[[4]]$indexbestmodel]+ VGOB1_subsetF_staph_LUR3[,models[[5]]$indexbestmodel]+ VGOB1_subsetF_staph_LUR3[,models[[6]]$indexbestmodel]) 

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[5]]$summarybestmodel
models[[6]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[5]]$namesbestmodel
models[[6]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel
models[[5]]$R2bestmodel
models[[6]]$R2bestmodel


# 7 #  
# add seventh variable (the only difference of the above part is that now model n=7 the model statement more variables)
#  and the call for the list of variable names in the model changed slightly

modeln<-7

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_3 :nlastvar_LUR_3){
  if (is.numeric(VGOB1_subsetF_staph_LUR3[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetF_staph_LUR3$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetF_staph_LUR3[,models[[1]]$indexbestmodel]+VGOB1_subsetF_staph_LUR3[,models[[2]]$indexbestmodel]+VGOB1_subsetF_staph_LUR3[,models[[3]]$indexbestmodel]+VGOB1_subsetF_staph_LUR3[,models[[4]]$indexbestmodel]+VGOB1_subsetF_staph_LUR3[,models[[5]]$indexbestmodel]+VGOB1_subsetF_staph_LUR3[,models[[6]]$indexbestmodel]+ VGOB1_subsetF_staph_LUR3[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # Measurements_livestockpreds_LUR3[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR3)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetF_staph_LUR3)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

# this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetF_staph_LUR3)[models[[1]]$indexbestmodel], names(VGOB1_subsetF_staph_LUR3)[models[[2]]$indexbestmodel] , names(VGOB1_subsetF_staph_LUR3)[models[[3]]$indexbestmodel], names(VGOB1_subsetF_staph_LUR3)[models[[4]]$indexbestmodel], names(VGOB1_subsetF_staph_LUR3)[models[[5]]$indexbestmodel], names(VGOB1_subsetF_staph_LUR3)[models[[6]]$indexbestmodel], names(VGOB1_subsetF_staph_LUR3)[models[[7]]$indexbestmodel])

#  this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetF_staph_LUR3$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetF_staph_LUR3[,models[[1]]$indexbestmodel]+VGOB1_subsetF_staph_LUR3[,models[[2]]$indexbestmodel]+VGOB1_subsetF_staph_LUR3[,models[[3]]$indexbestmodel]+ VGOB1_subsetF_staph_LUR3[,models[[4]]$indexbestmodel]+ VGOB1_subsetF_staph_LUR3[,models[[5]]$indexbestmodel]+ VGOB1_subsetF_staph_LUR3[,models[[6]]$indexbestmodel]+ VGOB1_subsetF_staph_LUR3[,models[[7]]$indexbestmodel]) 

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[5]]$summarybestmodel
models[[6]]$summarybestmodel
models[[7]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[5]]$namesbestmodel
models[[6]]$namesbestmodel
models[[7]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel
models[[5]]$R2bestmodel
models[[6]]$R2bestmodel
models[[7]]$R2bestmodel

# 8 #  
# add eighth variable (the only difference of the above part is that now modeln=7 the model statement more variables)
# and the call for the list of variable names in the model changed slightly

modeln<-8

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_3 :nlastvar_LUR_3){
  if (is.numeric(VGOB1_subsetF_staph_LUR3[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetF_staph_LUR3$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetF_staph_LUR3[,models[[1]]$indexbestmodel]+VGOB1_subsetF_staph_LUR3[,models[[2]]$indexbestmodel]+VGOB1_subsetF_staph_LUR3[,models[[3]]$indexbestmodel]+VGOB1_subsetF_staph_LUR3[,models[[4]]$indexbestmodel]+VGOB1_subsetF_staph_LUR3[,models[[5]]$indexbestmodel]+VGOB1_subsetF_staph_LUR3[,models[[6]]$indexbestmodel]+ VGOB1_subsetF_staph_LUR3[,models[[7]]$indexbestmodel]+ VGOB1_subsetF_staph_LUR3[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # Measurements_livestockpreds_LUR3[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR3)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetF_staph_LUR3)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

# this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetF_staph_LUR3)[models[[1]]$indexbestmodel], names(VGOB1_subsetF_staph_LUR3)[models[[2]]$indexbestmodel] , names(VGOB1_subsetF_staph_LUR3)[models[[3]]$indexbestmodel], names(VGOB1_subsetF_staph_LUR3)[models[[4]]$indexbestmodel], names(VGOB1_subsetF_staph_LUR3)[models[[5]]$indexbestmodel], names(VGOB1_subsetF_staph_LUR3)[models[[6]]$indexbestmodel], names(VGOB1_subsetF_staph_LUR3)[models[[7]]$indexbestmodel], names(VGOB1_subsetF_staph_LUR3)[models[[8]]$indexbestmodel])

#  this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetF_staph_LUR3$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetF_staph_LUR3[,models[[1]]$indexbestmodel]+VGOB1_subsetF_staph_LUR3[,models[[2]]$indexbestmodel]+VGOB1_subsetF_staph_LUR3[,models[[3]]$indexbestmodel]+ VGOB1_subsetF_staph_LUR3[,models[[4]]$indexbestmodel]+ VGOB1_subsetF_staph_LUR3[,models[[5]]$indexbestmodel]+ VGOB1_subsetF_staph_LUR3[,models[[6]]$indexbestmodel]+ VGOB1_subsetF_staph_LUR3[,models[[7]]$indexbestmodel]+ VGOB1_subsetF_staph_LUR3[,models[[8]]$indexbestmodel]) 

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[5]]$summarybestmodel
models[[6]]$summarybestmodel
models[[7]]$summarybestmodel
models[[8]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[5]]$namesbestmodel
models[[6]]$namesbestmodel
models[[7]]$namesbestmodel
models[[8]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel
models[[5]]$R2bestmodel
models[[6]]$R2bestmodel
models[[7]]$R2bestmodel
models[[8]]$R2bestmodel

# 9 #  
# add ninth variable (the only difference of the above part is that now modeln=9 the model statement more variables)
# and the call for the list of variable names in the model changed slightly

modeln<-9

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_3 :nlastvar_LUR_3){
  if (is.numeric(VGOB1_subsetF_staph_LUR3[,i])==TRUE){
      modeltry<-lm(VGOB1_subsetF_staph_LUR3$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetF_staph_LUR3[,models[[1]]$indexbestmodel]+VGOB1_subsetF_staph_LUR3[,models[[2]]$indexbestmodel]+VGOB1_subsetF_staph_LUR3[,models[[3]]$indexbestmodel]+VGOB1_subsetF_staph_LUR3[,models[[4]]$indexbestmodel]+VGOB1_subsetF_staph_LUR3[,models[[5]]$indexbestmodel]+VGOB1_subsetF_staph_LUR3[,models[[6]]$indexbestmodel]+ VGOB1_subsetF_staph_LUR3[,models[[7]]$indexbestmodel]+ VGOB1_subsetF_staph_LUR3[,models[[8]]$indexbestmodel]+ VGOB1_subsetF_staph_LUR3[,i]) 
        R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # Measurements_livestockpreds_LUR3[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR3)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetF_staph_LUR3)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

# this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetF_staph_LUR3)[models[[1]]$indexbestmodel], names(VGOB1_subsetF_staph_LUR3)[models[[2]]$indexbestmodel] , names(VGOB1_subsetF_staph_LUR3)[models[[3]]$indexbestmodel], names(VGOB1_subsetF_staph_LUR3)[models[[4]]$indexbestmodel], names(VGOB1_subsetF_staph_LUR3)[models[[5]]$indexbestmodel], names(VGOB1_subsetF_staph_LUR3)[models[[6]]$indexbestmodel], names(VGOB1_subsetF_staph_LUR3)[models[[7]]$indexbestmodel], names(VGOB1_subsetF_staph_LUR3)[models[[8]]$indexbestmodel],  names(VGOB1_subsetF_staph_LUR3)[models[[9]]$indexbestmodel])

#  this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetF_staph_LUR3$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetF_staph_LUR3[,models[[1]]$indexbestmodel]+VGOB1_subsetF_staph_LUR3[,models[[2]]$indexbestmodel]+VGOB1_subsetF_staph_LUR3[,models[[3]]$indexbestmodel]+ VGOB1_subsetF_staph_LUR3[,models[[4]]$indexbestmodel]+ VGOB1_subsetF_staph_LUR3[,models[[5]]$indexbestmodel]+ VGOB1_subsetF_staph_LUR3[,models[[6]]$indexbestmodel]+ VGOB1_subsetF_staph_LUR3[,models[[7]]$indexbestmodel]+ VGOB1_subsetF_staph_LUR3[,models[[8]]$indexbestmodel]+ VGOB1_subsetF_staph_LUR3[,models[[9]]$indexbestmodel]) 

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[5]]$summarybestmodel
models[[6]]$summarybestmodel
models[[7]]$summarybestmodel
models[[8]]$summarybestmodel
models[[9]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[5]]$namesbestmodel
models[[6]]$namesbestmodel
models[[7]]$namesbestmodel
models[[8]]$namesbestmodel
models[[9]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel
models[[5]]$R2bestmodel
models[[6]]$R2bestmodel
models[[7]]$R2bestmodel
models[[8]]$R2bestmodel
models[[9]]$R2bestmodel

# 10 #  
#  add tenth variable (the only difference of the above part is that now model n=10 the model statement more variables)
#  and the call for the list of variable names in the model changed slightly

modeln<-10

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_3 :nlastvar_LUR_3){if (is.numeric(VGOB1_subsetF_staph_LUR3[,i])==TRUE){ modeltry<-lm(VGOB1_subsetF_staph_LUR3$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetF_staph_LUR3[,models[[1]]$indexbestmodel]+VGOB1_subsetF_staph_LUR3[,models[[2]]$indexbestmodel]+ VGOB1_subsetF_staph_LUR3[,models[[3]]$indexbestmodel]+VGOB1_subsetF_staph_LUR3[,models[[4]]$indexbestmodel]+ VGOB1_subsetF_staph_LUR3[,models[[5]]$indexbestmodel]+ VGOB1_subsetF_staph_LUR3[,models[[6]]$indexbestmodel]+ VGOB1_subsetF_staph_LUR3[,models[[7]]$indexbestmodel]+ VGOB1_subsetF_staph_LUR3[,models[[8]]$indexbestmodel]+ VGOB1_subsetF_staph_LUR3[,models[[9]]$indexbestmodel]+ VGOB1_subsetF_staph_LUR3[,i]) 

R2<-rbind(R2,summary(modeltry)$adj.r.squared)
# the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # Measurements_livestockpreds_LUR3[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR3)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetF_staph_LUR3)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

# this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

# here are the names
models[[modeln]]$namesbestmodel<-c( names(VGOB1_subsetF_staph_LUR3)[models[[1]]$indexbestmodel],                   names(VGOB1_subsetF_staph_LUR3)[models[[2]]$indexbestmodel] , names(VGOB1_subsetF_staph_LUR3)[models[[3]]$indexbestmodel], names(VGOB1_subsetF_staph_LUR3)[models[[4]]$indexbestmodel], names(VGOB1_subsetF_staph_LUR3)[models[[5]]$indexbestmodel], names(VGOB1_subsetF_staph_LUR3)[models[[6]]$indexbestmodel], names(VGOB1_subsetF_staph_LUR3)[models[[7]]$indexbestmodel], names(VGOB1_subsetF_staph_LUR3)[models[[8]]$indexbestmodel], names(VGOB1_subsetF_staph_LUR3)[models[[9]]$indexbestmodel], names(VGOB1_subsetF_staph_LUR3)[models[[10]]$indexbestmodel])

#  this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetF_staph_LUR3$staph_copiespm3.ln.diffmeth.mean~                                VGOB1_subsetF_staph_LUR3[,models[[1]]$indexbestmodel]+ VGOB1_subsetF_staph_LUR3[,models[[2]]$indexbestmodel]+                           VGOB1_subsetF_staph_LUR3[,models[[3]]$indexbestmodel]+ VGOB1_subsetF_staph_LUR3[,models[[4]]$indexbestmodel]+ VGOB1_subsetF_staph_LUR3[,models[[5]]$indexbestmodel]+ VGOB1_subsetF_staph_LUR3[,models[[6]]$indexbestmodel]+ VGOB1_subsetF_staph_LUR3[,models[[7]]$indexbestmodel]+ VGOB1_subsetF_staph_LUR3[,models[[8]]$indexbestmodel]+ VGOB1_subsetF_staph_LUR3[,models[[9]]$indexbestmodel]+ VGOB1_subsetF_staph_LUR3[,models[[10]]$indexbestmodel]) 

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[5]]$summarybestmodel
models[[6]]$summarybestmodel
models[[7]]$summarybestmodel
models[[8]]$summarybestmodel
models[[9]]$summarybestmodel
models[[10]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[5]]$namesbestmodel
models[[6]]$namesbestmodel
models[[7]]$namesbestmodel
models[[8]]$namesbestmodel
models[[9]]$namesbestmodel
models[[10]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel
models[[5]]$R2bestmodel
models[[6]]$R2bestmodel
models[[7]]$R2bestmodel
models[[8]]$R2bestmodel
models[[9]]$R2bestmodel
models[[10]]$R2bestmodel

#  at this point I always check whether the next model is more than 1% better than the one before and if not I end here

#   CODE FOR PICKING OUT THE BEST MODEL #   
temp <- 0
besti <- 0
for (i in 1:10){ #  think this runs the loop 10 times - not fully sure thought - but not to do with the number of models I don't think - as when I change to 3, I still get the model with 4 variables as best model
  print(models[[i]]$R2bestmodel)
  #       print(models[[i]]$summarybestmodel$coefficients=-1,4])
  #       if((models[[i]]$R2bestmodel-temp > 0.0) && (all(models[[i]]$summarybestmodel$coefficients[-1,4]<0.1))){
  #         temp <- models[[i]]$R2bestmodel
  #         besti <- i
  #         }
  if((models[[i]]$R2bestmodel-temp > 0.0) && (all(models[[i]]$summarybestmodel$coefficients[-1,4]<0.1))){
    temp <- models[[i]]$R2bestmodel
    besti <- i
  }else{
    finalBestModel_staph_LUR3_subsetF <- models[[besti]]$bestmodel
    finalBestModelNames_staph_subsetF <- models[[besti]]$namesbestmodel
    Sites <- 1:dim(VGOB1_subsetF_staph_LUR3)[1] # full original model
    #  CVaR2<-escCV_staph_LUR3(Sites)[2] # Cross Validation
    maxCD<-max(cooks.distance(finalBestModel_staph_LUR3_subsetF))
    if(length(finalBestModelNames_staph_subsetF)<2){ # vif fn doesnot work when only 1 variable...       # 
      maxVIF<-"NA"
    }else{
      maxVIF<-max(vif(finalBestModel_staph_LUR3_subsetF))
    }
    print(paste("This is the best staph model for subset F: ",besti,
                "(AdjR2: ",format(models[[besti]]$R2bestmodel,digits=3), "; MaxCD: ",format(maxCD,digits=3),"; MaxVIF: ",
                format(maxVIF,digits=3),")", sep=''))
    print(finalBestModelNames_staph_subsetF)
    break
  }
}

#  Overview of the final best model using the algorithm selection process (taking into account VIF, R^2, and p-values)
finalBestModel_staph_LUR3_subsetF
finalBestModelNames_staph_subsetF
models[[besti]]$summarybestmodel
models[[besti]]$R2bestmodel

#### G ####
# LUR model building process for subset G
#  This is the dataframe with the relevant predictor vars for LUR3 models for subset G (55 sites)
VGOB1_subsetG_staph_LUR3 # n.b. this dataframe only includes microbial marker concentrations for staph unlike the dataframe Measurements_livestockpreds_LUR3 as previously used for the model building. 

#  Now set the values of some variables that will be needed
nfirstvar_LUR_3 <- 3  
nlastvar_LUR_3 <- 135

# Function building to run the models 
# 1 #  

models<-list()
modeln<-1
models[[modeln]]<-list()

R2<-1
betaaddedvar<-1
addedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_3:nlastvar_LUR_3){
  if (is.numeric(VGOB1_subsetG_staph_LUR3[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetG_staph_LUR3$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetG_staph_LUR3[,i])                            
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    #  Measurements_livestockpreds_LUR3[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR3)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetG_staph_LUR3)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)
models[[modeln]]$results

#  this are the candidates models with the highest R2, not a negative beta for the new, nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)
models[[modeln]]$resultspos

#  rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))
models[[modeln]]$resultspos

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j
models[[modeln]]$indexbestmodel

subset(models[[modeln]]$resultspos, rank==1)
subset(models[[modeln]]$resultspos)

#  this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]
models[[modeln]]$summarybestmodel

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetG_staph_LUR3)[models[[1]]$indexbestmodel])
models[[modeln]]$namesbestmodel

#  this is the r2 of that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2
models[[modeln]]$R2bestmodel

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetG_staph_LUR3$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetG_staph_LUR3[,models[[1]]$indexbestmodel]) 
models[[modeln]]$bestmodel

summary(models[[modeln]]$bestmodel)

#  The first model includes the predictor: nPigMultipFarmWghtDist.3000m.sum.Tr.1P9 - meaning the number of multiplier pig farms weighted to distance in a 3000m buffer

# 2 #  
# Add 2nd variable (the only difference of the above part is that now modeln=2 the model statement has 2 variables)
# and the call for the list of variable names in the model changed slightly

modeln<-2

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_3:nlastvar_LUR_3){
  if (is.numeric(VGOB1_subsetG_staph_LUR3[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetG_staph_LUR3$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetG_staph_LUR3[,models[[1]]$indexbestmodel]+ VGOB1_subsetG_staph_LUR3[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # Measurements_livestockpreds_LUR3[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR3)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetG_staph_LUR3)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  these are the candidate models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)
models[[modeln]]$resultspos

#  rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))
models[[modeln]]$resultspos

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j
models[[modeln]]$indexbestmodel

subset(models[[modeln]]$resultspos, rank==1)

# this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]
models[[modeln]]$summarybestmodel

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetG_staph_LUR3)[models[[1]]$indexbestmodel], names(VGOB1_subsetG_staph_LUR3)[models[[2]]$indexbestmodel] )
models[[modeln]]$namesbestmodel

# this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2
models[[modeln]]$R2bestmodel

# this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetG_staph_LUR3$staph_copiespm3.ln.diffmeth.mean~                               VGOB1_subsetG_staph_LUR3[,models[[1]]$indexbestmodel]+                           VGOB1_subsetG_staph_LUR3[,models[[2]]$indexbestmodel]) 

models[[modeln]]$bestmodel

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel


# 3 #  
# add third variable (the only difference of the above part is that now modeln=3 the model statement has 3 variables)
# and the call for the list of variable names in the model changed slightly

modeln<-3

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_3:nlastvar_LUR_3){
  if (is.numeric(VGOB1_subsetG_staph_LUR3[,i])==TRUE){  
    modeltry<-lm(VGOB1_subsetG_staph_LUR3$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetG_staph_LUR3[,models[[1]]$indexbestmodel]+VGOB1_subsetG_staph_LUR3[,models[[2]]$indexbestmodel]+ VGOB1_subsetG_staph_LUR3[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # All[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR3)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetG_staph_LUR3)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

#  rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

#  this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

#  here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetG_staph_LUR3)[models[[1]]$indexbestmodel], names(VGOB1_subsetG_staph_LUR3)[models[[2]]$indexbestmodel], names(VGOB1_subsetG_staph_LUR3)[models[[3]]$indexbestmodel])

#  this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetG_staph_LUR3$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetG_staph_LUR3[,models[[1]]$indexbestmodel]+ VGOB1_subsetG_staph_LUR3[,models[[2]]$indexbestmodel]+ VGOB1_subsetG_staph_LUR3[,models[[3]]$indexbestmodel]) 

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel


# 4 #  
#  add forth variable (the only difference of the above part is that now model n=4 the model statement more variables)
#  and the call for the list of variable names in the model changed slightly
modeln<-4

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1


for (i in nfirstvar_LUR_3:nlastvar_LUR_3){
  if (is.numeric(VGOB1_subsetG_staph_LUR3[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetG_staph_LUR3$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetG_staph_LUR3[,models[[1]]$indexbestmodel]+VGOB1_subsetG_staph_LUR3[,models[[2]]$indexbestmodel]+VGOB1_subsetG_staph_LUR3[,models[[3]]$indexbestmodel]+VGOB1_subsetG_staph_LUR3[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    #  the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    #  All[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR3)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetG_staph_LUR3)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

#  this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

#  here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetG_staph_LUR3)[models[[1]]$indexbestmodel], names(VGOB1_subsetG_staph_LUR3)[models[[2]]$indexbestmodel], names(VGOB1_subsetG_staph_LUR3)[models[[3]]$indexbestmodel], names(VGOB1_subsetG_staph_LUR3)[models[[4]]$indexbestmodel])

#  this is the r2 of that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetG_staph_LUR3$staph_copiespm3.ln.diffmeth.mean~ VGOB1_subsetG_staph_LUR3[,models[[1]]$indexbestmodel]+ VGOB1_subsetG_staph_LUR3[,models[[2]]$indexbestmodel]+VGOB1_subsetG_staph_LUR3[,models[[3]]$indexbestmodel]+ VGOB1_subsetG_staph_LUR3[,models[[4]]$indexbestmodel]) 


models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel


# 5 #  
# add fifth variable (the only difference of the above part is that now modeln=5 the model statement more variables)
# and the call for the list of variable names in the model changed slightly
modeln<-5

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_3:nlastvar_LUR_3){
  if (is.numeric(VGOB1_subsetG_staph_LUR3[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetG_staph_LUR3$staph_copiespm3.ln.diffmeth.mean~ VGOB1_subsetG_staph_LUR3[,models[[1]]$indexbestmodel]+ VGOB1_subsetG_staph_LUR3[,models[[2]]$indexbestmodel]+ VGOB1_subsetG_staph_LUR3[,models[[3]]$indexbestmodel]+ VGOB1_subsetG_staph_LUR3[,models[[4]]$indexbestmodel]+ VGOB1_subsetG_staph_LUR3[,i]) 
  
R2<-rbind(R2,summary(modeltry)$adj.r.squared)
# the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # All[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR3)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetG_staph_LUR3)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

#  this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetG_staph_LUR3)[models[[1]]$indexbestmodel], names(VGOB1_subsetG_staph_LUR3)[models[[2]]$indexbestmodel], names(VGOB1_subsetG_staph_LUR3)[models[[3]]$indexbestmodel], names(VGOB1_subsetG_staph_LUR3)[models[[4]]$indexbestmodel], names(VGOB1_subsetG_staph_LUR3)[models[[5]]$indexbestmodel])

#  this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetG_staph_LUR3$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetG_staph_LUR3[,models[[1]]$indexbestmodel]+VGOB1_subsetG_staph_LUR3[,models[[2]]$indexbestmodel]+VGOB1_subsetG_staph_LUR3[,models[[3]]$indexbestmodel]+ VGOB1_subsetG_staph_LUR3[,models[[4]]$indexbestmodel]+ VGOB1_subsetG_staph_LUR3[,models[[5]]$indexbestmodel]) 
models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[5]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[5]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel
models[[5]]$R2bestmodel

# 6 #  
# add sixth variable (the only difference of the above part is that now model n=6 the model statement more variables)
#  and the call for the list of variable names in the model changed slightly

modeln<-6

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_3 :nlastvar_LUR_3){
  if (is.numeric(VGOB1_subsetG_staph_LUR3[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetG_staph_LUR3$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetG_staph_LUR3[,models[[1]]$indexbestmodel]+VGOB1_subsetG_staph_LUR3[,models[[2]]$indexbestmodel]+VGOB1_subsetG_staph_LUR3[,models[[3]]$indexbestmodel]+VGOB1_subsetG_staph_LUR3[,models[[4]]$indexbestmodel]+VGOB1_subsetG_staph_LUR3[,models[[5]]$indexbestmodel]+ VGOB1_subsetG_staph_LUR3[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # All[,i] is the row that's being tried out now. the name of that row can be found in  names(All)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetG_staph_LUR3)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

# this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetG_staph_LUR3)[models[[1]]$indexbestmodel], names(VGOB1_subsetG_staph_LUR3)[models[[2]]$indexbestmodel] , names(VGOB1_subsetG_staph_LUR3)[models[[3]]$indexbestmodel], names(VGOB1_subsetG_staph_LUR3)[models[[4]]$indexbestmodel], names(VGOB1_subsetG_staph_LUR3)[models[[5]]$indexbestmodel], names(VGOB1_subsetG_staph_LUR3)[models[[6]]$indexbestmodel])

#  this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetG_staph_LUR3$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetG_staph_LUR3[,models[[1]]$indexbestmodel]+VGOB1_subsetG_staph_LUR3[,models[[2]]$indexbestmodel]+VGOB1_subsetG_staph_LUR3[,models[[3]]$indexbestmodel]+ VGOB1_subsetG_staph_LUR3[,models[[4]]$indexbestmodel]+ VGOB1_subsetG_staph_LUR3[,models[[5]]$indexbestmodel]+ VGOB1_subsetG_staph_LUR3[,models[[6]]$indexbestmodel]) 

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[5]]$summarybestmodel
models[[6]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[5]]$namesbestmodel
models[[6]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel
models[[5]]$R2bestmodel
models[[6]]$R2bestmodel


# 7 #  
# add seventh variable (the only difference of the above part is that now model n=7 the model statement more variables)
#  and the call for the list of variable names in the model changed slightly

modeln<-7

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_3 :nlastvar_LUR_3){
  if (is.numeric(VGOB1_subsetG_staph_LUR3[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetG_staph_LUR3$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetG_staph_LUR3[,models[[1]]$indexbestmodel]+VGOB1_subsetG_staph_LUR3[,models[[2]]$indexbestmodel]+VGOB1_subsetG_staph_LUR3[,models[[3]]$indexbestmodel]+VGOB1_subsetG_staph_LUR3[,models[[4]]$indexbestmodel]+VGOB1_subsetG_staph_LUR3[,models[[5]]$indexbestmodel]+VGOB1_subsetG_staph_LUR3[,models[[6]]$indexbestmodel]+ VGOB1_subsetG_staph_LUR3[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # Measurements_livestockpreds_LUR3[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR3)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetG_staph_LUR3)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

# this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetG_staph_LUR3)[models[[1]]$indexbestmodel], names(VGOB1_subsetG_staph_LUR3)[models[[2]]$indexbestmodel] , names(VGOB1_subsetG_staph_LUR3)[models[[3]]$indexbestmodel], names(VGOB1_subsetG_staph_LUR3)[models[[4]]$indexbestmodel], names(VGOB1_subsetG_staph_LUR3)[models[[5]]$indexbestmodel], names(VGOB1_subsetG_staph_LUR3)[models[[6]]$indexbestmodel], names(VGOB1_subsetG_staph_LUR3)[models[[7]]$indexbestmodel])

#  this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetG_staph_LUR3$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetG_staph_LUR3[,models[[1]]$indexbestmodel]+VGOB1_subsetG_staph_LUR3[,models[[2]]$indexbestmodel]+VGOB1_subsetG_staph_LUR3[,models[[3]]$indexbestmodel]+ VGOB1_subsetG_staph_LUR3[,models[[4]]$indexbestmodel]+ VGOB1_subsetG_staph_LUR3[,models[[5]]$indexbestmodel]+ VGOB1_subsetG_staph_LUR3[,models[[6]]$indexbestmodel]+ VGOB1_subsetG_staph_LUR3[,models[[7]]$indexbestmodel]) 

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[5]]$summarybestmodel
models[[6]]$summarybestmodel
models[[7]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[5]]$namesbestmodel
models[[6]]$namesbestmodel
models[[7]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel
models[[5]]$R2bestmodel
models[[6]]$R2bestmodel
models[[7]]$R2bestmodel

# 8 #  
# add eighth variable (the only difference of the above part is that now modeln=7 the model statement more variables)
# and the call for the list of variable names in the model changed slightly

modeln<-8

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_3 :nlastvar_LUR_3){
  if (is.numeric(VGOB1_subsetG_staph_LUR3[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetG_staph_LUR3$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetG_staph_LUR3[,models[[1]]$indexbestmodel]+VGOB1_subsetG_staph_LUR3[,models[[2]]$indexbestmodel]+VGOB1_subsetG_staph_LUR3[,models[[3]]$indexbestmodel]+VGOB1_subsetG_staph_LUR3[,models[[4]]$indexbestmodel]+VGOB1_subsetG_staph_LUR3[,models[[5]]$indexbestmodel]+VGOB1_subsetG_staph_LUR3[,models[[6]]$indexbestmodel]+ VGOB1_subsetG_staph_LUR3[,models[[7]]$indexbestmodel]+ VGOB1_subsetG_staph_LUR3[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # Measurements_livestockpreds_LUR3[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR3)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetG_staph_LUR3)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

# this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetG_staph_LUR3)[models[[1]]$indexbestmodel], names(VGOB1_subsetG_staph_LUR3)[models[[2]]$indexbestmodel] , names(VGOB1_subsetG_staph_LUR3)[models[[3]]$indexbestmodel], names(VGOB1_subsetG_staph_LUR3)[models[[4]]$indexbestmodel], names(VGOB1_subsetG_staph_LUR3)[models[[5]]$indexbestmodel], names(VGOB1_subsetG_staph_LUR3)[models[[6]]$indexbestmodel], names(VGOB1_subsetG_staph_LUR3)[models[[7]]$indexbestmodel], names(VGOB1_subsetG_staph_LUR3)[models[[8]]$indexbestmodel])

#  this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetG_staph_LUR3$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetG_staph_LUR3[,models[[1]]$indexbestmodel]+VGOB1_subsetG_staph_LUR3[,models[[2]]$indexbestmodel]+VGOB1_subsetG_staph_LUR3[,models[[3]]$indexbestmodel]+ VGOB1_subsetG_staph_LUR3[,models[[4]]$indexbestmodel]+ VGOB1_subsetG_staph_LUR3[,models[[5]]$indexbestmodel]+ VGOB1_subsetG_staph_LUR3[,models[[6]]$indexbestmodel]+ VGOB1_subsetG_staph_LUR3[,models[[7]]$indexbestmodel]+ VGOB1_subsetG_staph_LUR3[,models[[8]]$indexbestmodel]) 

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[5]]$summarybestmodel
models[[6]]$summarybestmodel
models[[7]]$summarybestmodel
models[[8]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[5]]$namesbestmodel
models[[6]]$namesbestmodel
models[[7]]$namesbestmodel
models[[8]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel
models[[5]]$R2bestmodel
models[[6]]$R2bestmodel
models[[7]]$R2bestmodel
models[[8]]$R2bestmodel

# 9 #  
# add ninth variable (the only difference of the above part is that now modeln=9 the model statement more variables)
# and the call for the list of variable names in the model changed slightly

modeln<-9

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_3 :nlastvar_LUR_3){
  if (is.numeric(VGOB1_subsetG_staph_LUR3[,i])==TRUE){
      modeltry<-lm(VGOB1_subsetG_staph_LUR3$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetG_staph_LUR3[,models[[1]]$indexbestmodel]+VGOB1_subsetG_staph_LUR3[,models[[2]]$indexbestmodel]+VGOB1_subsetG_staph_LUR3[,models[[3]]$indexbestmodel]+VGOB1_subsetG_staph_LUR3[,models[[4]]$indexbestmodel]+VGOB1_subsetG_staph_LUR3[,models[[5]]$indexbestmodel]+VGOB1_subsetG_staph_LUR3[,models[[6]]$indexbestmodel]+ VGOB1_subsetG_staph_LUR3[,models[[7]]$indexbestmodel]+ VGOB1_subsetG_staph_LUR3[,models[[8]]$indexbestmodel]+ VGOB1_subsetG_staph_LUR3[,i]) 
        R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # Measurements_livestockpreds_LUR3[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR3)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetG_staph_LUR3)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

# this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetG_staph_LUR3)[models[[1]]$indexbestmodel], names(VGOB1_subsetG_staph_LUR3)[models[[2]]$indexbestmodel] , names(VGOB1_subsetG_staph_LUR3)[models[[3]]$indexbestmodel], names(VGOB1_subsetG_staph_LUR3)[models[[4]]$indexbestmodel], names(VGOB1_subsetG_staph_LUR3)[models[[5]]$indexbestmodel], names(VGOB1_subsetG_staph_LUR3)[models[[6]]$indexbestmodel], names(VGOB1_subsetG_staph_LUR3)[models[[7]]$indexbestmodel], names(VGOB1_subsetG_staph_LUR3)[models[[8]]$indexbestmodel],  names(VGOB1_subsetG_staph_LUR3)[models[[9]]$indexbestmodel])

#  this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetG_staph_LUR3$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetG_staph_LUR3[,models[[1]]$indexbestmodel]+VGOB1_subsetG_staph_LUR3[,models[[2]]$indexbestmodel]+VGOB1_subsetG_staph_LUR3[,models[[3]]$indexbestmodel]+ VGOB1_subsetG_staph_LUR3[,models[[4]]$indexbestmodel]+ VGOB1_subsetG_staph_LUR3[,models[[5]]$indexbestmodel]+ VGOB1_subsetG_staph_LUR3[,models[[6]]$indexbestmodel]+ VGOB1_subsetG_staph_LUR3[,models[[7]]$indexbestmodel]+ VGOB1_subsetG_staph_LUR3[,models[[8]]$indexbestmodel]+ VGOB1_subsetG_staph_LUR3[,models[[9]]$indexbestmodel]) 

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[5]]$summarybestmodel
models[[6]]$summarybestmodel
models[[7]]$summarybestmodel
models[[8]]$summarybestmodel
models[[9]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[5]]$namesbestmodel
models[[6]]$namesbestmodel
models[[7]]$namesbestmodel
models[[8]]$namesbestmodel
models[[9]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel
models[[5]]$R2bestmodel
models[[6]]$R2bestmodel
models[[7]]$R2bestmodel
models[[8]]$R2bestmodel
models[[9]]$R2bestmodel

# 10 #  
#  add tenth variable (the only difference of the above part is that now model n=10 the model statement more variables)
#  and the call for the list of variable names in the model changed slightly

modeln<-10

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_3 :nlastvar_LUR_3){if (is.numeric(VGOB1_subsetG_staph_LUR3[,i])==TRUE){ modeltry<-lm(VGOB1_subsetG_staph_LUR3$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetG_staph_LUR3[,models[[1]]$indexbestmodel]+VGOB1_subsetG_staph_LUR3[,models[[2]]$indexbestmodel]+ VGOB1_subsetG_staph_LUR3[,models[[3]]$indexbestmodel]+VGOB1_subsetG_staph_LUR3[,models[[4]]$indexbestmodel]+ VGOB1_subsetG_staph_LUR3[,models[[5]]$indexbestmodel]+ VGOB1_subsetG_staph_LUR3[,models[[6]]$indexbestmodel]+ VGOB1_subsetG_staph_LUR3[,models[[7]]$indexbestmodel]+ VGOB1_subsetG_staph_LUR3[,models[[8]]$indexbestmodel]+ VGOB1_subsetG_staph_LUR3[,models[[9]]$indexbestmodel]+ VGOB1_subsetG_staph_LUR3[,i]) 

R2<-rbind(R2,summary(modeltry)$adj.r.squared)
# the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # Measurements_livestockpreds_LUR3[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR3)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetG_staph_LUR3)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

# this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

# here are the names
models[[modeln]]$namesbestmodel<-c( names(VGOB1_subsetG_staph_LUR3)[models[[1]]$indexbestmodel],                   names(VGOB1_subsetG_staph_LUR3)[models[[2]]$indexbestmodel] , names(VGOB1_subsetG_staph_LUR3)[models[[3]]$indexbestmodel], names(VGOB1_subsetG_staph_LUR3)[models[[4]]$indexbestmodel], names(VGOB1_subsetG_staph_LUR3)[models[[5]]$indexbestmodel], names(VGOB1_subsetG_staph_LUR3)[models[[6]]$indexbestmodel], names(VGOB1_subsetG_staph_LUR3)[models[[7]]$indexbestmodel], names(VGOB1_subsetG_staph_LUR3)[models[[8]]$indexbestmodel], names(VGOB1_subsetG_staph_LUR3)[models[[9]]$indexbestmodel], names(VGOB1_subsetG_staph_LUR3)[models[[10]]$indexbestmodel])

#  this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetG_staph_LUR3$staph_copiespm3.ln.diffmeth.mean~                                VGOB1_subsetG_staph_LUR3[,models[[1]]$indexbestmodel]+ VGOB1_subsetG_staph_LUR3[,models[[2]]$indexbestmodel]+                           VGOB1_subsetG_staph_LUR3[,models[[3]]$indexbestmodel]+ VGOB1_subsetG_staph_LUR3[,models[[4]]$indexbestmodel]+ VGOB1_subsetG_staph_LUR3[,models[[5]]$indexbestmodel]+ VGOB1_subsetG_staph_LUR3[,models[[6]]$indexbestmodel]+ VGOB1_subsetG_staph_LUR3[,models[[7]]$indexbestmodel]+ VGOB1_subsetG_staph_LUR3[,models[[8]]$indexbestmodel]+ VGOB1_subsetG_staph_LUR3[,models[[9]]$indexbestmodel]+ VGOB1_subsetG_staph_LUR3[,models[[10]]$indexbestmodel]) 

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[5]]$summarybestmodel
models[[6]]$summarybestmodel
models[[7]]$summarybestmodel
models[[8]]$summarybestmodel
models[[9]]$summarybestmodel
models[[10]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[5]]$namesbestmodel
models[[6]]$namesbestmodel
models[[7]]$namesbestmodel
models[[8]]$namesbestmodel
models[[9]]$namesbestmodel
models[[10]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel
models[[5]]$R2bestmodel
models[[6]]$R2bestmodel
models[[7]]$R2bestmodel
models[[8]]$R2bestmodel
models[[9]]$R2bestmodel
models[[10]]$R2bestmodel

#  at this point I always check whether the next model is more than 1% better than the one before and if not I end here

#   CODE FOR PICKING OUT THE BEST MODEL #   
temp <- 0
besti <- 0
for (i in 1:10){ #  think this runs the loop 10 times - not fully sure thought - but not to do with the number of models I don't think - as when I change to 3, I still get the model with 4 variables as best model
  print(models[[i]]$R2bestmodel)
  #       print(models[[i]]$summarybestmodel$coefficients=-1,4])
  #       if((models[[i]]$R2bestmodel-temp > 0.0) && (all(models[[i]]$summarybestmodel$coefficients[-1,4]<0.1))){
  #         temp <- models[[i]]$R2bestmodel
  #         besti <- i
  #         }
  if((models[[i]]$R2bestmodel-temp > 0.0) && (all(models[[i]]$summarybestmodel$coefficients[-1,4]<0.1))){
    temp <- models[[i]]$R2bestmodel
    besti <- i
  }else{
    finalBestModel_staph_LUR3_subsetG <- models[[besti]]$bestmodel
    finalBestModelNames_staph_subsetG <- models[[besti]]$namesbestmodel
    Sites <- 1:dim(VGOB1_subsetG_staph_LUR3)[1] # full original model
    #  CVaR2<-escCV_staph_LUR3(Sites)[2] # Cross Validation
    maxCD<-max(cooks.distance(finalBestModel_staph_LUR3_subsetG))
    if(length(finalBestModelNames_staph_subsetG)<2){ # vif fn doesnot work when only 1 variable...       # 
      maxVIF<-"NA"
    }else{
      maxVIF<-max(vif(finalBestModel_staph_LUR3_subsetG))
    }
    print(paste("This is the best staph model for subset G: ",besti,
                "(AdjR2: ",format(models[[besti]]$R2bestmodel,digits=3), "; MaxCD: ",format(maxCD,digits=3),"; MaxVIF: ",
                format(maxVIF,digits=3),")", sep=''))
    print(finalBestModelNames_staph_subsetG)
    break
  }
}

#  Overview of the final best model using the algorithm selection process (taking into account VIF, R^2, and p-values)
finalBestModel_staph_LUR3_subsetG
finalBestModelNames_staph_subsetG
models[[besti]]$summarybestmodel
models[[besti]]$R2bestmodel

#### H ####
# LUR model building process for subset H
#  This is the dataframe with the relevant predictor vars for LUR3 models for subset H (55 sites)
VGOB1_subsetH_staph_LUR3 # n.b. this dataframe only includes microbial marker concentrations for staph unlike the dataframe Measurements_livestockpreds_LUR3 as previously used for the model building. 

#  Now set the values of some variables that will be needed
nfirstvar_LUR_3 <- 3  
nlastvar_LUR_3 <- 135

# Function building to run the models 
# 1 #  

models<-list()
modeln<-1
models[[modeln]]<-list()

R2<-1
betaaddedvar<-1
addedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_3:nlastvar_LUR_3){
  if (is.numeric(VGOB1_subsetH_staph_LUR3[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetH_staph_LUR3$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetH_staph_LUR3[,i])                            
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    #  Measurements_livestockpreds_LUR3[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR3)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetH_staph_LUR3)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)
models[[modeln]]$results

#  this are the candidates models with the highest R2, not a negative beta for the new, nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)
models[[modeln]]$resultspos

#  rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))
models[[modeln]]$resultspos

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j
models[[modeln]]$indexbestmodel

subset(models[[modeln]]$resultspos, rank==1)
subset(models[[modeln]]$resultspos)

#  this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]
models[[modeln]]$summarybestmodel

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetH_staph_LUR3)[models[[1]]$indexbestmodel])
models[[modeln]]$namesbestmodel

#  this is the r2 of that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2
models[[modeln]]$R2bestmodel

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetH_staph_LUR3$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetH_staph_LUR3[,models[[1]]$indexbestmodel]) 
models[[modeln]]$bestmodel

summary(models[[modeln]]$bestmodel)

#  The first model includes the predictor: nPigMultipFarmWghtDist.3000m.sum.Tr.1P9 - meaning the number of multiplier pig farms weighted to distance in a 3000m buffer

# 2 #  
# Add 2nd variable (the only difference of the above part is that now modeln=2 the model statement has 2 variables)
# and the call for the list of variable names in the model changed slightly

modeln<-2

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_3:nlastvar_LUR_3){
  if (is.numeric(VGOB1_subsetH_staph_LUR3[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetH_staph_LUR3$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetH_staph_LUR3[,models[[1]]$indexbestmodel]+ VGOB1_subsetH_staph_LUR3[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # Measurements_livestockpreds_LUR3[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR3)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetH_staph_LUR3)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  these are the candidate models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)
models[[modeln]]$resultspos

#  rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))
models[[modeln]]$resultspos

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j
models[[modeln]]$indexbestmodel

subset(models[[modeln]]$resultspos, rank==1)

# this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]
models[[modeln]]$summarybestmodel

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetH_staph_LUR3)[models[[1]]$indexbestmodel], names(VGOB1_subsetH_staph_LUR3)[models[[2]]$indexbestmodel] )
models[[modeln]]$namesbestmodel

# this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2
models[[modeln]]$R2bestmodel

# this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetH_staph_LUR3$staph_copiespm3.ln.diffmeth.mean~                               VGOB1_subsetH_staph_LUR3[,models[[1]]$indexbestmodel]+                           VGOB1_subsetH_staph_LUR3[,models[[2]]$indexbestmodel]) 

models[[modeln]]$bestmodel

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel


# 3 #  
# add third variable (the only difference of the above part is that now modeln=3 the model statement has 3 variables)
# and the call for the list of variable names in the model changed slightly

modeln<-3

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_3:nlastvar_LUR_3){
  if (is.numeric(VGOB1_subsetH_staph_LUR3[,i])==TRUE){  
    modeltry<-lm(VGOB1_subsetH_staph_LUR3$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetH_staph_LUR3[,models[[1]]$indexbestmodel]+VGOB1_subsetH_staph_LUR3[,models[[2]]$indexbestmodel]+ VGOB1_subsetH_staph_LUR3[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # All[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR3)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetH_staph_LUR3)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

#  rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

#  this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

#  here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetH_staph_LUR3)[models[[1]]$indexbestmodel], names(VGOB1_subsetH_staph_LUR3)[models[[2]]$indexbestmodel], names(VGOB1_subsetH_staph_LUR3)[models[[3]]$indexbestmodel])

#  this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetH_staph_LUR3$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetH_staph_LUR3[,models[[1]]$indexbestmodel]+ VGOB1_subsetH_staph_LUR3[,models[[2]]$indexbestmodel]+ VGOB1_subsetH_staph_LUR3[,models[[3]]$indexbestmodel]) 

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel


# 4 #  
#  add forth variable (the only difference of the above part is that now model n=4 the model statement more variables)
#  and the call for the list of variable names in the model changed slightly
modeln<-4

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1


for (i in nfirstvar_LUR_3:nlastvar_LUR_3){
  if (is.numeric(VGOB1_subsetH_staph_LUR3[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetH_staph_LUR3$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetH_staph_LUR3[,models[[1]]$indexbestmodel]+VGOB1_subsetH_staph_LUR3[,models[[2]]$indexbestmodel]+VGOB1_subsetH_staph_LUR3[,models[[3]]$indexbestmodel]+VGOB1_subsetH_staph_LUR3[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    #  the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    #  All[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR3)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetH_staph_LUR3)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

#  this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

#  here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetH_staph_LUR3)[models[[1]]$indexbestmodel], names(VGOB1_subsetH_staph_LUR3)[models[[2]]$indexbestmodel], names(VGOB1_subsetH_staph_LUR3)[models[[3]]$indexbestmodel], names(VGOB1_subsetH_staph_LUR3)[models[[4]]$indexbestmodel])

#  this is the r2 of that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetH_staph_LUR3$staph_copiespm3.ln.diffmeth.mean~ VGOB1_subsetH_staph_LUR3[,models[[1]]$indexbestmodel]+ VGOB1_subsetH_staph_LUR3[,models[[2]]$indexbestmodel]+VGOB1_subsetH_staph_LUR3[,models[[3]]$indexbestmodel]+ VGOB1_subsetH_staph_LUR3[,models[[4]]$indexbestmodel]) 


models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel


# 5 #  
# add fifth variable (the only difference of the above part is that now modeln=5 the model statement more variables)
# and the call for the list of variable names in the model changed slightly
modeln<-5

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_3:nlastvar_LUR_3){
  if (is.numeric(VGOB1_subsetH_staph_LUR3[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetH_staph_LUR3$staph_copiespm3.ln.diffmeth.mean~ VGOB1_subsetH_staph_LUR3[,models[[1]]$indexbestmodel]+ VGOB1_subsetH_staph_LUR3[,models[[2]]$indexbestmodel]+ VGOB1_subsetH_staph_LUR3[,models[[3]]$indexbestmodel]+ VGOB1_subsetH_staph_LUR3[,models[[4]]$indexbestmodel]+ VGOB1_subsetH_staph_LUR3[,i]) 
  
R2<-rbind(R2,summary(modeltry)$adj.r.squared)
# the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # All[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR3)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetH_staph_LUR3)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

#  this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetH_staph_LUR3)[models[[1]]$indexbestmodel], names(VGOB1_subsetH_staph_LUR3)[models[[2]]$indexbestmodel], names(VGOB1_subsetH_staph_LUR3)[models[[3]]$indexbestmodel], names(VGOB1_subsetH_staph_LUR3)[models[[4]]$indexbestmodel], names(VGOB1_subsetH_staph_LUR3)[models[[5]]$indexbestmodel])

#  this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetH_staph_LUR3$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetH_staph_LUR3[,models[[1]]$indexbestmodel]+VGOB1_subsetH_staph_LUR3[,models[[2]]$indexbestmodel]+VGOB1_subsetH_staph_LUR3[,models[[3]]$indexbestmodel]+ VGOB1_subsetH_staph_LUR3[,models[[4]]$indexbestmodel]+ VGOB1_subsetH_staph_LUR3[,models[[5]]$indexbestmodel]) 
models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[5]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[5]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel
models[[5]]$R2bestmodel

# 6 #  
# add sixth variable (the only difference of the above part is that now model n=6 the model statement more variables)
#  and the call for the list of variable names in the model changed slightly

modeln<-6

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_3 :nlastvar_LUR_3){
  if (is.numeric(VGOB1_subsetH_staph_LUR3[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetH_staph_LUR3$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetH_staph_LUR3[,models[[1]]$indexbestmodel]+VGOB1_subsetH_staph_LUR3[,models[[2]]$indexbestmodel]+VGOB1_subsetH_staph_LUR3[,models[[3]]$indexbestmodel]+VGOB1_subsetH_staph_LUR3[,models[[4]]$indexbestmodel]+VGOB1_subsetH_staph_LUR3[,models[[5]]$indexbestmodel]+ VGOB1_subsetH_staph_LUR3[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # All[,i] is the row that's being tried out now. the name of that row can be found in  names(All)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetH_staph_LUR3)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

# this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetH_staph_LUR3)[models[[1]]$indexbestmodel], names(VGOB1_subsetH_staph_LUR3)[models[[2]]$indexbestmodel] , names(VGOB1_subsetH_staph_LUR3)[models[[3]]$indexbestmodel], names(VGOB1_subsetH_staph_LUR3)[models[[4]]$indexbestmodel], names(VGOB1_subsetH_staph_LUR3)[models[[5]]$indexbestmodel], names(VGOB1_subsetH_staph_LUR3)[models[[6]]$indexbestmodel])

#  this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetH_staph_LUR3$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetH_staph_LUR3[,models[[1]]$indexbestmodel]+VGOB1_subsetH_staph_LUR3[,models[[2]]$indexbestmodel]+VGOB1_subsetH_staph_LUR3[,models[[3]]$indexbestmodel]+ VGOB1_subsetH_staph_LUR3[,models[[4]]$indexbestmodel]+ VGOB1_subsetH_staph_LUR3[,models[[5]]$indexbestmodel]+ VGOB1_subsetH_staph_LUR3[,models[[6]]$indexbestmodel]) 

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[5]]$summarybestmodel
models[[6]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[5]]$namesbestmodel
models[[6]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel
models[[5]]$R2bestmodel
models[[6]]$R2bestmodel


# 7 #  
# add seventh variable (the only difference of the above part is that now model n=7 the model statement more variables)
#  and the call for the list of variable names in the model changed slightly

modeln<-7

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_3 :nlastvar_LUR_3){
  if (is.numeric(VGOB1_subsetH_staph_LUR3[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetH_staph_LUR3$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetH_staph_LUR3[,models[[1]]$indexbestmodel]+VGOB1_subsetH_staph_LUR3[,models[[2]]$indexbestmodel]+VGOB1_subsetH_staph_LUR3[,models[[3]]$indexbestmodel]+VGOB1_subsetH_staph_LUR3[,models[[4]]$indexbestmodel]+VGOB1_subsetH_staph_LUR3[,models[[5]]$indexbestmodel]+VGOB1_subsetH_staph_LUR3[,models[[6]]$indexbestmodel]+ VGOB1_subsetH_staph_LUR3[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # Measurements_livestockpreds_LUR3[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR3)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetH_staph_LUR3)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

# this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetH_staph_LUR3)[models[[1]]$indexbestmodel], names(VGOB1_subsetH_staph_LUR3)[models[[2]]$indexbestmodel] , names(VGOB1_subsetH_staph_LUR3)[models[[3]]$indexbestmodel], names(VGOB1_subsetH_staph_LUR3)[models[[4]]$indexbestmodel], names(VGOB1_subsetH_staph_LUR3)[models[[5]]$indexbestmodel], names(VGOB1_subsetH_staph_LUR3)[models[[6]]$indexbestmodel], names(VGOB1_subsetH_staph_LUR3)[models[[7]]$indexbestmodel])

#  this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetH_staph_LUR3$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetH_staph_LUR3[,models[[1]]$indexbestmodel]+VGOB1_subsetH_staph_LUR3[,models[[2]]$indexbestmodel]+VGOB1_subsetH_staph_LUR3[,models[[3]]$indexbestmodel]+ VGOB1_subsetH_staph_LUR3[,models[[4]]$indexbestmodel]+ VGOB1_subsetH_staph_LUR3[,models[[5]]$indexbestmodel]+ VGOB1_subsetH_staph_LUR3[,models[[6]]$indexbestmodel]+ VGOB1_subsetH_staph_LUR3[,models[[7]]$indexbestmodel]) 

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[5]]$summarybestmodel
models[[6]]$summarybestmodel
models[[7]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[5]]$namesbestmodel
models[[6]]$namesbestmodel
models[[7]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel
models[[5]]$R2bestmodel
models[[6]]$R2bestmodel
models[[7]]$R2bestmodel

# 8 #  
# add eighth variable (the only difference of the above part is that now modeln=7 the model statement more variables)
# and the call for the list of variable names in the model changed slightly

modeln<-8

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_3 :nlastvar_LUR_3){
  if (is.numeric(VGOB1_subsetH_staph_LUR3[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetH_staph_LUR3$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetH_staph_LUR3[,models[[1]]$indexbestmodel]+VGOB1_subsetH_staph_LUR3[,models[[2]]$indexbestmodel]+VGOB1_subsetH_staph_LUR3[,models[[3]]$indexbestmodel]+VGOB1_subsetH_staph_LUR3[,models[[4]]$indexbestmodel]+VGOB1_subsetH_staph_LUR3[,models[[5]]$indexbestmodel]+VGOB1_subsetH_staph_LUR3[,models[[6]]$indexbestmodel]+ VGOB1_subsetH_staph_LUR3[,models[[7]]$indexbestmodel]+ VGOB1_subsetH_staph_LUR3[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # Measurements_livestockpreds_LUR3[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR3)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetH_staph_LUR3)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

# this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetH_staph_LUR3)[models[[1]]$indexbestmodel], names(VGOB1_subsetH_staph_LUR3)[models[[2]]$indexbestmodel] , names(VGOB1_subsetH_staph_LUR3)[models[[3]]$indexbestmodel], names(VGOB1_subsetH_staph_LUR3)[models[[4]]$indexbestmodel], names(VGOB1_subsetH_staph_LUR3)[models[[5]]$indexbestmodel], names(VGOB1_subsetH_staph_LUR3)[models[[6]]$indexbestmodel], names(VGOB1_subsetH_staph_LUR3)[models[[7]]$indexbestmodel], names(VGOB1_subsetH_staph_LUR3)[models[[8]]$indexbestmodel])

#  this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetH_staph_LUR3$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetH_staph_LUR3[,models[[1]]$indexbestmodel]+VGOB1_subsetH_staph_LUR3[,models[[2]]$indexbestmodel]+VGOB1_subsetH_staph_LUR3[,models[[3]]$indexbestmodel]+ VGOB1_subsetH_staph_LUR3[,models[[4]]$indexbestmodel]+ VGOB1_subsetH_staph_LUR3[,models[[5]]$indexbestmodel]+ VGOB1_subsetH_staph_LUR3[,models[[6]]$indexbestmodel]+ VGOB1_subsetH_staph_LUR3[,models[[7]]$indexbestmodel]+ VGOB1_subsetH_staph_LUR3[,models[[8]]$indexbestmodel]) 

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[5]]$summarybestmodel
models[[6]]$summarybestmodel
models[[7]]$summarybestmodel
models[[8]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[5]]$namesbestmodel
models[[6]]$namesbestmodel
models[[7]]$namesbestmodel
models[[8]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel
models[[5]]$R2bestmodel
models[[6]]$R2bestmodel
models[[7]]$R2bestmodel
models[[8]]$R2bestmodel

# 9 #  
# add ninth variable (the only difference of the above part is that now modeln=9 the model statement more variables)
# and the call for the list of variable names in the model changed slightly

modeln<-9

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_3 :nlastvar_LUR_3){
  if (is.numeric(VGOB1_subsetH_staph_LUR3[,i])==TRUE){
      modeltry<-lm(VGOB1_subsetH_staph_LUR3$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetH_staph_LUR3[,models[[1]]$indexbestmodel]+VGOB1_subsetH_staph_LUR3[,models[[2]]$indexbestmodel]+VGOB1_subsetH_staph_LUR3[,models[[3]]$indexbestmodel]+VGOB1_subsetH_staph_LUR3[,models[[4]]$indexbestmodel]+VGOB1_subsetH_staph_LUR3[,models[[5]]$indexbestmodel]+VGOB1_subsetH_staph_LUR3[,models[[6]]$indexbestmodel]+ VGOB1_subsetH_staph_LUR3[,models[[7]]$indexbestmodel]+ VGOB1_subsetH_staph_LUR3[,models[[8]]$indexbestmodel]+ VGOB1_subsetH_staph_LUR3[,i]) 
        R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # Measurements_livestockpreds_LUR3[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR3)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetH_staph_LUR3)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

# this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetH_staph_LUR3)[models[[1]]$indexbestmodel], names(VGOB1_subsetH_staph_LUR3)[models[[2]]$indexbestmodel] , names(VGOB1_subsetH_staph_LUR3)[models[[3]]$indexbestmodel], names(VGOB1_subsetH_staph_LUR3)[models[[4]]$indexbestmodel], names(VGOB1_subsetH_staph_LUR3)[models[[5]]$indexbestmodel], names(VGOB1_subsetH_staph_LUR3)[models[[6]]$indexbestmodel], names(VGOB1_subsetH_staph_LUR3)[models[[7]]$indexbestmodel], names(VGOB1_subsetH_staph_LUR3)[models[[8]]$indexbestmodel],  names(VGOB1_subsetH_staph_LUR3)[models[[9]]$indexbestmodel])

#  this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetH_staph_LUR3$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetH_staph_LUR3[,models[[1]]$indexbestmodel]+VGOB1_subsetH_staph_LUR3[,models[[2]]$indexbestmodel]+VGOB1_subsetH_staph_LUR3[,models[[3]]$indexbestmodel]+ VGOB1_subsetH_staph_LUR3[,models[[4]]$indexbestmodel]+ VGOB1_subsetH_staph_LUR3[,models[[5]]$indexbestmodel]+ VGOB1_subsetH_staph_LUR3[,models[[6]]$indexbestmodel]+ VGOB1_subsetH_staph_LUR3[,models[[7]]$indexbestmodel]+ VGOB1_subsetH_staph_LUR3[,models[[8]]$indexbestmodel]+ VGOB1_subsetH_staph_LUR3[,models[[9]]$indexbestmodel]) 

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[5]]$summarybestmodel
models[[6]]$summarybestmodel
models[[7]]$summarybestmodel
models[[8]]$summarybestmodel
models[[9]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[5]]$namesbestmodel
models[[6]]$namesbestmodel
models[[7]]$namesbestmodel
models[[8]]$namesbestmodel
models[[9]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel
models[[5]]$R2bestmodel
models[[6]]$R2bestmodel
models[[7]]$R2bestmodel
models[[8]]$R2bestmodel
models[[9]]$R2bestmodel

# 10 #  
#  add tenth variable (the only difference of the above part is that now model n=10 the model statement more variables)
#  and the call for the list of variable names in the model changed slightly

modeln<-10

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_3 :nlastvar_LUR_3){if (is.numeric(VGOB1_subsetH_staph_LUR3[,i])==TRUE){ modeltry<-lm(VGOB1_subsetH_staph_LUR3$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetH_staph_LUR3[,models[[1]]$indexbestmodel]+VGOB1_subsetH_staph_LUR3[,models[[2]]$indexbestmodel]+ VGOB1_subsetH_staph_LUR3[,models[[3]]$indexbestmodel]+VGOB1_subsetH_staph_LUR3[,models[[4]]$indexbestmodel]+ VGOB1_subsetH_staph_LUR3[,models[[5]]$indexbestmodel]+ VGOB1_subsetH_staph_LUR3[,models[[6]]$indexbestmodel]+ VGOB1_subsetH_staph_LUR3[,models[[7]]$indexbestmodel]+ VGOB1_subsetH_staph_LUR3[,models[[8]]$indexbestmodel]+ VGOB1_subsetH_staph_LUR3[,models[[9]]$indexbestmodel]+ VGOB1_subsetH_staph_LUR3[,i]) 

R2<-rbind(R2,summary(modeltry)$adj.r.squared)
# the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # Measurements_livestockpreds_LUR3[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR3)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetH_staph_LUR3)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

# this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

# here are the names
models[[modeln]]$namesbestmodel<-c( names(VGOB1_subsetH_staph_LUR3)[models[[1]]$indexbestmodel],                   names(VGOB1_subsetH_staph_LUR3)[models[[2]]$indexbestmodel] , names(VGOB1_subsetH_staph_LUR3)[models[[3]]$indexbestmodel], names(VGOB1_subsetH_staph_LUR3)[models[[4]]$indexbestmodel], names(VGOB1_subsetH_staph_LUR3)[models[[5]]$indexbestmodel], names(VGOB1_subsetH_staph_LUR3)[models[[6]]$indexbestmodel], names(VGOB1_subsetH_staph_LUR3)[models[[7]]$indexbestmodel], names(VGOB1_subsetH_staph_LUR3)[models[[8]]$indexbestmodel], names(VGOB1_subsetH_staph_LUR3)[models[[9]]$indexbestmodel], names(VGOB1_subsetH_staph_LUR3)[models[[10]]$indexbestmodel])

#  this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetH_staph_LUR3$staph_copiespm3.ln.diffmeth.mean~                                VGOB1_subsetH_staph_LUR3[,models[[1]]$indexbestmodel]+ VGOB1_subsetH_staph_LUR3[,models[[2]]$indexbestmodel]+                           VGOB1_subsetH_staph_LUR3[,models[[3]]$indexbestmodel]+ VGOB1_subsetH_staph_LUR3[,models[[4]]$indexbestmodel]+ VGOB1_subsetH_staph_LUR3[,models[[5]]$indexbestmodel]+ VGOB1_subsetH_staph_LUR3[,models[[6]]$indexbestmodel]+ VGOB1_subsetH_staph_LUR3[,models[[7]]$indexbestmodel]+ VGOB1_subsetH_staph_LUR3[,models[[8]]$indexbestmodel]+ VGOB1_subsetH_staph_LUR3[,models[[9]]$indexbestmodel]+ VGOB1_subsetH_staph_LUR3[,models[[10]]$indexbestmodel]) 

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[5]]$summarybestmodel
models[[6]]$summarybestmodel
models[[7]]$summarybestmodel
models[[8]]$summarybestmodel
models[[9]]$summarybestmodel
models[[10]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[5]]$namesbestmodel
models[[6]]$namesbestmodel
models[[7]]$namesbestmodel
models[[8]]$namesbestmodel
models[[9]]$namesbestmodel
models[[10]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel
models[[5]]$R2bestmodel
models[[6]]$R2bestmodel
models[[7]]$R2bestmodel
models[[8]]$R2bestmodel
models[[9]]$R2bestmodel
models[[10]]$R2bestmodel

#  at this point I always check whether the next model is more than 1% better than the one before and if not I end here

#   CODE FOR PICKING OUT THE BEST MODEL #   
temp <- 0
besti <- 0
for (i in 1:10){ #  think this runs the loop 10 times - not fully sure thought - but not to do with the number of models I don't think - as when I change to 3, I still get the model with 4 variables as best model
  print(models[[i]]$R2bestmodel)
  #       print(models[[i]]$summarybestmodel$coefficients=-1,4])
  #       if((models[[i]]$R2bestmodel-temp > 0.0) && (all(models[[i]]$summarybestmodel$coefficients[-1,4]<0.1))){
  #         temp <- models[[i]]$R2bestmodel
  #         besti <- i
  #         }
  if((models[[i]]$R2bestmodel-temp > 0.0) && (all(models[[i]]$summarybestmodel$coefficients[-1,4]<0.1))){
    temp <- models[[i]]$R2bestmodel
    besti <- i
  }else{
    finalBestModel_staph_LUR3_subsetH <- models[[besti]]$bestmodel
    finalBestModelNames_staph_subsetH <- models[[besti]]$namesbestmodel
    Sites <- 1:dim(VGOB1_subsetH_staph_LUR3)[1] # full original model
    #  CVaR2<-escCV_staph_LUR3(Sites)[2] # Cross Validation
    maxCD<-max(cooks.distance(finalBestModel_staph_LUR3_subsetH))
    if(length(finalBestModelNames_staph_subsetH)<2){ # vif fn doesnot work when only 1 variable...       # 
      maxVIF<-"NA"
    }else{
      maxVIF<-max(vif(finalBestModel_staph_LUR3_subsetH))
    }
    print(paste("This is the best staph model for subset H: ",besti,
                "(AdjR2: ",format(models[[besti]]$R2bestmodel,digits=3), "; MaxCD: ",format(maxCD,digits=3),"; MaxVIF: ",
                format(maxVIF,digits=3),")", sep=''))
    print(finalBestModelNames_staph_subsetH)
    break
  }
}

#  Overview of the final best model using the algorithm selection process (taking into account VIF, R^2, and p-values)
finalBestModel_staph_LUR3_subsetH
finalBestModelNames_staph_subsetH
models[[besti]]$summarybestmodel
models[[besti]]$R2bestmodel


#### I ####
# LUR model building process for subset I
#  This is the dataframe with the relevant predictor vars for LUR3 models for subset I (55 sites)
VGOB1_subsetI_staph_LUR3 # n.b. this dataframe only includes microbial marker concentrations for staph unlike the dataframe Measurements_livestockpreds_LUR3 as previously used for the model building. 

#  Now set the values of some variables that will be needed
nfirstvar_LUR_3 <- 3  
nlastvar_LUR_3 <- 135

# Function building to run the models 
# 1 #  

models<-list()
modeln<-1
models[[modeln]]<-list()

R2<-1
betaaddedvar<-1
addedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_3:nlastvar_LUR_3){
  if (is.numeric(VGOB1_subsetI_staph_LUR3[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetI_staph_LUR3$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetI_staph_LUR3[,i])                            
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    #  Measurements_livestockpreds_LUR3[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR3)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetI_staph_LUR3)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)
models[[modeln]]$results

#  this are the candidates models with the highest R2, not a negative beta for the new, nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)
models[[modeln]]$resultspos

#  rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))
models[[modeln]]$resultspos

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j
models[[modeln]]$indexbestmodel

subset(models[[modeln]]$resultspos, rank==1)
subset(models[[modeln]]$resultspos)

#  this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]
models[[modeln]]$summarybestmodel

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetI_staph_LUR3)[models[[1]]$indexbestmodel])
models[[modeln]]$namesbestmodel

#  this is the r2 of that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2
models[[modeln]]$R2bestmodel

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetI_staph_LUR3$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetI_staph_LUR3[,models[[1]]$indexbestmodel]) 
models[[modeln]]$bestmodel

summary(models[[modeln]]$bestmodel)

#  The first model includes the predictor: nPigMultipFarmWghtDist.3000m.sum.Tr.1P9 - meaning the number of multiplier pig farms weighted to distance in a 3000m buffer

# 2 #  
# Add 2nd variable (the only difference of the above part is that now modeln=2 the model statement has 2 variables)
# and the call for the list of variable names in the model changed slightly

modeln<-2

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_3:nlastvar_LUR_3){
  if (is.numeric(VGOB1_subsetI_staph_LUR3[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetI_staph_LUR3$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetI_staph_LUR3[,models[[1]]$indexbestmodel]+ VGOB1_subsetI_staph_LUR3[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # Measurements_livestockpreds_LUR3[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR3)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetI_staph_LUR3)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  these are the candidate models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)
models[[modeln]]$resultspos

#  rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))
models[[modeln]]$resultspos

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j
models[[modeln]]$indexbestmodel

subset(models[[modeln]]$resultspos, rank==1)

# this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]
models[[modeln]]$summarybestmodel

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetI_staph_LUR3)[models[[1]]$indexbestmodel], names(VGOB1_subsetI_staph_LUR3)[models[[2]]$indexbestmodel] )
models[[modeln]]$namesbestmodel

# this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2
models[[modeln]]$R2bestmodel

# this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetI_staph_LUR3$staph_copiespm3.ln.diffmeth.mean~                               VGOB1_subsetI_staph_LUR3[,models[[1]]$indexbestmodel]+                           VGOB1_subsetI_staph_LUR3[,models[[2]]$indexbestmodel]) 

models[[modeln]]$bestmodel

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel


# 3 #  
# add third variable (the only difference of the above part is that now modeln=3 the model statement has 3 variables)
# and the call for the list of variable names in the model changed slightly

modeln<-3

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_3:nlastvar_LUR_3){
  if (is.numeric(VGOB1_subsetI_staph_LUR3[,i])==TRUE){  
    modeltry<-lm(VGOB1_subsetI_staph_LUR3$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetI_staph_LUR3[,models[[1]]$indexbestmodel]+VGOB1_subsetI_staph_LUR3[,models[[2]]$indexbestmodel]+ VGOB1_subsetI_staph_LUR3[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # All[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR3)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetI_staph_LUR3)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

#  rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

#  this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

#  here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetI_staph_LUR3)[models[[1]]$indexbestmodel], names(VGOB1_subsetI_staph_LUR3)[models[[2]]$indexbestmodel], names(VGOB1_subsetI_staph_LUR3)[models[[3]]$indexbestmodel])

#  this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetI_staph_LUR3$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetI_staph_LUR3[,models[[1]]$indexbestmodel]+ VGOB1_subsetI_staph_LUR3[,models[[2]]$indexbestmodel]+ VGOB1_subsetI_staph_LUR3[,models[[3]]$indexbestmodel]) 

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel


# 4 #  
#  add forth variable (the only difference of the above part is that now model n=4 the model statement more variables)
#  and the call for the list of variable names in the model changed slightly
modeln<-4

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1


for (i in nfirstvar_LUR_3:nlastvar_LUR_3){
  if (is.numeric(VGOB1_subsetI_staph_LUR3[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetI_staph_LUR3$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetI_staph_LUR3[,models[[1]]$indexbestmodel]+VGOB1_subsetI_staph_LUR3[,models[[2]]$indexbestmodel]+VGOB1_subsetI_staph_LUR3[,models[[3]]$indexbestmodel]+VGOB1_subsetI_staph_LUR3[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    #  the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    #  All[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR3)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetI_staph_LUR3)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

#  this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

#  here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetI_staph_LUR3)[models[[1]]$indexbestmodel], names(VGOB1_subsetI_staph_LUR3)[models[[2]]$indexbestmodel], names(VGOB1_subsetI_staph_LUR3)[models[[3]]$indexbestmodel], names(VGOB1_subsetI_staph_LUR3)[models[[4]]$indexbestmodel])

#  this is the r2 of that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetI_staph_LUR3$staph_copiespm3.ln.diffmeth.mean~ VGOB1_subsetI_staph_LUR3[,models[[1]]$indexbestmodel]+ VGOB1_subsetI_staph_LUR3[,models[[2]]$indexbestmodel]+VGOB1_subsetI_staph_LUR3[,models[[3]]$indexbestmodel]+ VGOB1_subsetI_staph_LUR3[,models[[4]]$indexbestmodel]) 


models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel


# 5 #  
# add fifth variable (the only difference of the above part is that now modeln=5 the model statement more variables)
# and the call for the list of variable names in the model changed slightly
modeln<-5

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_3:nlastvar_LUR_3){
  if (is.numeric(VGOB1_subsetI_staph_LUR3[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetI_staph_LUR3$staph_copiespm3.ln.diffmeth.mean~ VGOB1_subsetI_staph_LUR3[,models[[1]]$indexbestmodel]+ VGOB1_subsetI_staph_LUR3[,models[[2]]$indexbestmodel]+ VGOB1_subsetI_staph_LUR3[,models[[3]]$indexbestmodel]+ VGOB1_subsetI_staph_LUR3[,models[[4]]$indexbestmodel]+ VGOB1_subsetI_staph_LUR3[,i]) 
  
R2<-rbind(R2,summary(modeltry)$adj.r.squared)
# the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # All[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR3)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetI_staph_LUR3)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

#  this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetI_staph_LUR3)[models[[1]]$indexbestmodel], names(VGOB1_subsetI_staph_LUR3)[models[[2]]$indexbestmodel], names(VGOB1_subsetI_staph_LUR3)[models[[3]]$indexbestmodel], names(VGOB1_subsetI_staph_LUR3)[models[[4]]$indexbestmodel], names(VGOB1_subsetI_staph_LUR3)[models[[5]]$indexbestmodel])

#  this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetI_staph_LUR3$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetI_staph_LUR3[,models[[1]]$indexbestmodel]+VGOB1_subsetI_staph_LUR3[,models[[2]]$indexbestmodel]+VGOB1_subsetI_staph_LUR3[,models[[3]]$indexbestmodel]+ VGOB1_subsetI_staph_LUR3[,models[[4]]$indexbestmodel]+ VGOB1_subsetI_staph_LUR3[,models[[5]]$indexbestmodel]) 
models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[5]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[5]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel
models[[5]]$R2bestmodel

# 6 #  
# add sixth variable (the only difference of the above part is that now model n=6 the model statement more variables)
#  and the call for the list of variable names in the model changed slightly

modeln<-6

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_3 :nlastvar_LUR_3){
  if (is.numeric(VGOB1_subsetI_staph_LUR3[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetI_staph_LUR3$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetI_staph_LUR3[,models[[1]]$indexbestmodel]+VGOB1_subsetI_staph_LUR3[,models[[2]]$indexbestmodel]+VGOB1_subsetI_staph_LUR3[,models[[3]]$indexbestmodel]+VGOB1_subsetI_staph_LUR3[,models[[4]]$indexbestmodel]+VGOB1_subsetI_staph_LUR3[,models[[5]]$indexbestmodel]+ VGOB1_subsetI_staph_LUR3[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # All[,i] is the row that's being tried out now. the name of that row can be found in  names(All)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetI_staph_LUR3)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

# this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetI_staph_LUR3)[models[[1]]$indexbestmodel], names(VGOB1_subsetI_staph_LUR3)[models[[2]]$indexbestmodel] , names(VGOB1_subsetI_staph_LUR3)[models[[3]]$indexbestmodel], names(VGOB1_subsetI_staph_LUR3)[models[[4]]$indexbestmodel], names(VGOB1_subsetI_staph_LUR3)[models[[5]]$indexbestmodel], names(VGOB1_subsetI_staph_LUR3)[models[[6]]$indexbestmodel])

#  this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetI_staph_LUR3$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetI_staph_LUR3[,models[[1]]$indexbestmodel]+VGOB1_subsetI_staph_LUR3[,models[[2]]$indexbestmodel]+VGOB1_subsetI_staph_LUR3[,models[[3]]$indexbestmodel]+ VGOB1_subsetI_staph_LUR3[,models[[4]]$indexbestmodel]+ VGOB1_subsetI_staph_LUR3[,models[[5]]$indexbestmodel]+ VGOB1_subsetI_staph_LUR3[,models[[6]]$indexbestmodel]) 

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[5]]$summarybestmodel
models[[6]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[5]]$namesbestmodel
models[[6]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel
models[[5]]$R2bestmodel
models[[6]]$R2bestmodel


# 7 #  
# add seventh variable (the only difference of the above part is that now model n=7 the model statement more variables)
#  and the call for the list of variable names in the model changed slightly

modeln<-7

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_3 :nlastvar_LUR_3){
  if (is.numeric(VGOB1_subsetI_staph_LUR3[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetI_staph_LUR3$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetI_staph_LUR3[,models[[1]]$indexbestmodel]+VGOB1_subsetI_staph_LUR3[,models[[2]]$indexbestmodel]+VGOB1_subsetI_staph_LUR3[,models[[3]]$indexbestmodel]+VGOB1_subsetI_staph_LUR3[,models[[4]]$indexbestmodel]+VGOB1_subsetI_staph_LUR3[,models[[5]]$indexbestmodel]+VGOB1_subsetI_staph_LUR3[,models[[6]]$indexbestmodel]+ VGOB1_subsetI_staph_LUR3[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # Measurements_livestockpreds_LUR3[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR3)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetI_staph_LUR3)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

# this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetI_staph_LUR3)[models[[1]]$indexbestmodel], names(VGOB1_subsetI_staph_LUR3)[models[[2]]$indexbestmodel] , names(VGOB1_subsetI_staph_LUR3)[models[[3]]$indexbestmodel], names(VGOB1_subsetI_staph_LUR3)[models[[4]]$indexbestmodel], names(VGOB1_subsetI_staph_LUR3)[models[[5]]$indexbestmodel], names(VGOB1_subsetI_staph_LUR3)[models[[6]]$indexbestmodel], names(VGOB1_subsetI_staph_LUR3)[models[[7]]$indexbestmodel])

#  this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetI_staph_LUR3$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetI_staph_LUR3[,models[[1]]$indexbestmodel]+VGOB1_subsetI_staph_LUR3[,models[[2]]$indexbestmodel]+VGOB1_subsetI_staph_LUR3[,models[[3]]$indexbestmodel]+ VGOB1_subsetI_staph_LUR3[,models[[4]]$indexbestmodel]+ VGOB1_subsetI_staph_LUR3[,models[[5]]$indexbestmodel]+ VGOB1_subsetI_staph_LUR3[,models[[6]]$indexbestmodel]+ VGOB1_subsetI_staph_LUR3[,models[[7]]$indexbestmodel]) 

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[5]]$summarybestmodel
models[[6]]$summarybestmodel
models[[7]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[5]]$namesbestmodel
models[[6]]$namesbestmodel
models[[7]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel
models[[5]]$R2bestmodel
models[[6]]$R2bestmodel
models[[7]]$R2bestmodel

# 8 #  
# add eighth variable (the only difference of the above part is that now modeln=7 the model statement more variables)
# and the call for the list of variable names in the model changed slightly

modeln<-8

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_3 :nlastvar_LUR_3){
  if (is.numeric(VGOB1_subsetI_staph_LUR3[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetI_staph_LUR3$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetI_staph_LUR3[,models[[1]]$indexbestmodel]+VGOB1_subsetI_staph_LUR3[,models[[2]]$indexbestmodel]+VGOB1_subsetI_staph_LUR3[,models[[3]]$indexbestmodel]+VGOB1_subsetI_staph_LUR3[,models[[4]]$indexbestmodel]+VGOB1_subsetI_staph_LUR3[,models[[5]]$indexbestmodel]+VGOB1_subsetI_staph_LUR3[,models[[6]]$indexbestmodel]+ VGOB1_subsetI_staph_LUR3[,models[[7]]$indexbestmodel]+ VGOB1_subsetI_staph_LUR3[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # Measurements_livestockpreds_LUR3[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR3)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetI_staph_LUR3)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

# this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetI_staph_LUR3)[models[[1]]$indexbestmodel], names(VGOB1_subsetI_staph_LUR3)[models[[2]]$indexbestmodel] , names(VGOB1_subsetI_staph_LUR3)[models[[3]]$indexbestmodel], names(VGOB1_subsetI_staph_LUR3)[models[[4]]$indexbestmodel], names(VGOB1_subsetI_staph_LUR3)[models[[5]]$indexbestmodel], names(VGOB1_subsetI_staph_LUR3)[models[[6]]$indexbestmodel], names(VGOB1_subsetI_staph_LUR3)[models[[7]]$indexbestmodel], names(VGOB1_subsetI_staph_LUR3)[models[[8]]$indexbestmodel])

#  this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetI_staph_LUR3$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetI_staph_LUR3[,models[[1]]$indexbestmodel]+VGOB1_subsetI_staph_LUR3[,models[[2]]$indexbestmodel]+VGOB1_subsetI_staph_LUR3[,models[[3]]$indexbestmodel]+ VGOB1_subsetI_staph_LUR3[,models[[4]]$indexbestmodel]+ VGOB1_subsetI_staph_LUR3[,models[[5]]$indexbestmodel]+ VGOB1_subsetI_staph_LUR3[,models[[6]]$indexbestmodel]+ VGOB1_subsetI_staph_LUR3[,models[[7]]$indexbestmodel]+ VGOB1_subsetI_staph_LUR3[,models[[8]]$indexbestmodel]) 

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[5]]$summarybestmodel
models[[6]]$summarybestmodel
models[[7]]$summarybestmodel
models[[8]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[5]]$namesbestmodel
models[[6]]$namesbestmodel
models[[7]]$namesbestmodel
models[[8]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel
models[[5]]$R2bestmodel
models[[6]]$R2bestmodel
models[[7]]$R2bestmodel
models[[8]]$R2bestmodel

# 9 #  
# add ninth variable (the only difference of the above part is that now modeln=9 the model statement more variables)
# and the call for the list of variable names in the model changed slightly

modeln<-9

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_3 :nlastvar_LUR_3){
  if (is.numeric(VGOB1_subsetI_staph_LUR3[,i])==TRUE){
      modeltry<-lm(VGOB1_subsetI_staph_LUR3$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetI_staph_LUR3[,models[[1]]$indexbestmodel]+VGOB1_subsetI_staph_LUR3[,models[[2]]$indexbestmodel]+VGOB1_subsetI_staph_LUR3[,models[[3]]$indexbestmodel]+VGOB1_subsetI_staph_LUR3[,models[[4]]$indexbestmodel]+VGOB1_subsetI_staph_LUR3[,models[[5]]$indexbestmodel]+VGOB1_subsetI_staph_LUR3[,models[[6]]$indexbestmodel]+ VGOB1_subsetI_staph_LUR3[,models[[7]]$indexbestmodel]+ VGOB1_subsetI_staph_LUR3[,models[[8]]$indexbestmodel]+ VGOB1_subsetI_staph_LUR3[,i]) 
        R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # Measurements_livestockpreds_LUR3[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR3)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetI_staph_LUR3)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

# this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetI_staph_LUR3)[models[[1]]$indexbestmodel], names(VGOB1_subsetI_staph_LUR3)[models[[2]]$indexbestmodel] , names(VGOB1_subsetI_staph_LUR3)[models[[3]]$indexbestmodel], names(VGOB1_subsetI_staph_LUR3)[models[[4]]$indexbestmodel], names(VGOB1_subsetI_staph_LUR3)[models[[5]]$indexbestmodel], names(VGOB1_subsetI_staph_LUR3)[models[[6]]$indexbestmodel], names(VGOB1_subsetI_staph_LUR3)[models[[7]]$indexbestmodel], names(VGOB1_subsetI_staph_LUR3)[models[[8]]$indexbestmodel],  names(VGOB1_subsetI_staph_LUR3)[models[[9]]$indexbestmodel])

#  this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetI_staph_LUR3$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetI_staph_LUR3[,models[[1]]$indexbestmodel]+VGOB1_subsetI_staph_LUR3[,models[[2]]$indexbestmodel]+VGOB1_subsetI_staph_LUR3[,models[[3]]$indexbestmodel]+ VGOB1_subsetI_staph_LUR3[,models[[4]]$indexbestmodel]+ VGOB1_subsetI_staph_LUR3[,models[[5]]$indexbestmodel]+ VGOB1_subsetI_staph_LUR3[,models[[6]]$indexbestmodel]+ VGOB1_subsetI_staph_LUR3[,models[[7]]$indexbestmodel]+ VGOB1_subsetI_staph_LUR3[,models[[8]]$indexbestmodel]+ VGOB1_subsetI_staph_LUR3[,models[[9]]$indexbestmodel]) 

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[5]]$summarybestmodel
models[[6]]$summarybestmodel
models[[7]]$summarybestmodel
models[[8]]$summarybestmodel
models[[9]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[5]]$namesbestmodel
models[[6]]$namesbestmodel
models[[7]]$namesbestmodel
models[[8]]$namesbestmodel
models[[9]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel
models[[5]]$R2bestmodel
models[[6]]$R2bestmodel
models[[7]]$R2bestmodel
models[[8]]$R2bestmodel
models[[9]]$R2bestmodel

# 10 #  
#  add tenth variable (the only difference of the above part is that now model n=10 the model statement more variables)
#  and the call for the list of variable names in the model changed slightly

modeln<-10

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_3 :nlastvar_LUR_3){if (is.numeric(VGOB1_subsetI_staph_LUR3[,i])==TRUE){ modeltry<-lm(VGOB1_subsetI_staph_LUR3$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetI_staph_LUR3[,models[[1]]$indexbestmodel]+VGOB1_subsetI_staph_LUR3[,models[[2]]$indexbestmodel]+ VGOB1_subsetI_staph_LUR3[,models[[3]]$indexbestmodel]+VGOB1_subsetI_staph_LUR3[,models[[4]]$indexbestmodel]+ VGOB1_subsetI_staph_LUR3[,models[[5]]$indexbestmodel]+ VGOB1_subsetI_staph_LUR3[,models[[6]]$indexbestmodel]+ VGOB1_subsetI_staph_LUR3[,models[[7]]$indexbestmodel]+ VGOB1_subsetI_staph_LUR3[,models[[8]]$indexbestmodel]+ VGOB1_subsetI_staph_LUR3[,models[[9]]$indexbestmodel]+ VGOB1_subsetI_staph_LUR3[,i]) 

R2<-rbind(R2,summary(modeltry)$adj.r.squared)
# the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # Measurements_livestockpreds_LUR3[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR3)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetI_staph_LUR3)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

# this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

# here are the names
models[[modeln]]$namesbestmodel<-c( names(VGOB1_subsetI_staph_LUR3)[models[[1]]$indexbestmodel],                   names(VGOB1_subsetI_staph_LUR3)[models[[2]]$indexbestmodel] , names(VGOB1_subsetI_staph_LUR3)[models[[3]]$indexbestmodel], names(VGOB1_subsetI_staph_LUR3)[models[[4]]$indexbestmodel], names(VGOB1_subsetI_staph_LUR3)[models[[5]]$indexbestmodel], names(VGOB1_subsetI_staph_LUR3)[models[[6]]$indexbestmodel], names(VGOB1_subsetI_staph_LUR3)[models[[7]]$indexbestmodel], names(VGOB1_subsetI_staph_LUR3)[models[[8]]$indexbestmodel], names(VGOB1_subsetI_staph_LUR3)[models[[9]]$indexbestmodel], names(VGOB1_subsetI_staph_LUR3)[models[[10]]$indexbestmodel])

#  this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetI_staph_LUR3$staph_copiespm3.ln.diffmeth.mean~                                VGOB1_subsetI_staph_LUR3[,models[[1]]$indexbestmodel]+ VGOB1_subsetI_staph_LUR3[,models[[2]]$indexbestmodel]+                           VGOB1_subsetI_staph_LUR3[,models[[3]]$indexbestmodel]+ VGOB1_subsetI_staph_LUR3[,models[[4]]$indexbestmodel]+ VGOB1_subsetI_staph_LUR3[,models[[5]]$indexbestmodel]+ VGOB1_subsetI_staph_LUR3[,models[[6]]$indexbestmodel]+ VGOB1_subsetI_staph_LUR3[,models[[7]]$indexbestmodel]+ VGOB1_subsetI_staph_LUR3[,models[[8]]$indexbestmodel]+ VGOB1_subsetI_staph_LUR3[,models[[9]]$indexbestmodel]+ VGOB1_subsetI_staph_LUR3[,models[[10]]$indexbestmodel]) 

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[5]]$summarybestmodel
models[[6]]$summarybestmodel
models[[7]]$summarybestmodel
models[[8]]$summarybestmodel
models[[9]]$summarybestmodel
models[[10]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[5]]$namesbestmodel
models[[6]]$namesbestmodel
models[[7]]$namesbestmodel
models[[8]]$namesbestmodel
models[[9]]$namesbestmodel
models[[10]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel
models[[5]]$R2bestmodel
models[[6]]$R2bestmodel
models[[7]]$R2bestmodel
models[[8]]$R2bestmodel
models[[9]]$R2bestmodel
models[[10]]$R2bestmodel

#  at this point I always check whether the next model is more than 1% better than the one before and if not I end here

#   CODE FOR PICKING OUT THE BEST MODEL #   
temp <- 0
besti <- 0
for (i in 1:10){ #  think this runs the loop 10 times - not fully sure thought - but not to do with the number of models I don't think - as when I change to 3, I still get the model with 4 variables as best model
  print(models[[i]]$R2bestmodel)
  #       print(models[[i]]$summarybestmodel$coefficients=-1,4])
  #       if((models[[i]]$R2bestmodel-temp > 0.0) && (all(models[[i]]$summarybestmodel$coefficients[-1,4]<0.1))){
  #         temp <- models[[i]]$R2bestmodel
  #         besti <- i
  #         }
  if((models[[i]]$R2bestmodel-temp > 0.0) && (all(models[[i]]$summarybestmodel$coefficients[-1,4]<0.1))){
    temp <- models[[i]]$R2bestmodel
    besti <- i
  }else{
    finalBestModel_staph_LUR3_subsetI <- models[[besti]]$bestmodel
    finalBestModelNames_staph_subsetI <- models[[besti]]$namesbestmodel
    Sites <- 1:dim(VGOB1_subsetI_staph_LUR3)[1] # full original model
    #  CVaR2<-escCV_staph_LUR3(Sites)[2] # Cross Validation
    maxCD<-max(cooks.distance(finalBestModel_staph_LUR3_subsetI))
    if(length(finalBestModelNames_staph_subsetI)<2){ # vif fn doesnot work when only 1 variable...       # 
      maxVIF<-"NA"
    }else{
      maxVIF<-max(vif(finalBestModel_staph_LUR3_subsetI))
    }
    print(paste("This is the best staph model for subset I: ",besti,
                "(AdjR2: ",format(models[[besti]]$R2bestmodel,digits=3), "; MaxCD: ",format(maxCD,digits=3),"; MaxVIF: ",
                format(maxVIF,digits=3),")", sep=''))
    print(finalBestModelNames_staph_subsetI)
    break
  }
}

#  Overview of the final best model using the algorithm selection process (taking into account VIF, R^2, and p-values)
finalBestModel_staph_LUR3_subsetI
finalBestModelNames_staph_subsetI
models[[besti]]$summarybestmodel
models[[besti]]$R2bestmodel

#### J ####
# LUR model building process for subset J
#  This is the dataframe with the relevant predictor vars for LUR3 models for subset J (55 sites)
VGOB1_subsetJ_staph_LUR3 # n.b. this dataframe only includes microbial marker concentrations for staph unlike the dataframe Measurements_livestockpreds_LUR3 as previously used for the model building. 

#  Now set the values of some variables that will be needed
nfirstvar_LUR_3 <- 3  
nlastvar_LUR_3 <- 135

# Function building to run the models 
# 1 #  

models<-list()
modeln<-1
models[[modeln]]<-list()

R2<-1
betaaddedvar<-1
addedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_3:nlastvar_LUR_3){
  if (is.numeric(VGOB1_subsetJ_staph_LUR3[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetJ_staph_LUR3$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetJ_staph_LUR3[,i])                            
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    #  Measurements_livestockpreds_LUR3[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR3)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetJ_staph_LUR3)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)
models[[modeln]]$results

#  this are the candidates models with the highest R2, not a negative beta for the new, nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)
models[[modeln]]$resultspos

#  rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))
models[[modeln]]$resultspos

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j
models[[modeln]]$indexbestmodel

subset(models[[modeln]]$resultspos, rank==1)
subset(models[[modeln]]$resultspos)

#  this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]
models[[modeln]]$summarybestmodel

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetJ_staph_LUR3)[models[[1]]$indexbestmodel])
models[[modeln]]$namesbestmodel

#  this is the r2 of that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2
models[[modeln]]$R2bestmodel

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetJ_staph_LUR3$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetJ_staph_LUR3[,models[[1]]$indexbestmodel]) 
models[[modeln]]$bestmodel

summary(models[[modeln]]$bestmodel)

#  The first model includes the predictor: nPigMultipFarmWghtDist.3000m.sum.Tr.1P9 - meaning the number of multiplier pig farms weighted to distance in a 3000m buffer

# 2 #  
# Add 2nd variable (the only difference of the above part is that now modeln=2 the model statement has 2 variables)
# and the call for the list of variable names in the model changed slightly

modeln<-2

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_3:nlastvar_LUR_3){
  if (is.numeric(VGOB1_subsetJ_staph_LUR3[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetJ_staph_LUR3$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetJ_staph_LUR3[,models[[1]]$indexbestmodel]+ VGOB1_subsetJ_staph_LUR3[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # Measurements_livestockpreds_LUR3[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR3)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetJ_staph_LUR3)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  these are the candidate models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)
models[[modeln]]$resultspos

#  rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))
models[[modeln]]$resultspos

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j
models[[modeln]]$indexbestmodel

subset(models[[modeln]]$resultspos, rank==1)

# this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]
models[[modeln]]$summarybestmodel

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetJ_staph_LUR3)[models[[1]]$indexbestmodel], names(VGOB1_subsetJ_staph_LUR3)[models[[2]]$indexbestmodel] )
models[[modeln]]$namesbestmodel

# this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2
models[[modeln]]$R2bestmodel

# this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetJ_staph_LUR3$staph_copiespm3.ln.diffmeth.mean~                               VGOB1_subsetJ_staph_LUR3[,models[[1]]$indexbestmodel]+                           VGOB1_subsetJ_staph_LUR3[,models[[2]]$indexbestmodel]) 

models[[modeln]]$bestmodel

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel


# 3 #  
# add third variable (the only difference of the above part is that now modeln=3 the model statement has 3 variables)
# and the call for the list of variable names in the model changed slightly

modeln<-3

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_3:nlastvar_LUR_3){
  if (is.numeric(VGOB1_subsetJ_staph_LUR3[,i])==TRUE){  
    modeltry<-lm(VGOB1_subsetJ_staph_LUR3$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetJ_staph_LUR3[,models[[1]]$indexbestmodel]+VGOB1_subsetJ_staph_LUR3[,models[[2]]$indexbestmodel]+ VGOB1_subsetJ_staph_LUR3[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # All[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR3)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetJ_staph_LUR3)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

#  rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

#  this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

#  here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetJ_staph_LUR3)[models[[1]]$indexbestmodel], names(VGOB1_subsetJ_staph_LUR3)[models[[2]]$indexbestmodel], names(VGOB1_subsetJ_staph_LUR3)[models[[3]]$indexbestmodel])

#  this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetJ_staph_LUR3$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetJ_staph_LUR3[,models[[1]]$indexbestmodel]+ VGOB1_subsetJ_staph_LUR3[,models[[2]]$indexbestmodel]+ VGOB1_subsetJ_staph_LUR3[,models[[3]]$indexbestmodel]) 

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel


# 4 #  
#  add forth variable (the only difference of the above part is that now model n=4 the model statement more variables)
#  and the call for the list of variable names in the model changed slightly
modeln<-4

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1


for (i in nfirstvar_LUR_3:nlastvar_LUR_3){
  if (is.numeric(VGOB1_subsetJ_staph_LUR3[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetJ_staph_LUR3$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetJ_staph_LUR3[,models[[1]]$indexbestmodel]+VGOB1_subsetJ_staph_LUR3[,models[[2]]$indexbestmodel]+VGOB1_subsetJ_staph_LUR3[,models[[3]]$indexbestmodel]+VGOB1_subsetJ_staph_LUR3[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    #  the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    #  All[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR3)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetJ_staph_LUR3)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

#  this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

#  here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetJ_staph_LUR3)[models[[1]]$indexbestmodel], names(VGOB1_subsetJ_staph_LUR3)[models[[2]]$indexbestmodel], names(VGOB1_subsetJ_staph_LUR3)[models[[3]]$indexbestmodel], names(VGOB1_subsetJ_staph_LUR3)[models[[4]]$indexbestmodel])

#  this is the r2 of that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetJ_staph_LUR3$staph_copiespm3.ln.diffmeth.mean~ VGOB1_subsetJ_staph_LUR3[,models[[1]]$indexbestmodel]+ VGOB1_subsetJ_staph_LUR3[,models[[2]]$indexbestmodel]+VGOB1_subsetJ_staph_LUR3[,models[[3]]$indexbestmodel]+ VGOB1_subsetJ_staph_LUR3[,models[[4]]$indexbestmodel]) 


models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel


# 5 #  
# add fifth variable (the only difference of the above part is that now modeln=5 the model statement more variables)
# and the call for the list of variable names in the model changed slightly
modeln<-5

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_3:nlastvar_LUR_3){
  if (is.numeric(VGOB1_subsetJ_staph_LUR3[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetJ_staph_LUR3$staph_copiespm3.ln.diffmeth.mean~ VGOB1_subsetJ_staph_LUR3[,models[[1]]$indexbestmodel]+ VGOB1_subsetJ_staph_LUR3[,models[[2]]$indexbestmodel]+ VGOB1_subsetJ_staph_LUR3[,models[[3]]$indexbestmodel]+ VGOB1_subsetJ_staph_LUR3[,models[[4]]$indexbestmodel]+ VGOB1_subsetJ_staph_LUR3[,i]) 
  
R2<-rbind(R2,summary(modeltry)$adj.r.squared)
# the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # All[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR3)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetJ_staph_LUR3)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

#  this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetJ_staph_LUR3)[models[[1]]$indexbestmodel], names(VGOB1_subsetJ_staph_LUR3)[models[[2]]$indexbestmodel], names(VGOB1_subsetJ_staph_LUR3)[models[[3]]$indexbestmodel], names(VGOB1_subsetJ_staph_LUR3)[models[[4]]$indexbestmodel], names(VGOB1_subsetJ_staph_LUR3)[models[[5]]$indexbestmodel])

#  this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetJ_staph_LUR3$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetJ_staph_LUR3[,models[[1]]$indexbestmodel]+VGOB1_subsetJ_staph_LUR3[,models[[2]]$indexbestmodel]+VGOB1_subsetJ_staph_LUR3[,models[[3]]$indexbestmodel]+ VGOB1_subsetJ_staph_LUR3[,models[[4]]$indexbestmodel]+ VGOB1_subsetJ_staph_LUR3[,models[[5]]$indexbestmodel]) 
models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[5]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[5]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel
models[[5]]$R2bestmodel

# 6 #  
# add sixth variable (the only difference of the above part is that now model n=6 the model statement more variables)
#  and the call for the list of variable names in the model changed slightly

modeln<-6

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_3 :nlastvar_LUR_3){
  if (is.numeric(VGOB1_subsetJ_staph_LUR3[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetJ_staph_LUR3$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetJ_staph_LUR3[,models[[1]]$indexbestmodel]+VGOB1_subsetJ_staph_LUR3[,models[[2]]$indexbestmodel]+VGOB1_subsetJ_staph_LUR3[,models[[3]]$indexbestmodel]+VGOB1_subsetJ_staph_LUR3[,models[[4]]$indexbestmodel]+VGOB1_subsetJ_staph_LUR3[,models[[5]]$indexbestmodel]+ VGOB1_subsetJ_staph_LUR3[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # All[,i] is the row that's being tried out now. the name of that row can be found in  names(All)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetJ_staph_LUR3)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

# this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetJ_staph_LUR3)[models[[1]]$indexbestmodel], names(VGOB1_subsetJ_staph_LUR3)[models[[2]]$indexbestmodel] , names(VGOB1_subsetJ_staph_LUR3)[models[[3]]$indexbestmodel], names(VGOB1_subsetJ_staph_LUR3)[models[[4]]$indexbestmodel], names(VGOB1_subsetJ_staph_LUR3)[models[[5]]$indexbestmodel], names(VGOB1_subsetJ_staph_LUR3)[models[[6]]$indexbestmodel])

#  this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetJ_staph_LUR3$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetJ_staph_LUR3[,models[[1]]$indexbestmodel]+VGOB1_subsetJ_staph_LUR3[,models[[2]]$indexbestmodel]+VGOB1_subsetJ_staph_LUR3[,models[[3]]$indexbestmodel]+ VGOB1_subsetJ_staph_LUR3[,models[[4]]$indexbestmodel]+ VGOB1_subsetJ_staph_LUR3[,models[[5]]$indexbestmodel]+ VGOB1_subsetJ_staph_LUR3[,models[[6]]$indexbestmodel]) 

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[5]]$summarybestmodel
models[[6]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[5]]$namesbestmodel
models[[6]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel
models[[5]]$R2bestmodel
models[[6]]$R2bestmodel


# 7 #  
# add seventh variable (the only difference of the above part is that now model n=7 the model statement more variables)
#  and the call for the list of variable names in the model changed slightly

modeln<-7

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_3 :nlastvar_LUR_3){
  if (is.numeric(VGOB1_subsetJ_staph_LUR3[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetJ_staph_LUR3$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetJ_staph_LUR3[,models[[1]]$indexbestmodel]+VGOB1_subsetJ_staph_LUR3[,models[[2]]$indexbestmodel]+VGOB1_subsetJ_staph_LUR3[,models[[3]]$indexbestmodel]+VGOB1_subsetJ_staph_LUR3[,models[[4]]$indexbestmodel]+VGOB1_subsetJ_staph_LUR3[,models[[5]]$indexbestmodel]+VGOB1_subsetJ_staph_LUR3[,models[[6]]$indexbestmodel]+ VGOB1_subsetJ_staph_LUR3[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # Measurements_livestockpreds_LUR3[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR3)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetJ_staph_LUR3)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

# this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetJ_staph_LUR3)[models[[1]]$indexbestmodel], names(VGOB1_subsetJ_staph_LUR3)[models[[2]]$indexbestmodel] , names(VGOB1_subsetJ_staph_LUR3)[models[[3]]$indexbestmodel], names(VGOB1_subsetJ_staph_LUR3)[models[[4]]$indexbestmodel], names(VGOB1_subsetJ_staph_LUR3)[models[[5]]$indexbestmodel], names(VGOB1_subsetJ_staph_LUR3)[models[[6]]$indexbestmodel], names(VGOB1_subsetJ_staph_LUR3)[models[[7]]$indexbestmodel])

#  this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetJ_staph_LUR3$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetJ_staph_LUR3[,models[[1]]$indexbestmodel]+VGOB1_subsetJ_staph_LUR3[,models[[2]]$indexbestmodel]+VGOB1_subsetJ_staph_LUR3[,models[[3]]$indexbestmodel]+ VGOB1_subsetJ_staph_LUR3[,models[[4]]$indexbestmodel]+ VGOB1_subsetJ_staph_LUR3[,models[[5]]$indexbestmodel]+ VGOB1_subsetJ_staph_LUR3[,models[[6]]$indexbestmodel]+ VGOB1_subsetJ_staph_LUR3[,models[[7]]$indexbestmodel]) 

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[5]]$summarybestmodel
models[[6]]$summarybestmodel
models[[7]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[5]]$namesbestmodel
models[[6]]$namesbestmodel
models[[7]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel
models[[5]]$R2bestmodel
models[[6]]$R2bestmodel
models[[7]]$R2bestmodel

# 8 #  
# add eighth variable (the only difference of the above part is that now modeln=7 the model statement more variables)
# and the call for the list of variable names in the model changed slightly

modeln<-8

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_3 :nlastvar_LUR_3){
  if (is.numeric(VGOB1_subsetJ_staph_LUR3[,i])==TRUE){
    modeltry<-lm(VGOB1_subsetJ_staph_LUR3$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetJ_staph_LUR3[,models[[1]]$indexbestmodel]+VGOB1_subsetJ_staph_LUR3[,models[[2]]$indexbestmodel]+VGOB1_subsetJ_staph_LUR3[,models[[3]]$indexbestmodel]+VGOB1_subsetJ_staph_LUR3[,models[[4]]$indexbestmodel]+VGOB1_subsetJ_staph_LUR3[,models[[5]]$indexbestmodel]+VGOB1_subsetJ_staph_LUR3[,models[[6]]$indexbestmodel]+ VGOB1_subsetJ_staph_LUR3[,models[[7]]$indexbestmodel]+ VGOB1_subsetJ_staph_LUR3[,i]) 
    R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # Measurements_livestockpreds_LUR3[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR3)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetJ_staph_LUR3)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

# this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetJ_staph_LUR3)[models[[1]]$indexbestmodel], names(VGOB1_subsetJ_staph_LUR3)[models[[2]]$indexbestmodel] , names(VGOB1_subsetJ_staph_LUR3)[models[[3]]$indexbestmodel], names(VGOB1_subsetJ_staph_LUR3)[models[[4]]$indexbestmodel], names(VGOB1_subsetJ_staph_LUR3)[models[[5]]$indexbestmodel], names(VGOB1_subsetJ_staph_LUR3)[models[[6]]$indexbestmodel], names(VGOB1_subsetJ_staph_LUR3)[models[[7]]$indexbestmodel], names(VGOB1_subsetJ_staph_LUR3)[models[[8]]$indexbestmodel])

#  this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetJ_staph_LUR3$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetJ_staph_LUR3[,models[[1]]$indexbestmodel]+VGOB1_subsetJ_staph_LUR3[,models[[2]]$indexbestmodel]+VGOB1_subsetJ_staph_LUR3[,models[[3]]$indexbestmodel]+ VGOB1_subsetJ_staph_LUR3[,models[[4]]$indexbestmodel]+ VGOB1_subsetJ_staph_LUR3[,models[[5]]$indexbestmodel]+ VGOB1_subsetJ_staph_LUR3[,models[[6]]$indexbestmodel]+ VGOB1_subsetJ_staph_LUR3[,models[[7]]$indexbestmodel]+ VGOB1_subsetJ_staph_LUR3[,models[[8]]$indexbestmodel]) 

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[5]]$summarybestmodel
models[[6]]$summarybestmodel
models[[7]]$summarybestmodel
models[[8]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[5]]$namesbestmodel
models[[6]]$namesbestmodel
models[[7]]$namesbestmodel
models[[8]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel
models[[5]]$R2bestmodel
models[[6]]$R2bestmodel
models[[7]]$R2bestmodel
models[[8]]$R2bestmodel

# 9 #  
# add ninth variable (the only difference of the above part is that now modeln=9 the model statement more variables)
# and the call for the list of variable names in the model changed slightly

modeln<-9

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_3 :nlastvar_LUR_3){
  if (is.numeric(VGOB1_subsetJ_staph_LUR3[,i])==TRUE){
      modeltry<-lm(VGOB1_subsetJ_staph_LUR3$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetJ_staph_LUR3[,models[[1]]$indexbestmodel]+VGOB1_subsetJ_staph_LUR3[,models[[2]]$indexbestmodel]+VGOB1_subsetJ_staph_LUR3[,models[[3]]$indexbestmodel]+VGOB1_subsetJ_staph_LUR3[,models[[4]]$indexbestmodel]+VGOB1_subsetJ_staph_LUR3[,models[[5]]$indexbestmodel]+VGOB1_subsetJ_staph_LUR3[,models[[6]]$indexbestmodel]+ VGOB1_subsetJ_staph_LUR3[,models[[7]]$indexbestmodel]+ VGOB1_subsetJ_staph_LUR3[,models[[8]]$indexbestmodel]+ VGOB1_subsetJ_staph_LUR3[,i]) 
        R2<-rbind(R2,summary(modeltry)$adj.r.squared)
    # the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # Measurements_livestockpreds_LUR3[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR3)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetJ_staph_LUR3)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

# this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

# here are the names
models[[modeln]]$namesbestmodel<-c(names(VGOB1_subsetJ_staph_LUR3)[models[[1]]$indexbestmodel], names(VGOB1_subsetJ_staph_LUR3)[models[[2]]$indexbestmodel] , names(VGOB1_subsetJ_staph_LUR3)[models[[3]]$indexbestmodel], names(VGOB1_subsetJ_staph_LUR3)[models[[4]]$indexbestmodel], names(VGOB1_subsetJ_staph_LUR3)[models[[5]]$indexbestmodel], names(VGOB1_subsetJ_staph_LUR3)[models[[6]]$indexbestmodel], names(VGOB1_subsetJ_staph_LUR3)[models[[7]]$indexbestmodel], names(VGOB1_subsetJ_staph_LUR3)[models[[8]]$indexbestmodel],  names(VGOB1_subsetJ_staph_LUR3)[models[[9]]$indexbestmodel])

#  this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetJ_staph_LUR3$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetJ_staph_LUR3[,models[[1]]$indexbestmodel]+VGOB1_subsetJ_staph_LUR3[,models[[2]]$indexbestmodel]+VGOB1_subsetJ_staph_LUR3[,models[[3]]$indexbestmodel]+ VGOB1_subsetJ_staph_LUR3[,models[[4]]$indexbestmodel]+ VGOB1_subsetJ_staph_LUR3[,models[[5]]$indexbestmodel]+ VGOB1_subsetJ_staph_LUR3[,models[[6]]$indexbestmodel]+ VGOB1_subsetJ_staph_LUR3[,models[[7]]$indexbestmodel]+ VGOB1_subsetJ_staph_LUR3[,models[[8]]$indexbestmodel]+ VGOB1_subsetJ_staph_LUR3[,models[[9]]$indexbestmodel]) 

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[5]]$summarybestmodel
models[[6]]$summarybestmodel
models[[7]]$summarybestmodel
models[[8]]$summarybestmodel
models[[9]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[5]]$namesbestmodel
models[[6]]$namesbestmodel
models[[7]]$namesbestmodel
models[[8]]$namesbestmodel
models[[9]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel
models[[5]]$R2bestmodel
models[[6]]$R2bestmodel
models[[7]]$R2bestmodel
models[[8]]$R2bestmodel
models[[9]]$R2bestmodel

# 10 #  
#  add tenth variable (the only difference of the above part is that now model n=10 the model statement more variables)
#  and the call for the list of variable names in the model changed slightly

modeln<-10

models[[modeln]]<-list()

R2<-1
addedvar<-1
betaaddedvar<-1
minbetas<-1
j<-1

for (i in nfirstvar_LUR_3 :nlastvar_LUR_3){if (is.numeric(VGOB1_subsetJ_staph_LUR3[,i])==TRUE){ modeltry<-lm(VGOB1_subsetJ_staph_LUR3$staph_copiespm3.ln.diffmeth.mean~VGOB1_subsetJ_staph_LUR3[,models[[1]]$indexbestmodel]+VGOB1_subsetJ_staph_LUR3[,models[[2]]$indexbestmodel]+ VGOB1_subsetJ_staph_LUR3[,models[[3]]$indexbestmodel]+VGOB1_subsetJ_staph_LUR3[,models[[4]]$indexbestmodel]+ VGOB1_subsetJ_staph_LUR3[,models[[5]]$indexbestmodel]+ VGOB1_subsetJ_staph_LUR3[,models[[6]]$indexbestmodel]+ VGOB1_subsetJ_staph_LUR3[,models[[7]]$indexbestmodel]+ VGOB1_subsetJ_staph_LUR3[,models[[8]]$indexbestmodel]+ VGOB1_subsetJ_staph_LUR3[,models[[9]]$indexbestmodel]+ VGOB1_subsetJ_staph_LUR3[,i]) 

R2<-rbind(R2,summary(modeltry)$adj.r.squared)
# the new covariate is supposed to be in the last row, therefore I can select the row based on the model number +1
    betaaddedvar<-rbind(betaaddedvar, modeltry$coefficients[(modeln+1)])# 
    #  find out if there is a negative beta at All. The intercept does not count [-1]!
    minbetas<-rbind(minbetas, min(modeltry$coefficients[-1]))
    # Measurements_livestockpreds_LUR3[,i] is the row that's being tried out now. the name of that row can be found in  names(Measurements_livestockpreds_LUR3)[i]
    addedvar<-rbind(addedvar,names(VGOB1_subsetJ_staph_LUR3)[i])
    j<-rbind(j, i)
    models[[modeln]][[i]]<-summary(modeltry)
  }
}

models[[modeln]]$results<-data.frame(addedvar=addedvar[-1],R2=R2[-1]*1, j=j[-1], betaaddedvar=betaaddedvar[-1]*1,minbetas=minbetas[-1]*1)

#  this are the candidates models with the highest R2, not a negative beta for the new nor for any other covariate
models[[modeln]]$resultspos<-subset(models[[modeln]]$results, minbetas>0)

# rank the R2's of these models
models[[modeln]]$resultspos<-(data.frame(models[[modeln]]$resultspos, rank=rank(-models[[modeln]]$resultspos$R2, ties.method = "first")))

#  this is the index of the row with the highest R2 and  no negative betas in this subset
models[[modeln]]$indexbestmodel<-subset(models[[modeln]]$resultspos, rank==1)$j

subset(models[[modeln]]$resultspos, rank==1)

# this is the model
models[[modeln]]$summarybestmodel<-models[[modeln]][[models[[modeln]]$indexbestmodel]]

# here are the names
models[[modeln]]$namesbestmodel<-c( names(VGOB1_subsetJ_staph_LUR3)[models[[1]]$indexbestmodel],                   names(VGOB1_subsetJ_staph_LUR3)[models[[2]]$indexbestmodel] , names(VGOB1_subsetJ_staph_LUR3)[models[[3]]$indexbestmodel], names(VGOB1_subsetJ_staph_LUR3)[models[[4]]$indexbestmodel], names(VGOB1_subsetJ_staph_LUR3)[models[[5]]$indexbestmodel], names(VGOB1_subsetJ_staph_LUR3)[models[[6]]$indexbestmodel], names(VGOB1_subsetJ_staph_LUR3)[models[[7]]$indexbestmodel], names(VGOB1_subsetJ_staph_LUR3)[models[[8]]$indexbestmodel], names(VGOB1_subsetJ_staph_LUR3)[models[[9]]$indexbestmodel], names(VGOB1_subsetJ_staph_LUR3)[models[[10]]$indexbestmodel])

#  this is the r2 or that model
models[[modeln]]$R2bestmodel<-subset(models[[modeln]]$resultspos, rank==1)$R2

#  this is the model object of the best model (can be used in Cook's D in car.infIndexPlot())
models[[modeln]]$bestmodel <- lm(VGOB1_subsetJ_staph_LUR3$staph_copiespm3.ln.diffmeth.mean~                                VGOB1_subsetJ_staph_LUR3[,models[[1]]$indexbestmodel]+ VGOB1_subsetJ_staph_LUR3[,models[[2]]$indexbestmodel]+                           VGOB1_subsetJ_staph_LUR3[,models[[3]]$indexbestmodel]+ VGOB1_subsetJ_staph_LUR3[,models[[4]]$indexbestmodel]+ VGOB1_subsetJ_staph_LUR3[,models[[5]]$indexbestmodel]+ VGOB1_subsetJ_staph_LUR3[,models[[6]]$indexbestmodel]+ VGOB1_subsetJ_staph_LUR3[,models[[7]]$indexbestmodel]+ VGOB1_subsetJ_staph_LUR3[,models[[8]]$indexbestmodel]+ VGOB1_subsetJ_staph_LUR3[,models[[9]]$indexbestmodel]+ VGOB1_subsetJ_staph_LUR3[,models[[10]]$indexbestmodel]) 

models[[1]]$summarybestmodel
models[[2]]$summarybestmodel
models[[3]]$summarybestmodel
models[[4]]$summarybestmodel
models[[5]]$summarybestmodel
models[[6]]$summarybestmodel
models[[7]]$summarybestmodel
models[[8]]$summarybestmodel
models[[9]]$summarybestmodel
models[[10]]$summarybestmodel
models[[1]]$namesbestmodel
models[[2]]$namesbestmodel
models[[3]]$namesbestmodel
models[[4]]$namesbestmodel
models[[5]]$namesbestmodel
models[[6]]$namesbestmodel
models[[7]]$namesbestmodel
models[[8]]$namesbestmodel
models[[9]]$namesbestmodel
models[[10]]$namesbestmodel
models[[1]]$R2bestmodel
models[[2]]$R2bestmodel
models[[3]]$R2bestmodel
models[[4]]$R2bestmodel
models[[5]]$R2bestmodel
models[[6]]$R2bestmodel
models[[7]]$R2bestmodel
models[[8]]$R2bestmodel
models[[9]]$R2bestmodel
models[[10]]$R2bestmodel

#  at this point I always check whether the next model is more than 1% better than the one before and if not I end here

#   CODE FOR PICKING OUT THE BEST MODEL #   
temp <- 0
besti <- 0
for (i in 1:10){ #  think this runs the loop 10 times - not fully sure thought - but not to do with the number of models I don't think - as when I change to 3, I still get the model with 4 variables as best model
  print(models[[i]]$R2bestmodel)
  #       print(models[[i]]$summarybestmodel$coefficients=-1,4])
  #       if((models[[i]]$R2bestmodel-temp > 0.0) && (all(models[[i]]$summarybestmodel$coefficients[-1,4]<0.1))){
  #         temp <- models[[i]]$R2bestmodel
  #         besti <- i
  #         }
  if((models[[i]]$R2bestmodel-temp > 0.0) && (all(models[[i]]$summarybestmodel$coefficients[-1,4]<0.1))){
    temp <- models[[i]]$R2bestmodel
    besti <- i
  }else{
    finalBestModel_staph_LUR3_subsetJ <- models[[besti]]$bestmodel
    finalBestModelNames_staph_subsetJ <- models[[besti]]$namesbestmodel
    Sites <- 1:dim(VGOB1_subsetJ_staph_LUR3)[1] # full original model
    #  CVaR2<-escCV_staph_LUR3(Sites)[2] # Cross Validation
    maxCD<-max(cooks.distance(finalBestModel_staph_LUR3_subsetJ))
    if(length(finalBestModelNames_staph_subsetJ)<2){ # vif fn doesnot work when only 1 variable...       # 
      maxVIF<-"NA"
    }else{
      maxVIF<-max(vif(finalBestModel_staph_LUR3_subsetJ))
    }
    print(paste("This is the best staph model for subset J: ",besti,
                "(AdjR2: ",format(models[[besti]]$R2bestmodel,digits=3), "; MaxCD: ",format(maxCD,digits=3),"; MaxVIF: ",
                format(maxVIF,digits=3),")", sep=''))
    print(finalBestModelNames_staph_subsetJ)
    break
  }
}

#  Overview of the final best model using the algorithm selection process (taking into account VIF, R^2, and p-values)
finalBestModel_staph_LUR3_subsetJ
finalBestModelNames_staph_subsetJ
models[[besti]]$summarybestmodel
models[[besti]]$R2bestmodel

#### Predicting hold out sites ####
# These are the models from the 10 subsets: 
finalBestModel_staph_LUR3_subsetA
finalBestModel_staph_LUR3_subsetB
finalBestModel_staph_LUR3_subsetC
finalBestModel_staph_LUR3_subsetD
finalBestModel_staph_LUR3_subsetE
finalBestModel_staph_LUR3_subsetF
finalBestModel_staph_LUR3_subsetG
finalBestModel_staph_LUR3_subsetH
finalBestModel_staph_LUR3_subsetI
finalBestModel_staph_LUR3_subsetJ

#  Selecting of test sets
#  valID 1 to 10
VGOB1_subsetvalID1_staph_LUR3 <- subset(VGOB1_FINAL_staph_LUR3, valID == 1)
VGOB1_subsetvalID2_staph_LUR3 <- subset(VGOB1_FINAL_staph_LUR3, valID == 2)
VGOB1_subsetvalID3_staph_LUR3 <- subset(VGOB1_FINAL_staph_LUR3, valID == 3)
VGOB1_subsetvalID4_staph_LUR3 <- subset(VGOB1_FINAL_staph_LUR3, valID == 4)
VGOB1_subsetvalID5_staph_LUR3 <- subset(VGOB1_FINAL_staph_LUR3, valID == 5)
VGOB1_subsetvalID6_staph_LUR3 <- subset(VGOB1_FINAL_staph_LUR3, valID == 6)
VGOB1_subsetvalID7_staph_LUR3 <- subset(VGOB1_FINAL_staph_LUR3, valID == 7)
VGOB1_subsetvalID8_staph_LUR3 <- subset(VGOB1_FINAL_staph_LUR3, valID == 8)
VGOB1_subsetvalID9_staph_LUR3 <- subset(VGOB1_FINAL_staph_LUR3, valID == 9)
VGOB1_subsetvalID10_staph_LUR3 <- subset(VGOB1_FINAL_staph_LUR3, valID == 10)

#  For every subset predict (based on LUR model for that subset, so the training sites) the concentrations at the sites left out (test sites) to enable comparisons observed vs predicted 

#  Set 1
finalBestModel_staph_LUR3_subsetA
finalBestModelNames_staph_subsetA
summary(finalBestModel_staph_LUR3_subsetA)
# write the model out
finalBestModel_staph_LUR3_subsetA_lm <- lm(staph_copiespm3.ln.diffmeth.mean~ PoultryFarm.3000m.95Win.10to90scaled + nsowsWghtDist.1000m.sum.95Win.10to90scaled, data = VGOB1_subsetA_staph_LUR3)
VGOB1_subsetvalID1_staph_LUR3$staph_PRED_HV <- predict(finalBestModel_staph_LUR3_subsetA_lm,VGOB1_subsetvalID1_staph_LUR3)
summary(VGOB1_subsetvalID1_staph_LUR3$staph_PRED_HV)
plot(VGOB1_subsetvalID1_staph_LUR3$staph_PRED_HV, VGOB1_subsetvalID1_staph_LUR3$staph_copiespm3.ln.diffmeth.mean, xlab="staph predicted (HV)", ylab="staph concentration observed")
VGOB1_subsetvalID1_staph_LUR3_lm <- lm(staph_copiespm3.ln.diffmeth.mean~staph_PRED_HV, data=VGOB1_subsetvalID1_staph_LUR3 )
summary(VGOB1_subsetvalID1_staph_LUR3_lm)

#  Set 2
finalBestModel_staph_LUR3_subsetB
finalBestModelNames_staph_subsetB
summary(finalBestModel_staph_LUR3_subsetB)
# write the model out
finalBestModel_staph_LUR3_subsetB_lm <- lm(staph_copiespm3.ln.diffmeth.mean~nAnyFarmWghtDist.3000m.sum.95Win.10to90scaled+   HorseFarm.3000m.95Win.10to90scaled + notherpoultryanimWghtDist.3000m.sum.95Win.10to90scaled , data = VGOB1_subsetB_staph_LUR3)
VGOB1_subsetvalID2_staph_LUR3$staph_PRED_HV <- predict(finalBestModel_staph_LUR3_subsetB_lm,VGOB1_subsetvalID2_staph_LUR3)
summary(VGOB1_subsetvalID2_staph_LUR3$staph_PRED_HV)
plot(VGOB1_subsetvalID2_staph_LUR3$staph_PRED_HV, VGOB1_subsetvalID2_staph_LUR3$staph_copiespm3.ln.diffmeth.mean, xlab="staph predicted (HV)", ylab="staph concentration observed")
VGOB1_subsetvalID2_staph_LUR3_lm <- lm(staph_copiespm3.ln.diffmeth.mean~staph_PRED_HV, data=VGOB1_subsetvalID2_staph_LUR3)
summary(VGOB1_subsetvalID2_staph_LUR3_lm)

#  Set 3
finalBestModel_staph_LUR3_subsetC
finalBestModelNames_staph_subsetC
summary(finalBestModel_staph_LUR3_subsetC)
# write the model out
finalBestModel_staph_LUR3_subsetC_lm <- lm(staph_copiespm3.ln.diffmeth.mean~ PoultryFarm.3000m.95Win.10to90scaled+ nhorses.1000m.95Win.10to90scaled+HorseFarm.3000m.95Win.10to90scaled , data = VGOB1_subsetC_staph_LUR3)
VGOB1_subsetvalID3_staph_LUR3$staph_PRED_HV <- predict(finalBestModel_staph_LUR3_subsetC_lm,VGOB1_subsetvalID3_staph_LUR3)
summary(VGOB1_subsetvalID3_staph_LUR3$staph_PRED_HV)
plot(VGOB1_subsetvalID3_staph_LUR3$staph_PRED_HV, VGOB1_subsetvalID3_staph_LUR3$staph_copiespm3.ln.diffmeth.mean, xlab="staph predicted (HV)", ylab="staph concentration observed")
VGOB1_subsetvalID3_staph_LUR3_lm <- lm(staph_copiespm3.ln.diffmeth.mean~staph_PRED_HV, data=VGOB1_subsetvalID3_staph_LUR3 )
summary(VGOB1_subsetvalID3_staph_LUR3_lm)

#  Set 4
finalBestModel_staph_LUR3_subsetD
finalBestModelNames_staph_subsetD
summary(finalBestModel_staph_LUR3_subsetD)
# write the model out
finalBestModel_staph_LUR3_subsetD_lm <- lm(staph_copiespm3.ln.diffmeth.mean~ PoultryFarm.3000m.95Win.10to90scaled+nsowsWghtDist.1000m.sum.95Win.10to90scaled+ nhorses.1000m.95Win.10to90scaled, data = VGOB1_subsetD_staph_LUR3)
VGOB1_subsetvalID4_staph_LUR3$staph_PRED_HV <- predict(finalBestModel_staph_LUR3_subsetD_lm,VGOB1_subsetvalID4_staph_LUR3)
summary(VGOB1_subsetvalID4_staph_LUR3$staph_PRED_HV)
plot(VGOB1_subsetvalID4_staph_LUR3$staph_PRED_HV, VGOB1_subsetvalID4_staph_LUR3$staph_copiespm3.ln.diffmeth.mean, xlab="staph predicted (HV)", ylab="staph concentration observed")
VGOB1_subsetvalID4_staph_LUR3_lm <- lm(staph_copiespm3.ln.diffmeth.mean~staph_PRED_HV, data=VGOB1_subsetvalID4_staph_LUR3 )
summary(VGOB1_subsetvalID4_staph_LUR3_lm)

#  Set 5
finalBestModel_staph_LUR3_subsetE
finalBestModelNames_staph_subsetE
summary(finalBestModel_staph_LUR3_subsetE)
# write the model out
finalBestModel_staph_LUR3_subsetE_lm <- lm(staph_copiespm3.ln.diffmeth.mean~ PoultryFarm.3000m.95Win.10to90scaled+nsowsWghtDist.1000m.sum.95Win.10to90scaled+nhorsesWghtDist.3000m.sum.95Win.10to90scaled, data = VGOB1_subsetE_staph_LUR3)
VGOB1_subsetvalID5_staph_LUR3$staph_PRED_HV <- predict(finalBestModel_staph_LUR3_subsetE_lm,VGOB1_subsetvalID5_staph_LUR3)
summary(VGOB1_subsetvalID5_staph_LUR3$staph_PRED_HV)
plot(VGOB1_subsetvalID5_staph_LUR3$staph_PRED_HV, VGOB1_subsetvalID5_staph_LUR3$staph_copiespm3.ln.diffmeth.mean, xlab="staph predicted (HV)", ylab="staph concentration observed")
VGOB1_subsetvalID5_staph_LUR3_lm <- lm(staph_copiespm3.ln.diffmeth.mean~staph_PRED_HV, data=VGOB1_subsetvalID5_staph_LUR3)
summary(VGOB1_subsetvalID5_staph_LUR3_lm)

#  Set 6
finalBestModel_staph_LUR3_subsetF
finalBestModelNames_staph_subsetF
summary(finalBestModel_staph_LUR3_subsetF)
# write the model out
finalBestModel_staph_LUR3_subsetF_lm <- lm(staph_copiespm3.ln.diffmeth.mean~ PoultryFarm.3000m.95Win.10to90scaled + HorseFarm.3000m.95Win.10to90scaled + notherpoultryanimWghtDist.3000m.sum.95Win.10to90scaled, data = VGOB1_subsetF_staph_LUR3)
VGOB1_subsetvalID6_staph_LUR3$staph_PRED_HV <- predict(finalBestModel_staph_LUR3_subsetF_lm,VGOB1_subsetvalID1_staph_LUR3)
summary(VGOB1_subsetvalID6_staph_LUR3$staph_PRED_HV)
plot(VGOB1_subsetvalID6_staph_LUR3$staph_PRED_HV, VGOB1_subsetvalID6_staph_LUR3$staph_copiespm3.ln.diffmeth.mean, xlab="staph predicted (HV)", ylab="staph concentration observed")
VGOB1_subsetvalID6_staph_LUR3_lm <- lm(staph_copiespm3.ln.diffmeth.mean~staph_PRED_HV, data=VGOB1_subsetvalID6_staph_LUR3 )
summary(VGOB1_subsetvalID6_staph_LUR3_lm)

#  Set 7
finalBestModel_staph_LUR3_subsetG
finalBestModelNames_staph_subsetG
summary(finalBestModel_staph_LUR3_subsetG)
# write the model out
finalBestModel_staph_LUR3_subsetG_lm <- lm(staph_copiespm3.ln.diffmeth.mean~ nAnyFarmWghtDist.3000m.sum.95Win.10to90scaled + npoultry.3000m.95Win.10to90scaled, data = VGOB1_subsetG_staph_LUR3)
VGOB1_subsetvalID7_staph_LUR3$staph_PRED_HV <- predict(finalBestModel_staph_LUR3_subsetG_lm,VGOB1_subsetvalID7_staph_LUR3)
summary(VGOB1_subsetvalID7_staph_LUR3$staph_PRED_HV)
plot(VGOB1_subsetvalID7_staph_LUR3$staph_PRED_HV, VGOB1_subsetvalID7_staph_LUR3$staph_copiespm3.ln.diffmeth.mean, xlab="staph predicted (HV)", ylab="staph concentration observed")
VGOB1_subsetvalID7_staph_LUR3_lm <- lm(staph_copiespm3.ln.diffmeth.mean~staph_PRED_HV, data=VGOB1_subsetvalID7_staph_LUR3)
summary(VGOB1_subsetvalID7_staph_LUR3_lm)

#  Set 8
finalBestModel_staph_LUR3_subsetH
finalBestModelNames_staph_subsetH
summary(finalBestModel_staph_LUR3_subsetH)
# write the model out
finalBestModel_staph_LUR3_subsetH_lm <- lm(staph_copiespm3.ln.diffmeth.mean~ nAnyFarmWghtDist.3000m.sum.95Win.10to90scaled + HorseFarm.3000m.95Win.10to90scaled, data = VGOB1_subsetH_staph_LUR3)
VGOB1_subsetvalID8_staph_LUR3$staph_PRED_HV <- predict(finalBestModel_staph_LUR3_subsetH_lm,VGOB1_subsetvalID8_staph_LUR3)
summary(VGOB1_subsetvalID8_staph_LUR3$staph_PRED_HV)
plot(VGOB1_subsetvalID8_staph_LUR3$staph_PRED_HV, VGOB1_subsetvalID8_staph_LUR3$staph_copiespm3.ln.diffmeth.mean, xlab="staph predicted (HV)", ylab="staph concentration observed")
VGOB1_subsetvalID8_staph_LUR3_lm <- lm(staph_copiespm3.ln.diffmeth.mean~staph_PRED_HV, data=VGOB1_subsetvalID8_staph_LUR3)
summary(VGOB1_subsetvalID8_staph_LUR3_lm)

#  Set 9
finalBestModel_staph_LUR3_subsetI
finalBestModelNames_staph_subsetI
summary(finalBestModel_staph_LUR3_subsetI)
# write the model out
finalBestModel_staph_LUR3_subsetI_lm <- lm(staph_copiespm3.ln.diffmeth.mean~ PoultryFarm.3000m.95Win.10to90scaled + nboarsWghtDist.3000m.sum.95Win.10to90scaled, data = VGOB1_subsetI_staph_LUR3)
VGOB1_subsetvalID9_staph_LUR3$staph_PRED_HV <- predict(finalBestModel_staph_LUR3_subsetI_lm,VGOB1_subsetvalID9_staph_LUR3)
summary(VGOB1_subsetvalID9_staph_LUR3$staph_PRED_HV)
plot(VGOB1_subsetvalID9_staph_LUR3$staph_PRED_HV, VGOB1_subsetvalID9_staph_LUR3$staph_copiespm3.ln.diffmeth.mean, xlab="staph predicted (HV)", ylab="staph concentration observed")
VGOB1_subsetvalID9_staph_LUR3_lm <- lm(staph_copiespm3.ln.diffmeth.mean~staph_PRED_HV, data=VGOB1_subsetvalID9_staph_LUR3 )
summary(VGOB1_subsetvalID9_staph_LUR3_lm)

#  Set 10
finalBestModel_staph_LUR3_subsetJ
finalBestModelNames_staph_subsetJ
summary(finalBestModel_staph_LUR3_subsetJ)
# write the model out
finalBestModel_staph_LUR3_subsetJ_lm <- lm(staph_copiespm3.ln.diffmeth.mean~PoultryFarm.3000m.95Win.10to90scaled+ HorseFarm.3000m.95Win.10to90scaled+ nsowsWghtDist.1000m.sum.95Win.10to90scaled, data = VGOB1_subsetJ_staph_LUR3)
VGOB1_subsetvalID10_staph_LUR3$staph_PRED_HV <- predict(finalBestModel_staph_LUR3_subsetJ_lm,VGOB1_subsetvalID10_staph_LUR3)
summary(VGOB1_subsetvalID10_staph_LUR3$staph_PRED_HV)
plot(VGOB1_subsetvalID10_staph_LUR3$staph_PRED_HV, VGOB1_subsetvalID10_staph_LUR3$staph_copiespm3.ln.diffmeth.mean, xlab="staph predicted (HV)", ylab="staph concentration observed")
VGOB1_subsetvalID10_staph_LUR3_lm <- lm(staph_copiespm3.ln.diffmeth.mean~staph_PRED_HV, data=VGOB1_subsetvalID10_staph_LUR3)
summary(VGOB1_subsetvalID10_staph_LUR3_lm)

# Calculate max VIF and cook's distnace of each subset (each fold of the 10-fold CV)
# Since all models only include 1 variable, VIF is not possible to calculate
maxVIF_staph_LUR3_subsetA <- max(vif(finalBestModel_staph_LUR3_subsetA))
maxVIF_staph_LUR3_subsetB <- max(vif(finalBestModel_staph_LUR3_subsetB))
maxVIF_staph_LUR3_subsetC <- max(vif(finalBestModel_staph_LUR3_subsetC))
maxVIF_staph_LUR3_subsetD <- max(vif(finalBestModel_staph_LUR3_subsetD))
maxVIF_staph_LUR3_subsetE <- max(vif(finalBestModel_staph_LUR3_subsetE))
maxVIF_staph_LUR3_subsetF <- max(vif(finalBestModel_staph_LUR3_subsetF))
maxVIF_staph_LUR3_subsetG <- max(vif(finalBestModel_staph_LUR3_subsetG))
maxVIF_staph_LUR3_subsetH <- max(vif(finalBestModel_staph_LUR3_subsetH))
maxVIF_staph_LUR3_subsetI <- max(vif(finalBestModel_staph_LUR3_subsetI))
maxVIF_staph_LUR3_subsetJ <- max(vif(finalBestModel_staph_LUR3_subsetJ))

maxCD_staph_LUR3_subsetA <- max(cooks.distance(finalBestModel_staph_LUR3_subsetA))
maxCD_staph_LUR3_subsetB <- max(cooks.distance(finalBestModel_staph_LUR3_subsetB))
maxCD_staph_LUR3_subsetC <- max(cooks.distance(finalBestModel_staph_LUR3_subsetC))
maxCD_staph_LUR3_subsetD <- max(cooks.distance(finalBestModel_staph_LUR3_subsetD))
maxCD_staph_LUR3_subsetE <- max(cooks.distance(finalBestModel_staph_LUR3_subsetE))
maxCD_staph_LUR3_subsetF <- max(cooks.distance(finalBestModel_staph_LUR3_subsetF))
maxCD_staph_LUR3_subsetG <- max(cooks.distance(finalBestModel_staph_LUR3_subsetG))
maxCD_staph_LUR3_subsetH <- max(cooks.distance(finalBestModel_staph_LUR3_subsetH))
maxCD_staph_LUR3_subsetI <- max(cooks.distance(finalBestModel_staph_LUR3_subsetI))
maxCD_staph_LUR3_subsetJ <- max(cooks.distance(finalBestModel_staph_LUR3_subsetJ))

# Write out the max VIF and cook's distance figures for each of the 10 folds, and create a dataframe 

staph_LUR3_maxVIF_subsetvalID1to10 <- c(maxVIF_staph_LUR3_subsetA, maxVIF_staph_LUR3_subsetB, maxVIF_staph_LUR3_subsetC, maxVIF_staph_LUR3_subsetD, maxVIF_staph_LUR3_subsetE, maxVIF_staph_LUR3_subsetF, maxVIF_staph_LUR3_subsetG, maxVIF_staph_LUR3_subsetH, maxVIF_staph_LUR3_subsetI, maxVIF_staph_LUR3_subsetJ)

staph_LUR3_maxCD_maxCD_subsetvalID1to10 <- c(maxCD_staph_LUR3_subsetA, maxCD_staph_LUR3_subsetB, maxCD_staph_LUR3_subsetC, maxCD_staph_LUR3_subsetD, maxCD_staph_LUR3_subsetE, maxCD_staph_LUR3_subsetF, maxCD_staph_LUR3_subsetG, maxCD_staph_LUR3_subsetH, maxCD_staph_LUR3_subsetI, maxCD_staph_LUR3_subsetJ)

staph_LUR3_maxVIF_maxCD_matrix <- cbind(staph_LUR3_maxVIF_subsetvalID1to10, staph_LUR3_maxCD_maxCD_subsetvalID1to10)
staph_LUR3_maxVIF_maxCD_df <- as.data.frame(staph_LUR3_maxVIF_maxCD_matrix)

row.names(staph_LUR3_maxVIF_maxCD_df) <- c("SubsetA", "SubsetB", "SubsetC", "SubsetD", "SubsetE", "SubsetF", "SubsetG", "SubsetH", "SubsetI", "SubsetJ")

write_xlsx(staph_LUR3_maxVIF_maxCD_df,"Output_files\\staph_LUR3_maxVIF_maxCD_df.xlsx")

#  Merging of all test sets to make overall comparisons of predicted vs observed
VGOB1_subsetvalID1to10_staph_LUR3_10foldCV <- rbind(VGOB1_subsetvalID1_staph_LUR3, VGOB1_subsetvalID2_staph_LUR3, VGOB1_subsetvalID3_staph_LUR3, VGOB1_subsetvalID4_staph_LUR3, VGOB1_subsetvalID5_staph_LUR3, VGOB1_subsetvalID6_staph_LUR3, VGOB1_subsetvalID7_staph_LUR3, VGOB1_subsetvalID8_staph_LUR3, VGOB1_subsetvalID9_staph_LUR3, VGOB1_subsetvalID10_staph_LUR3)

#  Overall comparison of predicted vs observed
plot(VGOB1_subsetvalID1to10_staph_LUR3_10foldCV$staph_PRED_HV, VGOB1_subsetvalID1to10_staph_LUR3_10foldCV$staph_copiespm3.ln.diffmeth.mean, xlab="LUR3-predicted staph DNA concentration (ln copies/m^3)", ylab="Observed staph DNA concentration (ln copies/m^3)", cex.lab=0.85)
abline(lm(VGOB1_subsetvalID1to10_staph_LUR3_10foldCV$staph_copiespm3.ln.diffmeth.mean ~ VGOB1_subsetvalID1to10_staph_LUR3_10foldCV$staph_PRED_HV))


VGOB1_subsetvalID1to10_staph_LUR3_10foldCV_lm <- lm(staph_copiespm3.ln.diffmeth.mean ~ staph_PRED_HV, data=VGOB1_subsetvalID1to10_staph_LUR3_10foldCV)
summary(VGOB1_subsetvalID1to10_staph_LUR3_10foldCV_lm)

# 10-fold CV multiple R2 for Staph LUR3 = 0.09027

#  Calculate RMSE
RMSE_staph_LUR3_10foldCV <- sqrt(mean((VGOB1_subsetvalID1to10_staph_LUR3_10foldCV$staph_copiespm3.ln.diffmeth.mean - VGOB1_subsetvalID1to10_staph_LUR3_10foldCV$staph_PRED_HV)^2))
RMSE_staph_LUR3_10foldCV

#  Save these predicted concentrations as an excel file along with the actual measured concentrations of staph at each of the measurement sites 
#  These are the predicted concentrations for the sites that were left out of the model training procedure in 10-fold cross validation 
staph_LUR3_10foldCV_preds <- VGOB1_subsetvalID1to10_staph_LUR3_10foldCV$staph_PRED_HV 
#  These are the actual measured concentrations at the 61 measurement sites - these are in the same order as the above sites in order to match the predicted concentrations (i.e. not in order 1-61)
VGOB1_subsetvalID1to10_staph_LUR3_10foldCV$staph_copiespm3.ln.diffmeth.mean

VGOB1_subsetvalID1to10_staph_LUR3_10foldCV$Loc_ID

#  Create a dataframe 
staph_LUR3_10foldCVpreds_observed <- data.frame(VGOB1_subsetvalID1to10_staph_LUR3_10foldCV$Loc_ID,VGOB1_subsetvalID1to10_staph_LUR3_10foldCV$staph_copiespm3.ln.diffmeth.mean, VGOB1_subsetvalID1to10_staph_LUR3_10foldCV$staph_PRED_HV)
print(staph_LUR3_10foldCVpreds_observed)

#  Save as xls file 
write_xlsx(staph_LUR3_10foldCVpreds_observed,"Output_files//staph_LUR3_10foldCV_observed_predicted.xlsx")
```
# Summarise performance (R2 and RMSE) of the Staph models in a table 
```{r}
# staph 
# R-squared values
# Training models
staph_LUR1_trainingmodel_rsq <- summary(staph_LUR1_algorithmmethod)$r.squared
staph_LUR2_trainingmodel_rsq <- summary(staph_LUR2_algorithmmethod)$r.squared
staph_LUR3_trainingmodel_rsq <- summary(staph_LUR3_algorithmmethod)$r.squared

# LOOCV models 
staph_LUR1_LOOCVmodel_rsq <- summary(staph_LUR1_LOOCV_lm)$r.squared
staph_LUR2_LOOCVmodel_rsq <- summary(staph_LUR2_LOOCV_lm)$r.squared
staph_LUR3_LOOCVmodel_rsq <- summary(staph_LUR3_LOOCV_lm)$r.squared

# 10-fold CV models
staph_LUR1_10foldCVmodel_rsq <- summary(VGOB1_subsetvalID1to10_staph_LUR1_10foldCV_lm)$r.squared
staph_LUR2_10foldCVmodel_rsq <- summary(VGOB1_subsetvalID1to10_staph_LUR2_10foldCV_lm)$r.squared
staph_LUR3_10foldCVmodel_rsq <- summary(VGOB1_subsetvalID1to10_staph_LUR3_10foldCV_lm)$r.squared

# RMSE
# Training models
RMSE_staph_LUR1
RMSE_staph_LUR2
RMSE_staph_LUR3
# LOOCV models
RMSE_staph_LUR1_LOOCV
RMSE_staph_LUR2_LOOCV
RMSE_staph_LUR3_LOOCV
# 10-fold CV models 
RMSE_staph_LUR1_10foldCV
RMSE_staph_LUR2_10foldCV
RMSE_staph_LUR3_10foldCV

# Create dataframes
# Training models 
staph_trainingmodels_rsq <- c(staph_LUR1_trainingmodel_rsq,staph_LUR2_trainingmodel_rsq, staph_LUR3_trainingmodel_rsq)

staph_trainingmodels_RMSE <- c(RMSE_staph_LUR1,RMSE_staph_LUR2, RMSE_staph_LUR3)

# LOOCV models 
staph_LOOCVmodels_rsq <- c(staph_LUR1_LOOCVmodel_rsq,staph_LUR2_LOOCVmodel_rsq, staph_LUR3_LOOCVmodel_rsq)

staph_LOOCVmodels_RMSE <- c(RMSE_staph_LUR1_LOOCV,RMSE_staph_LUR2_LOOCV, RMSE_staph_LUR3_LOOCV)

# 10-fold CV models 
staph_10foldCVmodels_rsq <- c(staph_LUR1_10foldCVmodel_rsq,staph_LUR2_10foldCVmodel_rsq, staph_LUR3_10foldCVmodel_rsq)

staph_10foldCVmodels_RMSE <- c(RMSE_staph_LUR1_10foldCV,RMSE_staph_LUR2_10foldCV, RMSE_staph_LUR3_10foldCV)

# dataframe of all rsq and RMSE values from the training, LOOCV and 10-folds models (LUR1,2,3)
staph_allmodels_Rsq_RMSE <- data.frame(staph_trainingmodels_rsq, staph_trainingmodels_RMSE, staph_LOOCVmodels_rsq, staph_LOOCVmodels_RMSE, staph_10foldCVmodels_rsq, staph_10foldCVmodels_RMSE)
row_names_staphmodels <- c("LUR1", "LUR2", "LUR3")
row.names(staph_allmodels_Rsq_RMSE) <- row_names_staphmodels

write.csv(staph_allmodels_Rsq_RMSE,"Output_files\\staph_allmodels_Rsq_RMSE.csv")
```

